/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

window.CUI = window.CUI || {};
(function (CUI) {
  'use strict';
  CUI.rte = CUI.rte || {};
  CUI.rte.templates = CUI.rte.templates || {};
  CUI.rte.commands = {};
  CUI.rte.plugins = {};
  CUI.rte.adapter = {};
  CUI.rte.genhtml = {};
  CUI.rte.ui = {};
  CUI.rte.ui.ext = {};
  CUI.rte.ui.cui = {};
  CUI.rte.ui.stub = {};
}(window.CUI));

/**
 Crockford's new_constructor pattern, modified to allow walking the prototype chain, automatic constructor/destructor chaining, easy toString methods, and syntactic sugar for calling superclass methods

 @see Base

 @function

 @param {Object} descriptor                        Descriptor object
 @param {String|Function} descriptor.toString   A string or method to use for the toString of this class and instances of this class
 @param {Object} descriptor.extend                 The class to extend
 @param {Function} descriptor.construct            The constructor (setup) method for the new class
 @param {Function} descriptor.destruct             The destructor (teardown) method for the new class
 @param {Mixed} descriptor.*                       Other methods and properties for the new class

 @returns {Base} The created class.
 */
var Class;
var Exception;

(function () {
  /**
   @name Base

   @classdesc The abstract class which contains methods that all classes will inherit.
   Base cannot be extended or instantiated and does not exist in the global namespace.
   If you create a class using <code class="prettyprint">new Class()</code> or <code class="prettyprint">MyClass.extend()</code>, it will come with Base' methods.

   @desc Base is an abstract class and cannot be instantiated directly. Constructors are chained automatically, so you never need to call the constructor of an inherited class directly
   @constructs

   @param {Object} options  Instance options. Guaranteed to be defined as at least an empty Object
   */

  /**
   Binds a method of this instance to the execution scope of this instance.

   @name bind
   @memberOf Base.prototype
   @function

   @param {Function} func The this.method you want to bind
   */
  var bindFunc = function (func) {
    // Bind the function to always execute in scope
    var boundFunc = func.bind(this);

    // Store the method name
    boundFunc._methodName = func._methodName;

    // Store the bound function back to the class
    this[boundFunc._methodName] = boundFunc;

    // Return the bound function
    return boundFunc;
  };

  /**
   Extends this class using the passed descriptor.
   Called on the Class itself (not an instance), this is an alternative to using <code class="prettyprint">new Class()</code>.
   Any class created using Class will have this static method on the class itself.

   @name extend
   @memberOf Base
   @function
   @static

   @param {Object} descriptor                        Descriptor object
   @param {String|Function} descriptor.toString   A string or method to use for the toString of this class and instances of this class
   @param {Object} descriptor.extend                 The class to extend
   @param {Function} descriptor.construct            The constructor (setup) method for the new class
   @param {Function} descriptor.destruct             The destructor (teardown) method for the new class
   @param {Anything} descriptor.*                    Other methods and properties for the new class
   */
  var extendClass = function (descriptor) {
    descriptor.extend = this;
    return new Class(descriptor);
  };

  Class = function (descriptor) {
    descriptor = descriptor || {};

    if (descriptor.hasOwnProperty('extend') && !descriptor.extend) {
      throw new Class.NonTruthyExtendError(typeof descriptor.toString === 'function' ? descriptor.toString() : descriptor.toString);
    }

    // Extend Object by default
    var extend = descriptor.extend || Object;

    // Construct and destruct are not required
    var construct = descriptor.construct;
    var destruct = descriptor.destruct;

    // Remove special methods and keywords from descriptor
    delete descriptor.bind;
    delete descriptor.extend;
    delete descriptor.destruct;
    delete descriptor.construct;

    descriptor._construct = construct;
    descriptor._destruct = destruct;

    // Add toString method, if necessary
    if (descriptor.hasOwnProperty('toString') && typeof descriptor.toString !== 'function') {
      // Return the string provided
      var classString = descriptor.toString;
      descriptor.toString = function () {
        return classString.toString();
      };
    }
    else if (!descriptor.hasOwnProperty('toString') && extend.prototype.hasOwnProperty('toString')) {
      // Use parent's toString
      descriptor.toString = extend.prototype.toString;
    }

    // The remaining properties in descriptor are our methods
    var methodsAndProps = descriptor;

    // Create an object with the prototype of the class we're extending
    var prototype = Object.create(extend && extend.prototype);

    // Store super class as a property of the new class' prototype
    prototype.superClass = extend.prototype;

    // Copy new methods into prototype
    if (methodsAndProps) {
      for (var key in methodsAndProps) {
        if (methodsAndProps.hasOwnProperty(key)) {
          prototype[key] = methodsAndProps[key];

          // Store the method name so calls to inherited() work
          if (typeof methodsAndProps[key] === 'function') {
            prototype[key]._methodName = key;
            prototype[key]._parentProto = prototype;
          }
        }
      }
    }

    /**
     Call the superclass method with the same name as the currently executing method

     @name inherited
     @memberOf Base.prototype
     @function

     @param {Arguments} args  Unadulterated arguments array from calling function
     */
    prototype.inherited = function (args) {
      // Get the function that call us from the passed arguments objected
      var caller = args.callee;

      // Get the name of the method that called us from a property of the method
      var methodName = caller._methodName;

      if (!methodName) {
        throw new Class.MissingCalleeError(this.toString());
      }

      // Start iterating at the prototype that this function is defined in
      var curProto = caller._parentProto;
      var inheritedFunc = null;

      // Iterate up the prototype chain until we find the inherited function
      while (curProto.superClass) {
        curProto = curProto.superClass;
        inheritedFunc = curProto[methodName];
        if (typeof inheritedFunc === 'function')
          break;
      }

      if (typeof inheritedFunc === 'function') {
        // Store our inherited function
        var oldInherited = this.inherited;

        // Overwrite our inherited function with that of the prototype so the called function can call its parent
        this.inherited = curProto.inherited;

        // Call the inherited function our scope, apply the passed args array
        var retVal = inheritedFunc.apply(this, args);

        // Revert our inherited function to the old function
        this.inherited = oldInherited;

        // Return the value called by the inherited function
        return retVal;
      }
      else {
        throw new Class.InheritedMethodNotFoundError(this.toString(), methodName);
      }
    };

    // Add bind to the prototype of the class
    prototype.bind = bindFunc;

    /**
     Destroys this instance and frees associated memory. Destructors are chained automatically, so the <code class="prettyprint">destruct()</code> method of all inherited classes will be called for you

     @name destruct
     @memberOf Base.prototype
     @function
     */
    prototype.destruct = function () {
      // Call our destruct method first
      if (typeof destruct === 'function') {
        destruct.apply(this);
      }

      // Build a list of all destructors
      var destructors = [];
      var superClass = this.superClass;
      while (superClass) {
        if (typeof superClass._destruct === 'function') {
          destructors.push(superClass._destruct);
        }

        if (superClass === superClass.superClass) {
          throw new Class.InfiniteInheritanceLoopError(superClass.toString());
        }

        superClass = superClass.superClass;
      }

      // Execute desdestructors in child-first order
      for (var i = 0; i < destructors.length; i++) {
        destructors[i].apply(this);
      }
    };

    // Create a chained construct function which calls the superclass' construct function
    prototype.construct = function (option) {
      // Add a blank object as the first arg to the constructor, if none provided
      var args = Array.prototype.slice.call(arguments);
      if (args[0] === undefined) {
        args[0] = {};
      }

      // Build a list of all constructors
      var constructors = [];
      var superClass = this.superClass;
      while (superClass) {
        if (typeof superClass._construct === 'function') {
          constructors.push(superClass._construct);
        }

        if (superClass === superClass.superClass) {
          throw new Class.InfiniteInheritanceLoopError(superClass.toString());
        }

        superClass = superClass.superClass;
      }

      // Execute constructors in parent-first order
      for (var i = constructors.length - 1; i >= 0; i--) {
        constructors[i].apply(this, args);
      }

      // call constructor
      if (typeof construct === 'function') {
        construct.apply(this, args);
      }
    };

    // Create a function that generates instances of our class and calls our construct functions
    /** @ignore */
    var instanceGenerator = function () {
      // Create a new object with the prototype we built
      var instance = Object.create(prototype);

      // Call all inherited construct functions
      prototype.construct.apply(instance, arguments);

      return instance;
    };

    instanceGenerator.toString = prototype.toString;

    // Set the prototype of our instance generator to the prototype of our new class so things like MyClass.prototype.method.apply(this) work
    instanceGenerator.prototype = prototype;

    // Add extend to the instance generator for the class
    instanceGenerator.extend = extendClass;

    // The constructor, as far as JS is concerned, is actually our instance generator
    prototype.constructor = instanceGenerator;

    return instanceGenerator;
  };

  if (!Object.create) {
    /**
     Polyfill for Object.create. Creates a new object with the specified prototype.

     @author <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create/">Mozilla MDN</a>

     @param {Object} prototype  The prototype to create a new object with
     */
    Object.create = function (prototype) {
      if (arguments.length > 1) {
        throw new Error('Object.create implementation only accepts the first parameter.');
      }
      function Func() {
      }

      Func.prototype = prototype;
      return new Func();
    };
  }

  if (!Function.prototype.bind) {
    /**
     Polyfill for Function.bind. Binds a function to always execute in a specific scope.

     @author <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Mozilla MDN</a>

     @param {Object} scope  The scope to bind the function to
     */
    Function.prototype.bind = function (scope) {
      if (typeof this !== "function") {
        // closest thing possible to the ECMAScript 5 internal IsCallable function
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
      }

      var aArgs = Array.prototype.slice.call(arguments, 1);
      var fToBind = this;
      /** @ignore */
      var NoOp = function () {
      };
      /** @ignore */
      var fBound = function () {
        return fToBind.apply(this instanceof NoOp ? this : scope, aArgs.concat(Array.prototype.slice.call(arguments)));
      };

      NoOp.prototype = this.prototype;
      fBound.prototype = new NoOp();

      return fBound;
    };
  }

  Exception = new Class({
    extend: Error,
    construct: function () {
      this.name = 'Error';
      this.message = 'General exception';
    },

    toString: function () {
      return this.name + ': ' + this.message;
    }
  });

  var ClassException = Exception.extend({
    name: 'Class Exception'
  });

  // Exceptions
  Class.NonTruthyExtendError = ClassException.extend({
    construct: function (className) {
      this.message = className + ' attempted to extend a non-truthy object';
    }
  });

  Class.InheritedMethodNotFoundError = ClassException.extend({
    construct: function (className, methodName) {
      this.message = className + " can't call method '" + methodName + "', no method defined in parent classes";
    }
  });

  Class.MissingCalleeError = ClassException.extend({
    construct: function (className) {
      this.message = className + " can't call inherited method: calling method did not have _methodName";
    }
  });

  Class.InfiniteInheritanceLoopError = ClassException.extend({
    construct: function (className) {
      this.message = className + " seems to inherit from itself, cannot construct an object";
    }
  });
}());

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * This class represents basic editor-related events, such as keystrokes or mouseclicks.
 * @class CUI.rte.EditorEvent
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.EditorEvent = new Class({

    toString: 'EditorEvent',

    /**
     * The event's type
     * @type String
     * @private
     */
    type: null,

    /**
     * The key (for key-related events)
     * @type String
     * @private
     */
    key: null,

    /**
     * The character code of the key (for key-related events)
     * @type Number
     * @private
     */
    charCode: 0,

    /**
     * Flag that determines if the "Meta" key was held when the event occured
     * @type Boolean
     * @private
     */
    metaKeyPressed: false,

    /**
     * Flag that determines if the "Control" key was held when the event occured
     * @type Boolean
     * @private
     */
    ctrlKeyPressed: false,

    /**
     * The mouse button (for events related to mouse clicks)
     * @type Number
     * @private
     */
    button: Math.NaN,

    /**
     * Property that is used to signal if the event was cancelled by a listener; if a
     * listener sets this to true, event bubbling will be stopped and the system's default
     * behaviour will be  prevented.
     * @property {Boolean} cancelKey
     */
    cancelKey: false,

    /**
     * The edit context for the event
     * @property {CUI.rte.EditContext} editContext
     */
    editContext: null,


    /**
     * Constructor substitution.
     * @private
     */
    _init: function (cfg) {
      CUI.rte.Utils.apply(this, cfg);
    },

    /**
     * Gets the event type.
     * @return {String} The type
     */
    getType: function () {
      return this.type;
    },

    /**
     * <p>Checks if the specified event represents a caret key (left, right, up, down).</p>
     * <p>Returns false for non key-related events.</p>
     * @return {Boolean} True if the specified event represents a caret key
     */
    isCaretKey: function () {
      throw new Error(
        'EditorEvent#isCaretKey must be overridden by the extending class.');
    },

    /**
     * <p>Checks if the specified event describes a caret movement (for example through
     * one of the caret movement keys or pageup/pagedown).</p>
     * <p>Returns false for non key-related events.</p>
     * @return {Boolean} True if the specified event describes a caret movement
     */
    isCaretMovement: function () {
      throw new Error(
        'EditorEvent#isCaretMovement must be overridden by the extending class.');
    },

    /**
     * <p>Gets the key that is connected to the event.</p>
     * <p>Only valid for key-related events; check {@link #getType()} first.</p>
     * @return {String} The key
     */
    getKey: function () {
      return this.key;
    },

    /**
     * <p>Gets the char code that is connected to the event.</p>
     * <p>Only valid for key-related events; check {@link #getType()} first.</p>
     * @return {Number} The char code
     */
    getCharCode: function () {
      return this.charCode;
    },

    /**
     * <p>Checks if the event is related to the Tab key.</p>
     * <p>For non key-related events, this will return false.</p>
     * @return {Boolean} true if the event is related to the Tab key
     */
    isTab: function () {
      throw new Error(
        'EditorEvent#isTab must be overridden by the extending class.');
    },

    /**
     * <p>Checks if the event is related to the Enter key.</p>
     * <p>For non key-related events, this will return false.</p>
     * @return {Boolean} true if the event is related to the Enter key
     */
    isEnter: function () {
      throw new Error(
        'EditorEvent#isEnter must be overridden by the extending class.');
    },

    /**
     * <p>Checks if the event is related to the Space key.</p>
     * <p>For non key-related events, this will return false.</p>
     * @return {Boolean} true if the event is related to the Space key
     */
    isSpace: function () {
      throw new Error(
        'EditorEvent#isSpace must be overridden by the extending class.');
    },

    /**
     * <p>Checks if the event is related to the Backspace key.</p>
     * <p>For non key-related events, this will return false.</p>
     * @return {Boolean} true if the event is related to the Backspace key
     */
    isBackSpace: function () {
      throw new Error(
        'EditorEvent#isBackSpace must be overridden by the extending class.');
    },

    /**
     * <p>Checks if the event is related to the Delete key.</p>
     * <p>For non key-related events, this will return false.</p>
     * @return {Boolean} true if the event is related to the Delete key
     */
    isDelete: function () {
      throw new Error(
        'EditorEvent#isDelete must be overridden by the extending class.');
    },

    /**
     * Determines if one of the Shift keys was held when the event originated.
     * @return {Boolean} True if one of the Shift keys was held
     */
    isShift: function () {
      return this.shiftKeyPressed;
    },

    /**
     * Determines if the Meta key was held when the event originated.
     * @return {Boolean} True if the Meta key was held
     */
    isMeta: function () {
      return this.metaKeyPressed;
    },

    /**
     * Determines if the Control key was held when the event originated.
     * @return {Boolean} True if the Control key was held
     */
    isCtrl: function () {
      return this.ctrlKeyPressed;
    },

    /**
     * <p>Determines the position of the mouse for the event.</p>
     * <p>Only valid for mouse-related events; check {@link #getType()} first.</p>
     * @return {Boolean} True if the Meta key was held
     */
    getPos: function () {
      return this.pos;
    },

    /**
     * <p>Determines the mouse's button state for the event.</p>
     * <p>Only valid for mouse-related events; check {@link #getType()} first.</p>
     * @return {Number} The mouse button held (0 for first/left mouse button)
     */
    getButton: function () {
      return this.button;
    },

    /**
     * Prevents the browser's default behaviour for this event.
     */
    preventDefault: function () {
      throw new Error(
        'EditorEvent#preventDefault must be overridden by the extending class.');
    },

    /**
     * Stops the propagation of the event to parent DOM elements.
     */
    stopPropagation: function () {
      throw new Error(
        'EditorEvent#stopPropagation must be overridden by the extending class.');
    },

    /**
     * Stops the event - shortcut for both preventing the browser's default behaviour and
     * bubbling up to parent elements.
     */
    stopEvent: function () {
      throw new Error(
        'EditorEvent#stopEvent must be overridden by the extending class.');
    },

    /**
     * Returns the original target (before bubbling up) of the event.
     * @return {Node} The original target
     */
    getOriginalTarget: function() {
      throw new Error(
              'EditorEvent#getOriginalTarget must be overridden by the extending class.');
    }

  });

}(window.CUI));

/* global CUI */
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function($, window, undefined) {
  'use strict';

  /**
   * @classdesc The main CUI namespace.
   * @namespace
   *
   * @property {Object} options Main options for CloudUI components.
   * @property {Boolean} options.debug If true, show debug messages for all components.
   * @property {Boolean} options.dataAPI If true, add listeners for widget data APIs.
   * @property {Object} Templates Contains templates used by CUI widgets
   *
   * @example
   * <caption>Change CUI options</caption>
   * <description>You can change CUI options by defining <code>CUI.options</code> before you load CUI.js</description>
   * &lt;script type=&quot;text/javascript&quot;&gt;
   * var CUI = {
   *   options: {
   *     debug: false,
   *     dataAPI: true
   *   }
   * };
   * &lt;/script&gt;
   * &lt;script src=&quot;js/CUI.js&quot;&gt;&lt;/script&gt;
   *
   * preferable include the CUI.js at the bottom before the body closes
   */
  window.CUI = window.CUI || {};

  CUI.options = $.extend({
    debug: false,
    dataAPI: true
  }, CUI.options);

  // REMARK: disabled for now
  // Register partials for all templates
  // Note: this requires the templates to be included BEFORE CUI.js
  /*for (var template in CUI.Templates) {
   Handlebars.registerPartial(template, CUI.Templates[template]);
   }*/

  /**
   * <p><code>cui-contentloaded</code> event is an event that is triggered when a new content is injected to the DOM,
   * which is very similar to {@link https://developer.mozilla.org/en-US/docs/DOM/DOM_event_reference/DOMContentLoaded|DOMContentLoaded} event.</p>
   * <p>This event is normally used so that a JavaScript code can be notified when new content needs to be enhanced (applying event handler, layout, etc).
   * The element where the new content is injected is available at event.target, like so:
   * <pre class="prettyprint linenums jsDocExample">$(document).on("cui-contentloaded", function(e) {
   * var container = e.target;
   * // the container is the element where new content is injected.
   * });</pre>
   * This way the listener can limit the scope of the selector accordingly.</p>
   * <p>It will be triggered at DOMContentLoaded event as well, so component can just listen to this event instead of DOMContentLoaded for enhancement purpose.
   * In that case, the value of event.target is <code>document</code>.</p>
   *
   * @event cui-contentloaded
   */
  $(function() {
    $(document).trigger('cui-contentloaded');
  });

}(jQuery, this));

/* global CUI */
/* jshint -W033,-W116 */
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function($, window, undefined) {
  'use strict';

  var nextId = 1;

  /**
   * Utility functions used by CoralUI widgets
   * @namespace
   */
  CUI.util = CUI.util || {

    /**
     * Flag if a touch device was detected
     * @type {Boolean}
     */
    isTouch: (function() {
      // CUI-2327 Special value for Win8.x/Chrome
      if (/Windows NT 6\.[23];.*Chrome/.test(window.navigator.userAgent)) {
        return false;
      }

      return 'ontouchstart' in window;
    })(),

    /**
     * delivers a unique id within Coral
     * meant to be used in case a id attribute is necessary but missing
     */
    getNextId: function() {
      return 'coral-' + nextId++;
    },

    /**
     * Get the target element of a data API action using the data attributes of an element.
     *
     * @param {jQuery} $element The jQuery object representing the element to get the target from
     * @return {jQuery} The jQuery object representing the target element
     */
    getDataTarget: function($element) {
      var href = $element.attr('href');
      var $target = $($element.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))); // Strip for ie7
      return $target;
    },

    /**
     * Decapitalize a string by converting the first letter to lowercase.
     *
     * @param {String} str The string to de-capitalize
     * @return {String} The de-capitalized string
     */
    decapitalize: function(str) {
      return str.slice(0, 1).toLowerCase() + str.slice(1);
    },

    /**
     * Capitalize a string by converting the first letter to uppercase.
     *
     * @param {String} str The string to capitalize
     * @return {String} The capitalized string
     */
    capitalize: function(str) {
      return str.slice(0, 1).toUpperCase() + str.slice(1);
    },

    /**
     * Create a jQuery plugin from a class
     * @param {Class} PluginClass The class to create to create the plugin for
     * @param {String} [pluginName=PluginClass.toString()] The name of the plugin to create. The de-capitalized return value of PluginClass.toString() is used if left undefined
     * @param {Function} [callback]                              A function to execute in the scope of the jQuery object when the plugin is activated. Used for tacking on additional initialization procedures or behaviors for other plugin functionality.
     */
    plugClass: function(PluginClass, pluginName, callback) {
      pluginName = pluginName || CUI.util.decapitalize(PluginClass.toString());

      $.fn[pluginName] = function(optionsIn) {
        var pluginArgs = arguments;
        return this.each(function() {
          var $element = $(this);

          // Combine defaults, data, options, and element config
          var options = $.extend({}, $element.data(), typeof optionsIn === 'object' && optionsIn, {
            element: this
          });

          // Get instance, if present already
          var instance = $element.data(pluginName) || new PluginClass(options);

          if (typeof optionsIn === 'string') { // Call method, pass args
            instance[optionsIn].apply(instance, Array.prototype.slice.call(pluginArgs, 1));
          }
          else if ($.isPlainObject(optionsIn)) { // Apply options
            instance.set(optionsIn);
          }

          if (typeof callback === 'function') {
            callback.call(this, instance);
          }
        });
      };

      $.fn[pluginName].Constructor = PluginClass;
    },

    /**
     * Register a callback from a string
     *
     * @param {String} callbackAsString The string containing the callback function to register
     * @param {Object} [params] Parameters to provide when executing callback
     * @return {Function} The callback function generated from the provided string
     */
    buildFunction: function(callbackAsString, params) {
      params = params || [];

      if (typeof params === 'string') {
        params = [params];
      }

      if (callbackAsString) {
        try {
          var Fn = Function;
          return new Fn(params, 'return ' + callbackAsString + '(' + params.join(', ') + ');');
        } catch (e) {
          return null;
        }
      }
    },

    /**
     * Selects text in the provided field
     * @param {Number} start (optional) The index where the selection should start (defaults to 0)
     * @param {Number} end (optional) The index where the selection should end (defaults to the text length)
     */
    selectText: function(field, start, end) {
      var value = field.val();

      if (value.length > 0) {
        start = start || 0;
        end = end || value.length;
        var domEl = $(field)[0];
        if (domEl.setSelectionRange) {
          // Mostly all browsers
          domEl.blur();
          domEl.setSelectionRange(start, end);
          domEl.focus();
        }
        else if (domEl.createTextRange) {
          // IE
          var range = domEl.createTextRange();
          range.collapse(true);
          range.moveEnd('character', end - value.length);
          range.moveStart('character', start);
          range.select();
        }
      }
    },

    /**
     * Utility function to get the value of a nested key within an object
     *
     * @param {Object} object The object to retrieve the value from
     * @param {String} nestedKey The nested key. For instance 'foo.bar.baz'
     * @return {Object} The object value for the nested key
     */
    getNested: function(object, nestedKey) {
      if (!nestedKey) {
        return object;
      }

      // Split key into a table
      var keys = typeof nestedKey === 'string' ? nestedKey.split('.') : nestedKey;

      // Browse object
      var result = object;
      while (result && keys.length > 0) {
        result = result[keys.shift()];
      }

      return result;
    },

    /**
     * Utility function to transform a string representation of a boolean value into that boolean value
     *
     * @param {String} string representation
     * @return {Boolean} The boolean value of the string
     */
    isTrue: function(str) {
      return str === 'true';
    }

  };

  // add touch class to <html>
  $('html').toggleClass('touch', CUI.util.isTouch);

}(jQuery, this));

/* global CUI, Class */
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2014 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function($, window, undefined) {
  'use strict';

  CUI.Widget = CUI.Widget || new Class( /** @lends CUI.Widget# */ {
    toString: 'Widget',

    /**
     * @classdesc The base class for all widgets
     *
     * @desc Creates a new widget
     * @constructs CUI.Widget
     *
     * @param {Object} options Widget options
     * @param {Boolean} [options.visible=false] If True, show the widget immediately
     */
    construct: function(options) {

      // Store the target element jQuery object:
      this.$element = $(options.element);

      // Get widget name:
      var widgetName = CUI.util.decapitalize(this.toString());

      // See if the target element has a widget instance attached already:
      if (this.$element.data(widgetName) !== undefined) {
        var message = [
          'An instance of',
          this,
          'is already attached to the specified target element.',
          'Future versions of CoralUI will throw an exception at this point.'
        ].join(' ');

        window.console.log(message);
      }

      // Cascade and store options:
      this.options = $.extend(
        {},
        (typeof this.defaults === 'object' && this.defaults),
        this.$element.data(),
        options);

      // Add instance to element's data
      this.$element.data(widgetName, this);

      // Bind functions commonly called by listeners
      this.bind(this.hide);
      this.bind(this.show);
      this.bind(this.toggleVisibility);

      // Show/hide when this.options.visible changes
      this.on('change:visible', function(evt) {
        this[evt.value ? '_show' : '_hide']();
      }.bind(this));
    },

    /**
     * Set a number of options using an object or a string
     * @name set
     * @memberOf CUI.Widget#
     * @function
     *
     * @param {String|Object} option The option to set as a string, or an object of key/value pairs to set
     * @param {String} value The value to set the option to (is ignored when first argument is an object)
     *
     * @return {CUI.Widget} this, chainable
     */
    set: function(optionOrObj, value) {
      if ($.isPlainObject(optionOrObj)) {
        // Set multiple options
        for (var option in optionOrObj) {
          this._set(option, optionOrObj[option]);
        }
      }
      else {
        // Set single option
        this._set(optionOrObj, value);
      }

      return this;
    },

    /**
     * @ignore
     */
    _set: function(option, value) {
      // Trigger a change event
      var e = $.Event('beforeChange:' + option, {
        widget: this, // We want to know who fired this event (used by CUI.Filters, CUI.DropdownList)
        option: option,
        currentValue: this.options[option],
        value: value
      });
      this.$element.trigger(e);

      // Don't set if prevented
      if (e.isDefaultPrevented()) {
        return this;
      }

      // Set value
      this.options[option] = value;

      e = $.Event('change:' + option, {
        widget: this,
        option: option,
        value: value
      });
      this.$element.trigger(e);
    },

    /**
     * Get the value of an option
     * @param {String} option The name of the option to fetch the value of
     * @return {Mixed} Option value
     */
    get: function(option) {
      return this.options[option];
    },

    /**
     * Add an event listener
     * @param {String} evtName The event name to listen for
     * @param {Function} func The function that will be called when the event is triggered
     * @return {CUI.Widget} this, chainable
     */
    on: function(evtName, func) {
      this.$element.on.apply(this.$element, arguments);
      return this;
    },

    /**
     * Remove an event listener
     * @param {String} evtName The event name to stop listening for
     * @param {Function} func     The function that was passed to on()
     * @return {CUI.Widget} this, chainable
     */
    off: function(evtName, func) {
      this.$element.off.apply(this.$element, arguments);
      return this;
    },

    /**
     * Show the widget
     * @return {CUI.Widget} this, chainable
     */
    show: function(evt) {
      evt = evt || {};

      if (this.options.visible) {
        return this;
      }

      if (!evt.silent) {
        // Trigger event
        var e = $.Event('show');
        this.$element.trigger(e);

        // Do nothing if event is prevented or we're already visible
        if (e.isDefaultPrevented()) {
          return this;
        }
      }

      this.options.visible = true;

      this._show(evt);

      return this;
    },

    /**
     * @ignore
     */
    _show: function(evt) {
      this.$element.show();
    },

    /**
     * Hide the widget
     *
     * @return {CUI.Widget} this, chainable
     */
    hide: function(evt) {
      evt = evt || {};

      if (!this.options.visible) {
        return this;
      }

      if (!evt.silent) {
        // Trigger event
        var e = $.Event('hide');
        this.$element.trigger(e);

        if (e.isDefaultPrevented()) {
          return this;
        }
      }

      this.options.visible = false;

      this._hide(evt);

      return this;
    },

    /**
     * @ignore
     */
    _hide: function(evt) {
      this.$element.hide();
    },

    /**
     * Toggle the visibility of the widget
     * @return {CUI.Widget} this, chainable
     */
    toggleVisibility: function() {
      return this[!this.options.visible ? 'show' : 'hide']();
    },

    /**
     * Set a custom name for this widget.
     *
     * @param {String} customName Component name
     * @return {CUI.Widget} this, chainable
     */
    setName: function(customName) {
      /** @ignore */
      this.toString = function() {
        return customName;
      };

      return this;
    }

    /**
     Triggered when the widget is shown

     @name CUI.Widget#show
     @event
     */

    /**
     Triggered when the widget is hidden

     @name CUI.Widget#hide
     @event
     */

    /**
     Triggered when before an option is changed

     @name CUI.Widget#beforeChange:*
     @event

     @param {Object} evt                    Event object
     @param {Mixed} evt.option              The option that changed
     @param {Mixed} evt.currentValue        The current value
     @param {Mixed} evt.value               The value this option will be changed to
     @param {Function} evt.preventDefault   Call to prevent the option from changing
     */

  /**
   Triggered when an option is changed

   @name CUI.Widget#change:*
   @event

   @param {Object} evt          Event object
   @param {Mixed} evt.option    The option that changed
   @param {Mixed} evt.value     The new value
   */
  });

  /**
   * Utility function to get the widget class instance that's attached to
   * the provided element.
   *
   * @param WidgetClass The type of widget instance to obtain.
   * @param $element The target element to obtain the instance from.
   * @returns The obtained Widget instance, if the target element has an
   * instance attached.
   */
  CUI.Widget.fromElement = CUI.Widget.fromElement || function(WidgetClass, $element) {
    return $element.data(CUI.util.decapitalize(WidgetClass.toString()));
  };

  /**
   * The registry object maps data-init selector values to Widget
   * types.
   */
  CUI.Widget.registry = CUI.Widget.registry || {

    /**
     * Registers the given Widget type as the type that belongs
     * to the provided selector.
     *
     * @param selector String representing the data-init value
     * mapping to Widget.
     * @param Widget Widget subclass that maps to the given
     * selector.
     */
    register: function(selector, Widget) {

      // Register as a jQuery plug-in:
      CUI.util.plugClass(Widget);

      this._widgets[selector] = Widget;

      // Extend the Widget with a static 'init' method:
      Widget.init = function($element) {
        this._init(Widget, $element);
      }.bind(this);

    },

    /**
     * Look-up the Widget subclass that is mapped to the provided
     * selector String value.
     *
     * @param selector String value to look-up the registered
     * Widget subclass for.
     * @returns a Widget subclass, or undefined if the selector
     * could not be resolved.
     */
    resolve: function(selector) {
      return this._widgets[selector];
    },

    /**
     * Initialize the given jQuery element(s) as Widgets of the
     * type as indicated by the selector argument.
     *
     * @param selector String that indicates what Widget subclass
     * must be used to initialize the element.
     * @param $element The jQuery element(s) that the instances
     * must be bound to.
     */
    init: function(selector, $element) {
      this._init(this.resolve(selector), $element);
    },

    getSelectors: function() {
      var selectors = [];
      for (var selector in this._widgets) {
        selectors.push(selector);
      }
      return selectors;
    },

    /**
     * Maps selector values to Widget types
     * @private
     */
    _widgets: {},

    /**
     * Implementation of the public init method, as well as the
     * init method that gets added to registering Widget classes
     *
     * @param Widget The Widget subclass to instantiate.
     * @param $element The jQuery element(s) that the instances
     * must be bound to.
     * @private
     */
    _init: function(Widget, $element) {
      if (Widget !== undefined) {
        $element.each(function() {
          var $item = $(this);

          if (CUI.Widget.fromElement(Widget, $item) === undefined) {
            new Widget({
              element: $item
            });
          }
        });
      }
    }
  };

}(jQuery, this));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  CUI.rte.Eventing = (function ($) {
    //'use strict';

    var handlerMap = [];

    var delayed = [];

    var Wrapper = new Class({

      construct: function ($obj, eventName, handler, delay, scope, editContext) {
        this.$obj = $obj;
        this.eventName = eventName;
        this.handler = handler;
        this.delay = delay;
        this.scope = scope;
        this.editContext = editContext;
      },

      execute: function (jqEvent) {
        var evt = new CUI.rte.adapter.JQueryEvent(jqEvent, this.editContext);
        if (this.delay > 0) {
          for (var s = delayed.length - 1; s >= 0; s--) {
            var toCheck = delayed[s];
            if ((toCheck.obj = this.$obj) && (toCheck.evt === this.eventName) &&
              (toCheck.handler === this.handler)) {
              window.clearTimeout(toCheck.tid);
              delayed.splice(s, 1);
            }
          }
          var self = this;
          var task = function () {
            self.handler.call(self.scope, evt);
          };
          var taskDef = {
            'obj': this.$obj,
            'evt': this.eventName,
            'handler': this.handler
          };
          taskDef.tid = window.setTimeout(task, this.delay);
          delayed.push(taskDef);
        } else {
          this.handler.call(this.scope, evt);
        }
      }

    });


    return {

      on: function (editContext, obj, eventName, handler, scope, options) {
        var $obj = $(obj);
        options = options || {};
        var delay = (options.buffer ? options.buffer : 0);
        var idScope = scope || options.scope || obj || handler;
        scope = scope || options.scope || $obj;
        var wrapper = new Wrapper($obj, eventName, handler, delay, scope, editContext);
        var fn = CUI.rte.Utils.scope(wrapper.execute, wrapper);
        handlerMap.push({
          'name': eventName,
          'handler': handler,
          'idScope': idScope,
          'wrapper': wrapper,
          'fn': fn
        });
        $obj.on(eventName, fn);
      },

      un: function(obj, eventName, handler, scope) {
        var idScope = scope || obj || handler;
        scope = idScope;
        var fn = null;
        for (var e = 0; e < handlerMap.length; e++) {
          var def = handlerMap[e];
          if ((def.name === eventName) && (def.handler === handler) &&
            (def.idScope === idScope)) {
            fn = handlerMap[e].fn;
            handlerMap.splice(e, 1);
            break;
          }
        }
        if (fn === null  || fn === undefined) {
          throw new Error(
            'Unregistered handler provided for event \'' + eventName + '\'.');
        }
        $(obj).off(eventName, fn);
      }

    };

  }(window.jQuery));
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * This class implaments a {@link CUI.rte.EditorEvent} for the jQuery toolkit.
 * @class CUI.rte.adapter.ExtEvent
 * @extends CUI.rte.EditorEvent
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.adapter.JQueryEvent = new Class({

    toString: 'JQueryEvent',

    extend: CUI.rte.EditorEvent,

    /**
     * The native jQuery event
     * @type jQuery.Event
     * @private
     */
    nativeEvent: null,

    /**
     * Creates a new editor event from the specified jQuery event.
     * @param {jQuery.Event} jqEvent The underlying, native jQuery event
     * @param {CUI.rte.EditContext} editContext The editor context for the event
     */
    construct: function (jqEvent, editContext) {
      var isMac = CUI.rte.Common.ua.isMac;
      this.nativeEvent = jqEvent;
      // map to common properties
      var cfg = {
        'type': jqEvent.type,
        'key': jqEvent.keyCode || jqEvent.charCode,
        'charCode': jqEvent.charCode || jqEvent.keyCode,
        'metaKeyPressed': jqEvent.metaKey,
        'ctrlKeyPressed': jqEvent.ctrlKey | (isMac && jqEvent.metaKey),
        'shiftKeyPressed': jqEvent.shiftKey,
        'pos': {
          'x': jqEvent.pageX,
          'y': jqEvent.pageY
        },
        'button': jqEvent.button,
        'editContext': editContext
      };
      this._init(cfg);
    },

    // overrides CUI.rte.EditorEvent#isTab
    isTab: function () {
      return (this.charCode === 9);
    },

    // overrides CUI.rte.EditorEvent#isEnter
    isEnter: function () {
      return (this.charCode === 13);
    },

    // overrides CUI.rte.EditorEvent#isSpace
    isSpace: function () {
      return (this.charCode === 32);
    },

    // overrides CUI.rte.EditorEvent#isBackSpace
    isBackSpace: function () {
      return (this.charCode === 8);
    },

    // overrides CUI.rte.EditorEvent#isDelete
    isDelete: function () {
      return (this.charCode === 46);
    },

    // overrides CUI.rte.EditorEvent#isCaretKey
    isCaretKey: function () {
      return (this.charCode >= 37) && (this.charCode <= 40);
    },

    // overrides CUI.rte.EditorEvent#isCaretMovement
    isCaretMovement: function () {
      return this.isCaretKey() ||
        ((this.charCode >= 33) && (this.charCode <= 36));
    },

    // overrides CUI.rte.EditorEvent#preventDefault
    preventDefault: function () {
      this.nativeEvent.preventDefault();
    },

    // overrides CUI.rte.EditorEvent#stopPropagation
    stopPropagation: function () {
      this.nativeEvent.stopPropagation();
    },

    // overrides CUI.rte.EditorEvent#stopEvent
    stopEvent: function () {
      this.nativeEvent.preventDefault();
      this.nativeEvent.stopPropagation();
    },

    // overrides CUI.rte.EditorEvent#getOriginalTarget
    getOriginalTarget: function() {
      return this.nativeEvent.target;
    }

  });

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
(function (CUI) {
  'use strict';
  CUI.rte.Query = (function ($) {
    return {

      selectNode: function (q, dom) {
        var result = $(dom).find(q);
        if (result.length === 0) {
          return null;
        }
        return result[0];
      },

      select: function (q, dom) {
        return $(dom).find(q);
      }

    };

  }(window.jQuery));
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
(function (CUI) {
  'use strict';
  CUI.rte.AdapterUtils = (function ($) {

    return {

      isArray: function (obj) {
        return $.isArray(obj);
      },

      isString: function (obj) {
        return typeof obj === 'string';
      },

      apply: function (obj, config, defaults) {
        return $.extend(obj, config, defaults);
      },

      getPagePosition: function (dom) {
        var pos = $(dom).offset();
        return [pos.left, pos.top];
      },

      getWidth: function (dom) {
        return $(dom).width();
      },

      getHeight: function (dom) {
        return $(dom).height();
      },

      jsonDecode: function (str) {
        return $.parseJSON(str);
      },

      getBlankImageUrl: function () {
        return CUI.rte.Theme.BLANK_IMAGE;
      }

    };

  }(window.jQuery));
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * This class provides an overridable set of constants to be used by the RTE.
 * @class CUI.rte.Constants
 */
(function (CUI) {
  'use strict';
  CUI.rte.Constants = {

    EXTENSION_HTML: '.html'

  };
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * <p>This class allows to hook some special functionality into the RichTextEditor.</p>
 * <p>The provided default implementation depends on jQuery.</p>
 * <p>The class may be overridden in page-load time with application-specific functionality.
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.Hooks = new Class({

    copyObject: function (obj) {
      var newObj;
      if (CUI.rte.Utils.isArray(obj)) {
        newObj = [];
        for (var i = 0; i < obj.length; i++) {
          newObj.push(this.copyObject(obj[i]));
        }
      } else if (typeof(obj) === 'object') {
        newObj = {};
        for (var k in obj) {
          if (obj.hasOwnProperty(k)) {
            newObj[k] = this.copyObject(obj[k]);
          }
        }
      } else {
        newObj = obj;
      }
      return newObj;
    },

    applyDefaults: function (obj, defaults) {
      obj = obj || {};
      defaults = defaults || {};
      if (typeof(obj) === 'object') {
        for (var k in defaults) {
          if (defaults.hasOwnProperty(k)) {
            var v = defaults[k];
            if (v && (typeof(v) === 'object') && !CUI.rte.Utils.isArray(v)) {
              obj[k] = this.applyDefaults(obj[k], v);
            } else if (typeof(obj[k]) === 'undefined') {
              obj[k] = v;
            }
          }
        }
      }
      return obj;
    },

    getMainWindow: function () {
      return window;
    },

    processUrl: function (url, type) {
      return url;
    },

    onPluginCreated: function (plugin) {
      return plugin;
    },

    resolveRelativePath: function (relPath) {
      var path = document.location.pathname;
      var parentPath = path.substring(0, path.lastIndexOf('/'));
      var parts = parentPath.split('/');
      var relParts = relPath.split('/');
      for (var r = 0; r < relParts.length; r++) {
        var relPart = relParts[r];
        if (relPart === '..') {
          if (parts.length <= 1) {
            throw new Error('Invalid relative path: ' + relPath);
          }
          parts.splice(parts.length - 1, 1);
        } else if (relPart !== '.') {
          parts.push(relPart);
        }
      }
      return parts.join('/');
    },

    isExistingPage: function (path) {
      return true;
    },

    getServerPrefix: function (url) {
      var protSepPos = url.indexOf('://');
      if (protSepPos < 0) {
        return '';
      }
      var afterProtPos = url.indexOf('/', protSepPos + 3);
      return afterProtPos < 0 ? url : url.substring(0, afterProtPos);
    }

  });

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * <p>This interface class must be implemented for specific contexts to provide
 * internationalization for the Rich Text Editor.</p>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.I18nProvider = new Class({

    /**
     * Return the correctly internationalized text that is represented by the specified
     * ID.
     * @param {String} id The text ID
     * @param {Array} values (optional) Values to fill placeholders with
     * @returns {String} The internationalized text
     */
    getText: function (id, values) {
      // must be overridden by something meaningful for the respective context
      return id;
    }

  });

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * <p>This class implements a default internationalization that has no dependencies
 * on a specific environment.</p>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.DefaultI18nProvider = new Class({

    extend: CUI.rte.I18nProvider,

    /**
     * The default language
     */
    _defaultLanguage: null,

    /**
     * Current language
     */
    _language: null,

    /**
     * Table with translations
     */
    _translations: null,

    construct: function (config) {
      config = config || {};
      this._defaultLanguage = config.defaultLanguage ? config.defaultLanguage : 'en';
      this._translations = config.translations ? config.translations
        : CUI.rte.DefaultI18nProvider.DEFAULT_TRANSLATIONS;
      this._language = this._defaultLanguage;
    },

    setLanguage: function (lang) {
      this._language = lang;
    },

    getLanguage: function () {
      return this._language;
    },

    getText: function (id, values) {
      // TODO replace with CUI translation services when available
      var text = id;
      if (this._translations && this._translations.hasOwnProperty(id)) {
        var textDef = this._translations[id];
        if (textDef.hasOwnProperty(this._language)) {
          text = textDef[this._language];
        } else if (textDef.hasOwnProperty(this._defaultLanguage)) {
          text = textDef[this._defaultLanguage];
        }
      }
      if (values) {
        if (!CUI.rte.Utils.isArray(values)) {
          text = text.replace('{0}', values);
        } else {
          for (var s = 0; s < values.length; s++) {
            text = text.replace('{' + s + '}', values[s]);
          }
        }
      }
      return text;
    }

  });

  CUI.rte.DefaultI18nProvider.DEFAULT_TRANSLATIONS = {
    'dialog.apply': {
      'en': 'Apply'
    },
    'dialog.cancel': {
      'en': 'Cancel'
    },
    'dialogs.find.matchCase': {
      'en': 'Match Case'
    },
    'dialog.fullscreen.minimize': {
      'en': 'Minimize'
    },
    'dialog.fullscreen.text': {
      'en': 'Text'
    },
    'dialog.link.target': {
      'en': 'Target'
    },
    'dialog.link.same_tab': {
      'en': 'Same Tab'
    },
    'dialog.link.new_tab': {
      'en': 'New Tab'
    },
    'dialog.link.parent_frame': {
      'en': 'Parent Frame'
    },
    'dialog.link.pickerTitle': {
      'en': 'Choose a target path'
    },
    'dialog.link.top_frame': {
      'en': 'Top Frame'
    },
    'dialog.link.titleFieldPlaceHolder': {
      'en': 'Alt Text'
    },
    'dialog.pastePlainText.pasteAreaPlaceHolder': {
      'en': 'Please paste your text here....'
    },
    'dialog.replace.findButton': {
      'en': 'Find'
    },
    'dialog.replace.replaceButton': {
      'en': 'Replace'
    },
    'dialogs.replace.matchcase': {
      'en': 'Match Case'
    },
    'dialog.replace.replaceAllButton': {
      'en': 'Replace all'
    },
    'dialog.tableAndCellProps.cellProps': {
      'en': 'CELL PROPERTIES'
    },
    'dialog.tableAndCellProps.tableProps': {
      'en': 'TABLE PROPERTIES'
    },
    'dialog.tableAndCellProps.width': {
      'en': 'Width'
    },
    'dialog.tableAndCellProps.widthToolTip': {
      'en': 'Width in pixels. For relative values add \'%\' e.g. \'40%\'.'
    },
    'dialog.tableAndCellProps.noneAlignHor': {
      'en': 'None'
    },
    'dialog.tableAndCellProps.leftAlign': {
      'en': 'Left'
    },
    'dialog.tableAndCellProps.centerAlign': {
      'en': 'Center'
    },
    'dialog.tableAndCellProps.rightAlign': {
      'en': 'Right'
    },
    'dialog.tableAndCellProps.cellType': {
      'en': 'Cell Type'
    },
    'dialog.tableAndCellProps.dataCell': {
      'en': 'Data'
    },
    'dialog.tableAndCellProps.headerCell': {
      'en': 'Header'
    },
    'dialog.tableAndCellProps.height': {
      'en': 'Height'
    },
    'dialog.tableAndCellProps.heightToolTip': {
      'en': 'Height in pixels. For relative values add \'%\' e.g. \'40%\'.'
    },
    'dialog.tableAndCellProps.noneAlignVer': {
      'en': 'None'
    },
    'dialog.tableAndCellProps.topAlign': {
      'en': 'Top'
    },
    'dialog.tableAndCellProps.middleAlign': {
      'en': 'Middle'
    },
    'dialog.tableAndCellProps.bottomAlign': {
      'en': 'Bottom'
    },
    'dialog.tableAndCellProps.baselineAlign': {
      'en': 'Baseline'
    },
    'dialog.tableAndCellProps.hiddenHeader': {
      'en': 'Hidden Header'
    },
    'dialog.tableAndCellProps.headerAttrib': {
      'en': 'Header'
    },
    'dialog.tableAndCellProps.idAttrib': {
      'en': 'Id'
    },
    'dialog.tableAndCellProps.scopeAttrib': {
      'en': 'Scope'
    },
    'dialog.tableAndCellProps.noneScopeAttrib': {
      'en': 'Scope'
    },
    'dialog.tableAndCellProps.rowScope': {
      'en': 'Row'
    },
    'dialog.tableAndCellProps.columnScope': {
      'en': 'Column'
    },
    'dialog.tableAndCellProps.cellPadding': {
      'en': 'Cell padding'
    },
    'dialog.tableAndCellProps.cellSpacing': {
      'en': 'Cell spacing'
    },
    'dialog.tableAndCellProps.border': {
      'en': 'Border'
    },
    'dialog.tableAndCellProps.caption': {
      'en': 'Caption'
    },
    'dialog.tableProps.columns': {
      'en': 'Columns*'
    },
    'dialog.tableProps.width': {
      'en': 'Width'
    },
    'dialog.tableProps.cellPadding': {
      'en': 'Cell padding'
    },
    'dialog.tableProps.rows': {
      'en': 'Rows*'
    },
    'dialog.tableProps.height': {
      'en': 'Height'
    },
    'dialog.tableProps.cellSpacing': {
      'en': 'Cell spacing'
    },
    'dialog.tableProps.border': {
      'en': 'Border'
    },
    'dialog.tableProps.noHeader': {
      'en': 'No Header'
    },
    'dialog.tableProps.rowHeader': {
      'en': 'First row'
    },
    'dialog.tableProps.colHeader': {
      'en': 'First column'
    },
    'dialog.tableProps.rowAndColHeader': {
      'en': 'First row and column'
    },
    'dialog.tableProps.caption': {
      'en': 'Caption'
    },

    'kernel.alertTitlePaste': {
      'en': 'Paste'
    },
    'kernel.alertSecurityPaste': {
      'en': 'Your browser\'s security settings don\'t permit the editor to execute paste operations. Please use the keyboard shortcut (Ctrl/Cmd+V).'
    },
    'kernel.alertTitleCopy': {
      'en': 'Copy'
    },
    'kernel.alertSecurityCopy': {
      'en': 'Your browser\'s security settings don\'t permit the editor to execute copy operations. Please use the keyboard shortcut (Ctrl/Cmd+C).'
    },
    'kernel.alertTitleCut': {
      'en': 'Cut'
    },
    'kernel.alertSecurityCut': {
      'en': 'Your browser\'s security settings don\'t permit the editor to execute cut operations. Please use the keyboard shortcut (Ctrl/Cmd+X).'
    },
    'kernel.alertTitleError': {
      'en': 'Error'
    },
    'kernel.alertIELimitation': {
      'en': 'Could not insert text due to internal Internet Explorer limitations. Please try to select a smaller text fragment and try again.'
    },
    'commands.paste.alertTitle': {
      'en': 'Paste'
    },
    'commands.paste.alertTableError': {
      'en': 'You are trying to paste table data into an existing table.<br>As this operation would result in invalid HTML, it has been cancelled.<br>Please try to simplify the table\'s structure and try again.'
    },
    'commands.paste.alertCellSelectionError': {
      'en': 'You are trying to paste table data into an non-rectangular cell selection.<br>Please choose a rectangular cell selection and try again.'
    },
    'popover.trigger.plugins.Format': {
       'en': 'Format'
    },
    'popover.trigger.plugins.Justify': {
       'en': 'Justify'
    },
    'popover.trigger.plugins.Lists': {
       'en': 'Lists'
    },
    'plugins.editTools.cutTitle': {
      'en': 'Cut (Ctrl+X)'
    },
    'plugins.editTools.cutText': {
      'en': 'Cuts the currently selected text and puts it in to the clipboard.'
    },
    'plugins.editTools.copyTitle': {
      'en': 'Copy (Ctrl+C)'
    },
    'plugins.editTools.copyText': {
      'en': 'Copies the currently selected text to the clipboard.'
    },
    'plugins.editTools.pasteDefaultTitle': {
      'en': 'Paste (Ctrl+V)'
    },
    'plugins.editTools.pasteDefaultText': {
      'en': 'Pastes the clipboard content with the default paste method.'
    },
    'plugins.editTools.pastePlainTextTitle': {
      'en': 'Paste as text'
    },
    'plugins.editTools.pastePlainTextText': {
      'en': 'Pastes the clipboard content as plain text.'
    },
    'plugins.editTools.pasteWordHtmlTitle': {
      'en': 'Paste from Word'
    },
    'plugins.editTools.pasteWordHtmlText': {
      'en': 'Pastes the clipboard content from Word, applying some cleanup.'
    },
    'plugins.findReplace.findTitle': {
      'en': 'Find'
    },
    'plugins.findReplace.replaceTitle': {
      'en': 'Replace'
    },
    'plugins.findReplace.findReplaceTitle': {
      'en': 'Find/Replace'
    },
    'plugins.findReplace.replaceAllTitle': {
      'en': 'Replace all'
    },
    'plugins.findReplace.alertNoMoreResults': {
      'en': 'No more occurences of \'{0}\' found in document.<br>Search will be continued from the top.'
    },
    'plugins.findReplace.alertReplaceResults': {
      'en': 'Text \'{0}\' has been replaced {1} time(s).'
    },
    'plugins.findReplace.alertNotFound': {
      'en': 'Text \'{0}\' not found.'
    },
    'plugins.findReplace.alertIEProblems': {
      'en': 'Could not replace due to limited functionality in Internet Explorer.'
    },
    'plugins.findReplace.tooltipFind': {
      'en': 'Finds a text fragment in the text being edited.'
    },
    'plugins.findReplace.tooltipReplace': {
      'en': 'Replaces a text fragment with another fragment.'
    },
    'plugins.generichtml.generichtmlTitle': {
      'en': 'Generic HTML'
    },
    'plugins.generichtml.tooltipGenerichtml': {
      'en': 'Pastes the clipboard content as plain text.'
    },
    'plugins.format.boldTitle': {
      'en': 'Bold (Ctrl+B)'
    },
    'plugins.format.boldText': {
      'en': 'Make the selected text bold.'
    },
    'plugins.format.italicTitle': {
      'en': 'Italic (Ctrl+I)'
    },
    'plugins.format.italicText': {
      'en': 'Make the selected text italic.'
    },
    'plugins.format.underlineTitle': {
      'en': 'Underline (Ctrl+U)'
    },
    'plugins.format.underlineText': {
      'en': 'Underline the selected text.'
    },
    'plugins.image.alignMenu': {
      'en': 'Image alignment'
    },
    'plugins.image.alignLeft': {
      'en': 'Left'
    },
    'plugins.image.alignRight': {
      'en': 'Right'
    },
    'plugins.image.alignNone': {
      'en': 'None'
    },
    'plugins.image.alignInherit': {
      'en': 'Inherit'
    },
    'plugins.image.imageTitle': {
      'en': 'Image'
    },
    'plugins.image.noAlign': {
      'en': 'No alignment'
    },
    'plugins.image.properties': {
      'en': 'Image Properties'
    },
    'plugins.justify.leftTitle': {
      'en': 'Align Text Left'
    },
    'plugins.justify.leftText': {
      'en': 'Align text to the left.'
    },
    'plugins.justify.centerTitle': {
      'en': 'Center Text'
    },
    'plugins.justify.centerText': {
      'en': 'Center text in the editor.'
    },
    'plugins.justify.rightTitle': {
      'en': 'Align Text Right'
    },
    'plugins.justify.rightText': {
      'en': 'Align text to the right.'
    },
    'plugins.link.linkTitle': {
      'en': 'Hyperlink'
    },
    'plugins.link.linkText': {
      'en': 'Create or modify a hyperlink.'
    },
    'plugins.link.unlinkTitle': {
      'en': 'Unlink'
    },
    'plugins.link.unlinkText': {
      'en': 'Remove an existing hyperlink from the selected text.'
    },
    'plugins.link.anchorTitle': {
      'en': 'Anchor'
    },
    'plugins.link.anchorText': {
      'en': 'Add or edit an anchor.'
    },
    'plugins.list.ulTitle': {
      'en': 'Bullet List'
    },
    'plugins.list.ulText': {
      'en': 'Start a bulleted list.'
    },
    'plugins.list.olTitle': {
      'en': 'Numbered List'
    },
    'plugins.list.olText': {
      'en': 'Start a numbered list.'
    },
    'plugins.list.indentTitle': {
      'en': 'Indent'
    },
    'plugins.list.indentText': {
      'en': 'Indents the selected paragraph(s) or list item(s).'
    },
    'plugins.list.outdentTitle': {
      'en': 'Outdent'
    },
    'plugins.list.outdentText': {
      'en': 'Outdents the current paragraph(s) or list item(s).'
    },
    'plugins.miscTools.sourceEditTitle': {
      'en': 'Source Edit'
    },
    'plugins.miscTools.sourceEditText': {
      'en': 'Switch to source editing mode.'
    },
    'plugins.miscTools.specialCharsTitle': {
      'en': 'Special Characters'
    },
    'plugins.miscTools.specialCharsText': {
      'en': 'Insert a special character.'
    },
    'plugins.paraFormat.defaultP': {
      'en': 'Paragraph'
    },
    'plugins.paraFormat.defaultH1': {
      'en': 'Heading 1'
    },
    'plugins.paraFormat.defaultH2': {
      'en': 'Heading 2'
    },
    'plugins.paraFormat.defaultH3': {
      'en': 'Heading 3'
    },
    'plugins.spellCheck.spellChecking': {
      'en': 'Spell Checking'
    },
    'plugins.spellCheck.noMistakeAlert': {
      'en': 'No spelling mistakes found.'
    },
    'plugins.spellCheck.failAlert': {
      'en': 'Spell checking failed.'
    },
    'plugins.spellCheck.noSuggestions': {
      'en': 'No suggestions available'
    },
    'plugins.subSuperScript.subTitle': {
      'en': 'Subscript'
    },
    'plugins.subSuperScript.subText': {
      'en': 'Formats the selected text as subscript.'
    },
    'plugins.subSuperScript.superTitle': {
      'en': 'Superscript'
    },
    'plugins.subSuperScript.superText': {
      'en': 'Formats the selected text as superscript.'
    },
    'plugins.table.tableTitle': {
      'en': 'Table'
    },
    'plugins.table.tableText': {
      'en': 'Creates a new table or edits the properties of an existing table.'
    },
    'plugins.table.cellTitle': {
      'en': 'Cell'
    },
    'plugins.table.cellText': {
      'en': 'Edit the properties of a selected cell.'
    },
    'plugins.table.insertAboveTitle': {
      'en': 'Insert Above'
    },
    'plugins.table.insertAboveText': {
      'en': 'Insert a new row above the current row.'
    },
    'plugins.table.insertBelowTitle': {
      'en': 'Insert Below'
    },
    'plugins.table.insertBelowText': {
      'en': 'Insert a new row below the current row.'
    },
    'plugins.table.deleteRowTitle': {
      'en': 'Delete Row'
    },
    'plugins.table.deleteRowText': {
      'en': 'Delete the current row.'
    },
    'plugins.table.insertLeftTitle': {
      'en': 'Insert Left'
    },
    'plugins.table.insertLeftText': {
      'en': 'Insert a new column to the left of the current column.'
    },
    'plugins.table.insertRightTitle': {
      'en': 'Insert Right'
    },
    'plugins.table.insertRightText': {
      'en': 'Insert a new column to the right of the current column.'
    },
    'plugins.table.deleteColumnTitle': {
      'en': 'Delete Column'
    },
    'plugins.table.deleteColumnText': {
      'en': 'Delete the current column.'
    },
    'plugins.table.cellProps': {
      'en': 'Cell properties'
    },
    'plugins.table.mergeCells': {
      'en': 'Merge cells'
    },
    'plugins.table.mergeRight': {
      'en': 'Merge right'
    },
    'plugins.table.mergeDown': {
      'en': 'Merge down'
    },
    'plugins.table.splitHor': {
      'en': 'Split cell horizontally'
    },
    'plugins.table.splitVert': {
      'en': 'Split cell vertically'
    },
    'plugins.table.cell': {
      'en': 'Cell'
    },
    'plugins.table.column': {
      'en': 'Column'
    },
    'plugins.table.row': {
      'en': 'Row'
    },
    'plugins.table.insertBefore': {
      'en': 'Insert before'
    },
    'plugins.table.insertAfter': {
      'en': 'Insert after'
    },
    'plugins.table.remove': {
      'en': 'Remove'
    },
    'plugins.table.tableProps': {
      'en': 'Table properties'
    },
    'plugins.table.removeTable': {
      'en': 'Remove table'
    },
    'plugins.table.nestedTable': {
      'en': 'Create nested table'
    },
    'plugins.table.selectRow': {
      'en': 'Select entire row'
    },
    'plugins.table.selectColumn': {
      'en': 'Select entire column'
    },
    'plugins.table.insertParaBefore': {
      'en': 'Insert paragraph before table'
    },
    'plugins.table.insertParaAfter': {
      'en': 'Insert paragraph after table'
    },
    'plugins.table.createTable': {
      'en': 'Create table'
    },
    'plugins.table.ensureparagraph': {
      'en': 'Ensure Paragraph'
    },
    'plugins.table.modifytableandcell': {
      'en': 'Edit Table and Cell Properties'
    },
    'plugins.table.exitTableEditing': {
      'en': 'Exit Table Editing'
    },
    'plugins.undoRedo.undoTitle': {
      'en': 'Undo'
    },
    'plugins.undoRedo.undoText': {
      'en': 'Undo the last change.'
    },
    'plugins.undoRedo.redoTitle': {
      'en': 'Redo'
    },
    'plugins.undoRedo.redoText': {
      'en': 'Redo previously undone changes.'
    },
    'plugins.fullscreen.toggleTitle': {
      'en': 'Fullscreen'
    },
    'plugins.fullscreen.toggleText': {
      'en': 'Toggle fullscreen mode.'
    },
    'plugins.fullscreen.startTitle': {
      'en': 'Fullscreen'
    },
    'plugins.fullscreen.startText': {
      'en': 'Start fullscreen mode.'
    },
    'plugins.fullscreen.finishTitle': {
      'en': 'Fullscreen'
    },
    'plugins.fullscreen.finishText': {
      'en': 'Exit fullscreen mode.'
    },
    'plugins.control.closeTitle': {
      'en': 'Close'
    },
    'plugins.control.closeText': {
      'en': 'Finish editing the text.'
    },
    'plugins.control.saveTitle': {
      'en': 'Save'
    }
  };

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
(function (CUI) {
  'use strict';
  CUI.rte.Utils = (function () {

    var hooks = null;
    var getHooks = function () {
      if (!hooks) {
        hooks = new CUI.rte.Hooks();
      }
      return hooks;
    };

    var i18nProvider = null;
    var getI18nProvider = function () {
      if (!i18nProvider) {
        i18nProvider = new CUI.rte.I18nProvider();
      }
      return i18nProvider;
    };

    return {

      scope: function (fn, scope) {
        return function () {
          return fn.apply(scope, arguments);
        };
      },

      defer: function (fn, ms, scope, args) {
        var callFn = fn;
        if (scope) {
          callFn = function () {
            if (args) {
              fn.apply(scope, args);
            } else {
              fn.call(scope);
            }
          };
        } else if (args) {
          callFn = function () {
            fn.apply(scope, args);
          };
        }
        return window.setTimeout(callFn, ms);
      },

      htmlEncode: function (str) {
        if (str) {
          str = String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;')
            .replace(/>/g, '&gt;').replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
        }
        return str;
      },

      htmlDecode: function (str) {
        if (str) {
          str = String(str).replace(/&lt;/g, '<').replace(/&gt;/g, '>')
            .replace(/&quot;/g, '\"').replace(/&amp;/g, '&')
            .replace(/&#39;/, '\'');
        }
        return str;
      },

      stripTags: function (str) {
        if (str) {
          str = String(str).replace(/<\/?[a-z][a-z0-9]*[^<>]*>/gi, '');
        }
        return str;
      },

      merge: function (obj1, obj2) {
        for (var name in obj2) {
          if (obj2.hasOwnProperty(name)) {
            obj1[name] = obj2[name];
          }
        }
        return obj1;
      },

      setI18nProvider: function (provider) {
        i18nProvider = provider;
      },

      i18n: function (id, values) {
        return getI18nProvider().getText(id, values);
      },


      // "hooked" calls

      copyObject: function (obj) {
        return getHooks().copyObject(obj);
      },

      applyDefaults: function (obj, defaults) {
        return getHooks().applyDefaults(obj, defaults);
      },

      getMainWindow: function () {
        return getHooks().getMainWindow();
      },

      processUrl: function (url, type) {
        return getHooks().processUrl(url, type);
      },

      onPluginCreated: function (plugin) {
        return getHooks().onPluginCreated(plugin);
      },

      resolveRelativePath: function (relPath) {
        return getHooks().resolveRelativePath(relPath);
      },

      isExistingPage: function (path) {
        return getHooks().isExistingPage(path);
      },

      getServerPrefix: function (url) {
        return getHooks().getServerPrefix(url);
      },

      URL_IMAGE: 'image',

      URL_LINK: 'link',


      // mapping adapter specific stuff:

      isArray: CUI.rte.AdapterUtils.isArray,

      isString: CUI.rte.AdapterUtils.isString,

      apply: CUI.rte.AdapterUtils.apply,

      getPagePosition: CUI.rte.AdapterUtils.getPagePosition,

      getWidth: CUI.rte.AdapterUtils.getWidth,

      getHeight: CUI.rte.AdapterUtils.getHeight,

      jsonDecode: CUI.rte.AdapterUtils.jsonDecode,

      getBlankImageUrl: CUI.rte.AdapterUtils.getBlankImageUrl

    };

  }());
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.EditContext
 * This class is used to abstract the context the editor is used in.
 * @constructor
 * @param {HTMLElement} iFrame iframe the editor is running in (if any)
 * @param {window} win The window object that is suitable for the editor
 * @param {document} doc The document object that is suitable for the editor
 * @param {HTMLElement} root The "root" element (the iframe's body tag or the div that is
 *        made editable)
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.EditContext = new Class({

    toString: 'EditContext',

    /**
     * @private
     * @type HTMLElement
     */
    iFrame: null,

    /**
     * @private
     * @type window
     */
    win: null,

    /**
     * @private
     * @type document
     */
    doc: null,

    /**
     * @private
     * @type HTMLElement
     */
    root: null,

    /**
     * @private
     * @type Object
     */
    state: null,

    construct: function (iFrame, win, doc, root) {
      this.iFrame = iFrame;
      this.win = win;
      this.doc = doc;
      this.root = root;
      this.state = {};
    },

    /**
     * Creates the specified DOM element for the context.
     * @param {String} tagName The element's name
     * @return {HTMLElement} The DOM element; null, if context is not yet initialized
     */
    createElement: function (tagName) {
      return ((this.doc !== null && this.doc !== undefined) ? this.doc.createElement(tagName) : null);
    },

    /**
     * Creates a text node with the specified text data.
     * @param {String} textData Text data of the node
     * @return {HTMLElement} The text node
     */
    createTextNode: function (textData) {
      return ((this.doc !== null && this.doc !== undefined) ? this.doc.createTextNode(textData) : null);
    },

    /**
     * Checks if the edit context is fully initialized.
     * @return {Boolean} true if the edit context is fully initialized
     */
    isInitialized: function () {
      return (this.win !== null && this.win !== undefined) && (this.doc !== null && this.doc !== undefined) &&
        (this.root !== null && this.root !== undefined);
    },

    /**
     * Sets a certain context state.
     * @param {String} name The state's name
     * @param {Object} value The value
     * @since 5.6.1
     */
    setState: function (name, value) {
      this.state[name] = value;
    },

    /**
     * Gets a certain context state.
     * @param {String} name The state's name
     * @return {Object} The value; undefined if no value for the specified state is supplied
     * @since 5.6.1
     */
    getState: function (name) {
      var value;
      if (this.state.hasOwnProperty(name)) {
        value = this.state[name];
      }
      return value;
    },

    /**
     * Removes the specified context state.
     * @param {String} name The name of the state to be removed
     * @since 5.6.1
     */
    removeState: function (name) {
      if (this.state.hasOwnProperty(name)) {
        delete this.state[name];
      }
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.EditorKernel
 * @private
 * This class implements the core functionality each rich text-based editor requires.
 * It abstracts that core functionality from the component implementation - hence rich text
 * functionality may be used in different contexts, for example as a widget vs. inplace
 * editing.
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.EditorKernel = new Class({

    toString: 'EditorKernel',

    /**
     * @cfg {Boolean} removeSingleParagraphContainer
     * True if the paragraph element of texts that consist only of a single paragraph
     * should be removed on serialization (defaults to false).
     * For example, if a text is &lt;p&gt;Single paragraph text&lt;/p&gt;, the surrounding
     * "p" tag would get removed if this option was set to true. This option is mainly for
     * backward compatibility with CQ 5.1, where container tags had not yet been available.
     * Hence texts that were created by a CQ 5.1 instance will be surrounded by a single "p"
     * element before they are edited in a CQ 5.2 instance. By setting this option to true,
     * this automatically added "p" tag will get removed before the text is saved, at least
     * if no other paragraphs or containers were added.
     * @deprecated Use {@link CUI.rte.HtmlRules.BlockHandling#removeSingleParagraphContainer} instead
     */
    removeSingleParagraphContainer: false,

    /**
     * @cfg {String} singleParagraphContainerReplacement
     * Specifies the name of the tag that has to be used if a paragraph container cannot
     * be simply removed because it carries additional info (for example, alignment and/or
     * CSS classes; defaults to "div"). Note that this setting only takes effect if
     * {@link #removeSingleParagraphContainer} is set to true.
     * @deprecated Use {@link CUI.rte.HtmlRules.BlockHandling#singleParagraphContainerReplacement} instead
     */
    singleParagraphContainerReplacement: null,

    /**
     * @cfg {Object[]} linkInternalize
     * <p>Defines a list of attributes for which link internalizing has to be applied.</p>
     * <p>Link internalizing is necessary as the browser usually stores entire URLs in the
     * DOM, not relative links. Hence internal links must be rewritten to be "internal"
     * before submitting the text.</p>
     * <p>For example, the "href" attribute of a link might be created as something like
     * "http://localhost:4502/cq5/content/geometrixx/en.html", which has
     * to be stored as "/content/geometrixx/en.html".</p>
     * <p>Each element of the Array must have the following properties:</p>
     * <ul>
     *   <li><code>tag</code> : String<br>
     *     The name of the tag for which the internalizing should be done</li>
     *   <li><code>attribute</code> : String<br>
     *     The name of the attribute that contains the link to be internalized</li>
     * </ul>
     * <p>Defaults to:</p>
     <pre>
     [
     {
        "tag": "a",
        "attribute": "href"
    }, {
        "tag": "img",
        "attribute": "src"
    }
     ]
     </pre>
     */
    linkInternalize: null,

    /**
     * @cfg {Object} rtePlugins
     * <p>This is the root of all plugin-specific configuration.</p>
     * <p>You must provide a config element for each plugin you are about to configure.
     * Use the plugin's ID (see class documentation) as the property name for the
     * corresponding config element. Each config element has config options that are
     * used by all plugins, and plugin-specific options. Commonly used options are:</p>
     * <ul>
     *   <li><code>features</code> : String[]/String<br>
     *   A String[] that contains all features of a plugin that should be
     *   enabled; alternatively a String "*" may be provided to enable all features of the
     *   corresponding plugin</li>
     *   <li><code>tooltips</code> : Object<br>
     *   An object that defines the tooltips for the plugin's icons. Property name specifies
     *   the name of the icon (usually the ID of the feature that is represented by the
     *   icon; the value has a tooltip description object as required by Ext.</li>
     * </ul>
     * <p>Plugin-specific options are documented at the respective plugin. Note that this
     * object is null after constructing the RichText object has finished, as the
     * configuration is transferred to the respective plugin.</p>
     */

    /**
     * @cfg {CUI.rte.HtmlRules} htmlRules
     * This object defines how to create/process HTML. Defaults to null (uses default
     * HTML rules).
     * @since 5.3
     */
    htmlRules: null,

    /**
     * Processing module used for pre-processing HTML before editing
     * @private
     * @type CUI.rte.DomCleanup
     */
    preProcessor: null,

    /**
     * Processing module used for post-processing HTML before submitting or editing as
     * source code
     * @private
     * @type CUI.rte.DomCleanup
     */
    postProcessor: null,

    /**
     * Associative array of registered commands; values of type
     * {@link CUI.rte.commands.Command}
     * @private
     * @type Object
     */
    registeredCommands: null,

    /**
     * Associative array of registered plugins; values of type
     * {@link CUI.rte.plugins.Plugin}
     * @private
     * @type Object
     */
    registeredPlugins: null,

    /**
     * Current edit context. This should never be accessed directly, but only through
     * {@link #getEditContext}.
     * @private
     * @type CUI.rte.EditContext
     */
    editContext: null,

    /**
     * <p>Internal event listeners. Each element of the Array must have the following
     * properties:</p>
     * <ul>
     *   <li><code>fn</code> : String<br>
     *     A (suitably scoped) Function object that contains the listener code</li>
     *   <li><code>plugin</code> : String<br>
     *     The plugin that registers the listener</li>
     *   <li><code>deferred</code> : Boolean<br>
     *     True if the listener should be executed deferred (which is sometimes necessary to
     *     avoid some timing pitfalls, but not supported for all event types)</li>
     * </ul>
     * @private
     * @type Object[]
     */
    internalListeners: null,

    /**
     * <p>UI listeners. Each element of the Array must have the followeing properties:</p>
     * <ul>
     *   <li><code>fn</code> : String<br>
     *     A (suitably scoped) Function object that contains the listener code.</li>
     * </ul>
     * @private
     * @type Object[]
     */
    uiListeners: null,

    /**
     * The active toolbar (toolkit-independent)
     * @private
     * @type CUI.rte.ui.Toolbar
     */
    toolbar: null,

    /**
     * The previous active toolbar. (toolkit-independent)
     * @private
     * @type CUI.rte.ui.Toolbar
     */
    previousActiveToolbar: null,

    /**
     * Toolbars which are not active.
     * @private
     * @type Object of the form {String: CUI.rte.ui.Toolbar}
     */
    backgroundToolbars: {},

    /**
     * Context menu builder
     * @private
     * @type CUI.rte.ui.ContextMenuBuilder
     */
    contextMenuBuilder: null,

    /**
     * Currently displayed context menu (if any)
     * @private
     * @type Object
     */
    contextMenu: null,

    /**
     * The selection before the context menu gets invoked; required to be restored before
     * any command invoked through the context menu gets actually relayed
     * @private
     */
    contextMenuSavedRange: null,

    /**
     * Table of internally regsitered event handlers
     * @private
     * @type Object
     */
    registeredHandlers: null,

    /**
     * Flag that determines if event handling is currently established. Used to prevent
     * event handling being installed more than once.
     * @type Boolean
     * @private
     */
    isEventingEstablished: false,

    /**
     * Flag that determines if internal event handling is currently disabled.
     * @private
     * @type Boolean
     */
    isEventingDisabled: true,

    /**
     * Flag that determines if the current focus blur is only a temporary blur. This is
     * used to distinguish focus changes to the toolbar (= temporary blur) from focus
     * changes to somewhere else (those blurs lead to a disabled toolbar). Therefore,
     * toolbar elements that do not immediately return focus to the editor kernel, must
     * explicitly set this flag to true on receiving the focus themselves. For example,
     * a (style of format) selector sets isTemporaryBlur to true in their focus event.
     * On the other hand, buttons usually don't require to set it, as they are returning
     * focus immediately.
     * @private
     * @type Boolean
     */
    isTemporaryBlur: false,

    /**
     * Flag that determines if focus handling is active for this editor kernel. If disabled,
     * the toolbar doesn't get enabled/disabled on focus changes. This may for example
     * be used in situations where the client wants to take control over the toolbar (for
     * example in source edit mode)
     * @private
     * @type Boolean
     */
    isFocusHandlingDisabled: false,

    /**
     * Flag that determines if the kernel currently holds the keyboard focus.
     * @publicProp
     * @type Boolean
     */
    hasFocus: false,

    /**
     * Flag that determines if the kernel is currently enabled
     * @private
     * @type Boolean
     */
    isEnabled: false,

    /**
     * Object that defines which actions have to be executed on next focus gain.
     * @private
     * @type Object
     */
    focusGainActions: null,

    /**
     * Registered key shortcuts; key: the letter (Ctrl+&lt;letter&gt;); value: the command
     * @private
     * @type Object
     */
    keyboardShortcuts: null,

    /**
     * The UI toolkit to be used; default value: ext
     * @private
     */
    uiToolkit: null,

    /**
     * The dialog manager to be used
     * @private
     */
    dialogManager: null,

    /**
     * The ID of the selection change tracking interval
     * @private
     */
    selectionChangeTracker: null,

    /**
     * Number of times the editor has been locked
     */
    lockCount: 0,

    /**
     * The toolbar builder.
     * @private
     */
    tbBuilder: null,

    construct: function (config, defaultPluginConfigFn) {
      config = config || {};
      CUI.rte.Utils.applyDefaults(config, {
        'linkInternalize': [{
          'tag': 'a',
          'attribute': 'href'
        }, {
          'tag': 'img',
          'attribute': 'src'
        }]
      });
      this.keyboardShortcuts = {};
      // commands
      this.registeredCommands =
        CUI.rte.commands.CommandRegistry.createRegisteredCommands();
      // plugins
      this.registeredPlugins =
        CUI.rte.plugins.PluginRegistry.createRegisteredPlugins(this);
      CUI.rte.Compatibility.moveDeprecatedPluginConfig(config);
      CUI.rte.Compatibility.moveDeprecatedHtmlRules(config);
      CUI.rte.Compatibility.configurePlugins(config, this, defaultPluginConfigFn);
      delete config.rtePlugins;
      // Initialize HTML rules
      if (config.htmlRules) {
        this.htmlRules = new CUI.rte.HtmlRules(config.htmlRules);
        delete config.htmlRules;
      } else {
        this.htmlRules = new CUI.rte.HtmlRules();
      }
      // Toolkit ...
      if (config.uiToolkit) {
        this.uiToolkit = config.uiToolkit;
        delete config.uiToolkit;
      } else {
        this.uiToolkit = CUI.rte._toolkit ||
        CUI.rte.EditorKernel.DEFAULT_TOOLKIT;
      }
      // other config
      this.linkInternalize = config.linkInternalize;
      delete config.linkInternalize;
      // pre/post processing
      var tagRules = {};
      if (this.tagReplace) {
        // Compatibility layer for CQ 5.2
        for (var tag in this.tagReplace) {
          if (this.tagReplace.hasOwnProperty(tag)) {
            var replaceTag = this.tagReplace[tag];
            tagRules[tag] = {
              'rename': replaceTag
            };
          }
        }
      }
      // Processing HTML code/DOM
      var preProcessorConfig = this.htmlRules.serializer.cleanup ? this.htmlRules.serializer.cleanup.pre : undefined;
      preProcessorConfig = preProcessorConfig ? preProcessorConfig : {'tagsToRemove': ['font']};
      var postProcessorConfig = this.htmlRules.serializer.cleanup ? this.htmlRules.serializer.cleanup.post : undefined;
      postProcessorConfig = postProcessorConfig ? postProcessorConfig : {'tagsToRemove': ['font']};
      this.setProcessors(preProcessorConfig, postProcessorConfig);
      // other stuff
      var tk = CUI.rte.ui.ToolkitRegistry.get(this.uiToolkit);
      this.contextMenuBuilder = tk.createContextMenuBuilder(this);
      this.dialogManager = tk.createDialogManager(this);
      this.registeredHandlers = [];
      this.isEnabled = true;
      this.focusGainActions = {};
    },

    /**
     * @private
     */
    setProcessors: function (preProcessorConfig, postProcessorConfig) {
      this.preProcessor = new CUI.rte.DomCleanup(preProcessorConfig);
      this.postProcessor = new CUI.rte.DomCleanup(postProcessorConfig);
    },


    // Interface ---------------------------------------------------------------------------

    /**
     * Returns a suitable edit context for this EditorKernel's instance.
     * @return {CUI.rte.EditContext} The edit context for this instance
     */
    getEditContext: function () {
      // may be overridden by implementing EditorKernels
      if (this.editContext === null || this.editContext === undefined) {
        this.editContext = new CUI.rte.EditContext();
      }
      return this.editContext;
    },

    /**
     * Gets the HTML rules valid for this EditorKernel.
     * @return {CUI.rte.HtmlRules} The HTML rules
     */
    getHtmlRules: function () {
      return this.htmlRules;
    },

    /**
     * Gets a plugin by its ID
     * @iparam {String} id The plugin ID
     * @returns {CUI.rte.plugins.Plugin} The plugin; undefined if no such plugin exists
     */
    getPlugin: function (id) {
      var plugin;
      if (this.registeredPlugins.hasOwnProperty(id)) {
        plugin = this.registeredPlugins[id];
      }
      return plugin;
    },

    /**
     * Returns the path of the currently edited content (if available).
     * @return {String} The content path; null if no content path is available
     */
    getContentPath: function () {
      // must be overridden by implementing classes
      return null;
    },

    /**
     * Get the DOM element that is responsible for focus handling.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     * @return {HTMLElement} The DOM element that is responsible for focus handling
     */
    getFocusDom: function (context) {
      // must be overridden by implementing EditorKernels
      return null;
    },

    /**
     * Focusses the DOM element responsible for rich text editing.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    focus: function (context) {
      // must be overridden by implementing EditorKernels
    },

    /**
     * Blurs the focus.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    blurFocus: function (context) {
      // must be overridden by implementing EditorKernels
    },

    /**
     * Calculates a suitable position for a subordinate window.
     * @param {String} hint A positioning hint; allowed values are: "default"; defaults to
     *        "default"
     * @return {Number[]} The XY position for the subordinate window (e.g., [100, 200])
     */
    calculateWindowPosition: function (hint) {
      // must be overridden by implementing editor kernels
      return [0, 0];
    },

    /**
     * Calculates a suitable position for the context menu.
     * @param {CUI.rte.EditorEvent} event The event that invoked the context menu
     * @return {Number[]} The XY position for the context menu (e.g., [100, 200])
     */
    calculateContextMenuPosition: function (event) {
      // must be overridden by implementing editor kernels
      return [0, 0];
    },

    /**
     * Determines if the editor kernel can edit the html source.
     * @return {Boolean} True if the kernel is capable of editing the html source
     * @since 5.5
     */
    canEditSource: function () {
      // may be overridden accordingly
      return false;
    },

    /**
     * Gets the dialog manager for this editor kernel.
     * @return {CUI.rte.ui.DialogManager} The dialog manager
     * @since 5.6
     */
    getDialogManager: function () {
      return this.dialogManager;
    },


    // Helpers -----------------------------------------------------------------------------

    /**
     * Deferred focusing of the DOM element responsible for rich text editing.
     * @param {Function} addFn (optional) additional function to be executed after focus request
     */
    deferFocus: function (addFn) {
      // may be overridden if necessary
      CUI.rte.Utils.defer(function () {
        this.focus();
        if (addFn && (typeof(addFn) === 'function')) {
          addFn();
        }
      }, 10, this);
    },

    /**
     * Disables the kernel's event handling temporarily. It may be re-enabled by using
     * {@link #reenableEventHandling}.
     */
    disableEventHandling: function () {
      this.isEventingDisabled = true;
    },

    /**
     * Reeanbles the kernel's event handling after it was disabled temporarily (using
     * {@link #disableEventHandling}).
     */
    reenableEventHandling: function () {
      this.isEventingDisabled = false;
    },

    /**
     * Enables focus handling.
     */
    enableFocusHandling: function () {
      this.isFocusHandlingDisabled = false;
    },

    /**
     * Disables focus handling.
     */
    disableFocusHandling: function () {
      this.isFocusHandlingDisabled = true;
    },

    /**
     * Locks the editor, for example while a dialog for editing is shown.
     */
    lock: function () {
      this.lockCount++;
      if (this.isLocked() && !this.isEventingDisabled) {
        this.disableEventHandling();
      }
    },

    /**
     * Unlocks the editor, for example when a dialog (that has locked the editor) is hidden
     * again.
     */
    unlock: function () {
      this.lockCount--;
      if (!this.isLocked() && this.isEventingDisabled) {
        this.reenableEventHandling();
      }
    },

    /**
     * Checks if the editor is currently locked.
     * @returns {Boolean} True if the editor is currently locked
     */
    isLocked: function () {
      return (this.lockCount > 0);
    },


    /**
     * Executes some Gecko-related initialization. For example, disables the "enahanced"
     * table editing handles provided by Gecko browsers.
     */
    initializeGeckoSpecific: function () {
      var com = CUI.rte.Common;

      if (com.ua.isGecko && this.isEnabled) {
        var context = this.getEditContext();
        if (context.isInitialized()) {
          try {
            context.doc.execCommand('useCSS', true);
          } catch (e) {
            // ignore if unsupported
          }
          try {
            context.doc.execCommand('styleWithCSS', false, false);
          } catch (e) {
            // ignore if unsupported
          }
          try {
            context.doc.execCommand('enableInlineTableEditing', false, false);
          } catch (e) {
            // ignore if unsupported
          }
        }
      }
    },

    /**
     * <p>Ensures that the caret gets initialized.</p>
     * <p>Will be executed immediately, if the editor kernel currently has the focus, or
     * optionally on next focus gain.</p>
     */
    initializeCaret: function (enforceInit) {
      // may be overridden by the respective kernel implementation
    },

    /**
     * <p>Restores the last known IE selection.</p>
     * <p>This must be used to restore a selection after focus losses. For example, dragging
     * (and dropping) an image has to call this method to restore the insert point.</p>
     * <p>This method can be safely called for non-IE browsers - such calls are simply
     * ignored.</p>
     */
    restoreSelectionToLastKnownBookmark: function () {
      var sel = CUI.rte.Selection;
      var com = CUI.rte.Common;
      var context = this.getEditContext();
      if (com.ua.isOldIE && this.lastKnownBookmark) {
        if (!this.hasFocus) {
          this.focus();
        }
        sel.selectBookmark(context, this.lastKnownBookmark);
      }
    },


    // DOM-Event handling ------------------------------------------------------------------

    /**
     * Registers a DOM event handler.
     * @param {HTMLElement/window/document} obj The DOM object to register the handler for
     * @param {String} eventName The name of the event
     * @param {Function} handler The handler to be registered
     * @param {Object} scope Scope the handler will be executed in
     * @param {Object} options (optional) Options
     */
    registerHandler: function (obj, eventName, handler, scope, options) {
      var com = CUI.rte.Common;
      if (com.ua.isTouchInIframe && com.strStartsWith(eventName, 'touch')) {
        // emergency brake: must not use touch events if editor is in iframe
        return;
      }
      CUI.rte.Eventing.on(this.editContext, obj, eventName, handler, scope, options);
      this.registeredHandlers.push({
        'obj': obj,
        'eventName': eventName,
        'handler': handler,
        'scope': scope
      });
    },

    /**
     * Registers several DOM event handlers at once.
     * @param {HTMLElement/window/document} obj The DOM object to register the handler for
     * @param {Object} events The events to be registered. The key specifies the event name,
     *        the value contains the handler Function
     * @param {Object} scope Scope the handler will be executed in
     * @param {Object} options (optional) Options
     */
    registerHandlers: function (obj, events, scope, options) {
      for (var eventName in events) {
        if (events.hasOwnProperty(eventName)) {
          var handler = events[eventName];
          this.registerHandler(obj, eventName, handler, scope, options);
        }
      }
    },

    /**
     * Unregisters all elements that were registered through {@link #registerHandler} and
     * {@link #registerHandlers}.
     */
    unregisterHandlers: function () {
      var handlerCnt = this.registeredHandlers.length;
      for (var h = 0; h < handlerCnt; h++) {
        var def = this.registeredHandlers[h];
        CUI.rte.Eventing.un(def.obj, def.eventName, def.handler, def.scope);
      }
      this.registeredHandlers.length = 0;
    },

    /**
     * <p>Initializes event handling for this editor kernel.</p>
     * <p>Use {@link #suspendEventHandling}</p> to clean up after using the editor kernel.
     * </p>
     */
    initializeEventHandling: function () {
      if (this.isEventingEstablished) {
        // eventing already established - prevent initializing it again
        return;
      }
      var com = CUI.rte.Common;
      var context = this.getEditContext();
      // only initialize if the context is initialized and the component is enabled
      if (context.isInitialized() && this.isEnabled) {
        this.isEventingEstablished = true;
        var doc = context.doc;
        // deferred execution handlers - no workarounds here; performance-intense
        // operations are explicitly welcome for deferred execution!
        if (com.ua.isIE) {
          // IE must use selectionchange event to react on selection/caret changes,
          // otherwise we get invalid selections when clicking inside an existing
          // selection - see bug #21013
          this.registerHandlers(doc, {
            'selectionchange': function (e) {
              this.onEditorEvent(e);
            },
            'keyup': function (e) {
              this.onEditorEvent(e);
              if (this.isEventingDisabled) {
                return;
              }
              this.firePluginEvent('deferredkeyup', e, true);
            },
            'mousedown': function (e) {
              if (this.isEventingDisabled) {
                return;
              }
              this.firePluginEvent('deferredmousedown', e, true);
            },
            'mouseup': function (e) {
              if (this.isEventingDisabled) {
                return;
              }
              this.firePluginEvent('deferredmouseup', e, true);
            }
          }, this, {
            'buffer': 100
          });
        } else {
          // other browsers should listen to keyup/mousedown events
          this.registerHandlers(doc, {
            'keyup': function (e) {
              this.onEditorEvent(e);
              if (this.isEventingDisabled) {
                return;
              }
              this.firePluginEvent('deferredkeyup', e, true);
            }
          }, this, {
            'buffer': 100
          });
          if (!com.ua.isTouch) {
            this.registerHandlers(doc, {
              'mousedown': function (e) {
                if (this.isEventingDisabled) {
                  return;
                }
                this.firePluginEvent('deferredmousedown', e, true);
              },
              'mouseup': function (e) {
                this.onEditorEvent(e);
                if (this.isEventingDisabled) {
                  return;
                }
                this.firePluginEvent('deferredmouseup', e, true);
              }
            }, this, {
              'buffer': 100
            });
          } else {
            // touchstart/touchend are mapped to corresponding mousedown/mouseup
            // events
            this.registerHandlers(doc, {
              'touchstart': function (e) {
                if (this.isEventingDisabled) {
                  return;
                }
                this.firePluginEvent('deferredmousedown', e, true);
              },
              'touchend': function (e) {
                this.onEditorEvent(e);
                if (this.isEventingDisabled) {
                  return;
                }
                this.firePluginEvent('deferredmouseup', e, true);
              }
            }, this, {
              'buffer': 100
            });
            // "Thread" that checks periodically for selection changes on mobile
            // devices - there are a lot of cases where Safari does alter the
            // selection without notifying the app properly using an appropriate
            // DOM event
            var ek = this;
            this.selectionChangeTracker = window.setInterval(function () {
              var sel = CUI.rte.Selection;
              var bookmark = sel.createSelectionBookmark(context);
              if (this.lastKnownSelection) {
                var lks = this.lastKnownSelection;
                // TODO evaluate bookmark/lks.cells
                if ((bookmark.startPos !== lks.startPos) ||
                  (bookmark.charCnt !== lks.charCnt) ||
                  (bookmark.object !== lks.object)) {
                  ek.onEditorEvent(new CUI.rte.EditorEvent({
                    type: 'selectionchange'
                  }));
                }
              }
              this.lastKnownSelection = bookmark;
            }, 500);
          }
        }
        // keydown is the same across all browsers and all device categories
        this.registerHandlers(doc, {
          'keydown': function (e) {
            if (this.isEventingDisabled) {
              return;
            }
            this.firePluginEvent('deferredkeydown', e, true);
          }
        }, this, {
          'buffer': 100
        });

        // directly executed handlers - put workarounds that rely on immediately being
        // able on the DOM here. keep in mind that these events may get fired quite
        // often, so "expensive" operations should be executed here only if absolutely
        // necessary!
        this.registerHandlers(doc, {
          'keydown': function (e) {
            // workaround for MobileSafari temporary focus shift when in
            // iframe and touchXxx handlers present
            if (com.ua.isTouch) {
              if (com.isTag(context.win.frameElement, 'iframe')) {
                // console.log("using focus transfer workaround.")
                context.win.focus();
              }
            }
            this.cleanupOnEvent(e);
            if (this.isEventingDisabled) {
              return;
            }
            if (e.isCtrl()) {
              if (com.ua.isIE) {
                // handling of Ctrl-keys must be done here for IE
                var c = String.fromCharCode(e.getCharCode()).toLowerCase();
                var cmd = this.keyboardShortcuts[c];
                if (cmd) {
                  this.applyCommand(e);
                  return;
                } else {
                  // prevent formatting shortcuts from being automatically
                  // executed
                  if ((c === 'b') || (c === 'i') || (c === 'u') || (c === 'm')) {
                    e.stopEvent();
                    return;
                  }
                }
              }
            }
            this.firePluginEvent('beforekeydown', e, false);
            if (!e.cancelKey) {
              this.firePluginEvent('keydown', e, false);
            }
            if (e.cancelKey) {
              e.stopEvent();
              this.deferFocus();
            }
          },
          'keyup': function (e) {
            this.cleanupOnEvent(e);
            if (this.isEventingDisabled) {
              return;
            }
            this.firePluginEvent('beforekeyup', e, false);
            if (!e.cancelKey) {
              this.firePluginEvent('keyup', e, false);
            }
            if (e.cancelKey) {
              e.stopEvent();
              this.deferFocus();
            }
          },
          'keypress': function (e) {
            this.cleanupOnEvent(e);
            if (this.isEventingDisabled) {
              return;
            }
            if (com.ua.isGecko) {
              // shortcut handling on Gecko
              this.applyCommand(e);
            }
            if (!e.cancelKey) {
              this.firePluginEvent('beforekeypress', e, false);
            }
            if (!e.cancelKey) {
              this.firePluginEvent('keypress', e, false);
            }
            if (e.cancelKey) {
              e.stopEvent();
              this.deferFocus();
            }
          }
        }, this);

        // Mouse/Touch Events; fired directly
        if (com.ua.isTouch) {
          this.registerHandlers(doc, {
            'touchstart': function (e) {
              this.cleanupOnEvent(e);
              if (this.isEventingDisabled) {
                return;
              }
              this.firePluginEvent('mousedown', e, false);
            },
            'touchend': function (e) {
              this.cleanupOnEvent(e);
              if (this.isEventingDisabled) {
                return;
              }
              this.firePluginEvent('mouseup', e, false);
            }
          }, this);
        } else {
          this.registerHandlers(doc, {
            'mousedown': function (e) {
              this.cleanupOnEvent(e);
              if (this.isEventingDisabled) {
                return;
              }
              this.firePluginEvent('mousedown', e, false);
            },
            'mouseup': function (e) {
              this.cleanupOnEvent(e);
              if (this.isEventingDisabled) {
                return;
              }
              this.firePluginEvent('mouseup', e, false);
            }
          }, this);
        }

        // Focus-Events, fired immediately
        this.registerHandlers(this.getFocusDom(context), {
          'focus': function (e) {
            this.cleanupOnEvent(e);
            this.onFocus(e);
          },
          'blur': function (e) {
            this.cleanupOnEvent(e);
            this.onBlur(e);
          }
        }, this);

        // Other Events, fired immediately
        this.registerHandlers(doc.body, {
          'paste': function (e) {
            this.cleanupOnEvent(e);
            this.onPaste(e);
          }
        }, this);
        if (com.ua.isIE) {
          this.registerHandlers(doc, {
            'selectionchange': function (e) {
              this.cleanupOnEvent(e);
            }
          }, this, {
            // deferred execution required here; interacts strangely otherwise with
            // certain keystrokes (inserts two paragraphs when Enter is hit (once)
            // on IE >= 9)
            buffer: 10
          });
        }

        this.initializeGeckoSpecific();

        this.registerHandler(context.root, 'contextmenu', function (event) {
          if (this.isEventingDisabled) {
            return false;
          }
          // disable internal event handling for the time the context menu
          // is shown to prevent side-effects
          this.isEventingDisabled = true;
          event.preventDefault();
          if (!this.handleContextMenu(event)) {
            // no context menu shown: enable event handling again
            this.isEventingDisabled = false;
          }
          return false;
        }, this);
        // handler for selecting images directly on Webkit & MS Edge
        if (com.ua.isWebKit || com.ua.isEdge) {
          this.registerHandler(context.root, 'click', function(event) {
            var target = event.getOriginalTarget();
            if (com.isTag(target, 'img')) {
                CUI.rte.Selection.selectNode(context, target);
            }
          });
        }
      }
    },

    /**
     * <p>Suspends event handling for this editor kernel.</p>
     * <p>Use {@link #initializeEventHandling} to re-establish event handling.</p>
     */
    suspendEventHandling: function () {
      if (!this.isEventingEstablished) {
        // no eventing initialized - nothing to suspend
        return;
      }
      this.unregisterHandlers();
      if (this.selectionChangeTracker !== null) {
        window.clearInterval(this.selectionChangeTracker);
        this.selectionChangeTracker = null;
      }
      this.isEventingEstablished = false;
    },

    /**
     * <p>Adds CSS "feature classes" to the specified DOM element.</p>
     * <p>Supported feature classes are:</p>
     * <ul>
     *   <li>ie - Internet Explorer</li>
     *   <li>ie6 - Internet Explorer 6</li>
     *   <li>ie7 - Internet Explorer 7</li>
     *   <li>ie8 - Internet Explorer 8</li>
     *   <li>ie9 - Internet Explorer 9</li>
     *   <li>ie10 - Internet Explorer 10</li>
     *   <li>gecko - Gecko engine</li>
     *   <li>webkit - Webkit engine</li>
     *   <li>safari - Safari</li>
     *   <li>chrome - Chrome</li>
     * </ul>
     * @param {HTMLElement} dom The DOM element
     */
    addFeatureClasses: function (dom) {
      var com = CUI.rte.Common;

      function addConditionally(cond, cssClass) {
        if (cond) {
          com.addClass(dom, cssClass);
        }
      }

      addConditionally(com.ua.isIE, 'ie');
      addConditionally(com.ua.isIE6, 'ie6');
      addConditionally(com.ua.isIE7, 'ie7');
      addConditionally(com.ua.isIE8, 'ie8');
      addConditionally(com.ua.isIE9, 'ie9');
      addConditionally(com.ua.isIE10, 'ie10');
      addConditionally(com.ua.isGecko, 'gecko');
      addConditionally(com.ua.isWebKit, 'webkit');
      addConditionally(com.ua.isSafari, 'safari');
      addConditionally(com.ua.isChrome, 'chrome');
    },

    /**
     * Internal handler for focus events.
     * @private
     */
    onFocus: function (e) {
      var com = CUI.rte.Common;

      if (!this.hasFocus) {
        if (com.ua.isOldIE) {
          // IE sends a onFocus event if the main window, but not the editor window
          // gets the focus, so we'll ignore the focus event if the range doesn't
          // point to the editor's window object
          var context = this.getEditContext();
          var editorWin = context.win;
          var range = CUI.rte.Selection.getLeadRange(context);
          var rangeWin;
          if (range.item) {
            rangeWin = range.item(0).ownerDocument.parentWindow;
          } else {
            rangeWin = range.parentElement().ownerDocument.parentWindow;
          }
          var hasRange = (rangeWin === editorWin);
          if (!hasRange) {
            return;
          }
        }
        this.isEventingDisabled = false;
        this.hasFocus = true;
        if (!this.isFocusHandlingDisabled) {
          this.fireUIEvent('focusgained');
          this.enableToolbar();
          this.updateToolbar();
        }
        this.onEditorEvent(e);
        // execute deferred stuff that has been scheduled for being executed on focus
        // gain
        if (this.focusGainActions.initializeCaret) {
          this.initializeCaret(false);
          this.focusGainActions.initializeCaret = false;
        }
      }
    },

    /**
     * Internal handler for blur events.
     * @private
     */
    onBlur: function (e) {
      if (this.hasFocus) {
        this.isEventingDisabled = true;
        this.isTemporaryBlur = false;
        this.hasFocus = false;
        if (!this.isFocusHandlingDisabled) {
          this.fireUIEvent('focuslost');
          CUI.rte.Utils.defer(function () {
            if (this.isEventingDisabled && !this.isTemporaryBlur && !this.isFocusHandlingDisabled) {
              this.disableToolbar();
            }
          }, 100, this);
        }
      }
    },

    /**
     * Internal handler for paste events (currently supported browsers only).
     * @private
     */
    onPaste: function (e) {
      if (this.isEventingDisabled) {
        return;
      }
      this.firePluginEvent('paste', e, false);
    },

    /**
     * <p>Notifies an (indirect) blur.</p>
     * <p>This method may be used to tell the editor kernel about implicit blurs. For
     * example, Gecko doen't send explicit blur events if the internal iframe gets hidden.
     * </p>
     */
    notifyBlur: function () {
      if (this.hasFocus) {
        this.onBlur();
      }
    },

    /**
     * Cleans up temporary stuff, as required by the specified event.
     * @param {CUI.rte.EditorEvent} e The event
     * @private
     */
    cleanupOnEvent: function (e) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      switch (e.getType()) {
      case 'mousedown':
        dpr.removeTempSpans(e.editContext, true);
        break;
      case 'keydown':
        if (!com.ua.isWebKit) {
          dpr.removeTempSpans(e.editContext, true);
        }
        break;
      case 'keyup':
        if (com.ua.isWebKit) {
          dpr.removeTempSpans(e.editContext, true);
        }
        break;
      }
    },

    /**
     * <p>Centralized handler for deferred editor events (which should not be executed on
     * directly, but after a short while if no other event occurs).</p>
     * <p>There is several cleanup code in place; but mainly, the toolbar gets updated
     * (as it is a quite expensive operation).</p>
     * @param {Object} e The editor event (wrapping the original Ext event)
     * @private
     */
    onEditorEvent: function (e) {
      var com = CUI.rte.Common;
      var ignoreEventForContextMenu = false;
      if (com.ua.isIE) {
        if (e.getType() === 'selectionchange') {
          ignoreEventForContextMenu = true;
          // store current bookmark to have it available later
          var context = this.getEditContext();
          if (context.isInitialized() && this.hasFocus) {
            this.lastKnownBookmark = CUI.rte.Selection.createSelectionBookmark(
              context);
          }
        }
      } else {
        ignoreEventForContextMenu = (e.getType() === 'mouseup') && (e.getButton() === 2);
      }
      if (!ignoreEventForContextMenu) {
        if (this.contextMenu && this.contextMenuBuilder.isVisible()) {
          this.contextMenuBuilder.hideAll();
          this.isEventingDisabled = false;
        }
      }
      if (this.isEventingDisabled) {
        return;
      }
      this.fireUIEvent('updatestate', {
        'origin': 'event',
        'event': e
      });
    },


    // Markup-based processing -------------------------------------------------------------

    /**
     * @private
     */
    getEmptyLinePlaceholderMarkup: function () {
      // will be adjusted in a browser-specific way by DomCleanup
      return '<p>&nbsp;</p>';
    },


    // Pre- and postprocessing -------------------------------------------------------------

    setUnprocessedHtml: function (html) {
      if (html.length < 1) {
        var interceptedHtml = this.execContentInterception('emptyContent', null);
        if (interceptedHtml !== null && interceptedHtml !== undefined) {
          html = interceptedHtml;
        } else {
          html = this.getEmptyLinePlaceholderMarkup();
        }
      }
      var context = this.getEditContext();
      this.htmlRules.serializer.deserialize(context, html, context.root,
        this.htmlRules.docType);
      this.htmlRules.genericHtml.deserialize(context, context.root);
      CUI.rte.WhitespaceProcessor.process(context, context.root);
      this.preProcessor.preprocess(this, context.root);
      this.execContentInterception('postprocessDom', {
        'editContext': context
      });
    },

    getProcessedHtml: function () {
      var context = this.getEditContext();
      var root = context.root.cloneNode(true);
      this.execContentInterception('cleanDom', {
        'editContext': this.getEditContext(),
        'root': root
      });
      this.postProcessor.postprocess(this, root);
      this.htmlRules.genericHtml.serialize(context, root);
      return this.htmlRules.serializer.serialize(context, root, this.htmlRules.docType);
    },


    // Executing commands ------------------------------------------------------------------

    /**
     * @private
     */
    getCustomCommand: function (command) {
      var customCommand = this.registeredCommands[command];
      if (customCommand) {
        return customCommand;
      }
      for (var cmd in this.registeredCommands) {
        var cmdToCheck = this.registeredCommands[cmd];
        if (cmdToCheck.isCommand(command)) {
          return cmdToCheck;
        }
      }
      return null;
    },

    /**
     * Executes an editor command on the editor document and performs necessary focus and
     * toolbar updates. Commands that are not supported by a specific browser are emulated
     * accordingly. <b>This should only be called after the editor is initialized.</b>
     * @param {String} cmd The Midas command
     * @param {Object} value (optional) The value to pass to the command (defaults to null)
     */
    relayCmd: function (cmd, value) {
      if (!this.isEnabled) {
        return;
      }
      CUI.rte.Utils.defer(function () {
        var context = this.getEditContext();
        var sel = CUI.rte.Selection;
        var com = CUI.rte.Common;
        var execRet;

        if (context.isInitialized()) {
          this.focus(context);
        }
        try {
          var preferredScrollOffset;
          if (context.isInitialized()) {
            preferredScrollOffset = (com.ua.isIE ? null :
              sel.getPreferredScrollOffset(context));
          }
          execRet = this.execCmd(cmd, value, context);
          if (com.ua.isGecko && execRet && context.isInitialized()) {
            if (execRet.geckoEnsureCaretVisibility) {
              sel.ensureCaretVisibility(context, preferredScrollOffset);
            }
            if (execRet.bookmark) {
              sel.selectBookmark(context, execRet.bookmark);
            }
          }
        } catch (e) {
          if (e.message === 'Cannot paste.') {
            this.getDialogManager().alert(
              CUI.rte.Utils.i18n('kernel.alertTitlePaste'),
              CUI.rte.Utils.i18n('kernel.alertSecurityPaste'),
              CUI.rte.Utils.scope(this.deferFocus, this));
          } else if (e.message === 'Cannot copy.') {
            this.getDialogManager().alert(
              CUI.rte.Utils.i18n('kernel.alertTitleCopy'),
              CUI.rte.Utils.i18n('kernel.alertSecurityCopy'),
              CUI.rte.Utils.scope(this.deferFocus, this));
          } else if (e.message === 'Cannot cut.') {
            this.getDialogManager().alert(
              CUI.rte.Utils.i18n('kernel.alertTitleCut'),
              CUI.rte.Utils.i18n('kernel.alertSecurityCut'),
              CUI.rte.Utils.scope(this.deferFocus, this));
          } else if (e.message === 'Could not insert html due to IE limitations.') {
            this.getDialogManager().alert(
              CUI.rte.Utils.i18n('kernel.alertTitleError'),
              CUI.rte.Utils.i18n('kernel.alertIELimitation'),
              CUI.rte.Utils.scope(this.deferFocus, this));
          } else {
            throw e;
          }
        }
        this.fireUIEvent('updatestate', {
          'origin': 'command',
          'cmd': cmd,
          'value': value,
          'ret': execRet
        });
      }, 10, this);
    },

    /**
     * Executes an editor command directly on the editor document. For visual commands, you
     * should use {@link #relayCmd} instead. Commands that are not supported by a specific
     * browser are emulated accordingly. <b>This method should only be called after the
     * editor is initialized. Otherwise, it will return immediately if the command is not
     * explicitly flagged for use in unitialized state.</b>
     * @param {String} command The Midas command
     * @param {Object} value (optional) The value to pass to the command (defaults to null)
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    execCmd: function (command, value, context) {
      var sel = CUI.rte.Selection;
      var dpr = CUI.rte.DomProcessor;
      var cmd = CUI.rte.commands.Command;
      var com = CUI.rte.Common;
      // init
      if (!this.isEnabled) {
        return null;
      }
      if (!context) {
        context = this.getEditContext();
      }
      // check if a custom command has to be used instead of browser's implementation
      var customCommand = this.getCustomCommand(command);
      if (!context.isInitialized() && !customCommand) {
        return null;
      }
      if (!context.isInitialized()) {
        if (customCommand.requiresInitializedComponent(command)) {
          return null;
        }
      }
      if (this.initialized) {
        this.firePluginEvent('beforecommandexecuted', {
          'cmd': command,
          'cmdValue': value,
          'customCommand': customCommand
        }, false);
      }
      var calleeRet = null;
      if (customCommand) {
        var options = customCommand.getProcessingOptions();
        var execOptions = {
          'editContext': context,
          'command': command,
          'value': value,
          'component': this
        };
        if (context.isInitialized()) {
          if ((options & cmd.PO_SELECTION) > 0) {
            execOptions.selection = this.createQualifiedSelection(context);
            // Use normalized selection if we have a selection to ensure
            // start node does not point "behind" a node, but points to the
            // first actually included node. If the selection represents a caret,
            // we'll have to use the un-normalized selection, because the position
            // behind a node may have different impact than the position before
            // the succeeding node (for example, t|<b>ex</b>t will insert a
            // character in plaintext, whereas t<b>|ex</b>t will insert a bold
            // character.
            if (execOptions.selection &&
              sel.shouldNormalizePSel(context, execOptions.selection)) {
              sel.normalizeProcessingSelection(context, execOptions.selection);
            }
          }
          if ((options & cmd.PO_BOOKMARK) > 0) {
            if (execOptions.selection) {
              execOptions.bookmark = sel.bookmarkFromProcessingSelection(context,
                execOptions.selection);
            } else {
              execOptions.bookmark = sel.createSelectionBookmark(context);
            }
          }
          if ((options & cmd.PO_NODELIST) > 0) {
            if (!execOptions.selection) {
              execOptions.selection = this.createQualifiedSelection(context);
            }
            execOptions.nodeList = dpr.createNodeList(context,
              execOptions.selection);
          }
        }
        var execRet = customCommand.execute(execOptions);
        if (context.isInitialized()) {
          var bookmark = execOptions.bookmark;
          if (bookmark && execRet && execRet.preventBookmarkRestore) {
            bookmark = null;
          }
          if (bookmark && execRet && execRet.selOffset) {
            if (execRet.selOffset.start) {
              bookmark.startPos += execRet.selOffset.start;
            }
            if (execRet.selOffset.collapse) {
              bookmark.charCnt = 0;
            } else if (execRet.selOffset.cnt) {
              bookmark.charCnt += execRet.selOffset.cnt;
            }
          }
          if (bookmark) {
            sel.selectBookmark(context, bookmark);
          }
        }
        if (execRet && execRet.calleeRet) {
          calleeRet = execRet.calleeRet;
        }
      } else {
        context.doc.execCommand(command, false, value === undefined ? null : value);
        if (com.ua.isGecko && com.strStartsWith(command, 'insert') &&
          com.strEndsWith(command, 'list')) {
          // clean up, as Gecko creates lines, not paragraphs
          dpr.ensureBlockContent(context, 'p', null, true, false);
        }
      }
      if (context.isInitialized()) {
        this.firePluginEvent('commandexecuted', {
          'cmd': command,
          'cmdValue': value,
          'customCommand': customCommand
        }, false);
      }
      return calleeRet;
    },

    /**
     * <p>Queries the state for the specified command.</p>
     * <p>The result is dependent on the specified command. Some commands may not return
     * any state. See command documentation for more information.</p>
     * @param {String} command The command to query state for
     * @param {Object} selectionDef (optional) Analyzed selection
     * @since 5.3
     */
    queryState: function (command, selectionDef) {
      if (!this.isEnabled) {
        return false;
      }
      var context = this.getEditContext();
      if (!context.isInitialized) {
        return false;
      }
      var customCommand = this.getCustomCommand(command);
      if (!customCommand) {
        return context.doc.queryCommandState(command);
      }
      if (!selectionDef) {
        selectionDef = this.analyzeSelection();
      }
      if (!selectionDef) {
        return false;
      }
      return customCommand.queryState(selectionDef, command);
    },


    // Keyboard shortcuts ------------------------------------------------------------------

    /**
     * Registers a keyboard shortcut for the specified command.
     * @param {String} letter The letter to register; "b" will register the command for
     *        Ctrl+B
     * @param {String} command The command to be executed for the shortcut
     * @since 5.5
     */
    registerKeyboardShortcut: function (letter, command) {
      this.keyboardShortcuts[letter.toLowerCase()] = command;
    },

    /**
     * Applies several key commands on Gecko
     * @private
     */
    applyCommand: function (e) {
      if (e.isCtrl()) {
        var c = String.fromCharCode(e.getCharCode()).toLowerCase();
        var cmd = this.keyboardShortcuts[c];
        if (cmd) {
          e.cancelKey = true;
          e.stopEvent();
          this.focus();
          this.execCmd(cmd);
          this.deferFocus();
        }
      }
    },

    /**
     * Requests source edit mode (if available).
     * @param {Boolean} enable True if source edit mode should be activated
     */
    requestSourceEdit: function (enable) {
      this.isTemporaryBlur = true;
      this.fireUIEvent((enable ? 'enable' : 'disable') + 'sourceedit');
    },


    // State -------------------------------------------------------------------------------

    /**
     * Enables the editor kernel for editing.
     */
    enable: function () {
      if (!this.isEnabled) {
        this.isEnabled = true;
        this.initializeEventHandling();
        if (this.hasFocus) {
          this.updateToolbar();
        }
      }
    },

    /**
     * Disables the editor kernel for editing.
     */
    disable: function () {
      if (this.isEnabled) {
        this.suspendEventHandling();
        this.disableToolbar(['sourceedit']);
        this.isEnabled = false;
      }
    },


    // Selection handling ------------------------------------------------------------------

    /**
     * <p>Creates a "qualified" processing selection.</p>
     * <p>"Qualified" means the original browser selection plus manipulations executed
     * by one or more plugins.</p>
     * @return {Object} qualified selection; null if no valid selection exists
     * @private
     */
    createQualifiedSelection: function (context) {
      var selection = CUI.rte.Selection.createProcessingSelection(context);
      if (!selection || (selection.startNode === null || selection.startNode === undefined)) {
        return null;
      }
      for (var pluginId in this.registeredPlugins) {
        if (this.registeredPlugins.hasOwnProperty(pluginId)) {
          var plugin = this.registeredPlugins[pluginId];
          plugin.manipulateSelection(selection);
        }
      }
      return selection;
    },

    /**
     * <p>Creates a "qualified" range bookmark.</p>
     * <p>"Qualified" means the original ranges selection plus manipulations executed
     * by one or more plugins.</p>
     * @return {Object} qualified range bookmark
     * @private
     */
    createQualifiedRangeBookmark: function (context) {
      var bookmark = CUI.rte.Selection.createRangeBookmark(context);
      for (var pluginId in this.registeredPlugins) {
        if (this.registeredPlugins.hasOwnProperty(pluginId)) {
          var plugin = this.registeredPlugins[pluginId];
          plugin.saveRangeBookmark(bookmark);
        }
      }
      return bookmark;
    },

    /**
     * <p>Selects a "qualified" range bookmark.</p>
     * <p>"Qualified" means the original ranges selection plus manipulations executed
     * by one or more plugins.</p>
     * @param {Object} bookmark qualified range bookmark
     * @private
     */
    selectQualifiedRangeBookmark: function (context, bookmark) {
      CUI.rte.Selection.selectRangeBookmark(context, bookmark);
      for (var pluginId in this.registeredPlugins) {
        if (this.registeredPlugins.hasOwnProperty(pluginId)) {
          var plugin = this.registeredPlugins[pluginId];
          plugin.restoreRangeBookmark(bookmark);
        }
      }
    },

    /**
     * <p>Analyzes the current selection considering the following:</p>
     * <ul>
     *   <li>isSelection - if there is an actual selection or just a collapsed
     *     selection (caret)</li>
     *   <li>anchorCount - number of links intersected by the current selection</li>
     *   <li>anchors - definition (href, target) of all links intersected by the selection
     *     </li>
     *   <li>namedAnchorCount - number of anchors (a name="...") intersected by the current
     *     selection</li>
     *   <li>namedAnchors - definition of all anchors (a name="...") intersected by the
     *     current selection</li>
     *   <li>nodeList - List of nodes the selection consists of (see
     *     {@link CUI.rte.NodeList})</li>
     *   <li>styleCount - number of different CSS styles (classes) that are present in the
     *     current selection</li>
     *   <li>styles - CSS styles (classes) that are present in the current
     *     selection</li>
     *   <li>isContinuousStyle - true if there is only one style (CSS class) present in the
     *     current selection (not caret)</li>
     *   <li>containerList - list of all container tags that are intersected by the current
     *     selection</li>
     *   <li>consistentFormatting - list of all common ancestors DOM nodes (which define
     *     the formatting that is consistent through the entire selection)</li>
     *   <li>editContext - the edit context</li>
     *   <li>selection - the original processing selection</li>
     *   <li>selectedDom - the DOM node that is currently selected (if only the object
     *     itself is selected)</li>
     * </ul>
     * @param {Boolean} lastKnown (optional) if the current selection cannot be determined
     *        (for example, if the editor does not have the focus), the last known
     *        selection is returned instead of null if this parameter is set to true
     * @return {Object} The result as described above
     * @private
     */
    analyzeSelection: function (context, lastKnown) {
      var sel = CUI.rte.Selection;
      var dpr = CUI.rte.DomProcessor;
      if (!context) {
        context = this.getEditContext();
      }
      var anchors = [];
      var namedAnchors = [];
      var stylesDef = {};
      var startStylesDef = stylesDef;
      var consistentFormatting = [];
      var selection = this.createQualifiedSelection(context);
      if (!selection) {
        return (lastKnown ? this.currentAnalyzedSelection : null);
      }
      var isSelection = sel.isSelection(selection);
      // Use normalized selection if we have a selection to ensure
      // start node does not point "behind" a node, but points to the
      // first actually included node. If the selection represents a caret,
      // we'll have to use the un-normalized selection, because the position
      // behind a node may have different impact than the position before
      // the succeeding node (for example, t|<b>ex</b>t will insert a
      // character in plaintext, whereas t<b>|ex</b>t will insert a bold
      // character.
      if (sel.shouldNormalizePSel(context, selection)) {
        sel.normalizeProcessingSelection(context, selection);
      }
      var nodeList = dpr.createNodeList(context, selection);
      nodeList.getAnchors(context, anchors, true);
      nodeList.getNamedAnchors(context, namedAnchors, true);
      if (isSelection) {
        nodeList.getStyles(context, stylesDef, true);
        startStylesDef = {};
      }
      var styleNode = selection.startNode;
      dpr.getStyles(context, startStylesDef, styleNode);
      var commonAncestor = nodeList.commonAncestor;
      while (commonAncestor) {
        consistentFormatting.push(commonAncestor);
        commonAncestor = CUI.rte.Common.getParentNode(context, commonAncestor);
      }
      var selectedDom = sel.getSelectedDom(context, selection);
      var styles = (stylesDef.styles ? stylesDef.styles : []);
      var startStyles = startStylesDef.styles ? startStylesDef.styles : [];
      this.currentAnalyzedSelection = {
        'selection': selection,
        'selectedDom': selectedDom,
        'nodeList': nodeList,
        'isSelection': isSelection,
        'anchorCount': anchors.length,
        'anchors': anchors,
        'namedAnchorCount': namedAnchors.length,
        'namedAnchors': namedAnchors,
        'styleCount': styles.length,
        'styles': styles,
        'startStyleCount': startStyles.length,
        'startStyles': startStyles,
        'isContinuousStyle': stylesDef.isContinuousStyle,
        'consistentFormatting': consistentFormatting,
        'containerList': dpr.createContainerList(context, selection),
        'auxRoots': dpr.getAuxRoots(context, selection),
        'editContext': context
      };
      return this.currentAnalyzedSelection;
    },


    // Plugin-related stuff ----------------------------------------------------------------

    /**
     * <p>Registers a editor-related event handler for a plugin.</P>
     * <p>Currently the following events are supported:</p>
     * <ul>
     *   <li>mousedown</li>
     *   <li>mouseup</li>
     *   <li>beforekeydown (vetoable)</li>
     *   <li>keydown</li>
     *   <li>beforekeyup (vetoable)</li>
     *   <li>keyup</li>
     *   <li>beforecommandexecuted (non-deferred usage only)</li>
     *   <li>commandexecuted (non-deferred usage only)</li>
     *   <li>aftertoolbarswitch (is fired when active toolbar is replaced by a toolbar from background)</li>
     * </ul>
     * <p>Note that you can specify a priority for the listener to ensure the order in which
     * listeners are executed. Default priority is 1000.</p>
     * @param {String} eventName Event name (see doc for supported values)
     * @param {Function} fn Event handler function
     * @param {Object} scope Scope for fn
     * @param {CUI.rte.plugins.Plugin} plugin Plugin that registers the event handler
     * @param {Boolean} isDeferred True if the listener should be executed
     *        "deferred"
     * @param {Number} priority (optional) The listener's priority; defaults to 1000
     * @private
     */
    addPluginListener: function (eventName, fn, scope, plugin, isDeferred, priority) {
      if (priority === null || priority === undefined) {
        priority = 1000;
      }
      if (!this.internalListeners) {
        this.internalListeners = {};
      }
      if (!this.internalListeners[eventName]) {
        this.internalListeners[eventName] = [];
      }
      var listeners = this.internalListeners[eventName];
      var listenerCnt = listeners.length;
      var listenerDef = {
        'fn': scope ? CUI.rte.Utils.scope(fn, scope) : fn,
        'plugin': plugin,
        'deferred': isDeferred,
        'priority': priority
      };
      for (var l = 0; l < listenerCnt; l++) {
        var listenerToCheck = listeners[l];
        if (listenerToCheck.priority > priority) {
          listeners.splice(l, 0, listenerDef);
          return;
        }
      }
      listeners.push(listenerDef);
    },

    /**
     * Unregisters all editor-related event handlers of a specific type for the specified
     * plugin.
     * @param {String} eventName Event name (see {@link #addPluginListener} for supported
     *        values)
     * @param {CUI.rte.plugins.Plugin} plugin Plugin that unregisters its event handlers
     * @private
     */
    removePluginListener: function (eventName, plugin) {
      if (!this.internalListeners || !this.internalListeners[eventName]) {
        return;
      }
      var listeners = this.internalListeners[eventName];
      var listenerCnt = listeners.length;
      for (var l = listenerCnt - 1; l >= 0; l--) {
        if (listeners[l].plugin === plugin) {
          listeners.splice(l, 1);
        }
      }
    },

    /**
     * <p>Fires an editor-related event.</p>
     * <p>Both {@link CUI.rte.EditorEvent}s and "higher level"/custom events can be
     * sent to the registered listeners using this method. To dispatch a custom event,
     * provide a suitable Object as parameter param. Note that the eventName parameter is
     * ignored if a {@link CUI.rte.EditorEvent} is provided as param.</p>
     * @param {String} eventName Event name (see {@link #addPluginListener} for supported
     *        values)
     * @param {Object|CUI.rte.EditorEvent} param Event specific parameter: either an
     *        Object for a custom event, or a CUI.rte.EditorEvent for forwarding
     *        editor events.
     * @param {Boolean} isDeferred True if the Event is fired from a deferred
     *        context (note that the event is always dispatched immediately, but it is
     *        dispatched to different event listeners)
     * @private
     */
    firePluginEvent: function (eventName, param, isDeferred) {
      if (!this.internalListeners || !this.internalListeners[eventName]) {
        return;
      }
      // pass/forward EditorEvents 1:1; create a PluginEvent otherwise - this allows
      // the listeners to manipulate EditorEvents (mainly: cancel the event) directly
      // and the callee to react on it appropriately
      var event;
      if (param instanceof CUI.rte.EditorEvent) {
        event = param;
      } else {
        event = new CUI.rte.plugins.PluginEvent(eventName, this.getEditContext(),
          param);
      }
      var listenerCnt = this.internalListeners[eventName].length;
      for (var l = 0; l < listenerCnt; l++) {
        var listenerDef = this.internalListeners[eventName][l];
        if (listenerDef && listenerDef.fn) {
          if (listenerDef.deferred === isDeferred) {
            listenerDef.fn(event);
          }
        }
      }
      return event;
    },

    /**
     * <p>Executes a content interception.</p>
     * <p>"Content interceptions" are used for providing plugin-specific content or
     * processing content in a plugin-specific way. For example, the table plugin may
     * intercept the "empty content" situation and provide a different empty content
     * markup than the default in table edit mode. Also, it may intercept the HTML
     * creation on submit and change the transmitted HTML (for example) to an empty string
     * if actually an empty table would be submitted in table edit mode.</p>
     * @param {String} contentType Content type to intercept
     * @param {Object} defs Definitions of the content interception; format depends on the
     *        content type
     */
    execContentInterception: function (contentType, defs) {
      for (var pluginId in this.registeredPlugins) {
        if (this.registeredPlugins.hasOwnProperty(pluginId)) {
          var plugin = this.registeredPlugins[pluginId];
          var interceptedContent = plugin.interceptContent(contentType, defs);
          if (interceptedContent !== null && interceptedContent !== undefined) {
            return interceptedContent;
          }
        }
      }
      return null;
    },


    // UI-related stuff --------------------------------------------------------------------

    /**
     * <p>Registers a UI-related event handler.</P>
     * <p>Currently the following events are supported:</p>
     * <ul>
     *   <li>updatestate - signals a selection state change</li>
     *   <li>preventdrop - signals that drag & drop on the text component should be
     *     temporarily disabled</li>
     *   <li>reactivatedrop - signals that drag & drop on the text component should be
     *     reactivated</li>
     *   <li>enablesourceedit - signals that source edit mode is requested</li>
     *   <li>disablesourceedit - signals that WYSIWYG edit mode is requested</li>
     *   <li>dialogshow - signals that a dependent dialog has been shown</li>
     *   <li>dialoghide - signals that a dependent dialog has been hidden</li>
     *   <li>focusgained - signals that the text component has been focussed</li>
     *   <li>focuslost - signals that the text component has been blurred</li>
     * </ul>
     * @param {String} eventName Event name (see doc for supported values)
     * @param {Function} fn Event handler function
     * @param {Object} scope Scope for fn
     * @private
     */
    addUIListener: function (eventName, fn, scope) {
      if (!this.uiListeners) {
        this.uiListeners = {};
      }
      if (!this.uiListeners[eventName]) {
        this.uiListeners[eventName] = [];
      }
      this.uiListeners[eventName].push({
        'fn': scope ? CUI.rte.Utils.scope(fn, scope) : fn,
        'idFn': fn,
        'idScope': scope
      });
    },

    /**
     * Unregisters all or a single UI-related event handler(s) of a specific type.
     * @param {String} eventName Event name (see {@link #addUIListener} for supported
     *        values)
     * @param {Function} fn (optional) The listener to remove; if unspecified, all handlers
     *        will be removed
     * @param {Object} scope (optional) The scope of the listener to be removed
     * @private
     */
    removeUIListener: function (eventName, fn, scope) {
      if (!this.uiListeners || !this.uiListeners[eventName]) {
        return;
      }
      if (fn) {
        var listeners = this.uiListeners[eventName];
        for (var l = listeners.length - 1; l >= 0; l--) {
          var toCheck = listeners[l];
          if ((toCheck.idFn === fn) && (toCheck.idScope === scope)) {
            listeners.splice(l, 1);
          }
        }
      } else {
        delete this.uiListeners[eventName];
      }
    },

    /**
     * Fires a UI-related event.
     * @param {String} eventName Event name (see {@link #addUIListener} for supported
     *        values)
     * @param {Object} param (optional) Event specific parameter
     * @private
     */
    fireUIEvent: function (eventName, param) {
      if (!this.uiListeners || !this.uiListeners[eventName]) {
        return;
      }
      var event = new CUI.rte.ui.UIEvent(eventName, this.getEditContext(), param);
      var listenerCnt = this.uiListeners[eventName].length;
      for (var l = 0; l < listenerCnt; l++) {
        var listenerDef = this.uiListeners[eventName][l];
        if (listenerDef && listenerDef.fn) {
          listenerDef.fn(event);
        }
      }
      return event;
    },


    // Toolbar integration -----------------------------------------------------------------

    /**
     * @private
     */
    getToolbarHeight: function () {
      return this.toolbar.getHeight();
    },

    /**
     * Gets a toolbar item that is located in any of the editor's toolbars.
     * @param {Number} itemId item id of the toolbar item to determine
     * @private
     */
    getToolbarItem: function (itemId) {
      return this.toolbar.getItem(itemId);
    },

    /**
     * Creates the toolbar.
     * @param {Object} options (optional) kernel-specific options
     */
    createToolbar: function (options) {
      options = options || {};
      options.editorKernel = this;
      if (!this.tbBuilder) {
        this.tbBuilder = this.createToolbarBuilder();
        for (var pluginId in this.registeredPlugins) {
          if (this.registeredPlugins.hasOwnProperty(pluginId)) {
            var plugin = this.registeredPlugins[pluginId];
            plugin.initializeUI(this.tbBuilder, options);
          }
        }
      }
      this.toolbar = this.tbBuilder.createToolbar(options);
    },

    hasBackgroundToolbar: function (tbType) {
      return this.backgroundToolbars[tbType] ? true : false;
    },

    /**
     * Creates and adds a background toolbar. Background toolbar can only be added if there is an active toolbar
     * present. Background toolbar is hidden and disabled.
     * @param {Object} options (optional) kernel-specific options
     */
    addBackgroundToolbar: function (options) {
      if (!this.toolbar) {
        //Return as neither active toolbar nor toolbar builder is present
        return;
      }
      options = options || {};
      options.editorKernel = this;
      options.$editable = options.$editable || this.toolbar.$editable;
      if (this.backgroundToolbars[options.tbType]) {
        return;
      }
      this.backgroundToolbars[options.tbType] = this.tbBuilder.createToolbar(options);
    },

    /**
     * Destroy the background toolbar of passed type and removes its entry.
     * @param {String} tbType toolbar type
     */
    removeBackgroundToolbar: function (tbType) {
      var toolbar = this.backgroundToolbars[tbType];
      if (toolbar) {
        if (this.previousActiveToolbar && this.previousActiveToolbar.tbType === tbType) {
          this.previousActiveToolbar = null;
        }
        toolbar.destroy();
        delete this.backgroundToolbars[tbType];
      }
    },

    /**
     * Switch the active toolbar with a toolbar present in background.
     * @param {String} tbType - toolbar type of the background toolbar.
     */
    setActiveToolbar: function (tbType) {
      if (this.backgroundToolbars[tbType]) {
        var tb = this.toolbar;
        this.previousActiveToolbar = tb;
        this.toolbar.finishEditing();
        this.toolbar = this.backgroundToolbars[tbType];
        delete this.backgroundToolbars[tbType];
        this.toolbar.startEditing(this);
        this.backgroundToolbars[tb.tbType] = tb;
        this.tbBuilder.notifyToolbar(this.toolbar, true);
        this.firePluginEvent('aftertoolbarswitch', {'tbType': tbType}, false);
      }
    },

    /**
     * Activate the previously active toolbar (which could have been to background toolbars). This would swap the
     * current active toolbar with the previous active toolbar(if any).
     */
    swapToolbar: function() {
      if (this.previousActiveToolbar && this.backgroundToolbars[this.previousActiveToolbar.tbType]) {
        var tbType = this.previousActiveToolbar.tbType;
        var tb = this.toolbar;
        this.previousActiveToolbar = tb;
        this.toolbar.finishEditing();
        this.toolbar = this.backgroundToolbars[tbType];
        delete this.backgroundToolbars[tbType];
        this.toolbar.startEditing(this);
        this.backgroundToolbars[tb.tbType] = tb;
        this.tbBuilder.notifyToolbar(this.toolbar, true);
        this.firePluginEvent('aftertoolbarswitch', {'tbType': tbType}, false);
      }
    },

    /**
     * Create a kernel-specific instance of {@link CUI.rte.ui.ToolbarBuilder}.
     * @return {CUI.rte.ui.ToolbarBuilder} The kernel-specific toolbar builde instance
     *         to be used
     */
    createToolbarBuilder: function () {
      // must be overridden by implementing classes
      return null;
    },

    /**
     * Updates the toolbar to the current editor state.
     * @private
     * @hide
     */
    updateToolbar: function () {
      if (!this.isEnabled) {
        return;
      }
      var selectionDef = this.analyzeSelection();
      if (!selectionDef) {
        return;
      }
      for (var pluginId in this.registeredPlugins) {
        if (this.registeredPlugins.hasOwnProperty(pluginId)) {
          var plugin = this.registeredPlugins[pluginId];
          plugin.updateState(selectionDef);
        }
      }
      if (!this.contextMenu || !this.contextMenuBuilder.isVisible()) {
        this.contextMenuBuilder.hideAll();
      }
    },

    adjustToolbarToWidth: function (width) {
      this.toolbar.adjustToWidth(width);
    },

    enableToolbar: function (tbType) {
      if (!tbType || this.toolbar.tbType === tbType) {
        this.toolbar.enable();
      } else if (this.backgroundToolbars[tbType]) {
        this.backgroundToolbars[tbType].enable();
      }
    },

    disableToolbar: function (excludeItems, tbType) {
      if (!tbType || this.toolbar.tbType === tbType) {
        this.toolbar.disable(excludeItems);
      } else if (this.backgroundToolbars[tbType]) {
        this.backgroundToolbars[tbType].disable(excludeItems);
      }
    },

    destroyToolbar: function () {
      if (this.toolbar) {
        this.toolbar.finishEditing();
        this.toolbar.destroy();
      }
    },

    destroyBackgroundToolbars: function() {
      var tbType, toolbar;
      for (tbType in this.backgroundToolbars) {
        if (this.backgroundToolbars.hasOwnProperty(tbType)) {
          toolbar = this.backgroundToolbars[tbType];
          if (this.previousActiveToolbar && this.previousActiveToolbar.tbType === tbType) {
            this.previousActiveToolbar = null;
          }
          toolbar.finishEditing();
          toolbar.destroy();
          delete this.backgroundToolbars[tbType];
        }
      }
    },

    getToolbar: function () {
      return this.toolbar;
    },


    // Context menu implementation ---------------------------------------------------------

    /**
     * Handles a context menu event by building and showing the context menu.
     * @param {Event} event The HTML event that triggered the context menu
     * @return {Boolean} True if the context menu has been shown
     * @private
     */
    handleContextMenu: function (event) {
      var dpr = CUI.rte.DomProcessor;
      this.contextMenuBuilder.clear();
      var context = this.getEditContext();
      var selection = this.createQualifiedSelection(context);
      if (!selection) {
        return false;
      }
      var nodeList = dpr.createNodeList(context, selection);
      var selectionDef = {
        'selection': selection,
        'nodeList': nodeList
      };
      for (var id in this.registeredPlugins) {
        if (this.registeredPlugins.hasOwnProperty(id)) {
          this.registeredPlugins[id].handleContextMenu(this.contextMenuBuilder,
            selectionDef, context);
        }
      }
      this.contextMenu = this.contextMenuBuilder.build(selectionDef, context);
      if (this.contextMenu) {
        this.contextMenuSavedRange = this.createQualifiedRangeBookmark(context);
        var cmPos = this.calculateContextMenuPosition(event);
        this.contextMenuBuilder.showAt(cmPos[0], cmPos[1]);
        return true;
      }
      return false;
    }


  });

  /**
   * The default UI toolkit to be used
   * @type String
   */
  CUI.rte.EditorKernel.DEFAULT_TOOLKIT = 'ext';
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.IFrameKernel
 * @extends CUI.rte.EditorKernel
 * @private
 * This class implements an EditorKernel for iFrame-based rich text editing.
 * @constructor
 * Creates a new IFrameKernel for rich text editing.
 * @param {Object} config The kernel's configuration
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.IFrameKernel = new Class({

    toString: 'IFrameKernel',

    extend: CUI.rte.EditorKernel,

    /**
     * Path to content being edited
     * @private
     * @type String
     */
    contentPath: null,


    // Interface implementation ------------------------------------------------------------

    /**
     * Initializes the edit context once the rich text editing has been initialized.
     * @param {HTMLElement} iFrame The iFrame
     * @param {window} win The window object that is responsible for editing
     * @param {document} doc The document object that is reponsible for editing
     * @param {HTMLElement} root The root element (the "body" element of the iFrame)
     */
    initializeEditContext: function (iFrame, win, doc, root) {
      var com = CUI.rte.Common;
      this.editContext = new CUI.rte.EditContext(iFrame, win, doc, root);
      com.initializeTouchInIframe(this.editContext);
      // switch off auto linking - see http://msdn.microsoft.com/en-us/library/aa769893%28v=vs.85%29.aspx
      if (com.ua.isW3cIE) {
        doc.execCommand('AutoUrlDetect', false, false);
      }
      this.addFeatureClasses(root);
      if (this.toolbar) {
        this.toolbar.startEditing(this);
      }
    },

    /**
     * <p>Ensures that the caret gets initialized.</p>
     * <p>Will be executed immediately, if the editor kernel currently has the focus, or
     * optionally on next focus gain.</p>
     */
    initializeCaret: function (enforceInit) {
      var com = CUI.rte.Common;
      var sel = CUI.rte.Selection;
      if (this.hasFocus) {
        var context = this.getEditContext();
        sel.resetSelection(context, 'start');
        if ((com.ua.isGecko || com.ua.isWebKit) && context.iFrame) {
          sel.ensureCaretVisibility(context, 0);
        }
      } else if (enforceInit) {
        this.focusGainActions.initializeCaret = true;
      }
    },

    /**
     * Gets the path to the content being edited.
     * @return {String} The content path
     */
    getContentPath: function () {
      return this.contentPath;
    },

    /**
     * Get the DOM element that is responsible for focus handling.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     * @return {HTMLElement} The DOM element that is responsible for focus handling
     */
    getFocusDom: function (context) {
      if (!context) {
        context = this.getEditContext();
      }
      return context.win;
    },

    /**
     * Focusses the DOM element responsible for rich text editing.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    focus: function (context) {
      if (!context) {
        context = this.getEditContext();
      }
      if (context.win) {
        context.win.focus();
      }
    },

    /**
     * Blurs the focus.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    blurFocus: function (context) {
      if (!context) {
        context = this.getEditContext();
      }
      if (context.win) {
        context.win.blur();
      }
    },

    /**
     * Calculates a suitable position for a subordinate window.
     * @param {String} hint A positioning hint; allowed values are: "default"; defaults to
     *        "default"
     * @return {Number[]} The XY position for the subordinate window (e.g., [100, 200])
     */
    calculateWindowPosition: function (hint) {
      var winPos = null;
      switch (hint) {
      default:
        winPos = this.getEditorPosition();
        break;
      }
      return winPos || [0, 0];
    },

    // overrides CUI.rte.EditorKernel#calculateContextMenuPosition
    calculateContextMenuPosition: function (event) {
      var editContext = this.getEditContext();
      var editorPos = this.getEditorPosition();
      var scrollPos = [0, 0];
      var com = CUI.rte.Common;

      if (!com.ua.isOldIE) {
        scrollPos = [editContext.root.scrollLeft, editContext.root.scrollTop];
      } else {
        var contentWindow = CUI.rte.Utils.getMainWindow();
        var doc = contentWindow.document;
        var body = doc.body;
        scrollPos = [doc.documentElement.scrollLeft || body.scrollLeft,
          doc.documentElement.scrollTop || body.scrollTop];
      }
      var eventPos = event.getPos();
      return [editorPos[0] + eventPos.x - scrollPos[0],
        editorPos[1] + eventPos.y - scrollPos[1]];
    },

    // overrides CUI.rte.EditorKernel#createToolbarBuilder
    createToolbarBuilder: function () {
      var ui = CUI.rte.ui;
      return ui.ToolkitRegistry.get(this.uiToolkit).createToolbarBuilder(
        ui.Toolkit.TBHINT_LOCAL);
    },

    // overrides CUI.rte.EditorKernel#canEditSource
    canEditSource: function () {
      return true;
    },


    // Additional methods ------------------------------------------------------------------

    /**
     * Sets the path to the content being edited.
     * @param {String} contentPath The content path
     */
    setContentPath: function (contentPath) {
      this.contentPath = contentPath;
    },

    // Helpers -----------------------------------------------------------------------------

    /**
     * <p>Gets the current position of the iframe.</p>
     * @return {Number[]} The XY position of the element (e.g., [100, 200])
     */
    getEditorPosition: function () {
      var context = this.getEditContext();
      if (!context.iFrame) {
        return null;
      }
      return CUI.rte.Utils.getPagePosition(context.iFrame);
    }

  });

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.DivKernel
 * @extends CUI.rte.EditorKernel
 * @private
 * This class implements an EditorKernel for div-based rich text editing.
 * @constructor
 * Creates a new DivKernel for rich text editing.
 * @param {Object} config The kernel's configuration
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.DivKernel = new Class({

    toString: 'DivKernel',

    extend: CUI.rte.EditorKernel,

    /**
     * Path to content being edited
     * @private
     * @type String
     */
    contentPath: null,


    // Interface implementation ------------------------------------------------------------

    /**
     * Initializes the edit context once the rich text editing has been initialized.
     * @param {window} win The window object that is responsible for editing
     * @param {document} doc The document object that is reponsible for editing
     * @param {HTMLElement} root The root element (the "div" element being edited)
     */
    initializeEditContext: function (win, doc, root) {
      var com = CUI.rte.Common;
      this.editContext = new CUI.rte.EditContext(null, win, doc, root);
      com.initializeTouchInIframe(this.editContext);
      // switch off auto linking - see http://msdn.microsoft.com/en-us/library/aa769893%28v=vs.85%29.aspx
      if (com.ua.isW3cIE) {
        doc.execCommand('AutoUrlDetect', false, false);
      }
      this.addFeatureClasses(root);
      if (this.toolbar) {
        this.toolbar.startEditing(this);
      }
    },

    /**
     * <p>Ensures that the caret gets initialized.</p>
     * <p>Will be executed immediately, if the editor kernel currently has the focus, or
     * optionally on next focus gain.</p>
     */
    initializeCaret: function (enforceInit, emptyTextPara) {
      var com = CUI.rte.Common;
      var sel = CUI.rte.Selection;
      var context = this.getEditContext();
      if (com.ua.isGecko || com.ua.isWebKit) {
        this.deferFocus(CUI.rte.Utils.scope(function () {
          sel.resetSelection(context, 'start');
          this.fireUIEvent('updatestate', {
            'origin': 'init'
          });
        }, this));
      } else if (com.ua.isIE) {
        CUI.rte.Utils.defer(function () {
          this.focus();
          // workaround: EditorKernel does not always get first focus, so manually
          // ensuring that editorKernel.hasFocus is set correctly
          CUI.rte.Utils.defer(function () {
            this.hasFocus = true;
          }, 1, this);
          if (emptyTextPara !== null && emptyTextPara !== undefined) {
            sel.selectNode(context, emptyTextPara, true);
          } else {
            sel.resetSelection(context, 'start');
          }
        }, 1, this);
      }
    },

    /**
     * Gets the path to the content being edited.
     * @return {String} The content path
     */
    getContentPath: function () {
      return this.contentPath;
    },

    /**
     * Get the DOM element that is responsible for focus handling.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     * @return {HTMLElement} The DOM element that is responsible for focus handling
     */
    getFocusDom: function (context) {
      if (!context) {
        context = this.getEditContext();
      }
      return context.root;
    },

    /**
     * Focusses the DOM element responsible for rich text editing.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    focus: function (context) {
      if (!context) {
        context = this.getEditContext();
      }
      if (context.root) {
        try {
          context.root.focus();
        } catch (e) {
          // IE sometimes chokes on this, so at least prevent an error message popping
          // up
        }
      }
    },

    /**
     * Blurs the focus.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    blurFocus: function (context) {
      if (!context) {
        context = this.getEditContext();
      }
      if (context.root) {
        context.root.blur();
      }
    },

    /**
     * Calculates a suitable position for a subordinate window.
     * @param {String} hint A positioning hint; allowed values are: "default"; defaults to
     *        "default"
     * @return {Number[]} The XY position for the subordinate window (e.g., [100, 200])
     */
    calculateWindowPosition: function (hint) {
      var context = this.getEditContext();
      var winPos = null;
      var scrollTop = context.doc.documentElement.scrollTop || context.doc.body.scrollTop;
      switch (hint) {
      default:
        winPos = [0, scrollTop];
        break;
      }
      return winPos || [0, 0];
    },

    // overrides CUI.rte.EditorKernel#calculateContextMenuPosition
    calculateContextMenuPosition: function (event) {
      var eventPos = event.getPos();
      return [eventPos.x, eventPos.y];
    },

    // overrides CUI.rte.EditorKernel#createToolbarBuilder
    createToolbarBuilder: function () {
      var ui = CUI.rte.ui;
      return ui.ToolkitRegistry.get(this.uiToolkit).createToolbarBuilder(
        ui.Toolkit.TBHINT_GLOBAL);
    },

    // overrides CUI.rte.EditorKernel#setProcessors
    setProcessors: function (preProcessorConfig, postProcessorConfig) {
      if (CUI.rte.CUIDomCleanup) {
        this.preProcessor = new CUI.rte.CUIDomCleanup(preProcessorConfig);
        this.postProcessor = new CUI.rte.CUIDomCleanup(postProcessorConfig);
      } else {
        this.preProcessor = new CUI.rte.DomCleanup(preProcessorConfig);
        this.postProcessor = new CUI.rte.DomCleanup(postProcessorConfig);
      }

    },

    // overrides CUI.rte.EditorKernel#canEditSource
    canEditSource: function () {
      return CUI.rte._toolkit === 'cui';
    },


    // Additional methods ------------------------------------------------------------------

    /**
     * Sets the path to the content being edited.
     * @param {String} contentPath The content path
     */
    setContentPath: function (contentPath) {
      this.contentPath = contentPath;
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.Common
 * @static
 * @private
 * The Common provides some commonly used utility functionality.
 */
(function (CUI) {
  'use strict';
  CUI.rte.Common = (function () {

    var docMode = window.document.documentMode, // documentMode property explanation: http://msdn.microsoft.com/en-us/library/ie/cc196988%28v=vs.85%29.aspx
      ua = navigator.userAgent.toLowerCase(),
      check = function (r) {
        return r.test(ua);
      },
      isEdge = check(/\bedge\b/) && check(/webkit/),
      isWebkit = !isEdge && check(/webkit/),
      isIE = !isWebkit && (check(/msie/) || check(/trident/)),
      isGecko = !isIE && !isWebkit && check(/gecko/), // because the Webkit and IE11 user agent string sometimes contains "like Gecko"
    // TODO ambigious browser detection, see CUI-447
      isIE6 = isIE && ((check(/msie 6/) && docMode !== 7 && docMode !== 8 && docMode !== 9 && docMode !== 10) || (docMode === 5)), // docMode === 5 indicates "Quirks Mode"
      isIE7 = isIE && ((check(/msie 7/) && docMode !== 5 && docMode !== 8 && docMode !== 9 && docMode !== 10) || docMode === 7),
      isIE8 = isIE && ((check(/msie 8/) && docMode !== 5 && docMode !== 7 && docMode !== 9 && docMode !== 10) || docMode === 8),
      isIE9 = isIE && ((check(/msie 9/) && docMode !== 5 && docMode !== 7 && docMode !== 8 && docMode !== 10) || docMode === 9),
      isIE10 = isIE && ((check(/msie 10/) && docMode !== 5 && docMode !== 7 && docMode !== 8 && docMode !== 9) || docMode === 10),
      isIE11 = isIE && ((check(/trident\/7\.0/) && docMode !== 5 && docMode !== 7 && docMode !== 8 && docMode !== 9 && docMode !== 10) || docMode === 11),
      isOldIE = isIE && (isIE6 || isIE7 || isIE8), // indicator that this IE versions are using the old proprietary behavior (especially selection)
      isIEBRPlaceholder = isIE11,
      isW3cIE = isIE && !isOldIE,
      isMac = check(/macintosh|mac os x/),
      isChrome = isWebkit && check(/\bchrome\b/),
      isSafari = isWebkit && !isChrome && check(/safari/),
      isTouch = (function () {
        // CUI-2318 Special value for Win8.x/Chrome
        if (/Windows NT 6\.[23];.*Chrome/.test(window.navigator.userAgent)) {
          return false;
        }
        return 'ontouchstart' in window;
      })(),
      isIPad = isTouch && isSafari && check(/ipad/),
      isIPhone = isTouch && isSafari && check(/iphone/),
      calloutHeight = (isIPad || isIPhone ? 56 : 0),
      screenKeyHeightPortrait = (isIPad ? 354 : (isIPhone ? 266 : 0)),
      screenKeyHeightLandscape = (isIPad ? 442 : (isIPhone ? 246 : 0)),
      selectionHandlesHeight = (isIPad ? 32 : (isIPhone ? 20 : 0)); // TODO check iPhone?

    /**
     * Flag if the internal logging mechanism is enabled (used for ieLog())
     */
    var isLogEnabled = true;

    /**
     * Recursive part of getNodeAtPosition.
     */
    var getNodeAtPositionRec = function (context, node, state, pos, normalize) {
      var com = CUI.rte.Common;

      function isEOB(dom) {
        var editBlock = com.getTagInPath(context, dom, com.EDITBLOCK_TAGS);
        return (com.getLastChild(editBlock) === dom);
      }

      if (node.nodeType === 3) {
        var textLen = com.getNodeCharacterCnt(node);
        var endPos = state.charPos + textLen;
        if ((pos >= state.charPos) && (pos < endPos)) {
          state.node = {
            'dom': node,
            'start': state.charPos,
            'offset': pos - state.charPos,
            'nodeBefore': state.nodeBefore
          };
          return;
        } else if (pos === endPos) {
          // EOB/EOT-Situations
          if (isEOB(node)) {
            state.node = {
              'dom': node,
              'start': state.charPos,
              'offset': pos - state.charPos,
              'nodeBefore': state.nodeBefore
            };
            return;
          }
          state.nodeBefore = node;
          state.startBefore = state.charPos;
        }
        state.charPos += textLen;
      } else if (node.nodeType === 1) {
        if (com.isOneCharacterNode(node)) {
          if (state.charPos === pos) {
            state.node = {
              'isNodeSelection': true,
              'startOfElement': true,
              'dom': node
            };
            return;
          }
          if ((state.charPos + 1) === pos) {
            if (isEOB(node)) {
              state.node = {
                'isNodeSelection': true,
                'startOfElement': false,
                'dom': node,
                'offset': 0     // compatibility to other methods that use offset 0 for "behind one character node"
              };
            }
          }
          state.charPos++;
        } else {
          var offset;
          // if we got the first item of an irregularily nested edit block
          // (nested lists), we'll have to correct one character position before
          // we calculate anything else
          if (com.isTag(node, com.EDITBLOCK_UNREGNEST_TAGS)) {
            if ((com.getChildIndex(node) === 0) && com.isFirstNestedList(context, node.parentNode)) {
              var pNode = node;
              do {
                pNode = com.getParentNode(context, pNode);
                if (pNode && com.isTag(pNode,
                    com.EDITBLOCK_UNREGNEST_TAGS)) {
                  if (state.charPos === pos) {
                    var superItem = state.nodeBefore;
                    offset = com.getNodeCharacterCnt(superItem);
                    var itemParent = superItem.parentNode;
                    state.node = {
                      'dom': superItem,
                      'offset': offset,
                      'parentDom': itemParent,
                      'isUnregularNestedIssue': true,
                      'nestedItemDom': node
                    };
                    return;
                  }
                  state.charPos++;
                  break;
                }
              } while (pNode);
            }
          }
          var myCharPos = state.charPos;
          var childCnt = node.childNodes.length;
          for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            getNodeAtPositionRec(context, node.childNodes[childIndex], state, pos,
              normalize);
            if (state.node) {
              if (!state.node.parentDom) {
                state.node.parentDom = node;
                state.node.parentStart = myCharPos;
                state.node.parentOffset = pos - myCharPos;
              }
              return;
            }
          }
          if (com.isTag(node, com.EDITBLOCK_TAGS)) {
            // as always, there are corner cases we have to handle differently -
            // if we are at the last element of a nested structure, we will
            // usually directly move to the next nested element, without the
            // additional character position that is added when entering the
            // nested structure
            var isValidEOEB = true;
            var nestingType = null;
            if (com.isTag(node, com.EDITBLOCK_NESTED_TAGS)) {
              nestingType = com.EDITBLOCK_NESTED_TAGS;
            } else if (com.isTag(node, com.EDITBLOCK_UNREGNEST_TAGS)) {
              nestingType = com.EDITBLOCK_UNREGNEST_TAGS;
            }
            if (nestingType !== null && nestingType !== undefined) {
              isValidEOEB = !com.isLastChildDeep(node, nestingType);
            }
            if (isValidEOEB) {
              offset = 0;
              if (normalize) {
                // normalization of empty editing blocks
                if (com.isEmptyEditingBlock(node, true)) {
                  offset = 1;
                }
              }
              if ((state.charPos >= pos) && (state.charPos <= (pos + offset))) {
                state.node = {
                  'isNodeSelection': true,
                  'startOfElement': false,
                  'dom': node
                };
                return;
              }
              state.charPos += offset + 1;
            }
          }
        }
      }
    };

    /**
     * Recursive part of getCharacterOffsetForNode.
     * @param {Object} context
     * @param {Node} node
     * @param {Number} charPos
     * @param {Node} processingNode
     */
    var getCharacterOffsetForNodeRec = function (context, node, charPos, processingNode) {
      var com = CUI.rte.Common;
      // if we got the first item of an irregularily nested edit block (nested lists),
      // we'll have to correct one character position before we calculate anything
      if (com.isTag(processingNode, com.EDITBLOCK_UNREGNEST_TAGS)) {
        if ((com.getChildIndex(processingNode) === 0) &&
          com.isFirstNestedList(context, processingNode.parentNode)) {
          var pNode = processingNode;
          do {
            pNode = com.getParentNode(context, pNode);
            if (pNode && com.isTag(pNode, com.EDITBLOCK_UNREGNEST_TAGS)) {
              charPos++;
              break;
            }
          } while (pNode);
        }
      }
      if (processingNode === node) {
        return {
          'isFound': true,
          'charPos': charPos
        };
      }
      if (processingNode.nodeType === 3) {
        charPos += com.getNodeCharacterCnt(processingNode);
        return {
          'isFound': false,
          'charPos': charPos
        };
      }
      if (processingNode.nodeType === 1) {
        if (com.isOneCharacterNode(processingNode)) {
          charPos++;
        } else {
          var childCnt = processingNode.childNodes.length;
          for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            var childResult = getCharacterOffsetForNodeRec(context,
              node, charPos, processingNode.childNodes[childIndex]);
            if (childResult.isFound) {
              return childResult;
            }
            charPos = childResult.charPos;
          }
          // we'll have to add one character at the end of "edit blocks", to
          // distinguish the end of an edit block from the begin of the
          // succeeding edit block
          if (com.isTag(processingNode, com.EDITBLOCK_TAGS)) {
            var addCharPos = true;
            // as always, there are corner cases we have to handle differently -
            // if we are at the last element of a nested structure, we will
            // usually directly move to the next nested element, without the
            // additional character position that is added when entering the
            // nested structure
            if (com.isTag(processingNode, com.EDITBLOCK_NESTED_TAGS)) {
              // if a table cell being closed is the last element of the
              // edit element, we must not add the character offset
              addCharPos = !com.isLastElementOfNestingLevel(context,
                processingNode);
            } else if (com.isTag(processingNode,
                com.EDITBLOCK_UNREGNEST_TAGS)) {
              // if a list item being closed has a nested list as last
              // element, we must not add the character offset
              addCharPos = !com.isLastChildDeep(processingNode,
                com.EDITBLOCK_UNREGNEST_TAGS);
            }
            if (addCharPos) {
              charPos++;
            }
          }
        }
        return {
          'isFound': false,
          'charPos': charPos
        };
      }
      return {
        'isFound': false,
        'charPos': -1
      };
    };


    return {

      /**
       * user agent information.
       * @type {Object} allows to check the browser/engine type and version
       */
      ua: {
        /**
         * True if the detected browser uses WebKit.
         * @type Boolean
         */
        isWebKit: isWebkit,
        /**
         * True if the detected browser uses the Gecko layout engine (e.g. Mozilla, Firefox).
         * @type Boolean
         */
        isGecko: isGecko,
        /**
         * True if the detected browser is Internet Explorer.
         * @type {Boolean}
         */
        isIE: isIE,
        /**
         * True if the detected browser is Internet Explorer 6.x.
         * @type {Boolean}
         */
        isIE6: isIE6,
        /**
         * True if the detected browser is Internet Explorer 7.x.
         * @type {Boolean}
         */
        isIE7: isIE7,
        /**
         * True if the detected browser is Internet Explorer 8.x.
         * @type {Boolean}
         */
        isIE8: isIE8,
        /**
         * True if the detected browser is Internet Explorer 9.x.
         * @type {Boolean}
         */
        isIE9: isIE9,
        /**
         * True if the detected browser is Internet Explorer 10.x.
         * @type Boolean
         */
        isIE10: isIE10,
        /**
         * True if the detected browser is Internet Explorer 11.x.
         * @type Boolean
         */
        isIE11: isIE11,
        /**
         * True if the detected browser is a Internet Explorer which uses the old proprietary selection mode
         * @type {Boolean}
         */
        isOldIE: isOldIE,
        /**
         * True if the detected browser is a Internet Explorer which uses br placeholders for empty paragraphs.
         * @type Boolean
         */
        isIEBRPlaceholder: isIEBRPlaceholder,
        /**
         * True if the detected browser is a Internet Explorer which uses the W3C selection mode
         * @type {Boolean}
         */
        isW3cIE: isW3cIE,
        /**
         * True if the detected platform is Mac OS.
         * @type Boolean
         */
        isMac: isMac,
        /**
         * True if the detected browser is Microsoft Edge.
         * @type Boolean
         */
        isEdge: isEdge,
        /**
         * True if the detected browser is Chrome
         */
        isChrome: isChrome,
        /**
         * True if the detected browser is Safari
         */
        isSafari: isSafari,
        /**
         * True if a touch-enabled device is used
         */
        isTouch: isTouch,
        /**
         * True if an iPad is used
         */
        isIPad: isIPad,
        /**
         * True if an iPhone is used
         */
        isIPhone: isIPhone,
        /**
         * Height of a potentially used "callout"; 0 on non-iOS browsers
         */
        calloutHeight: calloutHeight,
        /**
         * Height of a potentially shown screen keyboard in Portrait mode
         */
        screenKeyHeightPortrait: screenKeyHeightPortrait,
        /**
         * Height of a potentially shown screen keyboard in Landscape mode
         */
        screenKeyHeightLandscape: screenKeyHeightLandscape,
        /**
         * Height of sensitive area for selection handles
         */
        selectionHandlesHeight: selectionHandlesHeight,
        /**
         * Determines if the editor is used on a touch platform inside an iframe;
         * must be initialized using {@link #initializeTouchInIframe}; if set to true,
         * no touch events must be used
         */
        isTouchInIframe: false
      },

      /**
       * Check if the given DOM node is the root node of the current editing context.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Node} dom DOM node to check
       * @return {Boolean} True if the given Node is a body node
       */
      isRootNode: function (context, dom) {
        return (context.root === dom);
      },

      /**
       * Check if the given DOM node has (one of) the given tag name(s).
       * <p>
       * Note that the method works case-insensitive; e.g. <code>isTag(dom, "IMG")</code>
       * and <code>isTag(dom, "img")</code> would both match an image tag.
       * @param {Node} dom dom DOM node to check
       * @param {String|Array} tagName name of the tag the node has to be checked against;
       *        if an array, the node will be checked if one of the specified tag names
       *        does match
       * @return {Boolean} True if the given node matches (one of) the given tag name(s)
       */
      isTag: function (dom, tagName) {
        if (!dom || (dom.nodeType !== 1)) {
          return false;
        }
        var domTag = dom.tagName.toLowerCase();
        if (!CUI.rte.Utils.isArray(tagName)) {
          return (domTag === tagName.toLowerCase());
        }
        var tagCnt = tagName.length;
        for (var tagIndex = 0; tagIndex < tagCnt; tagIndex++) {
          if (domTag === tagName[tagIndex].toLowerCase()) {
            return true;
          }
        }
        return false;
      },

      /**
       * Gets the namespace for the specified DOM element.
       * @param {HTMLElement} dom The DOM element to retrieve the namespace for
       * @return {String} The namespace of the specified DOM element; null if no namespace
       *         is available (= default HTML namespace)
       */
      getNamespace: function (dom) {
        var com = CUI.rte.Common;

        if (dom && dom.nodeType === 1) {
          // IE 10 doesn't support scopeName in Standards mode anymore, so check
          // before using it and rely on standard compliant behaviour otherwise
          if (com.ua.isIE && dom.scopeName) {
            if (dom.scopeName !== 'HTML') {
              return dom.scopeName.toLowerCase();
            }
          } else {
            var tagName = dom.tagName;
            var sepPos = tagName.indexOf(':');
            if (sepPos > 0) {
              return tagName.substring(0, sepPos).toLowerCase();
            }
          }
        }
        return null;
      },

      /**
       * Inserts the specified node before the second specified node in a
       * browser-independent way.
       * @param {HTMLElement} parentDom The parent node
       * @param {HTMLElement} dom The DOM element to insert
       * @param {HTMLElement} domRef The reference element; null to insert at the end
       *        of the existing child nodes of parentDom
       */
      insertBefore: function (parentDom, dom, domRef) {
        if (domRef !== null && domRef !== undefined) {
          parentDom.insertBefore(dom, domRef);
        } else {
          // IE6 bombs if we are using insertBefore(dom, null), so we are using
          // appendChild instead
          parentDom.appendChild(dom);
        }
      },

      /**
       * <p>Checks if the given DOM object has the specified attributes.</p>
       * <p>It is required that all attributes defined in the specified attribute
       * definition have equivalent values in the DOM object for this method to return
       * true.</p>
       * <p>Note that you can use "_class" or "className" to specifiy the name of the
       * class attribute.</p>
       * @param {HTMLElement} dom DOM object to check
       * @param {Object} attribs Attribute definition
       */
      hasAttributes: function (dom, attribs) {
        if (!dom || (dom.nodeType !== 1)) {
          return false;
        }
        for (var name in attribs) {
          if (attribs.hasOwnProperty(name)) {
            if ((name === '_class') || (name === 'className')) {
              name = 'class';
            }
            var cmpValue = CUI.rte.Common.getAttribute(dom, name);
            if (cmpValue !== attribs[name]) {
              return false;
            }
          }
        }
        return true;
      },

      /**
       * <p>Check if an attribute of the specified name is defined for the specified DOM
       * node.</p>
       * <p>The method will also return false if the attribute is defined, but has no
       * content (attrib=""). This is required for IE(6) compoatibility.</p>
       * <p>Note that you can address the "class" attribute of the node through "class"
       * and the "style" attribute through "style".</p>
       * @param {HTMLElement} dom The DOM node to check
       * @param {String} attribName The attribute name to check
       * @return {Boolean} True, if the attribute is defined for the DOM node
       */
      isAttribDefined: function (dom, attribName) {
        var attribValue = CUI.rte.Common.getAttribute(dom, attribName, true);
        return (attribValue !== null && attribValue !== undefined);
      },

      /**
       * <p>Gets the value of the attribute with the specified name in an
       * browser-independent way.</p>
       * <p>Note that you can address the "class" attribute of the node through "class"
       * and the "style" attribute through "style".</p>
       * @param {HTMLElement} dom The DOM node containing the attribute
       * @param {String} attribName The name of the attribute to retrieve
       * @param {Boolean} normalize True if empty attribute values (attrib="") should be
       *        returned as null rather than a String of length 0
       * @return {String} The attribute's value
       */
      getAttribute: function (dom, attribName, normalize) {
        var com = CUI.rte.Common;

        if (!dom || (dom.nodeType !== 1)) {
          return null;
        }
        var attribNameLC = attribName.toLowerCase();
        var attribValue;
        if ((attribNameLC === 'style') && com.ua.isOldIE) {
          attribValue = dom.style.cssText;
        } else {
          // the "name" attribute of an "a" tag must be retrieved through the
          // "attributes" collection for IE 6/7; see bug #36231
          var tagName = dom.tagName.toLowerCase();
          if ((com.ua.isIE6 || com.ua.isIE7) &&
            ((attribNameLC === 'name') && (tagName === 'a'))) {
            attribValue = dom.attributes['name'].nodeValue;
          } else {
            attribValue = dom.getAttribute(
              CUI.rte.Common.getIEAttributeName(attribName));
          }
        }
        if (normalize && ((attribValue !== null && attribValue !== undefined) && (attribValue.length === 0))) {
          attribValue = null;
        }
        if (normalize && (attribValue !== null && attribValue !== undefined)) {
          if ((attribNameLC === 'colspan') || (attribNameLC === 'rowspan')) {
            try {
              if (parseInt(attribValue, 10) === 1) {
                attribValue = null;
              }
            } catch (e) {
              // ignored
            }
          }
        }
        return attribValue;
      },

      /**
       * <p>Sets the value of the attribute with the specified name to the specified value
       * in a browser-independent way.</p>
       * <p>Note that you can address the "class" attribute of the node through "class"
       * and the "style" attribute through "style".</p>
       * @param {HTMLElement} dom The DOM element
       * @param {String} attribName The name of the attribute to be set
       * @param {String} attribValue The attribute value to be set
       */
      setAttribute: function (dom, attribName, attribValue) {
        var com = CUI.rte.Common,
          attribNameLC = attribName.toLowerCase();
        if (typeof attribValue !== String) {
          attribValue = String(attribValue);
        }
        if ((attribNameLC === 'style') && com.ua.isOldIE) {
          dom.style.cssText = attribValue;
          return;
        }
        // the "name" attribute of an "a" tag must be set through the "attributes"
        // collection for IE 6/7; see bug #36231
        if ((com.ua.isIE6 || com.ua.isIE7) &&
          ((attribNameLC === 'name') && (dom.tagName.toLowerCase() === 'a'))) {
          dom.attributes['name'].nodeValue = attribValue;
          return;
        }
        attribName = CUI.rte.Common.getIEAttributeName(attribName);
        dom.setAttribute(attribName, attribValue);
      },

      /**
       * <p>Adds styles directly to the style attribute on element.</p>
       * @param {HTMLElement} dom The DOM element
       * @param {Object|String} styleData JSON object or a String containing style property name and value.
       * Eg. {"height": "50px", "float": "right"} | "height: 50px;float: right;"
       */
      addInlineStyles: function (dom, styleData) {
        var com = CUI.rte.Common;
        var existingStyle = com.getAttribute(dom, 'style');
        var propRegexp;
        existingStyle = (existingStyle ? existingStyle : '').trim();
        if (existingStyle.length > 0 && existingStyle.lastIndexOf(';') !== existingStyle.length - 1) {
          existingStyle += ';';
        }
        if (typeof styleData === 'string') {
          styleData = styleData.trim();
          var attributes = styleData.split(';');
          for (var i = 0; i < attributes.length; i++) {
            var attribute = attributes[i];
            attribute = attribute.trim();
            var propNameValue = attribute.split(':');
            if (propNameValue.length === 2) {
              var propName = propNameValue[0].trim();
              var propValue = propNameValue[1].trim();
              propRegexp = new RegExp(propName + '[^;]+;');
              existingStyle = existingStyle.replace(propRegexp, '').replace(/  +/, ' ').trim();
              existingStyle += propName + ': ' + propValue + ';';
            }
          }
        } else {
          for (var prop in styleData) {
            if (styleData.hasOwnProperty(prop)) {
              propRegexp = new RegExp(prop + '[^;]+;');
              existingStyle = existingStyle.replace(propRegexp, '').replace(/  +/, ' ').trim();
              existingStyle += prop + ': ' + styleData[prop] + ';';
            }
          }
        }
        if (existingStyle.length > 0) {
          com.setAttribute(dom, 'style', existingStyle);
        }
      },

      /**
       * <p>Removes styles from the style attribute on element.</p>
       * @param {HTMLElement} dom The DOM element
       * @param {Array} stylesToRemove array containing names of style properties which are to be removed.
       * Eg. ["height", "float"]
       */
      removeInlineStyles: function (dom, stylesToRemove) {
        var com = CUI.rte.Common;
        var existingStyle = com.getAttribute(dom, 'style');
        if (existingStyle) {
          for (var i = 0; i < stylesToRemove.length; i++) {
            var propRegexp = new RegExp(stylesToRemove[i] + '[^;]+;');
            existingStyle = existingStyle.replace(propRegexp, '').replace(/  +/, ' ').trim();
          }
          if (existingStyle.length > 0) {
            com.setAttribute(dom, 'style', existingStyle);
          } else {
            com.removeAttribute(dom, 'style');
          }
        }
      },

      /**
       * Removes the specified attribute from the specified DOM element.
       * @param {HTMLElement} dom The DOM element
       * @param {String} attribName Name of attribute to remove
       */
      removeAttribute: function (dom, attribName) {
        var com = CUI.rte.Common;
        if (com.ua.isOldIE) {
          if (attribName === 'style') {
            dom.style.cssText = null;
            return;
          }
        }
        // IE 7 has gotten worse over time; newer versions cannot remove the
        // "name" attribute appropriately, using special treatment the 1.000.000th
        // time
        var tagName = dom.tagName.toLowerCase();
        if ((com.ua.isIE6 || com.ua.isIE7) &&
          ((attribName.toLowerCase() === 'name') && (tagName === 'a'))) {
          dom.attributes['name'].nodeValue = '';
        } else {
          dom.removeAttribute(CUI.rte.Common.getIEAttributeName(attribName));
        }
      },

      /**
       * Copies an attribute from dom1 to dom2 if it is actually available on dom1.
       * @param {HTMLElement} dom1 The source DOM element
       * @param {HTMLElement} dom2 The destination DOM element
       * @param {String} attribName The name of the attribute to be copied
       */
      copyAttribute: function (dom1, dom2, attribName) {
        var attribValue = dom1[attribName];
        if (attribValue !== null && attribValue !== undefined) {
          dom2[attribName] = attribValue;
        }
      },

      /**
       * Copies all available attributes from dom1 to dom2.
       * @param {HTMLElement} dom1 The source DOM element
       * @param {HTMLElement} dom2 The destination DOM element
       * @param {String[]} excludedAttribs (optional) List of attribute names to be
       *        excluded from copying
       */
      copyAttributes: function (dom1, dom2, excludedAttribs) {
        var com = CUI.rte.Common;
        var a, attributeCnt, attrib, attribName;
        if (com.ua.isIE6 || com.ua.isIE7) {
          // IE needs a special way of handling things again ...
          var attribNames = com.getIEAttributeNames(dom1, true);
          attributeCnt = attribNames.length;
          for (a = 0; a < attributeCnt; a++) {
            attribName = attribNames[a];
            if ((excludedAttribs === null || excludedAttribs === undefined) || !com.arrayContains(excludedAttribs, attribName)) {
              var attribValue;
              var attribNameLC = attribName.toLowerCase();
              if (attribNameLC === 'style') {
                attribValue = dom1.style.cssText;
              } else if (attribNameLC === 'class') {
                attribValue = dom1.getAttribute('className');
                attribName = 'className';
              } else if (com.isTag(dom1, 'a') && (attribNameLC === 'name')) {
                attribValue = dom1.attributes['name'].nodeValue;
              } else {
                attribValue = dom1.getAttribute(attribName);
              }
              if (attribValue !== null && attribValue !== undefined) {
                if (attribNameLC === 'style') {
                  dom2.style.cssText = attribValue;
                } else if (com.isTag(dom2, 'a') && (attribNameLC === 'name')) {
                  dom2.attributes['name'].nodeValue = attribValue;
                } else {
                  dom2.setAttribute(attribName, attribValue);
                }
              }
            }
          }
          return;
        }
        var attribs = dom1.attributes;
        attributeCnt = attribs.length;
        for (a = 0; a < attributeCnt; a++) {
          attrib = attribs[a];
          attribName = attrib.name;
          attribName = (com.ua.isIE8 ? attribName.toLowerCase() : attribName);
          if ((excludedAttribs === null || excludedAttribs === undefined) || !com.arrayContains(excludedAttribs, attribName)) {
            // don't need colspan/rowspan's of 1, as reported by IE 8
            var value = attrib.value;
            if (com.ua.isIE8) {
              if ((attribName === 'colspan') || (attribName === 'rowspan')) {
                if (value === '1') {
                  value = null;
                }
              }
            }
            if (value !== null && value !== undefined) {
              dom2.setAttribute(attribName, attrib.value);
            }
          }
        }
      },

      /**
       * <p>Compares the attributes of the specified DOM elements.</p>
       * <p>Note that attributes that are reported to be empty are omitted.</p>
       * @param {HTMLElement} dom1 The first element
       * @param {HTMLElement} dom2 The second element
       * @return {Boolean} True if both elements share the same attributes
       */
      compareAttributes: function (dom1, dom2) {
        var com = CUI.rte.Common;
        var name, value, cmpValue;
        var attribs1 = dom1.attributes;
        var attribs2 = dom2.attributes;
        var a1Cnt = attribs1.length;
        for (var a1 = 0; a1 < a1Cnt; a1++) {
          name = attribs1[a1].name;
          value = com.getAttribute(dom1, name, true);
          if (value !== null && value !== undefined) {
            cmpValue = com.getAttribute(dom2, name, true);
            if (cmpValue !== value) {
              return false;
            }
          }
        }
        var a2Cnt = attribs2.length;
        for (var a2 = 0; a2 < a2Cnt; a2++) {
          name = attribs2[a2].name;
          value = com.getAttribute(dom2, name, true);
          if (value !== null && value !== undefined) {
            cmpValue = com.getAttribute(dom1, name, true);
            if (cmpValue !== value) {
              return false;
            }
          }
        }
        return true;
      },

      /**
       * Creates an array with the names of all attributes of the specified DOM element.
       * @param {HTMLElement} dom The DOM element
       * @param {Boolean} keepCase (optional) True if the case of attribute names should
       *        be preserved
       * @param {Function} filter (optional) A filter method that allows to filter out a
       *        specific attribute; gets the DOM element, the attribute name and the
       *        lower case representation of the attribute's name as parameters; must
       *        return true to filter out the attribute.
       * @return {String[]} Array with all attribute names
       */
      getAttributeNames: function (dom, keepCase, filter) {
        var com = CUI.rte.Common;

        if (com.ua.isOldIE) {
          return CUI.rte.Common.getIEAttributeNames(dom, keepCase, filter);
        }
        // this is the correct method to determine valid DOM attributes on other
        // browsers
        var attribNames = [];
        var attribCnt = dom.attributes.length;
        for (var a = 0; a < attribCnt; a++) {
          var attribName = dom.attributes.item(a).nodeName;
          var attribNameLC = attribName.toLowerCase();
          var isFilteredOut = false;
          if (filter) {
            isFilteredOut = filter(dom, attribName, attribNameLC);
          }
          if (!isFilteredOut) {
            attribNames.push(keepCase ? attribName : attribNameLC);
          }
        }
        return attribNames;
      },

      /**
       * Gets all DOM nodes below the specified node (including the node itself) that are
       * of the specified type.
       * @param {HTMLElement} dom DOM node to check (recursively)
       * @param {String|String[]} tagName Tag name(s) of the specified type(s)
       * @return {HTMLElement[]} Array containing all specified tags
       */
      getTags: function (dom, tagName, nodes) {
        if (!nodes) {
          nodes = [];
        }
        var com = CUI.rte.Common;
        if (com.isTag(dom, tagName)) {
          nodes.push(dom);
        }
        if (dom.nodeType === 1) {
          var childCnt = dom.childNodes.length;
          for (var c = 0; c < childCnt; c++) {
            com.getTags(dom.childNodes[c], tagName, nodes);
          }
        }
        return nodes;
      },

      /**
       * Checks if the specified DOM node or one of its descendants is of the specified
       * type.
       * @param {HTMLElement} dom DOM node to check (recursively)
       * @param {String} tagName Tag name of the specified type
       */
      containsTag: function (dom, tagName) {
        var com = CUI.rte.Common;
        if (com.isTag(dom, tagName)) {
          return true;
        }
        if (dom.nodeType === 1) {
          var childCnt = dom.childNodes.length;
          for (var c = 0; c < childCnt; c++) {
            if (com.containsTag(dom.childNodes[c], tagName)) {
              return true;
            }
          }
        }
        return false;
      },

      /**
       * Checks if the specified DOM nodes are equal. This is the case if both nodes
       * share the same tag name and all attributes (structure nodes) or their text
       * contents are equal (text nodes).
       * @param {HTMLElement} dom1 first DOM node
       * @param {HTMLElement} dom2 second DOM node
       * @return {Boolean} true if both DOM nodes are equal according to the rules
       *         specified above
       */
      equals: function (dom1, dom2) {
        var com = CUI.rte.Common;
        if (dom1.nodeType !== dom2.nodeType) {
          return false;
        }
        if (dom1.nodeType === 3) {
          return (dom1.nodeValue === dom2.nodeValue);
        }
        if (dom1.tagName.toLowerCase() !== dom2.tagName.toLowerCase()) {
          return false;
        }
        return com.compareAttributes(dom1, dom2);
      },

      /**
       * Checks for null in a relaxed way - both null and undefined are accepted.
       * @param {Object} obj The object to check
       * @return {Boolean} True if the specified object is null or undefined
       */
      isNull: function (obj) {
        return (obj === null) || (obj === undefined);
      },

      /**
       * <p>Adds the specified text node to the specified parentNode. If nodeBefore is
       * specified, the text node is inserted before that node. Otherwise, it is appended
       * to the current list of child nodes.</p>
       * <p>Note that this method merges the node with existing text nodes if possible.
       * It returns the actual node and character offset, if the text node has been
       * merged.</p>
       * @param {HTMLElement} dom Text node to append
       * @param {HTMLElement} parentNode Parent node
       * @param {HTMLElement} nodeBefore The node the text has to be inserted before
       * @return {Object} Object defining the actual insert operation; properties:
       *         dom, startPos, charCnt
       */
      addTextNode: function (dom, parentNode, nodeBefore) {
        var text = dom.nodeValue;
        var charCnt = text.length;
        var childCnt = parentNode.childNodes.length;
        if (childCnt === 0) {
          parentNode.appendChild(dom);
          return {
            'dom': dom,
            'startPos': 0,
            'charCnt': charCnt
          };
        }
        var nextSibling = nodeBefore;
        if (nextSibling && (nextSibling.nodeType !== 3)) {
          nextSibling = null;
        }
        var prevSibling;
        if (nodeBefore) {
          prevSibling = nodeBefore.previousSibling;
        } else {
          prevSibling = parentNode.lastChild;
        }
        if (prevSibling && (prevSibling.nodeType !== 3)) {
          prevSibling = null;
        }
        var startOffs = (prevSibling ? prevSibling.nodeValue.length : 0);
        if (nextSibling && prevSibling) {
          prevSibling.nodeValue += text + nextSibling.nodeValue;
          dom = prevSibling;
          parentNode.removeChild(nextSibling);
        } else if (nextSibling) {
          nextSibling.nodeValue = text + nextSibling.nodeValue;
          dom = nextSibling;
        } else if (prevSibling) {
          prevSibling.nodeValue += text;
          dom = prevSibling;
        } else {
          if (nodeBefore) {
            parentNode.insertBefore(dom, nodeBefore);
          } else {
            parentNode.appendChild(dom);
          }
        }
        return {
          'dom': dom,
          'startPos': startOffs,
          'charCnt': charCnt
        };
      },

      /**
       * Get the textual "payload" of the given text node.
       * <p>
       * The payload is the character data that is actually relevant for node/character
       * calculations. It does not have any whitespace in it.
       * @param {Node} node text DOM node (<code>nodeType === 3</code>)
       * @return {String} the textual payload of the given text node
       */
      getNodeText: function (node) {
        if (node.nodeType !== 3) {
          return '';
        }
        var nodeText = node.nodeValue;
        if (nodeText) {
          nodeText = nodeText.replace(/[\n\t\r]/g, '');
        }
        return nodeText;
      },

      /**
       * Get the textual content of the given text node recursively.
       * <p>
       * Normalizes IE's innerText functionality across all browsers.
       * @param {Node} node The node
       * @return The textual content
       */
      getInnerText: function (node) {
        var com = CUI.rte.Common;

        function innerText(node, text) {
          if (com.isTag(node, ['script', 'style'])) {
            // ignore contents of script and style tags
            return text;
          }
          if (node.nodeType === 3) {
            text += node.nodeValue;
          } else if (node.nodeType === 1) {
            if (node.nodeName.toUpperCase() === 'BR') {
              text += '\n';
            } else {
              var children = node.childNodes;
              for (var c = 0; c < children.length; c++) {
                text = innerText(children[c], text);
              }
            }
          }
          return text;
        }

        return innerText(node, '');
      },

      /**
       * <p>Checks if the specified DOM element represents a (structural) node that must
       * be counted as a character, rather than being ignored for character position
       * calculation. (For example: br, img, a name).</p>
       * <p>Please note that this method does not count empty edit blocks
       * (&lt;p&gt;&lt;/p&gt;) as one character nodes, although they are actually counted
       * as one character nodes due to invalid recursion.</p>
       * @param {HTMLElement} dom The DOM element to be checked
       * @return {Boolean} True if the DOM element must be counted as a character
       */
      isOneCharacterNode: function (dom) {
        if (!dom || (dom.nodeType === 3)) {
          return false;
        }
        var com = CUI.rte.Common;
        var tagList = com.ONE_CHARACTER_NODES;
        for (var i = 0; i < tagList.length; i++) {
          var isMatching = com.matchesTagDef(dom, tagList[i]);
          if (isMatching) {
            return true;
          }
        }
        return false;
      },

      /**
       * Checks if the specified DOM element represents a character node. A character node
       * is a node that must be counted as a character (regarding caret movement et al).
       * All text nodes are character node. Additionally, several structural nodes (like
       * "a name", "br", "img") are character nodes.
       * @param {HTMLElement} dom The DOM element to be checked
       * @return {Boolean} True if the DOM element is a character
       */
      isCharacterNode: function (dom) {
        if (!dom) {
          return false;
        }
        return (dom.nodeType === 3) || CUI.rte.Common.isOneCharacterNode(dom);
      },

      /**
       * Checks if the specified DOM element represents an editable node. A editable
       * node is a text node, a "one character" structural node and empty edit blocks.
       * @param {HTMLElement} dom The DOM element to be checked
       * @return {Boolean} True if the DOM element is an editable node
       */
      isEditableNode: function (dom) {
        if (!dom) {
          return false;
        }
        var com = CUI.rte.Common;
        return com.isCharacterNode(dom) || com.isEmptyEditingBlock(dom, true);
      },

      /**
       * Checks if the specified node is a or contains at least one character node (as a
       * child node).
       * @param {HTMLElement} dom The DOM element to be checked
       * @return {Boolean} True if the DOM element contains at least one character
       */
      containsCharacterNode: function (dom) {
        var com = CUI.rte.Common;
        if (com.isCharacterNode(dom)) {
          return true;
        }
        if (dom.nodeType !== 1) {
          return false;
        }
        var children = dom.childNodes;
        var childCnt = children.length;
        for (var c = 0; c < childCnt; c++) {
          if (com.containsCharacterNode(children[c])) {
            return true;
          }
        }
        return false;
      },

      /**
       * Determines all character nodes for the subtree starting at the specified node.
       * @param {HTMLElement} dom
       * @return {HTMLElement[]} Array containing all character nodes
       */
      getCharacterNodes: function (dom, array) {
        var com = CUI.rte.Common;
        if (!array) {
          array = [];
        }
        if (com.isCharacterNode(dom)) {
          array.push(dom);
        }
        if (dom.nodeType === 1) {
          var children = dom.childNodes;
          var childCnt = children.length;
          for (var c = 0; c < childCnt; c++) {
            com.getCharacterNodes(children[c], array);
          }
        }
        return array;
      },

      /**
       * Checks if the specified node is an empty edit block tag (ie &lt;p&gt;&lt;/p&gt;,
       * which is used by IE).
       * @param {HTMLElement} dom The DOM element to be checked
       * @param {Boolean} checkDeep (optional) True if the specified node will qualify
       *        as "empty" if it has no "character" child nodes. False, if the specified
       *        node must only qualify as "empty" if it has no child nodes
       * @return {Boolean} True if the DOM element is an empty edit block
       */
      isEmptyEditingBlock: function (dom, checkDeep) {
        var com = CUI.rte.Common;
        if (dom.nodeType === 3) {
          return false;
        }
        if (!com.isTag(dom, com.EDITBLOCK_TAGS)) {
          return false;
        }
        if (!checkDeep) {
          return (dom.childNodes.length === 0);
        }
        return !com.containsCharacterNode(dom);
      },

      /**
       * Get the number of characters of the given node that are relevant for the
       * calculation of character positions.
       * <p>
       * Note that this method does not work recursively.
       * @see CUI.rte.Common.getNodeText
       * @param {Node} node DOM node
       * @return {Number} Number of relevant characters
       */
      getNodeCharacterCnt: function (node) {
        var com = CUI.rte.Common;
        if (node.nodeType === 1) {
          if (com.isOneCharacterNode(node)) {
            return 1;
          }
          // consider empty edit blocks as well
          if (com.isEmptyEditingBlock(node, true)) {
            return 1;
          }
          return 0;
        }
        var nodeText = CUI.rte.Common.getNodeText(node);
        if (nodeText) {
          return nodeText.length;
        }
        return 0;
      },

      /**
       * <p>Gets the number of characters of the specified node and all of its subnodes
       * that are relevant for the calculation of character positions.</p>
       * <p>Note that this method works recursively and doesn't consider edit block roots
       * ("p", "td", "li").</p>
       * .
       * @see CUI.rte.Common.getNodeText
       * @param {Node} node DOM node
       * @return {Number} Number of relevant characters
       */
      getNodeTextLength: function (node) {
        var com = CUI.rte.Common;
        if (node.nodeType === 3) {
          return com.getNodeCharacterCnt(node);
        } else if (node.nodeType === 1) {
          var charCnt = com.getNodeCharacterCnt(node);
          var childCnt = node.childNodes.length;
          for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            var childToProcess = node.childNodes[childIndex];
            charCnt += com.getNodeTextLength(childToProcess);
          }
          return charCnt;
        }
        return 0;
      },

      /**
       * Get the node at the given character position.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Number} pos character position to be calculated
       * @param {Boolean} normalize (optional) True to ensure results that are
       *        browser-independent; most notably, empty blocks are counted as two
       *        characters
       * @return {Object} definition of the DOM node at the given character position
       */
      getNodeAtPosition: function (context, pos, normalize) {
        var state = {
          'node': null,
          'charPos': 0,
          'nodeBefore': null
        };
        getNodeAtPositionRec(context, context.root, state, pos, normalize);
        var node = state.node;
        if (!node) {
          if (!state.nodeBefore) {
            return null;
          }
          node = {
            'dom': null,
            'nodeBefore': state.nodeBefore
          };
        }
        return node;
      },

      /**
       * Calculates the character position of the given node.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Node} node DOM node for which the character offset is to be calculated
       * @return {Number} Character position for the given node
       */
      getCharacterOffsetForNode: function (context, node) {
        return getCharacterOffsetForNodeRec(context, node, 0, context.root).charPos;
      },

      /**
       * <p>Get the previous sibling of the specified DOM node.</p>
       * <p>This method considers multiple hierarchical levels (whereas
       * HTMLElement.nextSibling only works on the same hierarchical level) and can be
       * used for DOM walking.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The DOM node
       * @return {HTMLElement} previous sibling of dom; <code>null</code> if
       *         there is no previous sibling
       */
      getPreviousNode: function (context, node) {
        if (node.previousSibling) {
          node = node.previousSibling;
          while (true) {
            var childCnt = node.childNodes.length;
            if (childCnt === 0) {
              return node;
            }
            node = node.childNodes[childCnt - 1];
          }
        }
        return CUI.rte.Common.getParentNode(context, node);
      },

      /**
       * <p>Get the previous text sibling of the given DOM node.</p>
       * <p>Note that "text like" structural elements (like br or img) are not considered
       * by this method.</p>
       * <p>Note on handling break tags: the method will not return a previous node if
       * break tags are specified and the initial node's type is one of the break tags.
       * This is contrary to the behaviour of {@link #getNextTextNode}, but correct in
       * the context of DOM traversal.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The DOM node
       * @return {HTMLElement} previous text sibling of dom; null if there is no previous
       *         sibling
       */
      getPreviousTextNode: function (context, node, breakTags) {
        var com = CUI.rte.Common;
        if (breakTags && com.isTag(node, breakTags)) {
          return null;
        }
        do {
          node = com.getPreviousNode(context, node);
          if (breakTags && com.isTag(node, breakTags)) {
            node = null;
            break;
          }
        } while (node && (node.nodeType !== 3));
        return node;
      },

      /**
       * <p>Get the previous sibling of the given DOM node that is handled as a character
       * node in the context of positioning the caret.</p>
       * <p>Hence "text like" structural elements (like br or img) are considered by this
       * method.</p>
       * <p>Note on handling break tags: the method will not return a previous node if
       * break tags are specified and the initial node's type is one of the break tags.
       * This is contrary to the behaviour of {@link #getNextCharacterNode}, but
       * correct in the context of DOM traversal.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The DOM node
       * @return {HTMLElement} previous sibling of dom that is a text node or has to be
       *         handled like a character for caret positioning; null if there is no
       *         previous sibling
       */
      getPreviousCharacterNode: function (context, node, breakTags) {
        var com = CUI.rte.Common;
        // if we're looking for a previous node, we'll have to check the starting
        // node also, contrary to getNextCharacterNode
        if ((breakTags && com.isTag(node, breakTags)) || (node === context.root)) {
          return null;
        }
        do {
          node = com.getPreviousNode(context, node);
          if (node === context.root) {
            node = null;
            break;
          }
          if (breakTags && com.isTag(node, breakTags)) {
            node = null;
            break;
          }
        } while (node && (com.getNodeCharacterCnt(node) === 0));
        return node;
      },

      /**
       * <p>Get the previous sibling of the given DOM node that is editable.</p>
       * <p>This method returns text nodes, "one character" structural nodes and
       * empty editing blocks (IE only).</p>
       * <p>Note on handling break tags: the method will not return a previous node if
       * break tags are specified and the initial node's type is one of the break tags.
       * This is contrary to the behaviour of {@link #getNextTextNode}, but correct in
       * the context of DOM traversal.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The DOM node
       * @return {HTMLElement} next sibling of dom that is a text node or has to be
       *         handled like a character for caret positioning; null if there is no
       *         next sibling
       */
      getPreviousEditableNode: function (context, node, breakTags) {
        var com = CUI.rte.Common;
        if (!node) {
          return null;
        }
        if (breakTags && com.isTag(node, breakTags)) {
          return null;
        }
        do {
          node = com.getPreviousNode(context, node);
          if (breakTags && com.isTag(node, breakTags)) {
            node = null;
            break;
          }
        } while (node && !com.isEditableNode(node));
        return node;
      },

      /**
       * <p>Get the next sibling of the specified DOM node.</p>
       * <p>This method considers multiple hierarchical levels (whereas
       * HTMLElement.nextSibling only works on the same hierarchical level) and can be
       * used for DOM walking.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The DOM node
       * @return {HTMLElement} next sibling of dom; null if there is no next sibling
       */
      getNextNode: function (context, node) {
        if (node.childNodes.length > 0) {
          return node.childNodes[0];
        }
        if (node.nextSibling) {
          return node.nextSibling;
        }
        while (true) {
          node = CUI.rte.Common.getParentNode(context, node);
          if (!node || (node === context.root)) {
            return null;
          }
          if (node.nextSibling) {
            return node.nextSibling;
          }
        }
      },

      /**
       * <p>Get the next text sibling of the specified DOM node.</p>
       * <p>Note that "text like" structural elements (like br or img) are not considered
       * by this method.</p>
       * <p>Note on handling break tags: the method will return a next node if break tags
       * are specified and the initial node's type is one of the break tags. This is
       * contrary to the behaviour of {@link #getPreviousTextNode}, but correct in
       * the context of DOM traversal.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The DOM node
       * @return {HTMLElement} next text sibling of dom; null if there is no previous
       *         sibling
       */
      getNextTextNode: function (context, node, breakTags) {
        var com = CUI.rte.Common;
        do {
          node = com.getNextNode(context, node);
          if (breakTags && com.isTag(node, breakTags)) {
            node = null;
            break;
          }
        } while (node && (node.nodeType !== 3));
        return node;
      },

      /**
       * <p>Get the next sibling of the given DOM node that is handled as a character
       * node in the context of positioning the caret.</p>
       * <p>Hence "text like" structural elements (like br or img) are considered by this
       * method.</p>
       * <p>Note on handling break tags: the method will return a next node if break tags
       * are specified and the initial node's type is one of the break tags. This is
       * contrary to the behaviour of {@link #getPreviousCharacterNode}, but correct in
       * the context of DOM traversal.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The DOM node
       * @return {HTMLElement} next sibling of dom that is a text node or has to be
       *         handled like a character for caret positioning; null if there is no
       *         next sibling
       */
      getNextCharacterNode: function (context, node, breakTags) {
        var com = CUI.rte.Common;
        do {
          node = com.getNextNode(context, node);
          if (breakTags && com.isTag(node, breakTags)) {
            node = null;
            break;
          }
        } while (node && (com.getNodeCharacterCnt(node) === 0));
        return node;
      },

      /**
       * <p>Get the next sibling of the given DOM node that is editable.</p>
       * <p>This method returns text nodes, "one character" structural nodes and
       * empty editing blocks (IE only).</p>
       * <p>Note on handling break tags: the method will return a next node if break tags
       * are specified and the initial node's type is one of the break tags. This is
       * contrary to the behaviour of {@link #getPreviousEditableNode}, but correct in
       * the context of DOM traversal.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The DOM node
       * @return {HTMLElement} next sibling of dom that is a text node or has to be
       *         handled like a character for caret positioning; null if there is no
       *         next sibling
       */
      getNextEditableNode: function (context, node, breakTags) {
        var com = CUI.rte.Common;
        if (!node) {
          return null;
        }
        do {
          node = com.getNextNode(context, node);
          if (breakTags && com.isTag(node, breakTags)) {
            node = null;
            break;
          }
        } while (node && !com.isEditableNode(node));
        return node;
      },

      /**
       * <p>Check if dom1 is an ancestor node of dom2.</p>
       * <p>Note that this method will (correctly) return false if dom1 === dom2.</p>
       * @param {HTMLElement} dom1 potential DOM ancestor node
       * @param {HTMLElement} dom2 potential DOM descendant node
       * @return {Boolean} True if <code>dom1</code> is an ancestor node
       *         of <code>dom2</code>
       */
      isAncestor: function (context, dom1, dom2) {
        if (!dom1 || !dom2) {
          return false;
        }
        do {
          dom2 = CUI.rte.Common.getParentNode(context, dom2);
          if (dom2) {
            if (dom2 === dom1) {
              return true;
            }
          }
        } while (dom2);
        return false;
      },

      /**
       * Checks if any of the descendant nodes of the specified sub-tree root has any of
       * the specified tags.
       * @param {HTMLElement} subTreeRoot The sub-tree root to check (node not included)
       * @param {String/String[]} tags The tag(s) to check against
       */
      isLastChildDeep: function (subTreeRoot, tags) {
        var com = CUI.rte.Common;
        var checkNode = subTreeRoot;
        do {
          if (checkNode.nodeType !== 1) {
            return false;
          }
          var children = checkNode.childNodes;
          if (children.length === 0) {
            return false;
          }
          checkNode = children[children.length - 1];
          if (com.isTag(checkNode, tags)) {
            return true;
          }
        } while (true);
      },

      /**
       * Checks if the specified element is the last element of a nesting level, for
       * example the last cell of a table that is nested into another table.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The node to check
       */
      isLastElementOfNestingLevel: function (context, node) {
        var com = CUI.rte.Common;
        // get the corresponding nesting element
        while (!com.isTag(node, com.EDITBLOCK_NESTED_TAGS) && !com.isTag(node, com.EDITBLOCK_UNREGNEST_TAGS)) {
          node = com.getParent(context, node);
          if (!node) {
            return false;
          }
        }
        var pNode = com.getParentNode(context, node);
        if (!pNode) {
          return false;
        }
        var maxChild = pNode.childNodes.length - 1;
        if (com.getChildIndex(node) !== maxChild) {
          return false;
        }
        // this is only valid for nested tags, so ensure that we are actually in a
        // nested context
        // todo check if this is true for mixed nestings (list in a table/table in a list)
        if (!com.containsTagInPath(context, pNode, com.EDITBLOCK_UNREGNEST_TAGS) && !com.containsTagInPath(context, pNode, com.EDITBLOCK_NESTED_TAGS)) {
          return false;
        }
        // ok, we are last in the list of the parent element; this may not be enough
        // (we may have found last cell of a row, but not of the entire table), so
        // we'll do some further element-specific stuff here
        if (com.isTag(node, ['td', 'th'])) {
          var tBody = com.getParentNode(context, pNode);
          if (!tBody) {
            return false;
          }
          maxChild = tBody.childNodes.length - 1;
          return (com.getChildIndex(pNode) === maxChild);
        }
        // in case of a list item, we can have multiple adjacent nested lists on the
        // same hierarchical level; this method must return false for all nested list
        // items besides the very last item
        if (com.isTag(node, 'li')) {
          var list = node.parentNode;
          return com.isLastNestedList(context, list);
        }
        return true;
      },

      /**
       * Gets the index that the given DOM node has in the <code>childNodes</code> array
       * of its parent node.
       * @param {HTMLElement} node The DOM node to check
       * @return {Number} child index in dom's parent node; -1 if the specified DOM node
       *         has no parent
       */
      getChildIndex: function (node) {
        if (!node.parentNode) {
          return -1;
        }
        var childCnt = node.parentNode.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          if (node.parentNode.childNodes[childIndex] === node) {
            return childIndex;
          }
        }
        return -1;
      },

      /**
       * Get the last "deep-child" of the given node.
       * <p>
       * This method works recursively. It will actually get the last descendant node.
       * @param {HTMLElement} node DOM node
       * @return {HTMLElement} The last descendant node; null if there are no
       *         descendant nodes
       */
      getLastChild: function (node, isRecCall) {
        var com = CUI.rte.Common;
        if (node.nodeType === 3) {
          return node;
        }
        var childCnt = node.childNodes.length;
        if (childCnt === 0) {
          return (isRecCall ? node : null);
        }
        return com.getLastChild(node.childNodes[childCnt - 1], true);
      },

      /**
       * <p>Get the first "deep-child" of the given node.</p>
       * <p>This method works recursively. It will actually get the first descendant node.
       * </p>
       * @param {HTMLElement} node DOM node
       * @return {HTMLElement} The first descendant node; null if there are no
       *         descendant nodes
       */
      getFirstChild: function (node, isRecCall) {
        var com = CUI.rte.Common;
        if (node.nodeType === 3) {
          return node;
        }
        var childCnt = node.childNodes.length;
        if (childCnt === 0) {
          return (isRecCall ? node : null);
        }
        return com.getFirstChild(node.childNodes[0], true);
      },

      /**
       * Check if the given node has a textual descendant node (or is itself a textual
       * node).
       * <p>
       * Note on using useTextLen: If set to true, this method will also consider
       * "text-like" structural DOM nodes (such as br) as text.
       * @param {HTMLElement} node Node to check
       * @param {Boolean} useTextLen True if the text length should be used (instead of
       *        the actual nodeType) to determine if a given node has a textual descendant
       *        node
       * @return {Boolean} True if the given node has a textual descendant, else false
       */
      hasTextChild: function (node, useTextLen) {
        var textChild = CUI.rte.Common.getFirstTextChild(node, useTextLen);
        return (textChild !== null && textChild !== undefined);
      },

      /**
       * <p>Get the first descendant text node of the given node.</p>
       * <p>Note on using useTextLen: If set to true, this method will also consider
       * "text-like" structural DOM nodes (such as br) as text. So be aware that you
       * might get a non-textual node as a result if you are setting this option.</i>
       * @param {HTMLElement} node Node for which the text node has to be determined
       * @param {Boolean} useTextLen True if the text length should be used (instead of
       *        the actual nodeType) to determine if a given node contains text
       * @param {Boolean} includeSelf True if the specified node itself is considered as
       *        a potential text node
       * @return {HTMLElement} The first descendant text node; null, if there is no
       *         text node available
       */
      getFirstTextChild: function (node, useTextLen, includeSelf) {
        var com = CUI.rte.Common;
        if (includeSelf) {
          if (useTextLen) {
            if (com.getNodeCharacterCnt(node) > 0) {
              return node;
            }
          } else if (node.nodeType === 3) {
            return node;
          }
        }
        var childCnt = node.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          var textNode = com.getFirstTextChild(node.childNodes[c], useTextLen, true);
          if (textNode) {
            return textNode;
          }
        }
        return null;
      },

      /**
       * Get the last descendant text node of the given node.
       * @param {HTMLElement} node Node for which the text node has to be determined
       * @param {Boolean} useTextLen True if the text length should be used (instead of
       *        the actual nodeType) to determine if a given node contains text
       * @param {Boolean} includeSelf True if the specified node itself is considered as
       *        a potential text node
       * @return {HTMLElement} The last descendant text node; null, if there is no
       *         text node available
       */
      getLastTextChild: function (node, useTextLen, includeSelf) {
        var com = CUI.rte.Common;
        if (includeSelf) {
          if (useTextLen) {
            if (com.getNodeCharacterCnt(node) > 0) {
              return node;
            }
          } else if (node.nodeType === 3) {
            return node;
          }
        }
        var childCnt = node.childNodes.length;
        for (var c = childCnt - 1; c >= 0; c--) {
          var textNode = com.getLastTextChild(node.childNodes[c], useTextLen, true);
          if (textNode) {
            return textNode;
          }
        }
        return null;
      },

      /**
       * Creates an (independent) array of the specified node's child nodes.
       * @param {HTMLElement} dom The node to create the child's list from
       * @return {HTMLElement[]} List of child nodes
       */
      childNodesAsArray: function (dom) {
        var array = [];
        if (dom.nodeType === 1) {
          var childCnt = dom.childNodes.length;
          for (var c = 0; c < childCnt; c++) {
            array.push(dom.childNodes[c]);
          }
        }
        return array;
      },

      /**
       * Get the parent node of the given DOM node, up to (and including) the
       * document's root node.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node DOM node for which the parent node has to be determined
       * @return {HTMLElement} parent node; <code>null</code> if the given node has no
       *         more "content" parent nodes
       */
      getParentNode: function (context, node) {
        if (node === context.root) {
          return null;
        }
        return node.parentNode;
      },

      /**
       * Gets the window object for the specified document.
       * @param {document} doc The document
       * @returns {window} The corresponding window object
       */
      getWindowForDocument: function (doc) {
        return (CUI.rte.Common.ua.isIE ? doc.parentWindow : doc.defaultView);
      },

      /**
       * Determines the parent element that contains the reference of the document's
       * window object, for example the parent iframe object.
       * @param {CUI.rte.EditContext} context The edit context
       * @returns {HTMLElement} The element that "hosts" the document's window object
       */
      getParentWindowRef: function (context) {
        var win = context.win;
        if (win.frameElement) {
          return win.frameElement;
        }
        return undefined;
      },

      /**
       * Initializes the "touch in iframe" user agent property. If the RTE is used
       * inside an iframe on a touch device, no touch events may be used, as Safari
       * goes crazy if they are used.
       * @param {CUI.rte.EditContext} context The edit context
       */
      initializeTouchInIframe: function (context) {
        var com = CUI.rte.Common;
        com.ua.isTouchInIframe = com.ua.isTouch && !!com.getParentWindowRef(context);
      },

      /**
       * <p>Checks if the specified node is a "zombie node".</p>
       * <p>Later Gecko versions introduced the behaviour that sometimes nodes get
       * referenced (for example by the selection) that are not connected to the
       * document anymore. This method can be used to detect such cases.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The DOM node to check
       * @return {Boolean} True if the specified node is a zombie node
       */
      isZombieNode: function (context, dom) {
        while (dom) {
          if (dom === context.root) {
            return false;
          }
          dom = dom.parentNode;
        }
        return true;
      },

      /**
       * Get the "block node" for the given DOM node.
       * <p>
       * Note that this method does only return the ancestor node (of <code>dom</code>)
       * that is a direct child of the document's root element. For proper block node
       * detection see the {@link #BLOCK_TAGS} array.
       * @see CUI.rte.DomProcessor#getScopedBlockNode
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom DOM node for which the "block node" has to be determined
       * @deprecated Use proper detection of block nodes instead
       */
      getBlockNode: function (context, dom) {
        var com = CUI.rte.Common;
        while (dom) {
          var domParentParent = com.getParentNode(context, dom.parentNode);
          if (domParentParent === null || domParentParent === undefined) {
            return dom;
          }
          dom = dom.parentNode;
        }
        return null;
      },

      /**
       * Checks if the given DOM node is a "block node".
       * <p>
       * Note that this method only checks if the given node is a direct child of the
       * document's body tag. For proper block node detection see the {@link #BLOCK_TAGS}
       * array.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom DOM node to check
       * @return {Boolean} True if the given DOM node is a direct child of
       *         the document's body element
       * @deprecated Use proper detection of block nodes instead
       */
      isBlockNode: function (context, dom) {
        return (dom && dom.parentNode &&
        CUI.rte.Common.isRootNode(context, dom.parentNode));
      },

      /**
       * @deprecated Use proper detection of block nodes instead
       */
      getLastBlockNode: function (context, dom) {
        while (!CUI.rte.Common.isRootNode(context, dom)) {
          dom = dom.parentNode;
        }
        var blocks = context.root.childNodes;
        if (blocks.length === 0) {
          return null;
        }
        return blocks[blocks.length - 1];
      },

      hasContent: function (dom) {
        if (dom.nodeType === 3) {
          return true;
        }
        var childCnt = dom.childNodes.length;
        if (childCnt === 0) {
          return false;
        }
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          var childToProcess = dom.childNodes[childIndex];
          if (childToProcess.nodeType === 3) {
            var text = childToProcess.nodeValue;
            text = text.replace(/[\n\t\r \u00A0]/g, '');
            if (text.length > 0) {
              return true;
            }
          } else {
            var hasChildContent = CUI.rte.Common.hasContent(
              childToProcess);
            if (hasChildContent) {
              return true;
            }
          }
        }
        return false;
      },

      /**
       * <p>Gets the first node "up the DOM tree" that matches the specified tag
       * definition (tag name and attributes).</p>
       * <p>If the specified DOM matches the tag definition itself, it is returned instead
       * of any super matching element.</p>
       * @param {CUI.rte.EditContext} context
       * @param {HTMLElement} dom The DOM element to start DOM traversal with
       * @param {String} tagName The tag name to check for
       * @param {Object} attribs Attribute definition
       * @return {HTMLElement} The first super element that matches the specified
       *         tag definition; null if no such element exists
       */
      getTagInPath: function (context, dom, tagName, attribs) {
        var com = CUI.rte.Common;
        while (dom) {
          if (dom.nodeType === 1) {
            if (dom === context.root) {
              return null;
            }
            if (com.isTag(dom, tagName)) {
              if (!attribs || com.hasAttributes(dom, attribs)) {
                return dom;
              }
            }
          }
          dom = com.getParentNode(context, dom);
        }
        return null;
      },

      containsTagInPath: function (context, dom, tagName, attribs) {
        var tagInPath = CUI.rte.Common.getTagInPath(context, dom, tagName, attribs);
        return (tagInPath !== null && tagInPath !== undefined);
      },

      matchesTagDefs: function (dom, tagDefs) {
        var com = CUI.rte.Common;
        if (!CUI.rte.Utils.isArray(tagDefs)) {
          return com.matchesTagDef(dom, tagDefs);
        }
        var defCnt = tagDefs.length;
        for (var t = 0; t < defCnt; t++) {
          if (CUI.rte.Common.matchesTagDef(dom, tagDefs[t])) {
            return true;
          }
        }
        return false;
      },

      matchesTagDef: function (dom, tagDef) {
        var com = CUI.rte.Common;
        if (!com.isTag(dom, tagDef.tagName)) {
          return false;
        }
        var attribIndex, attribCnt, attribToCheck;
        if (tagDef.attribsDefined) {
          attribCnt = tagDef.attribsDefined.length;
          for (attribIndex = 0; attribIndex < attribCnt; attribIndex++) {
            attribToCheck = tagDef.attribsDefined[attribIndex];
            if (!com.isAttribDefined(dom, attribToCheck)) {
              return false;
            }
          }
        }
        if (tagDef.attribsUndefined) {
          attribCnt = tagDef.attribsUndefined.length;
          for (attribIndex = 0; attribIndex < attribCnt; attribIndex++) {
            attribToCheck = tagDef.attribsUndefined[attribIndex];
            if (com.isAttribDefined(dom, attribToCheck)) {
              return false;
            }
          }
        }
        if (tagDef.attribValues) {
          var def = tagDef.attribValues;
          for (var name in def) {
            if (def.hasOwnProperty(name)) {
              attribToCheck = com.getAttribute(dom, name, true);
              if (!attribToCheck) {
                return false;
              }
              if (attribToCheck !== def[name]) {
                return false;
              }
            }
          }
        }
        if (tagDef.empty) {
          if (dom.childNodes.length > 0) {
            return false;
          }
        }
        return true;
      },

      /**
       * <p>Gets the list nesting level for the specified DOM element.</p>
       * <p>If the specified DOM element is a list itself, it does not add as another
       * list level.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The DOM element to determine list nesting for
       * @return {Number} The list nesting level of the specified DOM element
       */
      getListLevel: function (context, dom) {
        var com = CUI.rte.Common;
        var indentLevel = 0;
        while (dom) {
          dom = com.getParentNode(context, dom);
          if (dom && (com.isTag(dom, 'ul') || com.isTag(dom, 'ol'))) {
            indentLevel++;
          }
        }
        return indentLevel;
      },

      /**
       * Checks if the specified list DOM is the first nested list.
       * @param {HTMLElement} listDom DOM of list to check
       * @return {Boolean} True if the specified list DOM is the first nested list
       */
      isFirstNestedList: function (context, listDom) {
        // todo adapt if other unregular nested structures are supported in the future
        var com = CUI.rte.Common;
        var itemDom = com.getTagInPath(context, listDom, 'li');
        if (!itemDom) {
          return false;
        }
        var childCnt = itemDom.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          var childToCheck = itemDom.childNodes[c];
          if (childToCheck === listDom) {
            return true;
          }
          if (com.isTag(childToCheck, com.LIST_TAGS)) {
            return false;
          }
        }
        return false;
      },

      /**
       * Checks if the specified list DOM is the last nested list.
       * @param {HTMLElement} listDom DOM of list to check
       * @return {Boolean} True if the specified list DOM is the first nested list
       */
      isLastNestedList: function (context, listDom) {
        var com = CUI.rte.Common;
        var itemDom = com.getTagInPath(context, listDom, 'li');
        if (!itemDom) {
          return false;
        }
        var childCnt = itemDom.childNodes.length;
        for (var c = childCnt - 1; c >= 0; c--) {
          var childToCheck = itemDom.childNodes[c];
          if (childToCheck === listDom) {
            return true;
          }
          if (com.isTag(childToCheck, com.LIST_TAGS)) {
            return false;
          }
        }
        return false;
      },

      /**
       * Gets all child nodes of the specified DOM element that are of a specified type.
       * @param {HTMLElement} dom The DOM element
       * @param {String|String[]} tagName Type(s) to look for
       * @param {Boolean} isRecursive True if the search should be executed recursively
       * @param {String|String[]} stopTag Tag(s) to stop further recursion. For example,
       *        if "table" is specified here, nested tables will not be considered by
       *        the search.
       * @param {HTMLElement[]} result (optional) Array the results have to be added to
       * @return {HTMLElement[]} Array with all child nodes that match the specified
       *         criteria
       */
      getChildNodesByType: function (dom, tagName, isRecursive, stopTag, result) {
        var com = CUI.rte.Common;
        result = result || [];
        var children = dom.childNodes;
        var childCnt = children.length;
        for (var i = 0; i < childCnt; i++) {
          var child = children[i];
          if (com.isTag(child, tagName)) {
            result.push(child);
          }
          if (isRecursive && (child.nodeType === 1)) {
            var isStopTag = stopTag && com.isTag(child, stopTag);
            if (!isStopTag) {
              com.getChildNodesByType(child, tagName, isRecursive, stopTag,
                result);
            }
          }
        }
        return result;
      },

      getConsistentStyle: function (context, domList, styleName, defaultValue) {
        var nodeCnt = domList.length;
        var consistentStyle;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
          var dom = domList[nodeIndex];
          var styleAttrib = CUI.rte.Common.getStyleProp(context, dom, styleName);
          styleAttrib = (styleAttrib ? styleAttrib : defaultValue);
          if (nodeIndex === 0) {
            consistentStyle = styleAttrib;
          } else if (styleAttrib !== consistentStyle) {
            return null;
          }
        }
        return consistentStyle;
      },


      // --- DOM processing --------------------------------------------------------------

      /**
       * @deprecated use {@link CUI.rte.DomProcessor#insertElement} instead
       */
      insertNode: function (dom, node, offset) {
        var com = CUI.rte.Common;
        if (node.nodeType === 1) {
          if (!offset) {
            node.parentNode.insertBefore(dom, node);
          } else if (offset >= node.childNodes.length) {
            node.parentNode.append(dom);
          } else {
            var insertRef = node.childNodes[offset];
            node.parentNode.insertBefore(dom, insertRef);
          }
          return;
        }
        if (offset === 0) {
          node.parentNode.insertBefore(dom, node);
        } else if (offset >= com.getNodeCharacterCnt(node)) {
          node.parentNode.insertBefore(dom, node.nextSibling);
        } else {
          var nodeText = node.nodeValue;
          node.nodeValue = nodeText.substring(0, offset);
          var splitTextNode = node.cloneNode(false);
          splitTextNode.nodeValue = nodeText.substring(offset, nodeText.length);
          var nextSibling = node.nextSibling;
          var pNode = node.parentNode;
          pNode.insertBefore(dom, nextSibling);
          pNode.insertBefore(splitTextNode, nextSibling);
        }
      },

      /**
       * <p>Replaces one DOM element with another without changing the DOM structure
       * (other than replacing the DOM element).</p>
       * <p>If the replacement is an entire structure, you should specify childParent,
       * which specifies the node to which the child nodes of the replaced node are
       * moved.</p>
       * @param {HTMLElement} toReplace The node to be replaced
       * @param {HTMLElement} replacement The node (or substructure) to replace with
       * @param {HTMLElement} childParent (optional, if a substructure is specified as
       *        replacement) The node the child nodes of toReplace will be moved to
       */
      replaceNode: function (toReplace, replacement, childParent) {
        var children = toReplace.childNodes;
        if (!childParent) {
          childParent = replacement;
        }
        while (children.length > 0) {
          var child = children[0];
          toReplace.removeChild(child);
          childParent.appendChild(child);
        }
        toReplace.parentNode.replaceChild(replacement, toReplace);
      },

      /**
       * Moves the children of one node to another node.
       * @param {HTMLElement} src Node to move children from
       * @param {HTMLElement} dest Node to move children to
       * @param {Number} startIndex Index of first node to move (0/null to move all nodes)
       * @param {Boolean} insertAtEnd True if the moved nodes should be appended at the
       *        end of the destination node's existing child nodes
       */
      moveChildren: function (src, dest, startIndex, insertAtEnd) {
        var com = CUI.rte.Common;
        if ((startIndex === null) || (startIndex === undefined)) {
          startIndex = 0;
        }
        var moveCnt = src.childNodes.length;
        var moveIndex = 0;
        for (var c = moveCnt - 1; c >= startIndex; c--) {
          var childToMove = src.childNodes[c];
          src.removeChild(childToMove);
          if (!insertAtEnd) {
            com.insertBefore(dest, childToMove, dest.firstChild);
          } else {
            if (moveIndex === 0) {
              dest.appendChild(childToMove);
            } else {
              var insertRef = dest.childNodes[dest.childNodes.length - moveIndex];
              com.insertBefore(dest, childToMove, insertRef);
            }
            moveIndex++;
          }
        }
      },

      /**
       * Removes all child nodes of the specified DOM node.
       * @param {HTMLElement} dom DOM node to remove child nodes from
       */
      removeAllChildren: function (dom) {
        if (dom.nodeType !== 1) {
          return;
        }
        while (dom.childNodes.length > 0) {
          dom.removeChild(dom.childNodes[0]);
        }
      },

      /**
       * Removes all nodes with no child nodes "up the hierarchy", starting from the
       * given DOM node.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Node} dom DOM node to start
       */
      removeNodesWithoutContent: function (context, dom) {
        while (dom && !CUI.rte.Common.isRootNode(context, dom)) {
          if (dom.childNodes.length > 0) {
            break;
          }
          var removeParent = dom.parentNode;
          removeParent.removeChild(dom);
          dom = removeParent;
        }
      },

      /**
       * Removes all direct child nodes of given dom which have given tag name and no child nodes.
       * @param {Node} dom DOM node whose child nodes are to be removed
       * @param {String|String []} tagName - only the nodes with this(these) tagName(s) would be removed
       */
      removeEmptyChildNodes: function(dom, tagName) {
        var tags = CUI.rte.Common.getChildNodesByType(dom, tagName);
        var index = 0, tag;
        while (index < tags.length) {
          tag = tags[index];
          if (tag.childNodes.length === 0) {
            dom.removeChild(tag);
          }
          index++;
        }
      },

      /**
       * Get the value for the given style attribute name that is actually valid for
       * the specified DOM element. If necessary, the value is taken from a parent element
       * accordingly.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom DOM element
       * @param {String} styleName Name of the style attribute
       * @return {String} Style value; null if no applicable style value has been found
       */
      getStyleProp: function (context, dom, styleName) {
        if (dom === context.root) {
          return null;
        }
        while (dom) {
          if (dom.nodeType === 1) {
            if (dom.style && dom.style[styleName]) {
              return dom.style[styleName];
            }
          }
          dom = CUI.rte.Common.getParentNode(context, dom);
        }
        return null;
      },


      // --- CSS processing --------------------------------------------------------------

      /**
       * Parse the CSS classes of the specified DOM node to an array.
       * @param {HTMLElement} dom DOM node for which the CSS classes should be determined
       * @return {Array} Array (of Strings) containing all classes applied to the given
       *         DOM node
       */
      parseCSS: function (dom) {
        if (dom.nodeType !== 1) {
          return [];
        }
        var classNames = CUI.rte.Common.getAttribute(dom, 'class');
        if (!classNames) {
          return [];
        }
        return classNames.split(' ');
      },

      /**
       * Check if the specified DOM node has the given CSS class applied.
       * @param {HTMLElement} dom DOM node to check
       * @param {String} className CSS class name to check
       * @return {Boolean} True, if the given CSS class is applied to the
       *         given DOM node
       */
      hasCSS: function (dom, className) {
        if (dom.nodeType !== 1) {
          return false;
        }
        var classes = CUI.rte.Common.parseCSS(dom);
        var clsCnt = classes.length;
        for (var c = 0; c < clsCnt; c++) {
          if (classes[c] === className) {
            return true;
          }
        }
        return false;
      },

      /**
       * <p>Applies the specified CSS class to the specified DOM node.</p>
       * <p>If the DOM node already has the CSS class applied, the call is simply ignored.
       * </p>
       * @param {HTMLElement} dom DOM node
       * @param {String} className CSS class name to be applied
       */
      addClass: function (dom, className) {
        var com = CUI.rte.Common;
        if (!com.hasCSS(dom, className)) {
          var domClassName = com.getAttribute(dom, 'class');
          if (domClassName) {
            domClassName += ' ' + className;
          } else {
            domClassName = className;
          }
          com.setAttribute(dom, 'class', domClassName);
        }
      },

      /**
       * <p>Removes the specified CSS class from the specified DOM node.</p>
       * <p>If the DOM node doesn't have the CSS class applied, the call is simply
       * ignored.</p>
       * @param {HTMLElement} dom The DOM node
       * @param {String} className CSS class name to be removed
       */
      removeClass: function (dom, className) {
        var com = CUI.rte.Common;
        var classNames = com.parseCSS(dom);
        var recreateStr = '';
        var mustSet = false;
        for (var i = 0; i < classNames.length; i++) {
          if (classNames[i] === className) {
            mustSet = true;
          } else {
            if (recreateStr.length > 0) {
              recreateStr += ' ';
            }
            recreateStr += classNames[i];
          }
        }
        if (mustSet) {
          if (recreateStr) {
            com.setAttribute(dom, 'class', recreateStr);
          } else {
            com.removeAllClasses(dom);
          }
        }
      },

      /**
       * <p>Removes all CSS classes from the specified DOM node.</p>
       * <p>If the DOM node doesn't have the CSS class applied, the call is simply
       * ignored.</p>
       * @param {HTMLElement} dom DOM node
       */
      removeAllClasses: function (dom) {
        CUI.rte.Common.removeAttribute(dom, 'class');
      },


      // --- Browser-specific stuff ------------------------------------------------------

      /**
       * <p>Gets the translated IE attribute name if required.</p>
       * <p>IE does not implement attribute functions correctly. Mainly, the names
       * are differing. These method is used to work around that problem. Note that
       * there are other issues (handling of style attribute), which are not handled
       * by this method.</p>
       * <p>Note that you can call the method on other browsers as well.</p>
       * @param {String} attribName The attribute name to translate
       * @return {String} The attribute name as suitable for IE
       */
      getIEAttributeName: function (attribName) {
        var com = CUI.rte.Common;

        if (com.ua.isOldIE) {
          var attribNameLC = attribName.toLowerCase();
          // handle "class" attribute seperately, as "class" is a JavaScript keyword
          // and we can't imagine in what kind of browser hell we're running in if
          // we are using it as a key in an "associative array"
          if ((attribNameLC === 'class') && (com.ua.isIE6 || com.ua.isIE7)) {
            return 'className';
          }
          // use table for other attribute names
          var translatedAttribName = CUI.rte.Common.IE_ATTRIB_NAMES[attribNameLC];
          if (translatedAttribName !== null && translatedAttribName !== undefined) {
            attribName = translatedAttribName;
          }
        }
        return attribName;
      },

      /**
       * Gets all valid(!) attribute names for IE, as IE's implementation of the
       * attributes property is quite unusable for determining this.
       * @param {HTMLElement} dom The DOM element to get the list of attributes for
       * @param {Boolean} keepCase (optional) True if the case of the attribute names
       *        should be kept (this might be required for some IE issues to be worked
       *        around)
       * @param {Function} filter (optional) A filter method that allows to filter out a
       *        specific attribute; gets the DOM element, the attribute name and the
       *        lower case representation of the attribute's name as parameters; must
       *        return true to filter out the attribute.
       * @return {String[]} Array of all valid attribute names
       */
      getIEAttributeNames: function (dom, keepCase, filter) {
        var attributeNames = [];
        // IE bugs around again, so we'll use outerHTML to determine all *valid*
        // attributes
        var domHtml = dom.outerHTML;
        var tagEndPos = domHtml.indexOf('>');
        domHtml = domHtml.substring(0, tagEndPos + 1);
        var parsed = CUI.rte.HtmlProcessor.parseTag(domHtml);
        var attributes = parsed.attributes;
        for (var attribName in attributes) {
          var isFilteredOut = false;
          var attrib = attributes[attribName];
          if (filter) {
            isFilteredOut = filter(dom, attrib.originalName, attribName);
          }
          if (!isFilteredOut) {
            if (keepCase) {
              attributeNames.push(attrib.originalName);
            } else {
              attributeNames.push(attribName);
            }
          }
        }
        return attributeNames;
      },


      // --- Miscellaneous & Debugging ---------------------------------------------------

      /**
       * Removes all JCR-specific data from the given object.
       * <p>
       * You'll need this method to clean up collections with generic content before
       * iterating over them using something like <code>for (var key in coll)</code>.
       * Note that this method does intentionally not work recursively!
       * @param {Object} coll "Collection" to be cleaned
       */
      removeJcrData: function (coll) {
        for (var key in coll) {
          if (coll.hasOwnProperty(key)) {
            if (CUI.rte.Common.strStartsWith(key, 'jcr:')) {
              delete coll[key];
            } else if (key === 'xtype') {
              delete coll[key];
            }
          }
        }
      },

      /**
       * Check if the given array contains the given object.
       * @param {Array} array Array to check
       * @param {Object} object Object to be checked
       * @param {Function} cmp (optional) Function that is used to determine if two array
       *        elements equal each other
       * @return {Boolean} True</code> if <code>object is an element of
       *         <code>array/code>
       */
      arrayContains: function (array, object, cmp) {
        return (CUI.rte.Common.arrayIndex(array, object, cmp) >= 0);
      },

      /**
       * Adds the content of the specified array to the other specified array. All
       * elements are inserted at the end of the existing array.
       * @param {Array} array The base array; elements will be added to this array.
       * @param {Array} arrayToAdd The array to add; elements will be added at the end
       *                           of the object specified by parameter array
       */
      arrayAdd: function (array, arrayToAdd) {
        var copyCnt = arrayToAdd.length;
        for (var c = 0; c < copyCnt; c++) {
          array.push(arrayToAdd[c]);
        }
      },

      /**
       * Get the index of the given object within the given array.
       * @param {Array} array Array to check
       * @param {Object} object Object to be checked
       * @param {Function} cmp (optional) Function that is used to determine if two array
       *        elements equal each other
       * @return {Number} array index of the given object; <code>-1</code> if
       *         <code>object</code> is not an element of <code>array/code>
       */
      arrayIndex: function (array, object, cmp) {
        for (var i = 0; i < array.length; i++) {
          if (!cmp) {
            if (array[i] === object) {
              return i;
            }
          } else if (cmp(array[i], object)) {
            return i;
          }
        }
        return -1;
      },

      /**
       * Creates a 1:1 copy of the specified array.
       * @param {Array} arrayToCopy Array to copy
       * @return {Array} The copied array
       */
      arrayCopy: function (arrayToCopy) {
        var copy = [];
        var itemCnt = arrayToCopy.length;
        for (var i = 0; i < itemCnt; i++) {
          copy.push(arrayToCopy[i]);
        }
        return copy;
      },

      /**
       * Ensures that the specified object is an array. If it is an object, it is
       * converted into an array, losing the object keys.
       * @param {Object} obj The object to check/convert
       * @param {String} keyName (optional) If specified, name/value pairs are converted
       *        into objects that consist of two properties: The key (of the original
       *        object) is set as a property with the name specified by keyName; the
       *        value (of the original object) is set as a property with the name
       *        specified by valueName; for exampe: "propName": "propValue" is transformed
       *        into { [keyName]: "propName", [valueName]: "propValue" }
       * @param {String} valueName (optional) If specified, name/value pairs are converted
       *        into objects that consist of two properties: The key (of the original
       *        object) is set as a property with the name specified by keyName; the
       *        value (of the original object) is set as a property with the name
       *        specified by valueName; for exampe: "propName": "propValue" is transformed
       *        into { [keyName]: "propName", [valueName]: "propValue" }
       * @return {Array} The object (if it is already an array) or the converted object or
       *         null, if the object could not be converted to an array
       */
      toArray: function (obj, keyName, valueName) {
        if (!obj) {
          return null;
        }
        if (CUI.rte.Utils.isArray(obj)) {
          return obj;
        }
        if (typeof(obj) === 'object') {
          var array = [];
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              if (!keyName || !valueName) {
                array.push(obj[key]);
              } else {
                var value = obj[key];
                if (!!value && (value.constructor === Object)) {
                  array.push(obj[key]);
                } else {
                  var convObj = {};
                  convObj[keyName] = key;
                  convObj[valueName] = value;
                  array.push(convObj);
                }
              }
            }
          }
          return array;
        }
        return [obj];
      },

      /**
       * Check if the given string starts with the given partial string.
       * @param {String} str String to check
       * @param {String} partialStr partial String
       * @return {Boolean} True, if str starts with partialStr, else false
       */
      strStartsWith: function (str, partialStr) {
        if (!str || !partialStr) {
          return false;
        }
        var pLen = partialStr.length;
        if (str.length >= pLen) {
          return (str.substring(0, pLen) === partialStr);
        }
        return false;
      },

      /**
       * Check if the given string ends with the given partial string.
       * @param {String} str String to check
       * @param {String} partialStr partial String
       * @return {Boolean} True, if str ends with partialStr, else false
       */
      strEndsWith: function (str, partialStr) {
        if (!str || !partialStr) {
          return false;
        }
        var sLen = str.length;
        var pLen = partialStr.length;
        if (sLen >= pLen) {
          return (str.substring(sLen - pLen, sLen) === partialStr);
        }
        return false;
      },

      /**
       * Executes a simple String replacement.
       * @param {String} text The source text
       * @param {Number} startPos The first character to be replaced
       * @param {Number} endPosIncl The last character (inclusive) to be replaced
       * @param {String} replacement The replacement
       * @return {String} The result of the replacement
       */
      strReplace: function (text, startPos, endPosIncl, replacement) {
        var preStr = '';
        if (startPos > 0) {
          preStr = text.substring(0, startPos);
        }
        var postStr = '';
        if ((endPosIncl + 1) < text.length) {
          postStr = text.substring(endPosIncl + 1, text.length);
        }
        return preStr + replacement + postStr;
      },

      /**
       * Create an index path for the given DOM node.
       * <p>
       * An index path consists of the respective child positions up to the body node.
       * The index path may be used to determine if a node is "before" or "behind"
       * another node.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Node} node DOM node for which the index path has to be created
       * @return {Array} index path for the given node
       */
      createIndexPath: function (context, node) {
        var parentNode = CUI.rte.Common.getParentNode(context, node);
        if (!parentNode) {
          return [];
        }
        var sortIndex = CUI.rte.Common.getChildIndex(node);
        var sortIndices = CUI.rte.Common.createIndexPath(context, parentNode);
        sortIndices.push(sortIndex);
        return sortIndices;
      },

      /**
       * Get the element at the indexPath relative to passed node.
       * @param {Node} node node relative to which index path is to be considered
       * @param {Array} indexPath index path
       * @return {Node} node at relative index path
       */
      getElementByIndexPath: function (node, indexPath) {
        if (node.childNodes.length === 0) {
          return null;
        }
        var child = node;
        for (var index = 0; index < indexPath.length && child.childNodes.length > 0; index++) {
          child = child.childNodes[indexPath[index]];
        }
        return child;
      },

      /**
       * Compare two index paths.
       * <p>
       * An index path consists of the respective child positions up to the body node.
       * The index path may be used to determine if a node is "before" or "behind"
       * another node.
       * @param {Array} index1 first index path
       * @param {Array} index2 second index path
       * @return {Number} 0 if both index paths are the same;
       *         1 if <code>index1</code> is "before" <code>index2</code>;
       *         -1 if <code>index1</code> is "behind" <code>index2</code>
       */
      compareIndexPaths: function (index1, index2) {
        var i1Cnt = index1.length;
        var i2Cnt = index2.length;
        var index = 0;
        while (true) {
          if (index >= i1Cnt) {
            if (index >= i2Cnt) {
              // same node
              return 0;
            }
            // 1 is parent of 2
            return 1;
          }
          if (index >= i2Cnt) {
            // 2 is parent of 1
            return -1;
          }
          if (index1[index] < index2[index]) {
            return 1;
          }
          if (index1[index] > index2[index]) {
            return -1;
          }
          index++;
        }
      },

      /**
       * Blocks execution of JavaScript for the given amount of time and, if specified,
       * under the given condition.
       * @param {Number} ms Time to block JavaScript execution thread in milliseconds
       * @param {Boolean} cond (optional) A condition that has to be true for the block
       *        to be executed
       */
      block: function (ms, cond) {
        if ((typeof cond === 'undefined') || cond) {
          var endTime = new Date().getTime() + ms;
          while (true) {
            if (new Date().getTime() >= endTime) {
              break;
            }
          }
        }
      },

      /**
       * Gets the "outer html" of the specified DOM node (= the HTML code that represents
       * the specified node and all of its child nodes, recursively).
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The HTML element to get the outer HTML for
       */
      getOuterHTML: function (context, dom) {
        var com = CUI.rte.Common;
        if (com.ua.isIE) {
          return dom.outerHTML;
        }
        var fakeSpan = context.createElement('span');
        fakeSpan.appendChild(dom.cloneNode(true));
        return fakeSpan.innerHTML;
      },

      /**
       * Determines if the application is run in Portrait mode.
       * @return {Boolean} True if the application is run in Portrait mode
       */
      isPortrait: function () {
        return (window.innerHeight > window.innerWidth);
      },

      /**
       * Returns the height of a screen keyboard which might optionally be available.
       * @returns {Number} The height of a potentially available screen keyboard; 0 if
       *          there is definitely no screen keyboard available (if we're on desktop)
       */
      getScreenKeyboardHeight: function () {
        var com = CUI.rte.Common;
        return (com.isPortrait() ? com.ua.screenKeyHeightPortrait
          : com.ua.screenKeyHeightLandscape);
      },

      /**
       * Dump the given DOM node.
       * @param {Node} node DOM node to dump
       * @param {String} prefix text prefix (optional)
       * @param {String} suffix text suffix (optional)
       */
      dumpNode: function (node, prefix, suffix) {
        var text = (prefix ? prefix : '');
        if (node) {
          var childNo = CUI.rte.Common.getChildIndex(node);
          if (node.nodeType === 1) {
            text += node.tagName;
          } else if (node.nodeType === 3) {
            text += '\"' + node.nodeValue + '\"';
          } else if (node.nodeType === 8) {
            text += '(comment) ' + node.nodeValue;
          } else {
            text += '(nodeType #' + node.nodeType + ')';
          }
          text += ' (parentNode.childNodes[' + childNo + '])';
        } else {
          text += '[No node]';
        }
        if (suffix) {
          text += suffix;
        }
        return text;
      },

      /**
       * Dump the given DOM node recursively.
       * @param {Node} node DOM node to dump
       * @param {Number} indent indent (spaces) of the current recursion (optional)
       */
      dumpNodeRecursively: function (node, indent) {
        if (!indent) {
          indent = 0;
        }
        var text = '';
        for (var indentIndex = 0; indentIndex < indent; indentIndex++) {
          text += '   ';
        }
        text += CUI.rte.Common.dumpNode(node) + '\n';
        if (node && (node.nodeType === 1)) {
          var childCnt = node.childNodes.length;
          for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            text += CUI.rte.Common.dumpNodeRecursively(
              node.childNodes[childIndex], indent + 1);
          }
        }
        return text;
      },

      /**
       * Dump the specified JavaScript object recursively.
       * @param {Object} obj Object to dump
       * @param {Number} indent indent (spaces) of the current recursion (optional)
       * @param {Boolean} dumpDomRecursively True if DOM nodes that are
       *        contained in the object hierarchy should be dumped recursively
       */
      dumpObject: function (obj, indent, dumpDomRecursively) {
        var com = CUI.rte.Common;
        var dump = '';
        if (!indent) {
          indent = 0;
        }
        var indentStr = '';
        for (var indentPos = 0; indentPos < indent; indentPos++) {
          indentStr += ' ';
        }
        if (!obj) {
          return indentStr + '---';
        }
        if (obj.hasOwnProperty) {
          for (var name in obj) {
            if (obj.hasOwnProperty(name)) {
              var value = obj[name];
              dump += indentStr + name + ':';
              if ((value === null) || (value === undefined)) {
                dump += ' [undefined]\n';
              } else if (typeof(value) === 'object') {
                if (value.nodeType && (value.tagName || value.nodeValue)) {
                  if (dumpDomRecursively) {
                    dump += '\n' + com.dumpNodeRecursively(value,
                        indent + 2);
                  } else {
                    dump += com.dumpNode(value) + '\n';
                  }
                } else {
                  dump += '\n' + com.dumpObject(value,
                      indent + 2);
                }
              } else {
                dump += ' ' + value + '\n';
              }
            }
          }
        } else {
          if (obj.nodeType) {
            if (dumpDomRecursively) {
              dump += com.dumpNodeRecursively(obj, indent);
            } else {
              dump += indentStr + com.dumpNode(obj) + '\n';
            }
          } else {
            dump += indentStr + '[native object]\n';
          }
        }
        return dump;
      },

      /**
       * Provides simple logging facilities for IE, which requires a DOM element with
       * id === "debug" to be present. If no such DOM element is found, the logging
       * request is simply ignored.
       * @param {String} msg The message to be logged
       * @param {Boolean} enforceDebuggingDiv True if the debugging DIV should be enforced
       */
      ieLog: function (msg, enforceDebuggingDiv) {
        if (!isLogEnabled) {
          return;
        }
        var div = document.getElementById('cuiRTEdebug');
        if (!div && enforceDebuggingDiv) {
          var doc = window.document;
          var width = doc.body.clientWidth - 310;
          div = doc.createElement('div');
          div.id = 'cuiRTEdebug';
          div.style.width = '300px';
          div.style.height = '300px';
          div.style.position = 'absolute';
          div.style.top = '10px';
          div.style.left = width + 'px';
          div.style.zIndex = 10000;
          div.style.overflowY = 'scroll';
          div.style.border = '1px solid';
          div.style.fontFamily = 'sans-serif';
          div.style.fontSize = '12px';
          div.style.backgroundColor = '#ffffff';
          doc.body.appendChild(div);
        }
        if (div) {
          if (!msg) {
            msg = '';
          }
          msg = CUI.rte.Utils.htmlEncode(msg);
          var addBr = true;
          if ((msg.length > 0) && (msg.charAt(msg.length - 1) === '\n')) {
            addBr = false;
          }
          msg = msg.replace(/\n/g, '<br>');
          msg = msg.replace(/ /g, '&nbsp;');
          div.innerHTML = div.innerHTML + msg + (addBr ? '<br>' : '');
        }
      },

      /**
       * Enables or disables the logging facilities provided by {@link #ieLog}.
       * @param {Boolean} isEnabled True to enable logging through {@link #ieLog}
       */
      setLogEnabled: function (isEnabled) {
        isLogEnabled = isEnabled;
        if (isLogEnabled) {
          CUI.rte.Common.ieLog(null, true);
        }
      },

      /**
       * Array that contains the tag name of nodes that are treated as one character
       * when counting characters
       * @type String[]
       * @static
       * @final
       */
      ONE_CHARACTER_NODES: [
        {
          'tagName': 'a',
          'attribsDefined': ['name'],
          'attribsUndefined': ['href']
        }, {
          'tagName': 'img'
        }, {
          'tagName': 'br'
        }
      ],

      /**
       * List of actual block tags
       * @type String[]
       */
      BLOCK_TAGS: [
        'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div', 'ol', 'ul', 'pre', 'table',
        'address', 'blockquote', 'center', 'dl', 'fieldset', 'form', 'hr', 'marquee',
        'noscript', 'script'
      ],

      /**
       * List of edit fragment tags - editing fragments are DOM structures that are
       * considered to be edited as some kind of a block. The most important difference
       * to the average structure is that their end is counted as an extra space in
       * functions that map node/offset to a character position
       * @type String[]
       */
      EDITBLOCK_TAGS: [
        'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div', 'li', 'pre', 'td', 'th',
        'address', 'blockquote', 'center', 'caption'
      ],

      /**
       * List of edit fragment tags that may be nested
       * @type String[]
       */
      EDITBLOCK_NESTED_TAGS: [
        'td', 'th'
      ],

      /**
       * List of edit fragment tags that may be nested and if so, are nested irregularily.
       * This is currently the case for list items only.
       * @type String[]
       */
      EDITBLOCK_UNREGNEST_TAGS: [
        'li'
      ],

      /**
       * Prefix for RTE-specific attributes
       */
      RTE_ATTRIB_PREFIX: '_rte',

      /**
       * Helper attribute for providing "stable" HREF support - the HREF of a link is
       * stored both in the href attribute (which may be changed by browser deliberately)
       * and the attribute defined by this constant (which is supposed to not being
       * touched by the browser)
       */
      HREF_ATTRIB: '_rte_href',

      /**
       * Helper attribute for providing "stable" SRC support - the SRC of an image is
       * stored both in the href attribute (which may be changed by browser deliberately)
       * and the attribute defined by this constant (which is supposed to not being
       * touched by the browser)
       */
      SRC_ATTRIB: '_rte_src',

      /**
       * Helper attribute for determining helper line breaks used for working around
       * Webkit and Gecko issues
       */
      BR_TEMP_ATTRIB: '_rte_temp_br',

      /**
       * Helper attribute for images that are used as placeholders for named anchors
       */
      A_NAME_REPLACEMENT_ATTRIB: '_rte_a_name_repl',

      /**
       * Helper attributes for images that are used as placeholders for anchors with id {HTML5 compliant anchors}
       * See CUI-5923 for further information
       */

       A_ID_REPLACEMENT_ATTRIB: '_rte_a_id_repl',

      /**
       * Attribute for elements that are only used temporarily
       */
      TEMP_EL_ATTRIB: '_rte_temp_el',

      /**
       * Attribute value ({@see #TEMP_EL_ATTRIB} for a temporary element that should be
       * removed "immediately" after a selection changes
       */
      TEMP_EL_IMMEDIATE_REMOVAL: 'immediate',

      /**
       * Attribute value ({@see #TEMP_EL_ATTRIB} for a temporary element that should be
       * removed when the DOM gets serialized
       */
      TEMP_EL_REMOVE_ON_SERIALIZE: 'serialize',

      /**
       * Array of tags that are defining a table cell
       * @type String[]
       * @private
       */
      TABLE_CELLS: ['td', 'th'],

      /**
       * Array of tags that are defining lists
       * @type String[]
       * @private
       */
      LIST_TAGS: ['ul', 'ol'],

      /**
       * Table of attribute names that have to be translated for IE to work correctly
       */
      IE_ATTRIB_NAMES: {
        'cellpadding': 'cellPadding',
        'cellspacing': 'cellSpacing',
        'valign': 'vAlign',
        'bgcolor': 'bgColor',
        'rowspan': 'rowSpan',
        'colspan': 'colSpan'
      },

      KEY_STROKES: {
        'ARROW_LEFT': 37,
        'ARROW_UP': 38,
        'ARROW_RIGHT': 39,
        'ARROW_DOWN': 40
      },

      /**
       * List of void elements which do not contain any content and are self-closing.
       * @type String[]
       */
      VOID_TAGS: [
        'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link',
        'menuitem', 'meta', 'param', 'source', 'track', 'wbr'
      ],

      /**
       * Attribute filter for temporary Gecko-stuff
       * @param {HTMLElement} dom The DOM element
       * @param {String} attribName Attribute name (browser-dependent)
       * @param {String} attribNameLC Lower case version of the attribute name
       */
      FILTER_GECKO_TEMPORARY_ATTRIBS: function (dom, attribName, attribNameLC) {
        var com = CUI.rte.Common;
        // exclude temporary Mozilla attributes (as far as currently known)
        return com.strStartsWith(attribNameLC, '_moz') ||
          (com.isTag(dom, 'br') && (attribNameLC === 'type'));
      }

    };

  }());
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.HtmlProcessor
 * @static
 * @private
 * <p>The RichText.HtmlProcessor provides the means to process HTML based on its String
 * representation. It contains an HTML parser + several helper methods.</p>
 * <p><b>Caution:</b> String-based processing is a performance bottleneck on IE &lt; 8, so
 * if you plan to process large chunks of HTML, you should better use DOM-based processing
 * instead.</p>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.HtmlProcessor = (function () {

    return {

      // Helpers -------------------------------------------------------------------------

      /**
       * Does a simple String replacement.
       * @param {String} text The source text
       * @param {Number} startPos The first character to be replaced
       * @param {Number} endPosIncl The last character (inclusive) to be replaced
       * @param {String} replacement The replacement
       * @return {String} The result of the replacement
       */
      replace: function (text, startPos, endPosIncl, replacement) {
        return CUI.rte.Common.strReplace(text, startPos, endPosIncl, replacement);
      },

      isBlockTag: function (tagName) {
        var tags = CUI.rte.Common.BLOCK_TAGS;
        var tagNameLC = tagName.toLowerCase();
        var tagCnt = tags.length;
        for (var tagIndex = 0; tagIndex < tagCnt; tagIndex++) {
          if (tags[tagIndex] === tagNameLC) {
            return true;
          }
        }
        return false;
      },

      /**
       * Skips whitespace in the given String (if applicable).
       * @param {String} str The String to be processed
       * @param {Number} pos Position from where to skip whitespaces
       * @return {Number} Position of next non-whitespace character; -1 if no more
       *         (non-whitespace) characters were found
       */
      skipWhitespace: function (str, pos) {
        while ((pos < str.length) && (str.charCodeAt(pos) <= 32)) {
          pos++;
        }
        if (pos >= str.length) {
          return -1;
        }
        return pos;
      },

      /**
       * Strips surrounding whitespace from the given string.
       * @param {String} text The String for which the whitespace should be stripped
       * @return {String} The String, without surrounding whitespace
       * @type String
       */
      stripSurroundingWhitespace: function (text, excludeSpace) {
        var spaceIndex = 0;
        var lastValidChar = (excludeSpace ? 31 : 32);
        while (spaceIndex < text.length) {
          if (text.charCodeAt(spaceIndex) > lastValidChar) {
            break;
          }
          spaceIndex++;
        }
        if (spaceIndex < text.length) {
          text = text.substring(spaceIndex, text.length);
        } else {
          text = '';
        }
        spaceIndex = text.length;
        while (spaceIndex > 0) {
          spaceIndex--;
          if (text.charCodeAt(spaceIndex) >= lastValidChar) {
            break;
          }
        }
        if (spaceIndex >= 0) {
          text = text.substring(0, spaceIndex + 1);
        } else {
          text = '';
        }
        return text;
      },

      /**
       * Removes trailing characters.
       * @param {String} text The text to remove trailing characters from
       * @param {String} chars The characters to be removed
       * @return {String} The processed text
       */
      removeTrailingChars: function (text, chars) {
        var pos = text.length - 1;
        while (pos > 0) {
          if (chars.indexOf(text.charAt(pos)) < 0) {
            return text.substring(0, pos + 1);
          }
          pos--;
        }
        return '';
      },


      // Parsing -------------------------------------------------------------------------

      /**
       * <p>Parses the String representation of a tag into an object representation that
       * is much easier to process.</p>
       * <p>The object representation has the following properties:</p>
       * <ul>
       *   <li><code>tagName</code> : String<br>
       *     The name of the tag (lower case)</li>
       *   <li><code>attributes</code> : Object<br>
       *     A table representing the attributes of the tag; each object has the following
       *     properties:
       *     <ul>
       *       <li><code>name</code> : String<br>
       *         The name of the attribute (lower case).</li>
       *       <li><code>value</code> : String<br>
       *         The value of the attribute</li>
       *       <li><code>quoted</code> : Boolean<br>
       *         True if the attribute value is surrounded by quotation marks (IE loves to
       *         not quote simple attribute values)</li>
       *       <li><code>pos</code> : Number<br>
       *         The position where the attribute starts (relative to <code>tagStr</code>)
       *         </li>
       *       <li><code>cnt</code> : Number<br>
       *         Number of characters the attribute takes</li>
       *     </ul>
       *   </li>
       *   <li><code>isShortTag</code> : Boolean<br>
       *     True if the tag is a "short tag", i.e. &lt;br /&gt;</li>
       * </ul>
       * @param {String} tagStr The String, representing the tag (for example: &lt;a
       *        href="/path/to/page"&gt;)
       * @return {Object} An object representation of the tag String
       */
      parseTag: function (tagStr) {
        var hpr = CUI.rte.HtmlProcessor;
        // some preparations ...
        tagStr = tagStr.replace(/\r\n/g, ' ');
        tagStr = tagStr.replace(/[\r\n\t]/g, ' ');
        var tagDef = {
          tagName: null,
          attributes: {}
        };
        if (tagStr.length < 3) {
          return tagDef;
        }
        // parse tag
        var firstChar = hpr.skipWhitespace(tagStr, 0);
        if (firstChar < 0) {
          return tagDef;
        }
        if (tagStr.charAt(firstChar) !== '<') {
          return tagDef;
        }
        var closingBrace = tagStr.lastIndexOf('>');
        if (closingBrace <= firstChar) {
          return tagDef;
        }
        if (closingBrace > 0) {
          // exclude "/" of tag shortform (<br/>) from parsing if necessary
          if (tagStr.charAt(closingBrace - 1) === '/') {
            closingBrace--;
            tagDef.isShortTag = true;
          }
        }
        var tagEnd = tagStr.indexOf(' ', firstChar);
        if (tagEnd < 0) {
          // tag only, no attributes
          tagDef.tagName =
            tagStr.substring(firstChar + 1, closingBrace).toLowerCase();
          return tagDef;
        }
        tagDef.tagName = tagStr.substring(firstChar + 1, tagEnd).toLowerCase();
        // handle attributes
        var processPos = tagEnd;
        while (true) {
          if (processPos >= closingBrace) {
            return tagDef;
          }
          processPos = hpr.skipWhitespace(tagStr, processPos);
          if (processPos < 0) {
            return tagDef;
          }
          var attribSepPos = tagStr.indexOf('=', processPos);
          // IE issue: ismap="ismap" gets reduced to ismap
          var shortAttrib = null;
          var spaceSepPos = tagStr.indexOf(' ', processPos);
          if ((spaceSepPos >= 0) &&
            ((spaceSepPos < attribSepPos) || attribSepPos < 0)) {
            // consider superfluous whitespace (width = "200")
            var endSpacePos = hpr.skipWhitespace(tagStr, spaceSepPos);
            if (endSpacePos !== attribSepPos) {
              shortAttrib = tagStr.substring(processPos, spaceSepPos);
              processPos = endSpacePos;
            }
          } else if (attribSepPos < 0) {
            // handle short attrib at end of tag (<img src="..." ismap>)
            if (processPos < (tagStr.length - 1)) {
              shortAttrib = tagStr.substring(processPos, tagStr.length);
              // remove closing ">" and superflous whitespace
              shortAttrib = hpr.removeTrailingChars(shortAttrib, ' >');
            }
            processPos = tagStr.length;
          }
          var attributeName;
          if (shortAttrib !== null && shortAttrib !== undefined) {
            attributeName = shortAttrib.toLowerCase();
            tagDef.attributes[attributeName] = {
              'name': attributeName,
              'originalName': shortAttrib,
              'shortAttrib': true,
              'quoted': false
            };
          } else {
            if (attribSepPos < 0) {
              return tagDef;
            }
            var originalAttributeName = tagStr.substring(processPos, attribSepPos);
            originalAttributeName = hpr.removeTrailingChars(originalAttributeName,
              ' ');
            attributeName = originalAttributeName.toLowerCase();
            attribSepPos = hpr.skipWhitespace(tagStr, attribSepPos + 1);
            var spacePos = tagStr.indexOf(' ', attribSepPos);
            var quotChar = '\"';
            var quotPos = tagStr.indexOf('\"', attribSepPos);
            var aposPos = tagStr.indexOf('\'', attribSepPos);
            var attributeValue;
            var valueStartIndex = -1;
            var valueCharCnt = -1;
            var isQuotedValue = true;
            if (quotPos > closingBrace) {
              quotPos = -1;
            }
            if (aposPos > closingBrace) {
              aposPos = -1;
            }
            if (spacePos > closingBrace) {
              spacePos = -1;
            }
            // "browsers do such things", chapter 12789: IE uses ' if attribute values
            // contain "
            if (aposPos >= 0) {
              if ((aposPos < quotPos) || (quotPos < 0)) {
                quotPos = aposPos;
                quotChar = '\'';
              }
            }
            if ((quotPos >= 0) && ((quotPos < spacePos) || (spacePos < 0))) {
              var endQuotPos = tagStr.indexOf(quotChar, quotPos + 1);
              if (endQuotPos < 0) {
                // error - return what has already been parsed
                return tagDef;
              }
              attributeValue = tagStr.substring(quotPos + 1, endQuotPos);
              valueStartIndex = quotPos + 1;
              valueCharCnt = (endQuotPos - (quotPos + 1));
              processPos = endQuotPos + 1;
            } else {
              var lastCharPos = (spacePos >= 0 ? spacePos : closingBrace);
              // attribute value without quotation marks - IE likes to do such
              // things
              attributeValue = tagStr.substring(attribSepPos, lastCharPos);
              isQuotedValue = false;
              valueStartIndex = attribSepPos;
              valueCharCnt = (lastCharPos - attribSepPos);
              processPos = lastCharPos + 1;
            }
            tagDef.attributes[attributeName] = {
              'name': attributeName,
              'originalName': originalAttributeName,
              'value': attributeValue,
              'pos': valueStartIndex,
              'cnt': valueCharCnt,
              'shortAttrib': false,
              'quoted': isQuotedValue
            };
          }
        }
      },

      /**
       * Parses the String representation of a CSS style definition into an object
       * representation that is much easier to process.
       * @param {String} styleStr The style definition to parse (for example: font-family:
       *                          Arial; font-weight: bold)
       * @return {Object} A table that contains the parsed style definition (for example:
       *         <code>{ "font-family": "Arial", "font-weight:", "bold" }</code>)
       * @type Object
       */
      parseStyleDef: function (styleStr) {
        styleStr = CUI.rte.Utils.htmlDecode(styleStr);
        var processPos = 0;
        var styleDef = {};
        while (true) {
          processPos =
            CUI.rte.HtmlProcessor.skipWhitespace(styleStr, processPos);
          if (processPos < 0) {
            return styleDef;
          }
          var sepPos = styleStr.indexOf(':', processPos + 1);
          var styleName = styleStr.substring(processPos, sepPos);
          styleName = CUI.rte.HtmlProcessor
            .stripSurroundingWhitespace(styleName);
          if (styleName.length === 0) {
            return styleDef;
          }
          var defEndPos = styleStr.indexOf(';', sepPos + 1);
          if (defEndPos < 0) {
            defEndPos = styleStr.length;
          }
          var styleCode = styleStr.substring(sepPos + 1, defEndPos);
          styleCode = CUI.rte.HtmlProcessor
            .stripSurroundingWhitespace(styleCode);
          // IE < 9 will report uppercase style names; hence normalize to lowercase
          styleDef[styleName.toLowerCase()] = styleCode;
          processPos = defEndPos + 1;
        }
      },

      /**
       * <p>Creates a suitable string for a style attribute from the given style
       * definition (like created by {@link #parseStyleDef}).</p>
       * @param {Object} styleDef The style definition
       * @return {String} The style attribute; undefined if no styles were defined
       */
      createStyleAttrib: function (styleDef) {
        var styleStr = '';
        for (var name in styleDef) {
          if (styleDef.hasOwnProperty(name)) {
            var value = styleDef[name];
            if (styleStr.length > 0) {
              styleStr += ' ';
            }
            styleStr += name + ': ' + value + ';';
          }
        }
        return (styleStr.length > 0 ? styleStr : undefined);
      },

      /**
       * <p>Handles the callback for HTML text for <code>parseHtml()</code>.</p>
       * @private
       * @param {String} htmlStr HTML string that is currently being parsed
       * @param {Object} callback callback object
       * @param {Number} startPos position of first character
       * @param {Number} endPos position of last character (exclusive)
       * @return {Object} object containing a <code>html</code> property that contains the
       *         replaced text and a <code>delta</code> property that contains the
       *         positioning delta
       */
      handleHtmlText: function (htmlStr, callback, startPos, endPos) {
        var noReplacementRet = {
          'html': htmlStr,
          'delta': 0
        };
        if (!callback.onHtmlText) {
          return noReplacementRet;
        }
        if (endPos <= startPos) {
          return noReplacementRet;
        }
        var text = htmlStr.substring(startPos, endPos);
        var replaceStr = callback.onHtmlText(text);
        if (replaceStr === null || replaceStr === undefined) {
          return noReplacementRet;
        }
        var delta = replaceStr.length - (endPos - startPos);
        htmlStr = CUI.rte.HtmlProcessor.replace(
          htmlStr, startPos, endPos - 1, replaceStr);
        return {
          'html': htmlStr,
          'delta': delta
        };
      },

      /**
       * <p>Gets the most probable end position of the specified processing tag.</p>
       * <p>Currently handled:</p>
       * <ul>
       *   <li>&lt;-- ... --&gt;</li>
       *   <li>&lt;? ... ?&gt;</li>
       *   <li>&lt;<! ... >&gt;<li>
       * </ul>
       * @private
       * @param {String} htmlStr
       * @param {Number} dataPos
       */
      getProcessingTagEndPos: function (htmlStr, dataPos) {
        var strLen = htmlStr.length;
        var charAtPos = htmlStr.charAt(dataPos);
        if (charAtPos === '!') {
          if (strLen > dataPos + 3) {
            if (htmlStr.substring(dataPos, dataPos + 3) === '!--') {
              return htmlStr.indexOf('-->', dataPos + 3) + 2;
            }
          }
          return htmlStr.indexOf('>', dataPos + 1);
        }
        return htmlStr.indexOf('>', dataPos);
      },

      /**
       * <p>Parses the tags of a HTML string generically.</p>
       * <p>The caller should define a callback object with the following methods (each
       * is optional and only called if present):</p>
       * <ul>
       *   <li><code>htmlStart</code> : Function<br>
       *     This method is called before the first tag is parsed.</li>
       *   <li><code>htmlEnd</code> : Function<br>
       *     This method is called after the last tag has been parsed.</li>
       *   <li><code>onTagStart</code> : Function<br>
       *     This method is called on an opening tag. It takes the following parameters:
       *     <ol>
       *       <li><code>tagName</code> : String<br>
       *         The name of the tag.</li>
       *       <li><code>attributes</code> : Object<br>
       *         Information of the attributes as key/value pairs. Each value consists of
       *         the following properties:
       *         <ul>
       *           <li><code>name</code> : String<br>
       *             The name of the attribute (lower case).</li>
       *           <li><code>value</code> : String<br>
       *             The value of the attribute</li>
       *           <li><code>quoted</code> : Boolean<br>
       *             True if the attribute value is surrounded by quotation marks (IE
       *             loves to not quote simple attribute values)</li>
       *           <li><code>pos</code> : Number<br>
       *             The position where the attribute starts (relative to
       *             <code>tagStr</code>)</li>
       *           <li><code>cnt</code> : Number<br>
       *             Number of characters the attribute takes</li>
       *         </ul>
       *       </li>
       *       <li><code>isShortTag</code> : Boolean<br>
       *         True if the tag is a "short tag", that means it already includes the
       *         closing tag (i.e. &lt;br /&gt;). Note that the corresponding
       *         {@link #onTagEnd} method will be called for each tag, including short
       *         tags.</li>
       *       <li><code>startPos</code> : Number<br>
       *         Position (relative to the entire HTML to parse) of the first character (a
       *         '&lt;') of the tag.</li>
       *       <li><code>tagLen</code> : Number<br>
       *         Number of characters the tag is actually consisting of (from '&lt;' to
       *         '&gt;', as it is formatted in the HTML to parse)</li>
       *     </ol>
       *   </li>
       *   <li><code>onTagEnd</code> : Function<br>
       *     This method is called on a closing tag. It takes the following parameters:
       *     <ol>
       *       <li><code>tagName</code> : String<br>
       *         The name of the tag.</li>
       *       <li><code>isShortTag</code> : Boolean<br>
       *         True if the tag is a "short tag", that means it already includes the
       *         closing tag (i.e. &lt;br /&gt;). Note that the corresponding
       *         {@link #onTagEnd} method will be called for each tag, including short
       *         tags.</li>
       *       <li><code>startPos</code> : Number<br>
       *         Position (relative to the entire HTML to parse) of the first character (a
       *         '&lt;') of the tag.</li>
       *       <li><code>tagLen</code> : Number<br>
       *         Number of characters the tag is actually consisting of (from '&lt;' to
       *         '&gt;', as it is formatted in the HTML to parse)</li>
       *     </ol>
       *   </li>
       *   <li><code>onProcessingTag</code> : Function<br>
       *     This method is called on "processing tags" (like &lt;? ... ?&gt;, &lt;!--
       *     &gt;, ...). It takes the entire processing tag as its only parameter.</li>
       *   <li><code>onHtmlText</code> : Function<br>
       *     This method is called for HTML text. It takes the text as its only parameter.
       *     </li>
       * </ul>
       * <p>Note that all tag- and attribute names are lowercase.</p>
       * @param {String} htmlStr HTML string to parse
       * @param {Object} callback callback object which is called on opening and closing
       *                          tags (if <code>tagStart</code> resp. <code>tagEnd</code>
       *                          is specified)
       * @return {String} HTML after processing
       */
      parseHtml: function (htmlStr, callback) {
        var hpr = CUI.rte.HtmlProcessor;
        var processingPos = 0;
        var textPos = 0;
        var textHandlerResult;
        while ((processingPos >= 0) && (processingPos < htmlStr.length)) {
          var tagStartPos = htmlStr.indexOf('<', processingPos);
          if (tagStartPos >= 0) {
            var dataPos = hpr.skipWhitespace(htmlStr, tagStartPos + 1);
            var firstCharOfTag = htmlStr.charAt(dataPos);

            var tagName, tagEndPos, replaceStr;
            if ((firstCharOfTag === '?') || (firstCharOfTag === '!')) {
              // "Processing tags" (<!DOCTYPE >, <!-- -->, <? ?>)
              processingPos = hpr.getProcessingTagEndPos(htmlStr, dataPos);
              if (processingPos > 0) {
                textHandlerResult = hpr.handleHtmlText(htmlStr, callback,
                  textPos, tagStartPos);
                htmlStr = textHandlerResult.html;
                tagStartPos += textHandlerResult.delta;
                dataPos += textHandlerResult.delta;
                processingPos += textHandlerResult.delta;
                if (callback.onProcessingTag) {
                  var pTag =
                    htmlStr.substring(tagStartPos, processingPos + 1);
                  replaceStr = callback.onProcessingTag(pTag);
                  if (replaceStr !== null && replaceStr !== undefined) {
                    htmlStr = hpr.replace(htmlStr,
                      tagStartPos, processingPos, replaceStr);
                    processingPos += replaceStr.length - pTag.length + 1;
                  }
                } else {
                  processingPos++;
                }
                textPos = processingPos;
              }

            } else if (firstCharOfTag === '/') {

              // closing tags
              tagEndPos = htmlStr.indexOf('>', dataPos + 1);
              if (tagEndPos > 0) {
                textHandlerResult = hpr.handleHtmlText(htmlStr, callback,
                  textPos, tagStartPos);
                htmlStr = textHandlerResult.html;
                tagStartPos += textHandlerResult.delta;
                dataPos += textHandlerResult.delta;
                tagEndPos += textHandlerResult.delta;
                tagName = htmlStr.substring(dataPos + 1, tagEndPos);
                tagName = hpr.stripSurroundingWhitespace(tagName);
                if (callback.onTagEnd) {
                  var endTagLen = tagEndPos - tagStartPos + 1;
                  replaceStr = callback.onTagEnd(tagName.toLowerCase(), false,
                    tagStartPos, endTagLen);
                  if (replaceStr !== null && replaceStr !== undefined) {
                    htmlStr = hpr.replace(
                      htmlStr, tagStartPos, tagEndPos, replaceStr);
                    tagEndPos += replaceStr.length - endTagLen;
                  }
                }
              } else {
                tagEndPos = dataPos;
              }
              processingPos = tagEndPos + 1;
              textPos = processingPos;

            } else {

              // opening tags
              tagEndPos = htmlStr.indexOf('>', tagStartPos);
              if (tagEndPos > 0) {
                var includesClosingTag = false;
                if (htmlStr.charAt(tagEndPos - 1) === '/') {
                  includesClosingTag = true;
                }
                textHandlerResult = hpr.handleHtmlText(htmlStr, callback,
                  textPos, tagStartPos);
                htmlStr = textHandlerResult.html;
                tagStartPos += textHandlerResult.delta;
                dataPos += textHandlerResult.delta;
                tagEndPos += textHandlerResult.delta;
                var tag = htmlStr.substring(tagStartPos, tagEndPos + 1);
                var tagDef = hpr.parseTag(tag);
                tagName = tagDef.tagName;
                if (tagName && callback.onTagStart) {
                  replaceStr = callback.onTagStart(tagName, tagDef.attributes,
                    includesClosingTag, tagStartPos, tag.length,
                    tagStartPos, tag.length);
                  if (replaceStr !== null && replaceStr !== undefined) {
                    htmlStr = hpr.replace(
                      htmlStr, tagStartPos, tagEndPos, replaceStr);
                    tagEndPos += replaceStr.length - tag.length;
                  }
                }
                if (tagName && includesClosingTag && callback.onTagEnd) {
                  replaceStr = callback.onTagEnd(tagName, includesClosingTag,
                    tagStartPos, tag.length);
                  if (replaceStr !== null && replaceStr !== undefined) {
                    htmlStr = hpr.replace(
                      htmlStr, tagEndPos + 1, tagEndPos, replaceStr);
                    tagEndPos += replaceStr.length;
                  }
                }
              } else {
                tagEndPos = dataPos;
              }
              processingPos = tagEndPos + 1;
              textPos = processingPos;

            }
          } else {
            textHandlerResult = hpr.handleHtmlText(htmlStr, callback, processingPos,
              htmlStr.length);
            htmlStr = textHandlerResult.html;
            processingPos = -1;
          }
        }
        return htmlStr;
      },

      /**
       * Checks if the given attribute definitions equal each other.
       * <p>
       * Both attribute definitions must be in the format that is created by
       * <code>CUI.rte.HtmlProcessor.parseTag()</code>.
       * @param {Object} attribs attribute set
       * @param {Object} cmpAttribs attribute set to compare
       * @return {Boolean} True if the given attribute definitions equal each other
       */
      hasEqualAttributes: function (attribs, cmpAttribs) {
        var attribCnt = 0;
        for (var attribToCheck in attribs) {
          if (attribs.hasOwnProperty(attribToCheck)) {
            if (!cmpAttribs.hasOwnProperty(attribToCheck)) {
              return false;
            }
            if (attribs[attribToCheck].value !== cmpAttribs[attribToCheck].value) {
              return false;
            }
            attribCnt++;
          }
        }
        for (attribToCheck in cmpAttribs) {
          if (cmpAttribs.hasOwnProperty(attribToCheck)) {
            attribCnt--;
            if (attribCnt < 0) {
              return false;
            }
          }
        }
        return (attribCnt === 0);
      },


      // Processing helpers --------------------------------------------------------------

      /**
       * Parses a style-related tag (resp. its style attribute) and creates simple
       * tag replacements that work with the browser's components.
       * @param {String} tagStr The tag string to parse; for example: &lt;span
       *                        style="font-weight:bold"&gt;
       * @return {Array} Array with tag replacements; for example: <code>[ "b" ]</code>
       * @deprecated
       */
      parseStyleTag: function (tagStr) {
        var tagReplacement = null;
        var tagDef = CUI.rte.HtmlProcessor.parseTag(tagStr);
        var styleDef = tagDef.attributes['style'];
        if (styleDef) {
          styleDef = styleDef.value;
          var styleDefs = CUI.rte.HtmlProcessor.parseStyleDef(styleDef);
          if (styleDefs['font-weight'] === 'bold') {
            if (!tagReplacement) {
              tagReplacement = [];
            }
            tagReplacement.push('b');
          }
          if (styleDefs['font-style'] === 'italic') {
            if (!tagReplacement) {
              tagReplacement = [];
            }
            tagReplacement.push('i');
          }
        }
        return tagReplacement;
      },


      // Processing ----------------------------------------------------------------------

      /**
       * Executes a simple tag replace.
       * <p>
       * Attributes can not be properly processed using this method. Use
       * <code>parseHtml()</code> instead.
       *
       * @deprecated use pre/post processing facilities instead
       *
       * @param {String} value The String where the given tag replacements will be applied
       *                      to
       * @param {Object} tagReplace The replacements to apply; key: tag to be replace (for
       *                            example: strong); value: replacing tag (for example:
       *                            b)
       */
      executeTagReplace: function (value, tagReplace) {
        if (tagReplace) {
          for (var srcTag in tagReplace) {
            if (tagReplace.hasOwnProperty(srcTag)) {
              var destTag = tagReplace[srcTag];
              if (srcTag && destTag) {
                var srcStartTag = '<' + srcTag + '>';
                var srcEndTag = '<\\/' + srcTag + '>';
                var destStartTag = '<' + destTag + '>';
                var destEndTag = '</' + destTag + '>';
                var expStart = new RegExp(srcStartTag, 'gi');
                var expEnd = new RegExp(srcEndTag, 'gi');
                value = value.replace(expStart, destStartTag);
                value = value.replace(expEnd, destEndTag);
              }
            }
          }
        }
        return value;
      },

      /**
       * @deprecated use generic parsing functionality if appropriate to avoid unnecessary
       * maintenance
       */
      executeStyleReplace: function (value) {
        var tag, tagEndPos, tagsToReplace, replaceText;
        var replacePos = 0;
        var spanEndTags = [];
        while (replacePos >= 0) {
          var valueLC = value.toLowerCase();
          tag = null;
          var closingTagPos = valueLC.indexOf('</span>', replacePos);
          var wholeTagPos = valueLC.indexOf('<span>', replacePos);
          replacePos = valueLC.indexOf('<span ', replacePos);
          if ((wholeTagPos >= 0) &&
            ((wholeTagPos < replacePos) || (replacePos < 0))) {
            replacePos = wholeTagPos;
          }
          while ((closingTagPos >= 0) &&
          ((closingTagPos < replacePos) || (replacePos < 0))) {
            tagsToReplace = spanEndTags.pop();
            var replaceCnt = tagsToReplace.length;
            if ((replaceCnt > 0) && (tagsToReplace[0] !== 'span')) {
              replaceText = '';
              for (var replaceIndex = replaceCnt - 1;
                   replaceIndex >= 0; replaceIndex--) {
                replaceText += '</' + tagsToReplace[replaceIndex] + '>';
              }
              value = CUI.rte.HtmlProcessor.replace(
                value, closingTagPos, closingTagPos + 6, replaceText);
              closingTagPos += replaceText.length;
              // correct replacePos by the difference between old and new
              // closing tag
              replacePos += replaceText.length - 7;
            } else {
              closingTagPos += 7;
            }
            valueLC = value.toLowerCase();
            closingTagPos = valueLC.indexOf('</span>', closingTagPos);
          }
          if (replacePos >= 0) {
            tagEndPos = valueLC.indexOf('>', replacePos);
            if (tagEndPos > replacePos) {
              tag = value.substring(replacePos, tagEndPos + 1);
            }
          }
          if (tag) {
            tagsToReplace = CUI.rte.HtmlProcessor.parseStyleTag(tag);
            if (tagsToReplace) {
              replaceText = '';
              var tagCnt = tagsToReplace.length;
              var closingTagInfo = [];
              for (var tagIndex = 0; tagIndex < tagCnt; tagIndex++) {
                var tagToReplace = tagsToReplace[tagIndex];
                closingTagInfo.push(tagToReplace);
                replaceText += '<' + tagToReplace + '>';
              }
              value = CUI.rte.HtmlProcessor.replace(
                value, replacePos, tagEndPos, replaceText);
              replacePos += replaceText.length;
              spanEndTags.push(closingTagInfo);
            } else {
              replacePos += tag.length;
              spanEndTags.push(['span']);
            }
          }
        }
        return value;
      },

      /**
       * <p>Internalizes links that were rewritten by the underlying browser component to
       * point to URLs that look valid to the browser.</p>
       * <p>Note that link internalizing might become obsolete if we used a different
       * DOM-to-HTML conversion method, as the attribs collection of each DOM element
       * should already contain the correct, relative link. Unfortunately, the innerHTML
       * method currently used for DOM-to-HTML conversion uses DOM attributes instead of
       * the attribs collection, hence requiring link internalizing.</p>
       * @param {String} value The String which contains the links to be internalized
       * @param {Object} linkInternalize definition of which tags are suitable for
       *        link internalization; property tag defines the tag (for example: img);
       *        property attribute defines the attribute that carries the link to
       *        be internalized (for example: src)
       * @return {String} The String with internalized links
       */
      executeInternalizeLinks: function (value, linkInternalize) {
        var valueLC = value.toLowerCase();
        var replacePos, tagEndPos;
        var tagCnt = linkInternalize.length;
        for (var tagIndex = 0; tagIndex < tagCnt; tagIndex++) {
          var tag = linkInternalize[tagIndex];
          var tagName = tag['tag'];
          var attribute = tag['attribute'];
          replacePos = 0;
          while ((replacePos >= 0) && (replacePos < value.length)) {
            replacePos = valueLC.indexOf('<' + tagName + ' ', replacePos);
            if (replacePos >= 0) {
              var tagStr = null;
              tagEndPos = valueLC.indexOf('>', replacePos + 1);
              if (tagEndPos > replacePos) {
                tagStr = value.substring(replacePos, tagEndPos + 1);
              }
              if (tagStr) {
                var tagDef = CUI.rte.HtmlProcessor.parseTag(tagStr);
                if (tagDef) {
                  var attribDef = tagDef.attributes[attribute];
                  if (attribDef && !attribDef.shortAttrib) {
                    var attribValue = attribDef.value;
                    var attribPos = attribDef.pos;
                    var attribCharCnt = attribDef.cnt;
                    var isQuoted = attribDef.quoted;
                    var url = CUI.rte.HtmlRules
                      .removePrefixForInternalLinks(attribValue,
                      CUI.rte.Utils.URL_LINK);
                    if (url !== attribValue) {
                      if (!isQuoted) {
                        url = '\"' + url + '\"';
                      }
                      value = CUI.rte.HtmlProcessor.replace(
                        value, replacePos + attribPos,
                        replacePos + attribPos + attribCharCnt - 1,
                        url);
                      valueLC = value.toLowerCase();
                      replacePos += tagStr.length +
                      (url.length - attribValue.length);
                    } else {
                      replacePos += tagStr.length;
                    }
                  } else {
                    replacePos += tagStr.length;
                  }
                } else {
                  replacePos += tagStr.length;
                }
              } else {
                replacePos += tagName.length + 2;
              }
            }
          }
        }
        return value;
      },

      /**
       * Creates HTML code for the specified tag definition.
       * @param {String} tagName Name of the tag
       * @param {Object} attribs Attribute definition as created by
       *        {@link CUI.rte.HtmlProcessor.parseHtml}
       * @param {Boolean} isClosingTag True if a closing tag should be created
       * @param {Boolean} isShortTag True if the tag is a "short tag" (for example
       *        &lt;br /&gt;)
       * @param {Boolean} normalizeTag True if the tag should be created in a "normalized"
       *        form (mostly, tag name and attribute names are put to lower case)
       * @return {String} HTML code for the specified tag definition
       */
      createTag: function (tagName, attribs, isClosingTag, isShortTag, normalizeTag) {
        if (isClosingTag && isShortTag) {
          return '';
        }
        var tag = '<';
        if (isClosingTag) {
          tag += '/';
        }
        tag += (normalizeTag ? tagName.toLowerCase() : tagName);
        if (attribs && !isClosingTag) {
          tag += CUI.rte.HtmlProcessor.createAttributes(attribs, normalizeTag);
        }
        if (isShortTag) {
          tag += ' /';
        }
        tag += '>';
        return tag;
      },

      /**
       * Creates HTML code for the specified attribute definition.
       * @param {Array} attribs
       * @param {Boolean} normalizeTag
       */
      createAttributes: function (attribs, normalizeTag) {
        var strRep = '';
        if (!attribs) {
          return strRep;
        }
        for (var attribName in attribs) {
          if (attribs.hasOwnProperty(attribName)) {
            if (attribName !== 'classname') {
              var attribDef = attribs[attribName];
              if (attribDef) {
                strRep += ' ' + (normalizeTag ? attribName.toLowerCase()
                  : attribName);
                if (attribDef.shortAttrib) {
                  if (normalizeTag) {
                    strRep += '=\"' + attribName.toLowerCase() + '\"';
                  }
                } else {
                  strRep += '=';
                  var value = attribDef.value;
                  var isQuoted = attribDef.quoted;
                  if (!isQuoted) {
                    isQuoted = (value.indexOf(' ') >= 0);
                  }
                  if (isQuoted || normalizeTag) {
                    strRep += '\"';
                  }
                  strRep += value;
                  if (isQuoted || normalizeTag) {
                    strRep += '\"';
                  }
                }
              }
            }
          }
        }
        return strRep;
      }

    };

  }());


  /**
   * @class CUI.rte.HtmlProcessor.StripTags
   * @private
   * This class implements a "Tag strip" processor, which removes all tags from a given
   * HTML fragment.
   */
  CUI.rte.HtmlProcessor.StripTags = new Class({

    toString: 'HtmlProcessor.StripTags',

    /**
     * Flag if content has to be ignored
     */
    ignoreContent: false,

    /**
     * Strips all tags from the given HTML-String.
     * @param {String} html HTML code
     * @return {String} the plain text code
     */
    strip: function (html) {
      return CUI.rte.HtmlProcessor.parseHtml(html, this);
    },

    /**
     * Handler for starting HTML tags.
     * @param {String} tagName Name of tag
     * @private
     */
    onTagStart: function (tagName) {
      if ((tagName === 'style') || (tagName === 'script')) {
        this.ignoreContent = true;
      }
      if (tagName === 'br') {
        return '\n';
      }
      return '';
    },

    /**
     * Handler for ending HTML tags.
     * @param {String} tagName Name of tag
     * @private
     */
    onTagEnd: function (tagName) {
      if ((tagName === 'style') || (tagName === 'script')) {
        this.ignoreContent = false;
      }
      if (tagName === 'tr') {
        return '\n';
      }
      if (tagName === 'p') {
        return '\n\n';
      }
      if (tagName.match(/h[1-6]/)) {
        return '\n\n';
      }
      if (tagName === 'li') {
        return '\n\n';
      }
      return '';
    },

    onHtmlText: function (text) {
      if (this.ignoreContent) {
        return '';
      }
      var noCrLfText = text.replace(/[\n\r]/g, ' ');
      return (noCrLfText !== text ? noCrLfText : null);
    },

    onProcessingTag: function (pTag) {
      return '';
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.DomProcessor
 * @static
 * @private
 * The DomProcessor provides utility functions to manipulate the DOM directly.
 */
(function (CUI) {
  'use strict';
  CUI.rte.DomProcessor = (function () {

    var com = CUI.rte.Common;

    return {

      getTagType: function (dom) {
        var dpr = CUI.rte.DomProcessor;
        var tagName = (dom instanceof String ? dom : dom.tagName).toLowerCase();
        var type = dpr.STRUCTURE;
        var typeTable = dpr.TYPE_TABLE;
        if (typeTable.hasOwnProperty(tagName)) {
          type = typeTable[tagName];
          if (typeof(type) !== 'string') {
            type = type.type;
          }
        }
        return type;
      },

      resolveTagType: function (dom) {
        var dpr = CUI.rte.DomProcessor;
        var tagName = (dom instanceof String ? dom : dom.tagName).toLowerCase();
        var type = dpr.STRUCTURE;
        var typeTable = dpr.TYPE_TABLE;
        if (typeTable.hasOwnProperty(tagName)) {
          type = typeTable[tagName];
          if (typeof(type) !== 'string') {
            if (type.type === dpr.DYNAMIC) {
              if (type.getDynamicType) {
                type = type.getDynamicType(dom);
              } else {
                type = dpr.STRUCTURE;
              }
            } else {
              type = type.type;
            }
          }
        }
        return type;
      },

      createNodeList: function (context, selection) {
        var nodeList = new CUI.rte.NodeList();
        if (selection.cellSelection && selection.cellSelection.cells) {
          nodeList.createFromDomNodes(context, selection.cellSelection.cells);
        } else {
          nodeList.createFromDocument(context, selection);
        }
        return nodeList;
      },

      getCommonAncestor: function (context, dom1, dom2) {
        if ((dom1 === null || dom1 === undefined) || (dom2 === null || dom2 === undefined)) {
          return null;
        }
        if (com.isAncestor(context, dom1, dom2)) {
          return dom1.parentNode;
        }
        if (com.isAncestor(context, dom2, dom1)) {
          return dom2.parentNode;
        }
        while (dom1) {
          var dom2Check = dom2;
          while (dom2Check) {
            if (dom2Check === dom1) {
              return dom1;
            }
            dom2Check = com.getParentNode(context, dom2Check);
          }
          dom1 = com.getParentNode(context, dom1);
        }
        return null;
      },

      /**
       * Splits the specified text node at the specified offset(s).
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} textNode The text node to be split
       * @param {Number|Number[]} splitPoints Offsets to split the node
       * @return {HTMLElement[]} Array containing all split nodes in correct order
       */
      splitTextNode: function (context, textNode, splitPoints) {
        if (textNode.nodeType !== 3) {
          throw new Error('splitTextNode() may only operate on text nodes.');
        }
        if (!CUI.rte.Utils.isArray(splitPoints)) {
          splitPoints = [splitPoints];
        }
        splitPoints.sort(function (c1, c2) {
          return c1 - c2;
        });
        var splitNodes = [];
        var startPos = 0;
        var textToSplit = textNode.nodeValue;
        var pointCnt = splitPoints.length;
        var parentNode = textNode.parentNode;
        var fragText, splitNode;
        for (var pointIndex = 0; pointIndex < pointCnt; pointIndex++) {
          var splitPos = splitPoints[pointIndex];
          fragText = textToSplit.substring(startPos, splitPos);
          splitNode = context.createTextNode(fragText);
          splitNodes.push(splitNode);
          parentNode.insertBefore(splitNode, textNode);
          startPos = splitPos;
        }
        fragText = textToSplit.substring(startPos, textToSplit.length);
        splitNode = context.createTextNode(fragText);
        splitNodes.push(splitNode);
        parentNode.insertBefore(splitNode, textNode);
        parentNode.removeChild(textNode);
        return splitNodes;
      },

      /**
       * <p>Creates a new DOM element with the specified attributes in a browser
       * independent way.</p>
       * <p>Note that you can use "class" or "className" for specifying the "class"
       * attribute and "style" to specify the "style" attribute.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {String} tagName The tag of the element to be created
       * @param {Object} attribs Attribute definition (key: attribute name; value:
       *        attribute value); null for a DOM element without attributes
       * @return {HTMLElement} The created DOM element
       */
      createNode: function (context, tagName, attribs) {
        // IE <= 7 is not able to create anchors the normal way, so we'll have to
        // create it in a single step; see bug #36231
        // http://msdn.microsoft.com/en-us/library/ms534184(v=VS.85).aspx
        var useInnerHTML = (com.ua.isIE6 || com.ua.isIE7) &&
          ((tagName.toLowerCase() === 'a') && attribs.hasOwnProperty('name'));
        var node = (useInnerHTML ? null : context.createElement(tagName));
        var tagStr = null;
        if (useInnerHTML) {
          tagStr = '<' + tagName;
        }
        if (attribs) {
          for (var name in attribs) {
            if (attribs.hasOwnProperty(name)) {
              var value = attribs[name];
              if (useInnerHTML) {
                value = CUI.rte.Utils.htmlEncode(value);
                tagStr += ' ' + name + '=\"' + value + '\"';
              } else {
                name = (name === 'className' ? 'class' : name);
                CUI.rte.Common.setAttribute(node, name, value);
              }
            }
          }
        }
        if (useInnerHTML) {
          tagStr += '></' + tagName + '>';
          node = context.createElement(tagStr);
        }
        return node;
      },

      /**
       * Inserts a new element with the specified tag name and attributes as a direct
       * parent node of the specified node. The specified node will be the only child
       * node of the newly created element.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The node that will be the child of the newly created
       *        element
       * @param {String} tagName Tag name of the element to be created
       * @param {Object} attribs Attributes of the element to be created
       */
      insertAsParent: function (context, node, tagName, attribs) {
        var dpr = CUI.rte.DomProcessor;
        var nodeToInsert = dpr.createNode(context, tagName, attribs);
        var parentNode = node.parentNode;
        parentNode.insertBefore(nodeToInsert, node);
        parentNode.removeChild(node);
        nodeToInsert.appendChild(node);
        return nodeToInsert;
      },

      /**
       * Removes the specified node without removing its child nodes. The child nodes
       * will be inserted in the node's parent node at the position of the node to be
       * removed.
       * @param {HTMLElement} nodeToRemove The node to be removed
       */
      removeWithoutChildren: function (nodeToRemove) {
        var newParent = nodeToRemove.parentNode;
        while (nodeToRemove.childNodes.length > 0) {
          var nodeToMove = nodeToRemove.childNodes[0];
          nodeToRemove.removeChild(nodeToMove);
          newParent.insertBefore(nodeToMove, nodeToRemove);
        }
        newParent.removeChild(nodeToRemove);
      },

      /**
       * Moves the nodes, specified by the "nodes" list, to a newly created node, which
       * is created before the first node of the "nodes" list.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} baseNode The parent of the nodes to be moved
       * @param {HTMLElement[]} nodes List of nodes to be moved (must be child nodes of
       *        baseNode)
       * @param {String} tagName Tag name of the node to be created
       * @param {Object} attribs Attributes of the node to be created
       */
      restructureAsChild: function (context, baseNode, nodes, tagName, attribs) {
        var dpr = CUI.rte.DomProcessor;
        var nodeToInsert = dpr.createNode(context, tagName, attribs);
        baseNode.insertBefore(nodeToInsert, nodes[0]);
        var nodeCnt = nodes.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
          var nodeToRestructure = nodes[nodeIndex];
          baseNode.removeChild(nodeToRestructure);
          nodeToInsert.appendChild(nodeToRestructure);
        }
        return nodeToInsert;
      },

      /**
       * Determines if the given DOM node <i>may</i> represent a placeholder object.
       * @deprecated
       * @param {HTMLElement} node Node to check
       * @return {Boolean} True if the given DOM node may represent a placeholder object
       */
      isPlaceholderObject: function (node) {
        if (com.ua.isIE && !com.ua.isIEBRPlaceholder) {
          return ((node.nodeType === 3) && (node.nodeValue === CUI.rte.DomProcessor.NBSP));
        } else {
          var isPlaceholder = com.isTag(node, 'br');
          if (!isPlaceholder && com.isTag(node.parentNode, ['td', 'th'])) {
            isPlaceholder = ((node.nodeType === 3) && (node.nodeValue === CUI.rte.DomProcessor.NBSP));
          }
          return isPlaceholder;
        }
      },

      /**
       * @deprecated
       */
      getEmptyLinePlaceholder: function (node) {
        if (node.nodeType !== 1) {
          return null;
        }
        if (node.childNodes.length !== 1) {
          return null;
        }
        var child = node.childNodes[0];
        if (CUI.rte.DomProcessor.isPlaceholderObject(child)) {
          return child;
        }
        return null;
      },

      /**
       * Checks if the given node represents an empty "line" (consisting of a placeholder
       * object only).
       * @deprecated
       * @param {HTMLElement} node Node to check
       */
      isEmptyLinePlaceholder: function (node) {
        var emptyLinePlaceholder = CUI.rte.DomProcessor.getEmptyLinePlaceholder(node);
        return (emptyLinePlaceholder !== null && emptyLinePlaceholder !== undefined);
      },

      /**
       * Creates a browser-specific empty line placeholder.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Boolean} createBlock True if a surrounding paragraph node has also to
       *        be created
       * @param {String} blockType (optional) The type of block to create; if none is
       *        specified, a "p" block is created by default
       * @return {HTMLElement} The placeholder element if one has been created (note that
       *         this might be null on IE when createBlock == false).
       */
      createEmptyLinePlaceholder: function (context, createBlock, blockType) {
        var placeholder;
        if (!com.ua.isIE || com.ua.isIEBRPlaceholder) {
          placeholder = CUI.rte.DomProcessor.createGeckoPlaceholder(context);
        }
        if (createBlock) {
          var para = context.createElement(blockType || 'p');
          if (placeholder) {
            para.appendChild(placeholder);
          }
          placeholder = para;
        }
        return placeholder;
      },

      /**
       * Creates a Gecko-compatible placeholder br. Can also be used for Webkit browsers.
       * @param {CUI.rte.EditContext} context The edit context
       * @return {HTMLElement} The placeholder element
       */
      createGeckoPlaceholder: function (context) {
        var placeholder = context.createElement('br');
        if (com.ua.isGecko || com.ua.isWebKit || com.ua.isIEBRPlaceholder) {
          com.setAttribute(placeholder, com.BR_TEMP_ATTRIB, 'brEOB');
        }
        return placeholder;
      },

      /**
       * Ensures that a placeholder is available for an empty edit block.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} editBlockDom The edit block
       */
      ensureValidEmptyEditBlock: function (context, editBlockDom) {
        if (!com.isTag(editBlockDom, com.EDITBLOCK_TAGS) || (editBlockDom.nodeType !== 1)) {
          throw new Error('No valid edit block provided');
        }
        if (editBlockDom.childNodes.length === 0) {
          var dpr = CUI.rte.DomProcessor;
          if (!com.ua.isIE || com.ua.isIEBRPlaceholder) {
            editBlockDom.appendChild(dpr.createGeckoPlaceholder(context));
          }
          dpr.fixEmptyEditingBlockIE(context, editBlockDom);
        }
      },

      /**
       * @deprecated
       */
      ensureEmptyLinePlaceholders: function (context, node) {
        if (node.nodeType === 1) {
          var dpr = CUI.rte.DomProcessor;
          var sel = CUI.rte.Selection;
          if (dpr.getTagType(node) === dpr.CONTAINER) {
            var textChild = com.getFirstTextChild(node, true);
            if (textChild === null || textChild === undefined) {
              var placeholderNode = dpr.getEmptyLinePlaceholder(node);
              if (!placeholderNode) {
                placeholderNode = dpr.createEmptyLinePlaceholder(context,
                  false);
                if (placeholderNode) {
                  var appendingNode = com.getFirstChild(node);
                  if (appendingNode === null || appendingNode === undefined) {
                    appendingNode = node;
                  } else {
                    // prevent appending the placeholder object to a named
                    // anchor (or similar)
                    while (sel.isNoInsertNode(appendingNode, true)) {
                      appendingNode = appendingNode.parentNode;
                      if (appendingNode === node) {
                        break;
                      }
                    }
                  }
                  appendingNode.appendChild(placeholderNode);
                }
              }
            } else {
              // here we'll have to check if the structure is correct, as on Gecko
              // we might get something like <p><b></b><br></p> which would
              // prevent us from keeping formatting (see bug #22395)
              if (dpr.isPlaceholderObject(textChild)) {
                var firstChild = com.getFirstChild(node);
                // prevent moving the placeholder object into a named anchor
                // (or similar)
                if (!sel.isNoInsertNode(firstChild, true)) {
                  if (firstChild !== textChild) {
                    textChild.parentNode.removeChild(textChild);
                    firstChild.appendChild(textChild);
                  }
                }
              }
            }
          }
        }
      },

      /**
       * Checks if the specified block node represents an empty line.
       * @param {HTMLElement} blockNode The block node to check
       * @return {Boolean} True if the specified block node represents an empty line
       */
      isEmptyLineBlock: function (blockNode) {
        var dpr = CUI.rte.DomProcessor;
        var isEmpty = dpr.isEmptyLinePlaceholder(blockNode);
        if (!isEmpty) {
          // handle completely empty blocks + Blocks containing a single &nbsp; node
          var characterNodes = com.getCharacterNodes(blockNode);
          if (characterNodes.length === 0) {
            isEmpty = true;
          } else if (characterNodes.length === 1) {
            var text = com.getNodeText(characterNodes[0]);
            isEmpty = (text === dpr.NBSP);
          }
        }
        return isEmpty;
      },

      /**
       * <p>On Internet Explorer, this method should be called on each newly created,
       * empty edit block to ensure that it is actually editable.</p>
       * <p>Implicitly (= by RTE) inserted empty blocks are usually not editable due to
       * some internal IE issues, so there has to be some "selection magic" executed
       * to ensure the user can actually see and edit them.</p>
       * <p>Note that you may call the method on a deliberate node and even on Gecko
       * browsers, as it will automatically determine if the fix has to be applied or
       * not.</p>
       * <p>Note also that the node must have already been added to the DOM-tree of the
       * editor's document before this method is called. Otherwise IE will throw an
       * exception.</p>
       * <p>Also note that this method changes the behaviour of the outerHTML and
       * innerHTML properties: Before calling this method, an empty block is reported
       * - outerHTML for example has a value of &lt;p&gt;&lt;/p&gt;. Afterwards, an
       * additional &amp;nbsp; is visible - the outerHTML changes to
       * &lt;p&gt;&amp;nbsp;&lt;/p&gt;. The additional &amp;nbsp; is not actually present
       * in the DOM, cannot be iterated or removed.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} editBlock The editing block
       */
      fixEmptyEditingBlockIE: function (context, editBlock) {
        // Workaround to ensure that IE actually displays an empty block. It is not
        // really comprehensible when empty paragraphs are automatically displayed, and
        // when they have to be "made displayable" manually
        if (com.ua.isIE && !com.ua.isIEBRPlaceholder && com.isEmptyEditingBlock(editBlock, true)) {
          if (com.isTag(editBlock, com.TABLE_CELLS)) {
            // not required and throwing an exception on table cells
            return;
          }
          var dpr = CUI.rte.DomProcessor;
          // we'll have to provide another node before the span that is used for
          // "persisting" the block, as IE would remove the paragraph otherwise
          // if there is a "a name" at the end of the previous block
          var secNode = context.createTextNode(dpr.NBSP);
          editBlock.appendChild(secNode);
          var helperNode = context.createElement('span');
          editBlock.appendChild(helperNode);
          helperNode.appendChild(context.createTextNode(dpr.NBSP));
          // focus request required for IE >= 8 compatibility
          context.win.focus();
          // empty selection before creating the range - otherwise IE 9 might choke
          // on some edge cases
          context.doc.selection.empty();
          // select the temporary span ...
          var range = context.doc.selection.createRange();
          range.moveToElementText(helperNode);
          // ... and replace it by an empty String - this seems to finally make the
          // paragraph displayable
          range.pasteHTML('');
          editBlock.removeChild(secNode);
        }
      },

      /**
       * This fixes empty lines at the end of a block similar to the way
       * {@link #fixEmptyEditingBlockIE} does for empty blocks.
       * @param {CUI.rte.EditContext} context The editing context
       * @param {HTMLElement} brDom The linefeed (&lt;br&gt;) to be fixed
       */
      fixEmptyLinefeedIE: function (context, brDom) {
        if (com.ua.isIE && !com.ua.isIEBRPlaceholder) {
          var dpr = CUI.rte.DomProcessor;
          var helperNode = context.createElement('span');
          var insertRef = brDom.nextSibling;
          if (insertRef) {
            brDom.parentNode.insertBefore(helperNode, insertRef);
          } else {
            brDom.parentNode.appendChild(helperNode);
          }
          helperNode.appendChild(context.createTextNode(dpr.NBSP));
          context.win.focus();
          var range = context.doc.selection.createRange();
          range.moveToElementText(helperNode);
          range.pasteHTML('');
        }
      },

      /**
       * Ensure the minimum content that is required for the browser to work properly.
       * @private
       */
      ensureMinimumContent: function (context) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        var sel = CUI.rte.Selection;
        var pNode = null;
        if (context.root.childNodes.length === 1) {
          var nodeToCheck = context.root.childNodes[0];
          if (com.isTag(nodeToCheck, 'br')) {
            context.root.removeChild(nodeToCheck);
          }
          if (com.isTag(nodeToCheck, 'p')) {
            dpr.ensureEmptyLinePlaceholders(context, nodeToCheck);
          }
        }
        var bookmark = dpr.ensureBlockContent(context, 'p', null, false, true);
        if (bookmark) {
          sel.selectBookmark(context, bookmark);
        }
        if (context.root.childNodes.length === 0) {
          pNode = context.createElement('p');
          context.root.appendChild(pNode);
          dpr.ensureEmptyLinePlaceholders(context, pNode);
          sel.selectNode(context, pNode, true);
        }
        return pNode;
      },

      /**
       * Checks if the specified selection represents an empty line and returns the
       * block node for the empty line if there is one.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Object} selection Processing selection to check (as createad by
       *        {@link CUI.rte.Selection#createProcessingSelection})
       * @return {HTMLElement} The edit block node if there is an empty line; null if the
       *         selection doesn't specify an empty line
       */
      getEmptyLine: function (context, selection) {
        var dpr = CUI.rte.DomProcessor;
        var blockNode = dpr.getEditBlock(context, selection.startNode);
        if (!blockNode) {
          return null;
        }
        // check if the block nodes of start and end node are the same
        if (selection.endNode) {
          var blockEndNode = dpr.getEditBlock(context, selection.endNode);
          if (blockNode !== blockEndNode) {
            return null;
          }
        }
        return (dpr.isEmptyLineBlock(blockNode) ? blockNode : null);
      },

      /**
       * Checks if the specified selection represents an empty line.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Object} selection Processing selection to check (as createad by
       *        {@link CUI.rte.Selection#createProcessingSelection})
       * @return {Boolean} True if the selection represents an empty line
       */
      isEmptyLine: function (context, selection) {
        var emptyLine = CUI.rte.DomProcessor.getEmptyLine(context, selection);
        return (emptyLine !== null && emptyLine !== undefined);
      },

      /**
       * <p>Determines if the specified node determines an empty line.</p>
       * <p>This is the case for "br" nodes that have either another "br" node as
       * "previous character sibling" or no direct "previous character sibling". The
       * latter condition is valid for IE only.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The DOM element to check
       * @return {Boolean} True if the specified node determines an empty linefeed node
       */
      isEmptyLineDeterminator: function (context, node) {
        if (!com.isTag(node, 'br')) {
          return false;
        }
        var prev = com.getPreviousCharacterNode(context, node, com.EDITBLOCK_TAGS);
        return (((prev === null || prev === undefined) && com.ua.isIE) || com.isTag(prev, 'br'));
      },

      /**
       * Determines the empty block placeholder from the specified block if present.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The DOM element (the edit block or any node inside
       *        the edit block
       * @param {Boolean} isStrict True if only explictly marked placeholders should be
       *        determined
       * @return {HTMLElement} The placeholder; null if no placeholder is present
       */
      getEmptyBlockPlaceholder: function (context, node, isStrict) {
        while (node && !com.isTag(node, com.EDITBLOCK_TAGS)) {
          node = com.getParentNode(context, node);
        }
        if (node) {
          var charNodes = com.getCharacterNodes(node);
          if (charNodes.length === 1) {
            var toCheck = charNodes[0];
            if (com.isTag(toCheck, 'br')) {
              if (!isStrict || com.isAttribDefined(toCheck, com.BR_TEMP_ATTRIB)) {
                return toCheck;
              }
            }
          }
        }
        return null;
      },

      /**
       * Removes the empty block placeholder from the specified block if present.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The DOM element (the edit block or any node inside
       *        the edit block
       * @param {Boolean} isStrict True if only explictly marked placeholders should be
       *        removed
       */
      removeEmptyBlockPlaceholder: function (context, node, isStrict) {
        var dpr = CUI.rte.DomProcessor;
        var placeholder = dpr.getEmptyBlockPlaceholder(context, node, isStrict);
        if (placeholder && placeholder.parentNode) {
          placeholder.parentNode.removeChild(placeholder);
        }
      },

      /**
       * <p>Adjusts the table structure of the document represented by the specified
       * edit context.</p>
       * <p>Tables that are nested in paragraphs are moved out of this paragraph. Header
       * cells are moved from the "thead" section to the "tbody" section.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {CUI.rte.HtmlRules.TableHandling} rules to apply to tables
       */
      adjustTables: function (context, tableRules) {
        var root = context.root;
        var blockNodes = root.childNodes;
        var i, insertNode;
        for (i = 0; i < blockNodes.length; i++) {
          var nodeToCheck = blockNodes[i];
          if (com.isTag(nodeToCheck, 'p')) {
            if (nodeToCheck.childNodes.length === 1) {
              var childNode = nodeToCheck.childNodes[0];
              if (com.isTag(childNode, 'table')) {
                root.insertBefore(childNode, nodeToCheck);
                root.removeChild(nodeToCheck);
                nodeToCheck = childNode;
              }
            }
          }
          if (com.isTag(nodeToCheck, 'table')) {
            var header = tableRules.mergeTheadToTbody ? com.getChildNodesByType(nodeToCheck, 'thead') : null;
            var tBody, rowToMove;
            if (header && header.length === 1) {
              header = header[0];
              tBody = com.getChildNodesByType(nodeToCheck, 'tbody');
              if (tBody.length === 0) {
                tBody.push(context.createElement('tbody'));
              }
              tBody = tBody[0];
              insertNode = null;
              if (tBody.childNodes.length > 0) {
                insertNode = tBody.childNodes[0];
              }
              for (i = header.childNodes.length - 1; i >= 0; i--) {
                rowToMove = header.childNodes[i];
                header.removeChild(rowToMove);
                tBody.insertBefore(rowToMove, insertNode);
                insertNode = rowToMove;
              }
              nodeToCheck.removeChild(header);
            }
            var footer = tableRules.mergeTfootToTbody ? com.getChildNodesByType(nodeToCheck, 'tfoot') : null;
            if (footer && footer.length === 1) {
              footer = footer[0];
              tBody = com.getChildNodesByType(nodeToCheck, 'tbody');
              if (tBody.length === 0) {
                tBody.push(context.createElement('tbody'));
              }
              tBody = tBody[0];
              insertNode = null;
              for (i = footer.childNodes.length - 1; i >= 0; i--) {
                rowToMove = footer.childNodes[i];
                footer.removeChild(rowToMove);
                tBody.insertBefore(rowToMove, insertNode);
                insertNode = rowToMove;
              }
              nodeToCheck.removeChild(footer);
            }
          }
        }
      },

      /**
       * Removes all non-table blocks to ensure that only tables are left for editing.
       * @param {CUI.rte.EditContext} context The edit context
       */
      removeNonTableBlocks: function (context) {
        var root = context.root;
        var blocks = root.childNodes;
        for (var i = blocks.length - 1; i >= 0; i--) {
          if (!com.isTag(blocks[i], 'table')) {
            root.removeChild(blocks[i]);
          }
        }
      },

      /**
       * @private
       */
      hasSimilarParent: function (context, dom) {
        var dpr = CUI.rte.DomProcessor;
        if (!dom || (dom.nodeType !== 1)) {
          return false;
        }
        var checkDom = com.getParentNode(context, dom);
        while (checkDom) {
          if (dpr.getTagType(checkDom) === dpr.CONTAINER) {
            return false;
          }
          if (checkDom.nodeType === 1) {
            if (com.equals(dom, checkDom)) {
              return true;
            }
          }
          checkDom = com.getParentNode(context, checkDom);
        }
        return false;
      },

      /**
       * Removes duplicate DOM nodes. For example, the inner "b" node in &lt;b&gt;A bold
       * &lt;b&gt;text&lt;/b&gt;.&lt;/b&gt; gets removed, as it is unnecessary.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} startNode first node to check (inclusive)
       * @param {HTMLElement} endNode last node to check (inclusive)
       * @return {Object} Object that contains the valid start/end node after duplicates
       *         have been removed (properties: startNode, endNode)
       */
      removeDuplicateStructures: function (context, startNode, endNode) {
        var dpr = CUI.rte.DomProcessor;
        var node = startNode;
        while (node) {
          var isProcessed = false;
          if (node.nodeType === 1) {
            if ((dpr.getTagType(node) !== dpr.CONTAINER) && dpr.hasSimilarParent(context, node)) {
              var nextNode = com.getNextNode(context, node);
              if (node === startNode) {
                startNode = nextNode;
              }
              if (node === endNode) {
                endNode = nextNode;
              }
              dpr.removeWithoutChildren(node);
              node = nextNode;
              isProcessed = true;
            }
          }
          if (!isProcessed) {
            if (node === endNode) {
              break;
            }
            node = com.getNextNode(context, node);
          }
        }
        return {
          'startNode': startNode,
          'endNode': endNode
        };
      },

      /**
       * <p>Joins the specified DOM text node with the preceding or succeeding text node
       * structurally if possible.</p>
       * <p>For example: &lt;b&gt;ABC &lt;/b&gt;&lt;b&gt;DEF&lt;/b&gt; can be joined to
       * &lt;b&gt;ABC DEF&lt;/b&gt;</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom node to check; if this is no text node, the first
       *        descendant text node will be used instead
       * @param {Boolean} joinPreceding True if the specified DOM node should be joined
       *        with the preceding text node; False if the succeeding node should be used
       *        for joining
       */
      joinIdenticalStructures: function (context, dom, joinPreceding) {
        var dpr = CUI.rte.DomProcessor;
        if (dom.nodeType === 1) {
          dom = com.getFirstTextChild(dom) || dom;
        }
        var joinDom = (joinPreceding ? com.getPreviousCharacterNode(context, dom)
          : com.getNextCharacterNode(context, dom));
        if (!dom || !joinDom) {
          return;
        }
        var domCheck = com.getParentNode(context, dom);
        var joinCheck = com.getParentNode(context, joinDom);
        var canJoin = true;
        var hasCommonAncestors = false;
        while (dpr.getTagType(domCheck) === dpr.STRUCTURE) {
          if (!com.equals(domCheck, joinCheck)) {
            canJoin = false;
            break;
          }
          hasCommonAncestors = true;
          domCheck = com.getParentNode(context, domCheck);
          joinCheck = com.getParentNode(context, joinCheck);
          if ((domCheck === null || domCheck === undefined) || (joinCheck === null || joinCheck === undefined)) {
            canJoin = (domCheck === joinCheck);
            break;
          }
        }
        if (canJoin) {
          // must share the same container
          canJoin = (domCheck === joinCheck);
        }
        if (canJoin && hasCommonAncestors) {
          var destParent = dom.parentNode;
          var srcParent = joinDom.parentNode;
          // joining up the hierarchy
          while (destParent !== srcParent) {
            var newSrcParent = srcParent.parentNode;
            if (joinPreceding) {
              com.moveChildren(srcParent, destParent, 0, false);
            } else {
              com.moveChildren(srcParent, destParent, 0, true);
            }
            // clean up after every iteration
            com.removeNodesWithoutContent(context, srcParent);
            srcParent = newSrcParent;
            destParent = destParent.parentNode;
            if (dpr.getTagType(destParent) === dpr.CONTAINER) {
              break;
            }
          }
        }
      },

      splitToParent: function (splitParent, node, offset) {
        var sel = CUI.rte.Selection;
        var isNoInsertNode = sel.isNoInsertNode(node, true) && (offset === null || offset === undefined);
        var clonedNode, parentNode, nodeToMove;
        var nodesToMove = [];
        var isOriginalNode = true;
        var childIndex;
        while (true) {
          if (!node) {
            return null;
          }
          if (isNoInsertNode) {
            // must mark all nodes "behind" the current node for moving, as the
            // normal mechanism does not work for non-insertable nodes
            childIndex = com.getChildIndex(node);
            offset = childIndex;
            var children = node.parentNode.childNodes;
            for (; childIndex < children.length; childIndex++) {
              nodeToMove = children[childIndex];
              nodesToMove.push(nodeToMove);
            }
            node = node.parentNode;
            isNoInsertNode = false;
          }
          parentNode = node.parentNode;
          if (node.nodeType === 3) {
            if (offset === 0) {
              // will be removed one hierarchy level up on moving
              nodesToMove.push(node);
            } else if (offset < com.getNodeCharacterCnt(node)) {
              var nodeText = node.nodeValue;
              node.nodeValue = nodeText.substring(0, offset);
              clonedNode = node.cloneNode(false);
              clonedNode.nodeValue = nodeText.substring(offset, nodeText.length);
              nodesToMove.push(clonedNode);
            }
          } else {
            // edge case: splitting from a parent node offset
            if (isOriginalNode) {
              for (childIndex = offset; childIndex < node.childNodes.length;
                   childIndex++) {
                nodesToMove.push(node.childNodes[childIndex]);
              }
            }
            clonedNode = node.cloneNode(false);
            // IDs should not be used twice
            com.removeAttribute(clonedNode, 'id');
            var copyCnt = nodesToMove.length;
            for (var moveIndex = 0; moveIndex < copyCnt; moveIndex++) {
              nodeToMove = nodesToMove[moveIndex];
              if (nodeToMove.parentNode) {
                nodeToMove.parentNode.removeChild(nodeToMove);
              }
              clonedNode.appendChild(nodesToMove[moveIndex]);
            }
            nodesToMove.length = 0;
            nodesToMove.push(clonedNode);
          }
          if (node !== splitParent) {
            childIndex = com.getChildIndex(node) + 1;
            while (childIndex < parentNode.childNodes.length) {
              nodeToMove = parentNode.childNodes[childIndex];
              parentNode.removeChild(nodeToMove);
              nodesToMove.push(nodeToMove);
            }
          } else {
            if (node.nextSibling) {
              parentNode.insertBefore(clonedNode, node.nextSibling);
            } else {
              parentNode.appendChild(clonedNode);
            }
            return clonedNode;
          }
          node = parentNode;
          isOriginalNode = false;
        }
      },

      removeUnwantedEmptyTags: function (node, tagList) {
        if (com.matchesTagDefs(node, tagList)) {
          if (!com.hasTextChild(node, true)) {
            node.parentNode.removeChild(node);
            return;
          }
        }
        if (node.nodeType === 1) {
          var childCnt = node.childNodes.length;
          for (var c = childCnt - 1; c >= 0; c--) {
            CUI.rte.DomProcessor.removeUnwantedEmptyTags(node.childNodes[c],
              tagList);
          }
        }
      },

      /**
       * <p>Inserts a new paragraph at the specified text position.</p>
       * <p>Note that the node returned is the new paragraph in an
       * implementation-specific, technical way. It is always the latter of both affected
       * paragraphs contentwise. This may not always be what you'd expect: If inserting a
       * paragraph at the beginning of an existing paragraph, the existing paragraph seems
       * to be returned as "new paragraph". This is practically not the case, because the
       * method creates a new paragraph (which is actually returned), inserts it behind
       * the existing one and then (in the given case) moves all child nodes to the newly
       * created paragraph, seemingly returning the existing paragraph.</p>
       * <p>Interpretation of <code>offset</code>:</p>
       * <ul>
       *     <li>if node is a text node, it determines the character offset where the
       *     paragraph has to be inserted.</li>
       *     <li>if node is a structural node, it determines the index of child nodes
       *     where the paragraph has to be inserted before.</li>
       *     <li>if node is a "one character structural node" (&lt;bt&gt;, &lt;img&gt;),
       *     a value of 0 determines that the paragraph has to be inserted after the
       *     one character node.</li>
       *     <li>A value of null determines that the paragraph has to be inserted at
       *     the end of the child list of a structural node.</li>
       * </ul>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node Node that determines the insert position
       * @param {Number} offset (optional) Offset which determines the insert position
       * @return {HTMLElement} The newly created paragraph
       */
      insertParagraph: function (context, node, offset) {
        var dpr = CUI.rte.DomProcessor;
        var sel = CUI.rte.Selection;
        var newPara;
        // inserting "behind" a one-character node must be handled differently:
        // use the next text node in the block if available or offset to parent DOM
        // instead
        if (com.isOneCharacterNode(node) && (offset === 0)) {
          var nextTextNode = com.getNextCharacterNode(context, node,
            com.EDITBLOCK_TAGS);
          if (nextTextNode) {
            node = nextTextNode;
            offset = (node.nodeType === 3 ? 0 : null);
          } else {
            while (node && !com.isTag(node, com.EDITBLOCK_TAGS)) {
              offset = com.getChildIndex(node) + 1;
              node = com.getParentNode(context, node);
            }
            if (!node) {
              throw new Error('Invalid insert position');
            }
          }
        }
        // handle EOT & EOL with objects
        if ((node.nodeType === 1) && !com.isOneCharacterNode(node) &&
          ((offset === null || offset === undefined) || (offset === node.childNodes.length))) {
          if (offset === null || offset === undefined) {
            offset = node.childNodes.length;
          }
          if (com.isRootNode(context, node)) {
            newPara = node.childNodes[offset - 1].cloneNode(false);
            node.appendChild(newPara);
            node = node.childNodes[offset - 1];
          } else {
            newPara = node.cloneNode(false);
            node.parentNode.insertBefore(newPara, node.nextSibling);
          }
          var clonedRoot = null;
          var copyNode = com.getLastTextChild(node);
          copyNode = copyNode ? copyNode : com.getLastChild(node);
          copyNode = copyNode ? copyNode : node;
          while (copyNode !== node) {
            if ((copyNode.nodeType === 1) && !sel.isNoInsertNode(copyNode, true)) {
              var clonedNode = copyNode.cloneNode(false);
              if (clonedRoot !== null && clonedRoot !== undefined) {
                clonedNode.appendChild(clonedRoot);
              }
              clonedRoot = clonedNode;
            }
            copyNode = com.getParentNode(context, copyNode);
          }
          if (clonedRoot !== null && clonedRoot !== undefined) {
            newPara.appendChild(clonedRoot);
          }
          dpr.ensureEmptyLinePlaceholders(context, newPara);
          dpr.fixEmptyEditingBlockIE(context, newPara);
        } else {
          var scopedBlock = dpr.getScopedBlockNode(context, node);
          if (!scopedBlock) {
            throw new Error('Inserting paragraph outside an existing format scope');
          }
          var containerNode = scopedBlock.dom;
          if (scopedBlock.isAuxiliaryRoot) {
            // if a block is created explicitly inside an aux root (for example a
            // table cell), move the existing content into a splitable paragraph
            // first
            var newParagraph = context.createElement('p');
            com.moveChildren(containerNode, newParagraph);
            containerNode.appendChild(newParagraph);
            containerNode = newParagraph;
          }
          newPara = dpr.splitToParent(containerNode, node, offset);
          dpr.removeUnwantedEmptyTags(containerNode, dpr.EMPTYTEXT_EXCLUSIONS);
          var toCheck = com.getLastTextChild(containerNode, true, false);
          if (com.isTag(toCheck, 'br')) {
            toCheck.parentNode.removeChild(toCheck);
          }
          dpr.removeUnwantedEmptyTags(newPara, dpr.EMPTYTEXT_EXCLUSIONS);
          dpr.ensureEmptyLinePlaceholders(context, newPara);
          dpr.ensureEmptyLinePlaceholders(context, containerNode);
          dpr.fixEmptyEditingBlockIE(context, newPara);
          dpr.fixEmptyEditingBlockIE(context, containerNode);
        }
        return newPara;
      },

      /**
       * <p>Checks if the specified node is at the beginning of a block.</p>
       * <p>Note that in &lt;p&gt;&lt;b&gt;Test&lt;/b&gt;text&lt;/p&gt; both the
       * "b" tag and the first character of "Test" are recognized as residing at the
       * beginning of the "p" block.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The HTML element to check
       * @param {Number} offset The character offest (if dom is a text node) or the
       *        offset in dom's childNodes array
       * @param {Boolean} useEditBlocks if this is true, then the method returns true
       *        only if the specified node is at the beginning of a edit block.
       */
      isBlockStart: function (context, dom, offset, useEditBlocks) {
        var dpr = CUI.rte.DomProcessor;
        var scopedBlock = dpr.getScopedBlockNode(context, dom, useEditBlocks);
        if (!scopedBlock) {
          return false;
        }
        scopedBlock = scopedBlock.dom;
        if (dom.nodeType === 3) {
          if (offset > 0) {
            return false;
          }
          return (com.getFirstTextChild(scopedBlock, true) === dom);
        }
        if (offset !== null && offset !== undefined) {
          if (offset > 0) {
            return false;
          }
        }
        var walker = scopedBlock;
        while ((walker.nodeType === 1) && (walker.childNodes.length > 0)) {
          if (walker.childNodes[0] === dom) {
            return true;
          }
          walker = walker.childNodes[0];
        }
        return false;
      },

      /**
       * <p>Checks if the specified node is at the end of a block.</p>
       * <p>Note that in &lt;p&gt;Test &lt;b&gt;text&lt;/b&gt;&lt;/p&gt; both the
       * "b" tag and the last character of "text" are recognized as residing at the
       * end of the "p" block.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The HTML element to check
       * @param {Number} offset The character offest (if dom is a text node) or the
       *        offset in dom's childNodes array
       * @param {Boolean} useEditBlocks if this is true, then the method returns true
       *        only if the specified node is at the end of a edit block.
       */
      isBlockEnd: function (context, dom, offset, useEditBlocks) {
        var dpr = CUI.rte.DomProcessor;
        var scopedBlock = dpr.getScopedBlockNode(context, dom, useEditBlocks);
        if (!scopedBlock) {
          return false;
        }
        scopedBlock = scopedBlock.dom;
        if (dom.nodeType === 3) {
          if (offset < dom.nodeValue.length) {
            return false;
          }
          return (com.getLastTextChild(scopedBlock, true) === dom);
        }
        if (offset !== null && offset !== undefined) {
          if (offset < dom.childNodes.length - 1) {
            return false;
          }
        }
        var walker = scopedBlock;
        while ((walker.nodeType === 1) && (walker.childNodes.length > 0)) {
          if (walker.childNodes[walker.childNodes.length - 1] === dom) {
            return true;
          }
          walker = walker.childNodes[walker.childNodes.length - 1];
        }
        return false;
      },

      /**
       * <p>Get the container node (such as p, ul, etc.) for the specified DOM
       * element.</p>
       * <p>Note that only container nodes that are directly under the root node are
       * taken into account. "Auxiliary root nodes" (such as td, th) will not be included.
       * </p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom DOM element to determine container node for
       * @return {HTMLElement} container DOM node; null if no container node is present
       */
      getContainerNode: function (context, dom) {
        var dpr = CUI.rte.DomProcessor;
        while (dom) {
          if (dom.nodeType === 1) {
            if (!com.isTag(dom, dpr.AUXILIARY_ROOT_TAGS)) {
              if (dpr.getTagType(dom) === dpr.CONTAINER) {
                return dom;
              }
            }
          }
          dom = com.getParentNode(context, dom);
          // never return the root, even if it is a container element
          if (dom === context.root) {
            return null;
          }
        }
        return null;
      },

      /**
       * Gets the edit block for the specified node.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The DOM element to get the edit block for
       */
      getEditBlock: function (context, dom) {
        return com.getTagInPath(context, dom, com.EDITBLOCK_TAGS);
      },

      /**
       * Gets all editable blocks under the specified auxiliary root.
       * @param {HTMLElement} auxRoot The auxiliary root (or the document's body element)
       * @param {HTMLElement[]} editBlocks (optional) The array containing all edit blocks
       *        found
       * @return {HTMLElement[]}  The array containing all edit blocks found
       */
      getEditBlocks: function (auxRoot, editBlocks) {
        var dpr = CUI.rte.DomProcessor;
        if (editBlocks === undefined) {
          editBlocks = [];
        }
        var childCnt = auxRoot.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          var child = auxRoot.childNodes[c];
          if (!com.isTag(child, dpr.AUXILIARY_ROOT_TAGS)) {
            if (com.isTag(child, com.EDITBLOCK_TAGS)) {
              editBlocks.push(child);
            }
            dpr.getEditBlocks(child, editBlocks);
          }
        }
        return editBlocks;
      },

      /**
       * Checks if there are any editable blocks under the specified auxiliary root.
       * @param {HTMLElement} auxRoot The auxiliary root (or the document's body element)
       * @return {Boolean} True if there are editable blocks available
       */
      hasEditBlocks: function (auxRoot) {
        var dpr = CUI.rte.DomProcessor;
        var childCnt = auxRoot.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          var child = auxRoot.childNodes[c];
          if (!com.isTag(child, dpr.AUXILIARY_ROOT_TAGS)) {
            if (com.isTag(child, com.EDITBLOCK_TAGS) || dpr.hasEditBlocks(child)) {
              return true;
            }
          }
        }
        return false;
      },

      /**
       * <p>Gets the "auxiliary root" for the specified node.</p>
       * <p>This is either one of the elements that is specified as an aux root (table
       * cells, etc.) or the document's body node.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The DOM element to determine the aux root for; if the
       *        specified element is an auxiliary root by itself, dom (and not dom's super
       *        auxiliary root) is returned
       * @return {HTMLElement} The auxiliary root (or the document's body node)
       */
      getAuxRootNode: function (context, dom) {
        while (dom) {
          if (com.isRootNode(context, dom)) {
            return dom;
          }
          if (com.isTag(dom, CUI.rte.DomProcessor.AUXILIARY_ROOT_TAGS)) {
            return dom;
          }
          dom = com.getParentNode(context, dom);
        }
        return context.root;
      },

      /**
       * <p>Get the container node (such as p, ul, etc.) for the specified DOM
       * element, considering it being the last container node in the document
       * (required for handling "end of text" situations.</p>
       * <p>Note that only container nodes that are directly under the body node are
       * taken into account. "Auxiliary root nodes" (such as td, th) will not be included.
       * </p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom DOM element to determine container node for
       * @return {HTMLElement} container DOM node; null if no container node is present
       */
      getLastContainerNode: function (context, dom) {
        var dpr = CUI.rte.DomProcessor;
        var node = com.getLastChild(dom);
        while (node && (node !== dom)) {
          if (node.nodeType === 1) {
            if (dpr.getTagType(node) === dpr.CONTAINER) {
              if (!com.isTag(node, dpr.AUXILIARY_ROOT_TAGS)) {
                return node;
              }
            }
          }
          node = com.getPreviousNode(context, node);
        }
        return null;
      },

      /**
       * @private
       */
      getSiblingContainerNode: function (context, dom, delimiterDom, fn) {
        var dpr = CUI.rte.DomProcessor;
        while (dom) {
          if (dom === delimiterDom) {
            return null;
          }
          if (dom.nodeType === 1) {
            if (dpr.getTagType(dom) === dpr.CONTAINER) {
              if (!com.isTag(dom, dpr.AUXILIARY_ROOT_TAGS)) {
                return dom;
              }
            }
          }
          dom = fn(context, dom);
        }
        return null;
      },

      getFormatTagInPath: function (context, dom, formatDefs) {
        while (dom) {
          if (dom.nodeType === 1) {
            if (com.isRootNode(context, dom)) {
              return null;
            }
            var tagToCheck = dom.tagName.toLowerCase();
            for (var formatId in formatDefs) {
              if (formatDefs.hasOwnProperty(formatId)) {
                var formatDef = formatDefs[formatId];
                if (formatDef.tag && (formatDef.tag === tagToCheck)) {
                  return dom;
                }
              }
            }
          }
          dom = dom.parentNode;
        }
        return null;
      },

      /**
       * <p>Creates a list of all "first level" container nodes (such as p, h1, etc.),
       * covered by the specified selection.</p>
       * <p>Note that only container nodes that are directly under the body node are
       * taken into account. "Auxiliary root nodes" (such as td, th) will not be included.
       * Also note that this method only includes "container" nodes (nodes that are
       * explicitly marked as such through {@link CUI.rte.DomProcessor.TYPE_TABLE}),
       * not block nodes.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Object} selection Selection to create container list from (as created by
       *        CUI.rte.Selection.createProcessingSelection()
       */
      createContainerList: function (context, selection) {
        var sel = CUI.rte.Selection;
        var dpr = CUI.rte.DomProcessor;
        selection = sel.adaptToInclusiveEndNode(context, selection);
        var startNode = selection.startNode;
        var endNode = selection.endNode;
        var node;
        if (!selection.isEOT) {
          node = dpr.getContainerNode(context, startNode);
        } else {
          node = dpr.getLastContainerNode(context, startNode);
        }
        if (!node && endNode && (endNode !== startNode)) {
          // corner case: selection might start under an auxiliary root - then take
          // next container (only if there is a end node and the end node is different
          // from the start node)
          node = dpr.getSiblingContainerNode(context, startNode, endNode,
            com.getNextNode);
        }
        if (!node) {
          return [];
        }
        if (!endNode) {
          return [node];
        }
        endNode = dpr.getContainerNode(context, endNode);
        if (!endNode) {
          endNode = dpr.getLastContainerNode(context, selection.endNode);
        }
        if (!endNode) {
          // corner case: selection might end under an auxiliary root - then take
          // previous container
          endNode = dpr.getSiblingContainerNode(context, selection.endNode, startNode,
            com.getPreviousNode);
        }
        if (!endNode) {
          return [node];
        }
        var containerNodes = [];
        while (node) {
          if (node.nodeType === 1) {
            // as auxiliary roots are usually also container tags, exclude them
            // as we only cover first level container nodes
            if (!com.isTag(node, dpr.AUXILIARY_ROOT_TAGS)) {
              if (dpr.getTagType(node) === dpr.CONTAINER) {
                containerNodes.push(node);
              }
            }
          }
          if (node === endNode) {
            break;
          }
          node = com.getNextNode(context, node);
        }
        return containerNodes;
      },

      /**
       * <p>Creates a list of all block nodes (such as p, h1, etc.), covered by the
       * specified selection.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Object} selection Selection to create block list from (as created by
       *        CUI.rte.Selection.createProcessingSelection()
       * @deprecated
       */
      createBlockList: function (context, selection) {
        var sel = CUI.rte.Selection;
        selection = sel.adaptToInclusiveEndNode(context, selection);
        var startNode = selection.startNode;
        var endNode = selection.endNode;
        var node;
        if (!selection.isEOT) {
          node = com.getBlockNode(context, startNode);
        } else {
          node = com.getLastBlockNode(context, startNode);
        }
        if (!node) {
          return [];
        }
        if (!endNode) {
          return [node];
        }
        endNode = com.getBlockNode(context, endNode);
        if (!endNode) {
          return [node];
        }
        var blockNodes = [];
        while (node) {
          if (node.nodeType === 1) {
            if (com.isBlockNode(context, node)) {
              blockNodes.push(node);
            }
          }
          if (node === endNode) {
            break;
          }
          node = com.getNextNode(context, node);
        }
        return blockNodes;
      },

      /**
       * <p>Checks if the given node has any child that is a container node.</p>
       * <p>Note that this method does not work recursively (by nature). Hence the
       * specified node must be a body node or an auxiliary root node.</p>
       * @private
       */
      hasContainerChildNodes: function (dom) {
        var dpr = CUI.rte.DomProcessor;
        var childCnt = dom.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          var child = dom.childNodes[c];
          if (child.nodeType === 1) {
            if (dpr.getTagType(child) === dpr.CONTAINER) {
              return true;
            }
          }
        }
        return false;
      },

      /**
       * <p>Creates a list of auxiliary root nodes for the given selection.</p>
       * <p>Note that only auxiliary roots without any containing container nodes are
       * returned. For example: &lt;td&gt;text&lt;/td&gt; is reported as an auxiliary
       * root, whereas &lt;td&gt;&gt;p&lt;para 1&gt;/p&lt;&gt;p&lt;para 2&gt;/p&lt;
       * &lt;/td&gt; is not reported as an auxiliary root.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Object} selection Processing selection
       * @return {Array} List of auxiliary roots
       */
      getAuxRoots: function (context, selection) {
        var sel = CUI.rte.Selection;
        var dpr = CUI.rte.DomProcessor;
        var auxRoots = [];
        // handle cell selection separately
        if (selection.cellSelection) {
          var cells = selection.cellSelection.cells;
          if (cells && (cells.length > 0)) {
            for (var c = 0; c < cells.length; c++) {
              auxRoots.push(cells[c]);
            }
            return auxRoots;
          }
        }
        selection = sel.adaptToInclusiveEndNode(context, selection);
        var node = selection.startNode;
        var endNode = selection.endNode;
        while (node) {
          if (node.nodeType === 1) {
            if (dpr.getTagType(node) === dpr.CONTAINER) {
              if (com.isTag(node, dpr.AUXILIARY_ROOT_TAGS)) {
                auxRoots.push(node);
              }
              break;
            }
          }
          node = com.getParentNode(context, node);
        }
        // corner case: we're starting on a non-container
        if (!node) {
          node = com.getTagInPath(context, selection.startNode, com.BLOCK_TAGS);
          if (!node) {
            return auxRoots;
          }
        }
        if (endNode && (endNode !== node)) {
          node = com.getNextNode(context, node);
          while (node) {
            if (node.nodeType === 1) {
              if (com.isTag(node, dpr.AUXILIARY_ROOT_TAGS)) {
                if (!dpr.hasContainerChildNodes(node)) {
                  auxRoots.push(node);
                }
              }
            }
            if (node === endNode) {
              break;
            }
            node = com.getNextNode(context, node);
          }
        }
        return auxRoots;
      },

      changeContainerTag: function (context, containerList, blueprintDom,
                                    ensurePlaceholder) {
        var dpr = CUI.rte.DomProcessor;
        var elCnt = containerList.length;
        var isToPre = com.isTag(blueprintDom, 'pre');
        for (var elIndex = 0; elIndex < elCnt; elIndex++) {
          var containerEl = containerList[elIndex];
          var isFromPre = com.isTag(containerEl, 'pre');
          var clonedDom = blueprintDom.cloneNode(blueprintDom);
          var txt = containerEl.innerHTML;
          com.replaceNode(containerEl, clonedDom);
          if (isFromPre !== isToPre) {
            if (isFromPre) {
              // $todo handle multispaces
              txt = txt.replace(/\n\r/g, '\n');
              txt = txt.replace(/\r\n/g, '\n');
              txt = txt.replace(/\r/g, '\n');
              txt = txt.replace(/\n/g, '<br>');
              clonedDom.innerHTML = txt;
            }
          }
          if (ensurePlaceholder) {
            dpr.ensureEmptyLinePlaceholders(context, clonedDom);
          }
          dpr.fixEmptyEditingBlockIE(context, clonedDom);
        }
      },

      getStyles: function (context, stylesDef, node) {
        var styles = stylesDef.styles;
        if (!styles) {
          styles = [];
          stylesDef.styles = styles;
        }
        while (!com.isRootNode(context, node)) {
          if (com.isTag(node, 'span')) {
            if (node.className) {
              styles.push({
                'dom': node,
                'className': node.className
              });
            }
          }
          node = com.getParentNode(context, node);
        }
        stylesDef.isContinuousStyle = (styles.length === 1);
      },

      getScopedBlockNode: function (context, dom, useEditBlocks) {
        var dpr = CUI.rte.DomProcessor;
        while (dom) {
          if (com.isTag(dom, useEditBlocks ? com.EDITBLOCK_TAGS : com.BLOCK_TAGS)) {
            return {
              'dom': dom,
              'isAuxiliaryRoot': false
            };
          }
          if (com.isTag(dom, dpr.AUXILIARY_ROOT_TAGS)) {
            return {
              'dom': dom,
              'isAuxiliaryRoot': true
            };
          }
          if (com.isRootNode(context, dom.parentNode)) {
            return {
              'dom': dom,
              'isAuxiliaryRoot': false
            };
          }
          dom = com.getParentNode(context, dom);
        }
        return null;
      },

      ensureBlockContent: function (context, tagName, attribs, brAsParDelimiter,
                                    createBookmark) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var sel = CUI.rte.Selection;
        var bookmark = null;
        var pNode = null;
        var root = context.root;
        var insertTag = null;
        var nodes = root.childNodes;
        for (var childIndex = nodes.length - 1; childIndex >= 0; childIndex--) {
          var nodeToProcess = nodes[childIndex];
          var isBr = com.isTag(nodeToProcess, 'br');
          var isBlockNode = com.isTag(nodeToProcess, com.BLOCK_TAGS);
          if ((nodeToProcess.nodeType === 3) || (isBr && !brAsParDelimiter) || (!isBr && !isBlockNode)) {
            if ((bookmark === null || bookmark === undefined) && createBookmark) {
              bookmark = sel.createSelectionBookmark(context);
            }
            if (!pNode) {
              pNode = dpr.createNode(context, tagName, attribs);
              root.insertBefore(pNode, insertTag);
              insertTag = pNode;
            }
            // Firefox 6 throws an exception if a node with _moz_editor_bogus_node
            // attribute set to TRUE is removed from its parent (although it is
            // physically present ...)
            if (nodeToProcess.parentNode) {
              root.removeChild(nodeToProcess);
            }
            pNode.insertBefore(nodeToProcess, pNode.firstChild);
          } else if (isBr) {
            if ((bookmark === null || bookmark === undefined) && createBookmark) {
              bookmark = sel.createSelectionBookmark(context);
            }
            pNode = null;
            root.removeChild(nodeToProcess);
          } else if (nodeToProcess.nodeType === 1) {
            insertTag = nodeToProcess;
            pNode = null;
          }
        }
        return bookmark;
      },

      /**
       * Inserts the specified plain text at the specified position.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The node where the text will be inserted
       * @param {Number} offset Inserting offset; null (in conjunction with a structural
       *        node) means "insert at the first possible child position; for example
       *        if node is a "p" tag, the text gets inserted before the first character
       *        of that paragraph)
       * @param {String} text The text to insert
       */
      insertText: function (context, node, offset, text) {
        var root = context.root;
        var firstNode, nodeSave;
        if (node.nodeType === 1) {
          if (offset === null || offset === undefined) {
            nodeSave = node;
            node = com.getFirstTextChild(node);
            if (!node) {
              var isBlockNode = false;
              firstNode = com.getFirstChild(nodeSave);
              if (!firstNode) {
                if (!com.isOneCharacterNode(nodeSave)) {
                  // inserting in an empty structural node
                  firstNode = nodeSave;
                  isBlockNode = true;
                } else {
                  // inserting before BR, IMG, A et al
                  firstNode = nodeSave;
                }
              }
              else if (!com.isCharacterNode(firstNode)) {
                isBlockNode = true;
              }
              node = context.createTextNode('');
              if (isBlockNode) {
                firstNode.appendChild(node);
              } else {
                firstNode.parentNode.insertBefore(node, firstNode);
              }
            }
            offset = 0;
          } else {
            var childCnt = node.childNodes.length;
            if (childCnt > 0) {
              if (offset >= childCnt) {
                // EOL/EOT
                node = com.getLastChild(node);
                if (node.nodeType === 3) {
                  offset = com.getNodeCharacterCnt(node);
                } else {
                  var pNode = node.parentNode;
                  node = context.createTextNode('');
                  pNode.appendChild(node);
                  offset = 0;
                }
              } else {
                node = node.childNodes[offset];
                if (node.nodeType === 1) {
                  node = com.getPreviousCharacterNode(context, node);
                  if (!node) {
                    // BOT
                    firstNode = com.getFirstChild(root);
                    node = context.createTextNode('');
                    firstNode.parentNode.insertBefore(node, firstNode);
                  } else if (node.nodeType === 1) {
                    // if previous node is also a "one character node", we
                    // will insert an empty text node behind
                    var textNode = context.createTextNode('');
                    node.parentNode.insertBefore(textNode,
                      node.nextSibling);
                    node = textNode;
                  }
                }
                offset = com.getNodeCharacterCnt(node);
              }
            } else {
              node = com.getPreviousTextNode(context, node);
              if (!node) {
                // BOT
                firstNode = com.getFirstChild(root);
                node = context.createTextNode('');
                firstNode.parentNode.insertBefore(node, firstNode);
              }
              offset = com.getNodeCharacterCnt(node);
            }
          }
        }
        var currentText = node.nodeValue;
        if (currentText.length <= offset) {
          currentText += text;
        } else if (offset === 0) {
          currentText = text + currentText;
        } else {
          currentText = currentText.substring(0, offset) + text +
          currentText.substring(offset, currentText.length);
        }
        node.nodeValue = currentText;
        return {
          'node': node,
          'offset': offset + text.length
        };
      },

      /**
       * Removes all elements that match the specified tag definitions from the DOM
       * recursively.
       * @param {HTMLElement} rootEl The root element to execute the removal on
       * @param {Object} tagDefsToRemove The definition of the tags to be removed. See
       *        {@link CUI.rte.Common#matchesTagDefs} for an explanation
       */
      removeTagsFromHierarchy: function (rootEl, tagDefsToRemove) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        var childCnt = rootEl.childNodes.length;
        for (var childIndex = childCnt - 1; childIndex >= 0; childIndex--) {
          var childToProcess = rootEl.childNodes[childIndex];
          dpr.removeTagsFromHierarchy(childToProcess, tagDefsToRemove);
        }
        if (rootEl.nodeType === 1) {
          if (com.matchesTagDefs(rootEl, tagDefsToRemove)) {
            dpr.removeWithoutChildren(rootEl);
          }
        }
      },

      saveChildNodes: function (dom) {
        var savedChildren = [];
        var children = dom.childNodes;
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          var savedChild = {
            'dom': child
          };
          savedChildren.push(savedChild);
          if (child.nodeType === 1) {
            savedChild.children = CUI.rte.DomProcessor.saveChildNodes(
              child);
          } else {
            savedChild.text = child.nodeValue;
          }
        }
        return savedChildren;
      },

      restoreChildNodes: function (dom, savedChildren) {
        while (dom.childNodes.length > 0) {
          dom.removeChild(dom.childNodes[0]);
        }
        for (var i = 0; i < savedChildren.length; i++) {
          var child = savedChildren[i];
          var domChild = child.dom;
          if (child.text !== undefined) {
            domChild.nodeValue = child.text;
          }
          var children = child.children;
          dom.appendChild(domChild);
          if (children) {
            CUI.rte.DomProcessor.restoreChildNodes(domChild, children);
          }
        }
      },

      /**
       * Inserts the specified DOM node at the specified location.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom Element to insert
       * @param {HTMLElement} insertNode Node of insert location
       * @param {Number} insertOffset Offset of insert location
       */
      insertElement: function (context, dom, insertNode, insertOffset) {
        var parent = insertNode.parentNode;
        if (insertNode.nodeType === 3) {
          // set marker inside a text node
          if (insertOffset === 0) {
            parent.insertBefore(dom, insertNode);
          } else if (insertOffset >= com.getNodeCharacterCnt(insertNode)) {
            parent.insertBefore(dom, insertNode.nextSibling);
          } else {
            var splitNodes = CUI.rte.DomProcessor.splitTextNode(context,
              insertNode, insertOffset);
            parent.insertBefore(dom, splitNodes[1]);
          }
          return;
        }
        if (com.isOneCharacterNode(insertNode)) {
          if (insertOffset === null || insertOffset === undefined) {
            com.insertBefore(parent, dom, insertNode);
          } else {
            com.insertBefore(parent, dom, insertNode.nextSibling);
          }
        } else {
          var children = insertNode.childNodes;
          if ((insertOffset !== null && insertOffset !== undefined) && (insertOffset < children.length)) {
            insertNode.insertBefore(dom, children[insertOffset]);
          } else {
            insertNode.appendChild(dom);
          }
        }
      },

      /**
       * Creates a marker span.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node Node the marker is to be added
       * @param {Number} offset Offset of the marker (relative to node)
       * @return {HTMLElement} The marker span
       */
      createMarker: function (context, node, offset) {
        var markerDom = context.createElement('span');
        CUI.rte.DomProcessor.insertElement(context, markerDom, node, offset);
        return markerDom;
      },

      /**
       * Removes a marker span previously set by {@link #createMarker}.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} markerDom The marker span to be removed
       */
      removeMarker: function (context, markerDom) {
        var prevNode = markerDom.previousSibling;
        var nextNode = markerDom.nextSibling;
        com.removeNodesWithoutContent(context, markerDom);
        if (prevNode && nextNode) {
          if ((prevNode.nodeType === 3) && (nextNode.nodeType === 3)) {
            prevNode.nodeValue += nextNode.nodeValue;
            nextNode.parentNode.removeChild(nextNode);
          }
        }
      },

      /**
       * Creates a span that contains temporary content.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Boolean} removeImmediately True if the span should be removed
       *        immediately after the selection changes
       * @param {Boolean} keepChildren True if child nodes should be kept if the
       *        temporary span should get removed again
       * @param {Boolean} adjustInner True if child nodes chould be kept, but cleaned
       *        up (remove special placeholder characters, etc.))
       */
      createTempSpan: function (context, removeImmediately, keepChildren, adjustInner) {
        var com = CUI.rte.Common;
        var span = context.createElement('span');
        var value = (removeImmediately ? com.TEMP_EL_IMMEDIATE_REMOVAL
          : com.TEMP_EL_REMOVE_ON_SERIALIZE);
        if (keepChildren) {
          value += ':keepChildren';
        }
        if (adjustInner) {
          value += ':adjustInner';
        }
        com.setAttribute(span, com.TEMP_EL_ATTRIB, value);
        return span;
      },

      /**
       * Removes all currently active temporary spans (as created by
       * {@link #createTempSpan}).
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Boolean} immediate True if all spans that were marked for immediate
       *        removal should get removed; fals for spans marked for removal after
       *        serialization
       */
      removeTempSpans: function (context, immediate) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var spans = context.doc.getElementsByTagName('span');
        var spanCnt = spans.length;
        var value = (immediate ? com.TEMP_EL_IMMEDIATE_REMOVAL
          : com.TEMP_EL_REMOVE_ON_SERIALIZE);
        // on Webkit browsers, the selection may indirectly change,
        // so ensure that it is the same after the clean up again
        var hasSelectionChanged = false;
        var selection, restoreNode, restoreOffset;
        if (com.ua.isWebKit) {
          selection = context.win.getSelection();
          restoreNode = selection.anchorNode;
          restoreOffset = selection.anchorOffset;
        }
        var cleanUp = function (dom) {
          if (dom.nodeType === 3) {
            var text = dom.nodeValue;
            var isReplaced = false;
            var znbspPos;
            do {
              znbspPos = text.indexOf(dpr.ZERO_WIDTH_NBSP);
              if (znbspPos >= 0) {
                text = com.strReplace(text, znbspPos, znbspPos,
                  '');
                if (com.ua.isWebKit && (dom === restoreNode) &&
                  (znbspPos < restoreOffset)) {
                  restoreOffset--;
                  hasSelectionChanged = true;
                }
                isReplaced = true;
              }
            } while (znbspPos >= 0);
            if (isReplaced) {
              dom.nodeValue = text;
            }
          } else if (dom.nodeType === 1) {
            var childCnt = dom.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
              cleanUp(dom.childNodes[c]);
            }
          }
        };
        for (var s = 0; s < spanCnt; s++) {
          var spanToRemove = spans[s];
          var attrValue = com.getAttribute(spanToRemove, com.TEMP_EL_ATTRIB, true);
          if (attrValue && com.strStartsWith(attrValue, value)) {
            if (spanToRemove.parentNode) {
              var splitAttrib = attrValue.split(':');
              var keepChildren = com.arrayContains(splitAttrib, 'keepChildren');
              var adjustInner = com.arrayContains(splitAttrib, 'adjustInner');
              if (keepChildren) {
                dpr.removeWithoutChildren(spanToRemove);
              } else if (adjustInner) {
                cleanUp(spanToRemove);
                dpr.removeWithoutChildren(spanToRemove);
              } else {
                spanToRemove.parentNode.removeChild(spanToRemove);
              }
            }
          }
        }
        if (com.ua.isWebKit && hasSelectionChanged) {
          var range = context.doc.createRange();
          range.setStart(restoreNode, restoreOffset);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      },

      /**
       * Removes all DOM elements that are marked as temporary using the
       * {@link CUI.rte.Common#TEMP_EL_ATTRIB} attribute.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} treeRoot (optional) The sub tree to process
       */
      removeTempElements: function (context, treeRoot) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        if (!treeRoot) {
          treeRoot = context.doc;
        }
        var childCnt = treeRoot.length;
        for (var c = 0; c < childCnt; c++) {
          var child = treeRoot.childNodes[c];
          if (child.nodeType === 1) {
            var tempAttrib = com.getAttribute(child, com.TEMP_EL_ATTRIB, true);
            if (tempAttrib) {
              var splitAttrib = tempAttrib.split(':');
              var keepChildren = com.arrayContains(splitAttrib, 'keepChildren');
              var emptyOnly = com.arrayContains(splitAttrib, 'emptyOnly');
              if (keepChildren) {
                dpr.removeWithoutChildren(child);
              } else {
                if (emptyOnly) {
                  if (child.childNodes.length === 0) {
                    child.parentNode.removeChild(child);
                    continue;
                  } else {
                    com.removeAttribute(child, com.TEMP_EL_ATTRIB);
                  }
                } else {
                  child.parentNode.removeChild(child);
                  continue;
                }
              }
            }
            dpr.removeTempElements(context, child);
          }
        }
      },

      /**
       * Checks if the specified node represents a "zero width placeholder node".
       * @param {HTMLElement} dom The node to check
       * @return {Boolean} True if the specified node is a zero width placeholder node
       */
      isZeroSizePlaceholder: function (dom) {
        if (dom.nodeType === 1) {
          if (dom.childNodes.length !== 1) {
            return false;
          }
          dom = dom.childNodes[0];
        }
        if (dom.nodeType !== 3) {
          return false;
        }
        var text = com.getNodeText(dom);
        if (text.length !== 1) {
          return false;
        }
        return (text.charAt(0) === CUI.rte.DomProcessor.ZERO_WIDTH_NBSP);
      },

      /**
       * Gecko has several bugs (row-in-row, no table root element) that have to be
       * corrected. As content may theoretically be copied from Gecko to IE, this
       * method should also be called in IE's pasting mechanisms.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The DOM element that contains the pasted DOM to be
       *        corrected
       */
      correctGeckoCopyBugs: function (context, dom) {
        // fix "no table tag" issue
        var html = dom.innerHTML;
        var htmlLC = html.toLowerCase();
        if (com.strStartsWith(htmlLC, '<tr>') || com.strStartsWith(htmlLC, '<tr ')) {
          dom.innerHTML = '<table>' + html + '</table>';
        }
        // fix "row-in-row" issue (<table><tr><tr><td>...</td></tr></tr></table>
        var rows = com.getChildNodesByType(dom, 'tr', true);
        var rowCnt = rows.length;
        for (var r = rowCnt - 1; r >= 0; r--) {
          var row = rows[r];
          var childRows = com.getChildNodesByType(row, 'tr', false);
          if (childRows.length > 0) {
            CUI.rte.DomProcessor.removeWithoutChildren(row);
          }
        }
      },

      /**
       * <p>Checks if the specified DOM element represents a named anchor and returns
       * additional information about it if appropriate.</p>
       * <p>Note that a named anchor must not necessarily be represented by a
       * corresponding "a" DOM element, but may also be substituted by another element,
       * for example a specially attributed image, as not all browsers support editing
       * named anchor elements correctly.</p>
       * @param {HTMLElement} dom The DOM element to check
       * @return {Object} Null if the specified DOM element does not represent a named
       *         anchor; otherwise an object with properties dom (the DOM object) id
       *         (the appropriate name attribute) and isAnchorTag (True if the DOM object
       *         is actually an "a" element, false if the "a" element is substituted by,
       *         for example, an "img" element)
       */
      checkNamedAnchor: function (dom) {
        // Anchors are edited as img elements with a marker
        // attribute set accordingly
        if (com.isTag(dom, 'img')) {
          var idReplacement = com.getAttribute(dom,
            com.A_ID_REPLACEMENT_ATTRIB);
          if (idReplacement !== null) {
            return {
              'dom': dom,
              'id': idReplacement,
              'isAnchorTag': false
            };
          }
        }
        return null;
      },

      /**
       * <p>Calculates the "screen estate" the specified nodes/offsets span.</p>
       * <p>This method returns the top coordinate of the start node and the
       * bottom coordinate of the end node if available or of the start node.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} startNode The start node
       * @param {HTMLElement} startOffset The start offset
       * @param {HTMLElement} endNode (optional) The end node
       * @param {HTMLElement} endOffset (optional) The end offset
       */
      calcScreenEstate: function (context, startNode, startOffset, endNode, endOffset) {
        var dpr = CUI.rte.DomProcessor, range, boundingRect;
        if (!endNode) {
          endNode = startNode;
          endOffset = startOffset;
        }

        if (com.ua.isIE11) {
          range = context.doc.createRange();
          range.setStart(startNode, startOffset);
          range.setEnd(endNode, endOffset);
          boundingRect = range.getBoundingClientRect();
          return {
            startY: boundingRect.top,
            endY: boundingRect.bottom
          };
        }

        // get start and end block to limit the scope
        var startBlock = com.getTagInPath(context, startNode, com.BLOCK_TAGS);
        var endBlock = com.getTagInPath(context, endNode, com.BLOCK_TAGS);

        // we're working on cloned blocks to avoid implicit changes in the selection
        // if start/end reflects the start/end of a selection
        var clonedStartBlock = startBlock.cloneNode(true);
        var clonedEndBlock = endBlock.cloneNode(true);

        // match start and end nodes to their counterparts in the cloned block
        function getPath(node, parentNode) {
          var path = [];
          while (node && (node !== parentNode)) {
            path.splice(0, 0, com.getChildIndex(node));
            node = node.parentNode;
          }
          return path;
        }

        function applyPath(path, parent) {
          var node = parent;
          var pathCnt = path.length;
          for (var p = 0; p < pathCnt; p++) {
            node = node.childNodes[path[p]];
          }
          return node;
        }

        var clonedStartNode = applyPath(getPath(startNode, startBlock),
          clonedStartBlock);
        var clonedEndNode = applyPath(getPath(endNode, endBlock), clonedEndBlock);

        // insert marker to finally determine the position
        var startMarker = dpr.createMarker(context, clonedStartNode, startOffset);
        startMarker.appendChild(context.createTextNode(dpr.ZERO_WIDTH_NBSP));
        var endMarker = startMarker;
        if ((startOffset !== endOffset) || (startNode !== endNode)) {
          endMarker = dpr.createMarker(context, clonedEndNode, endOffset);
          endMarker.appendChild(context.createTextNode(dpr.ZERO_WIDTH_NBSP));
        }
        startBlock.parentNode.insertBefore(clonedStartBlock, startBlock);
        var startPos = CUI.rte.Utils.getPagePosition(startMarker);
        var startHeight = CUI.rte.Utils.getHeight(startMarker);
        var endPos = startPos;
        var endHeight = startHeight;
        startBlock.parentNode.removeChild(clonedStartBlock);
        if ((startOffset !== endOffset) || (startNode !== endNode)) {
          endBlock.parentNode.insertBefore(clonedEndBlock, endBlock);
          endPos = CUI.rte.Utils.getPagePosition(endMarker);
          endHeight = CUI.rte.Utils.getHeight(endMarker);
          endBlock.parentNode.removeChild(clonedEndBlock);
        }
        return {
          startY: startPos[1],
          endY: endPos[1] + endHeight
        };
      },

      /**
       * Main node type of a {@link CUI.rte.NodeList}'s node: Text node
       * @type String
       */
      TEXT_NODE: 'text',

      /**
       * Main node type of a {@link CUI.rte.NodeList}'s node: Structural node
       * @type String
       */
      DOM_NODE: 'dom',

      /**
       * Type of DOM/structural node: Container - containers (such as div, p) are
       * considered to be "stronger" than simple structures (such as b, i, u) and hence
       * handled differently, for example when being surrounded: the content of containers
       * always gets explicitly surrounded, for example <i>&lt;p&gt;&lt;span
       * class="test"&gt;Surrounded paragraph &lt;/span&gt;&lt;/p&gt;</i>
       * @type String
       */
      CONTAINER: 'container',

      /**
       * Type of DOM/structural node: (Simple) Structure
       * @type String
       */
      STRUCTURE: 'structure',

      /**
       * Type of DOM/structural node: Dynamic - the type of some tags is dependent on the
       * context they're used in. For example, "a" tags are sometimes handled as
       * containers, sometimes as structures, sometimes not at all
       * @type String
       */
      DYNAMIC: 'dynamic',

      /**
       * Type of DOM/structural node: The node has to be ignored regarding processing
       * functions. For example, list nodes must not be included in any formatting
       * operation, but their item nodes must be included.
       * @type String
       */
      IGNORE: 'ignore',

      /**
       * List of tags that may provide their own block tag root
       * @type Array
       */
      AUXILIARY_ROOT_TAGS: [
        'td', 'th', 'caption'
      ],

      /**
       * Constant that defines the &amp;nbsp; char code
       * @type Number
       */
      NBSP_CODE: 160,

      /**
       * Constant that defines the &amp;nbsp; character
       * @type String
       */
      NBSP: String.fromCharCode(160),

      /**
       * Constant that defines the char code for a non-breaking, zero-width character
       * @type String
       */
      ZERO_WIDTH_NBSP_CODE: 65279,

      /**
       * Constant that defines a non-breaking, zero-width character as a String
       * @type String
       */
      ZERO_WIDTH_NBSP: String.fromCharCode(65279),

      EMPTYTEXT_EXCLUSIONS: [{
        'tagName': 'a',
        'attribsDefined': ['href'],
        'attribsUndefined': ['name']
      },
        {'tagName': 'b'}, {'tagName': 'i'}, {'tagName': 'u'},
        {'tagName': 'sub'}, {'tagName': 'sup'},
        {'tagName': 'span'}
      ]

    };

  }());

  /**
   * This table is used to determine the type (<code>STRUCTURE</code>,
   * <code>CONTAINER</p>, <p>DYNAMIC</p> of a tag. If nothing is specified
   * for a given tag, <code>STRUCTURE</code> is used as a default. Note: This table
   * may be changed if required. <i>But don't do so unless you are absolutely sure
   * about what you are doing!</i>
   */
  CUI.rte.DomProcessor.TYPE_TABLE = {
    'h1': CUI.rte.DomProcessor.CONTAINER,
    'h2': CUI.rte.DomProcessor.CONTAINER,
    'h3': CUI.rte.DomProcessor.CONTAINER,
    'h4': CUI.rte.DomProcessor.CONTAINER,
    'h5': CUI.rte.DomProcessor.CONTAINER,
    'h6': CUI.rte.DomProcessor.CONTAINER,
    'p': CUI.rte.DomProcessor.CONTAINER,
    'div': CUI.rte.DomProcessor.CONTAINER,
    'li': CUI.rte.DomProcessor.CONTAINER,
    'ul': CUI.rte.DomProcessor.IGNORE,
    'ol': CUI.rte.DomProcessor.IGNORE,
    'table': CUI.rte.DomProcessor.IGNORE,
    'tbody': CUI.rte.DomProcessor.IGNORE,
    'thead': CUI.rte.DomProcessor.IGNORE,
    'tfoot': CUI.rte.DomProcessor.IGNORE,
    'tr': CUI.rte.DomProcessor.IGNORE,
    'td': CUI.rte.DomProcessor.CONTAINER,
    'th': CUI.rte.DomProcessor.CONTAINER,
    'caption': CUI.rte.DomProcessor.CONTAINER,
    'address': CUI.rte.DomProcessor.CONTAINER,
    'blockquote': CUI.rte.DomProcessor.CONTAINER,
    'pre': CUI.rte.DomProcessor.CONTAINER
  };
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.DomProcessor
 * @static
 * @private
 * The WhitespaceProcessor provides utility functions to remove unnecessary whitespace
 * from the DOM.
 */
(function (CUI) {
  'use strict';
  CUI.rte.WhitespaceProcessor = (function () {

    var com = CUI.rte.Common;

    var dpr = CUI.rte.DomProcessor;

    return {

      /**
       * Normalizes whitespace in the specified text by:
       * <ul>
       *   <li>Replacing different types (tab, linefeed) of whitespace by simple spaces.
       *     </li>
       *   <li>Removing double/multiple spaces by single spaces</li>
       *   <li>Removing leading and trailing spaces if specified<li>
       * </ul>
       * @param {String} text The text to be normalized
       * @param {Boolean} trimLeft True if leading spaces should be trimmed
       * @param {Boolean} trimRight True if trailing spaces should be timmed
       * @return {String} The normalized text
       */
      normalizeWhitespace: function (text, trimLeft, trimRight) {
        var wsp = CUI.rte.WhitespaceProcessor;
        text = text.replace(wsp.WHITESPACE_REGEX, ' ');
        text = text.replace(wsp.MULTISPACE_REGEX, ' ');
        var charPos;
        if (trimLeft) {
          charPos = 0;
          while ((charPos < text.length) && (text.charAt(charPos) === ' ')) {
            charPos++;
          }
          if (charPos < text.length) {
            text = text.substring(charPos, text.length);
          } else {
            text = '';
          }
        }
        if (trimRight) {
          charPos = text.length - 1;
          while ((charPos >= 0) && (text.charAt(charPos) === ' ')) {
            charPos--;
          }
          if (charPos >= 0) {
            text = text.substring(0, charPos + 1);
          } else {
            text = '';
          }
        }
        return text;
      },

      /**
       * <p>Handles the whitespace of a text block.</p>
       * <p>A text block are any number of adjacent text nodes, sharing the same
       * parent node.</p>
       * <p>Note that adjacent text nodes are merged into one single text node if
       * necessary.</p>
       * @param {String} text The text of the text block (to be normalized)
       * @param {HTMLElement[]} children Array with child nodes of the parent node
       * @param {Number} startIndex Index of first child the text block is consisting of
       * @param {Number} endIndex Index of last child the text block is consisting of
       * @param {Array} nodesToRemove Array that is filled with nodes that have to be
       *        removed because of joined text nodes
       * @param {Boolean} trimEdges True if trailing and leading whitespace has to be
       *        trimmed
       */
      handleTextBlock: function (text, children, startIndex, endIndex, nodesToRemove,
                                 trimEdges) {
        var wsp = CUI.rte.WhitespaceProcessor;
        var childCnt = children.length;
        var trimLeft = (startIndex === 0) && trimEdges;
        if (!trimLeft && trimEdges) {
          if (com.isTag(children[startIndex - 1], 'br')) {
            trimLeft = true;
          }
        }
        var trimRight = (endIndex === (childCnt - 1)) && trimEdges;
        if (!trimRight && trimEdges) {
          if (com.isTag(children[endIndex + 1], 'br')) {
            trimRight = true;
          }
        }
        text = wsp.normalizeWhitespace(text, trimLeft, trimRight);
        children[startIndex].nodeValue = text;
        if (text.length === 0) {
          nodesToRemove.push(children[startIndex]);
        }
        for (var mr = startIndex + 1; mr <= endIndex; mr++) {
          nodesToRemove.push(children[mr]);
        }
      },

      /**
       * <p>Handles "no text" structures.</p>
       * <p>"No text" structures have a certain parent element that does not allow to
       * have text nodes (directly) under it. For example, text under a "table" node
       * must not have (editable) text, hence all text nodes under it can safely be
       * removed.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The "no text" parent node
       * @param {Object[]} removalRules Rules that define the nodes that have to be
       *        removed before whitespace processing is being applied
       */
      handleNoTextStructure: function (context, dom, removalRules) {
        var wsp = CUI.rte.WhitespaceProcessor;
        var children = dom.childNodes;
        var childCnt = children.length;
        // remove all text nodes if the current node is a "no text" tag
        for (var c = childCnt - 1; c >= 0; c--) {
          var child = children[c];
          if (child.nodeType === 3) {
            dom.removeChild(child);
          } else {
            var isEditBlock = com.isTag(child, com.EDITBLOCK_TAGS);
            wsp.processStructure(context, child, isEditBlock, removalRules);
          }
        }
      },

      /**
       * <p>Cleans the text nodes of an "average" structural node.</p>
       * <p>Unnecessary whitespace is removed. The method works recursively. Trailing
       * and leading whitespace (as specified by the trimEdges parameter) should only be
       * trimmed for edit block parent nodes such as "p", "h1", "td", etc.</p>
       * <p>Note that adjacent text nodes are merged by this method.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The parental structural node
       * @param {Boolean} trimEdges True if trailing and leading whitspace has to be
       *        trimmed
       * @param {Object[]} removalRules Rules that define the nodes that have to be
       *        removed before whitespace processing is being applied
       */
      cleanTextNodes: function (context, dom, trimEdges, removalRules) {
        var wsp = CUI.rte.WhitespaceProcessor;
        var children = dom.childNodes;
        // join all text nodes as far as possible and execute whitespace processing on
        // them
        var text = '';
        var textStartIndex = 0;
        var childrenToRemove = [];
        for (var c = 0; c < children.length; c++) {
          var child = children[c];
          if (child.nodeType === 3) {
            text += child.nodeValue;
            if (c === (children.length - 1)) {
              wsp.handleTextBlock(text, children, textStartIndex, c,
                childrenToRemove, trimEdges);
            }
          } else {
            if (textStartIndex < c) {
              wsp.handleTextBlock(text, children, textStartIndex, c - 1,
                childrenToRemove, trimEdges);
            }
            textStartIndex = c + 1;
            text = '';
            wsp.processStructure(context, child, com.isTag(child,
              com.EDITBLOCK_TAGS), removalRules);
          }
        }
        // remove blocks that are superfluous by now
        for (var r = 0; r < childrenToRemove.length; r++) {
          dom.removeChild(childrenToRemove[r]);
        }
      },

      /**
       * <p>Executes some "super-structural" normalizing.</p>
       * <p>"Super-structural" means that the text nodes of several hierarchical levels
       * are considered for normalizing whitespace. For example,
       * "Some.&lt;b&gt;.text.&lt;/b&gt;" should be normalized to
       * "Some.&lt;b&gt;text&lt;/b&gt;", which can only be done by considering text
       * nodes on different hierarchical levels.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The structural node to be normalized
       */
      normalizeSuperStructural: function (context, dom) {
        var wsp = CUI.rte.WhitespaceProcessor;
        var children = dom.childNodes;
        var childCnt = children.length;
        var childrenToRemove = [];
        var child;
        for (var c = 1; c < childCnt; c++) {
          child = children[c];
          if (!com.isTag(child, wsp.AS_IS_TAGS)) {
            var prevChild = children[c - 1];
            var textChild = com.getFirstTextChild(child, false, true);
            var prevTextChild = com.getLastTextChild(prevChild, false, true);
            if (textChild && prevTextChild) {
              var text = textChild.nodeValue;
              var prevText = prevTextChild.nodeValue;
              if (com.strStartsWith(text, ' ') && com.strEndsWith(prevText, ' ')) {
                if ((child.nodeType === 3) && (prevChild.nodeType === 1)) {
                  // convert "a <b> b </b> c" to "a <b>b</b> c" rather than to
                  // "a <b>b </b>c"
                  prevText = wsp.normalizeWhitespace(prevText, false, true);
                  prevTextChild.nodeValue = prevText;
                  if (prevText.length === 0) {
                    childrenToRemove.push(prevTextChild);
                  }
                } else {
                  text = wsp.normalizeWhitespace(text, true, false);
                  textChild.nodeValue = text;
                  if (text.length === 0) {
                    childrenToRemove.push(textChild);
                  }
                }
              }
            }
          }
        }
        // remove blocks that are superfluous by now
        for (var r = 0; r < childrenToRemove.length; r++) {
          child = childrenToRemove[r];
          child.parentNode.removeChild(child);
        }
      },

      /**
       * <p>Trims and removes empty text nodes between blocks of the specified parent
       * node.</p>
       * <p>For example, "&lt;td&gt;...&lt;p&gt;Para&lt;/p&gt;....&lt;/td&gt;" should be
       * normalized to "&lt;td&gt;&lt;p&gt;Para&lt;/p&gt;&lt;/td&gt;";
       * "&lt;td&gt;..Text..&lt;p&gt;Para&lt;/p&gt;..Text..&lt;/td&gt;" to
       * "&lt;td&gt;Text&lt;p&gt;Para&lt;/p&gt;Text&lt;/td&gt;"
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The parent node to be processed
       */
      handleTextNodesBetweenBlocks: function (context, dom) {
        var wsp = CUI.rte.WhitespaceProcessor;
        var children = dom.childNodes;
        var childCnt = children.length;
        // remove all empty text nodes if they are preceded or succeed by a block
        for (var c = childCnt - 1; c >= 0; c--) {
          var child = children[c];
          if (child.nodeType === 3) {
            var text = child.nodeValue;
            var noTextCheck = text.replace(wsp.WHITESPACEONLY_REGEX, '');
            var hasBlockSiblingLeft = false;
            var hasBlockSiblingRight = false;
            var prevSib = child.previousSibling;
            if (prevSib) {
              hasBlockSiblingLeft = com.isTag(prevSib, com.BLOCK_TAGS) ||
                com.isTag(prevSib, com.EDITBLOCK_TAGS);
            }
            var nextSib = child.nextSibling;
            if (nextSib) {
              hasBlockSiblingRight = com.isTag(nextSib, com.BLOCK_TAGS) ||
                com.isTag(nextSib, com.EDITBLOCK_TAGS);
            }
            if (hasBlockSiblingLeft || hasBlockSiblingRight) {
              if (noTextCheck.length === 0) {
                dom.removeChild(child);
              } else {
                text = wsp.normalizeWhitespace(text, hasBlockSiblingLeft,
                  hasBlockSiblingRight);
                if (text.length > 0) {
                  child.nodeValue = text;
                } else {
                  dom.removeChild(child);
                }
              }
            }
          }
        }
      },

      /**
       * <p>Removes all child nodes that match the specified removal rules.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The parent node
       * @param {Object[]} removalRules Rules that define the nodes that have to be
       *        removed before whitespace processing is being applied
       */
      removeUnsupportedNodes: function (context, dom, removalRules) {
        if (!removalRules) {
          return;
        }
        var children = dom.childNodes;
        var childCnt = children.length;
        var ruleCnt = removalRules.length;
        for (var c = childCnt - 1; c >= 0; c--) {
          var child = children[c];
          for (var r = 0; r < ruleCnt; r++) {
            var rule = removalRules[r];
            var mustRemove = false;
            if ((rule.tagName !== null && rule.tagName !== undefined) && com.isTag(child, rule.tagName)) {
              mustRemove = true;
            } else if ((rule.namespace !== null && rule.namespace !== undefined)) {
              var namespace = com.getNamespace(child);
              if (namespace !== null && namespace !== undefined) {
                var nspcRules = rule.namespace;
                if (!CUI.rte.Utils.isArray(nspcRules)) {
                  nspcRules = [nspcRules];
                }
                var nspcRuleCnt = nspcRules.length;
                for (var n = 0; n < nspcRuleCnt; n++) {
                  var ruleNspc = nspcRules[n];
                  if ((ruleNspc === '*') || (namespace === ruleNspc)) {
                    mustRemove = true;
                    break;
                  }
                }
              }
            } else if ((rule.nodeType !== null && rule.nodeType !== undefined) && (child.nodeType === rule.nodeType)) {
              mustRemove = true;
            } else if ((rule.fn !== null && rule.fn !== undefined) && (rule.fn(child))) {
              mustRemove = true;
            }
            if (mustRemove) {
              if (!rule.keepChildren) {
                dom.removeChild(child);
              } else {
                var delta = child.childNodes.length;
                dpr.removeWithoutChildren(child);
                // re-scan moved nodes
                if (delta > 0) {
                  c += delta;
                }
              }
              break;
            }
          }
        }
      },

      /**
       * <p>Processes a DOM structure recursively.</p>
       * <p>Note that leading and trailing whitespace (as specified by the trimEdges
       * parameter) should be trimmed for edit block elements only.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The structural DOM node to be processed
       * @param {Boolean} trimEdges True if trailing and leading whitespace must be
       *        trimmed
       * @param {Object[]} removalRules Rules that define the nodes that have to be
       *        removed before whitespace processing is being applied
       * @private
       */
      processStructure: function (context, dom, trimEdges, removalRules) {
        var wsp = CUI.rte.WhitespaceProcessor;
        // keep "as is tags" as they are (don't change anything for "pre" tag, etc.)
        if (com.isTag(dom, wsp.AS_IS_TAGS)) {
          return;
        }
        wsp.removeUnsupportedNodes(context, dom, removalRules);
        if (com.isTag(dom, wsp.NO_TEXT_TAGS)) {
          wsp.handleNoTextStructure(context, dom, removalRules);
          return;
        }
        wsp.cleanTextNodes(context, dom, trimEdges, removalRules);
        wsp.normalizeSuperStructural(context, dom);
        wsp.handleTextNodesBetweenBlocks(context, dom);
      },

      /**
       * <p>Processes the specified node recursively by removing all unnecessary
       * whitespace.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The element to be processed
       * @param {Object[]} removalRules Rules that define what nodes will be removed
       *        before whitespace rules are applied
       * @param {Boolean} omitDefaultRemoveRules True if default remove rules will be
       *        omitted; false if default remove rules have to be be applied
       */
      process: function (context, dom, removalRules, omitDefaultRemoveRules) {
        var wsp = CUI.rte.WhitespaceProcessor;
        if (!omitDefaultRemoveRules) {
          if (removalRules !== null && removalRules !== undefined) {
            removalRules = com.arrayCopy(removalRules);
            com.arrayAdd(removalRules, wsp.DEFAULT_REMOVAL_RULES);
          } else {
            removalRules = wsp.DEFAULT_REMOVAL_RULES;
          }
        }
        if (com.isTag(dom, com.EDITBLOCK_TAGS)) {
          wsp.processStructure(context, dom, true, removalRules);
        } else if (!com.isTag(dom, wsp.AS_IS_TAGS)) {
          if (dom.nodeType === 1) {
            wsp.processStructure(context, dom, true, removalRules);
          } else if (dom.nodeType === 3) {
            var text = dom.nodeValue;
            dom.nodeValue = wsp.normalizeWhitespace(text, true, true);
          } else {
            // nodes of an unsupported type get removed immediately
            dom.parentNode.removeChild(dom);
          }
        }
      },

      AS_IS_TAGS: ['pre'],

      NO_TEXT_TAGS: ['table', 'tbody', 'thead', 'tr', 'ul', 'ol'],

      WHITESPACE_REGEX: /[ \n\r\t]/g,

      MULTISPACE_REGEX: / {2,}/g,

      WHITESPACEONLY_REGEX: / /g,

      DEFAULT_REMOVAL_RULES: [{
        // Commentary nodes
        'nodeType': 8
      }, {
        // Processing instructions
        'nodeType': 7
      }, {
        // tags that are not suitable for content
        'tagName': ['meta', 'link', 'style', 'script'],
        'keepChildren': false
      }, {
        // MS Word specific, namespaced tags, to keep content for
        'namespace': ['st1'],
        'keepChildren': true
      }, {
        // other namedspace tags, to be removed completely
        'namespace': ['*']
      }
      ]

    };

  }());
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.NodeList
 * @private
 * <p>Class that implements a node list that can be used to manipulate document ranges
 * more easily.</p>
 * <p>Some explanation on the terms used:</p>
 * <ul>
 *   <li>Document range - is a fragment of a document, determined by its first character
 *   position and the number of characters. This is the same model as used by
 *   {@link CUI.rte.Selection}.</li>
 *   <li>Common ancestor - refers to the DOM node that is the direct parent of all nodes of
 *   the represented document range.</li>
 *   <li>"Aligned" - most often, document ranges will start and end in the middle of a DOM
 *   text node. This is referred to as "unaligned". If a document range starts or ends at
 *   the beginning/end of a DOM text node, it is referred to as "aligned".</li>
 * </ul>
 * <p>Some explanation on how this class works:</p>
 * <ul>
 *   <li>Use {@link CUI.rte.DomProcessor#createNodeList} to create a corresponding
 *   node list.</li>
 *   <li>Use {@link #surround} to surround the document range with a certain tag. For
 *   example, you could surround the document range with a "span" tag that contains
 *   a "class" attribute to style the range accordingly. {@link #surround} will handle
 *   some common rules to ensure a correct nesting of tags. See the documentation of
 *   {@link #surround} for further information about what is supported.</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.NodeList = new Class({

    toString: 'NodeList',

    /**
     * @property nodes
     */
    nodes: null,

    /**
     * @property commonAncestor
     */
    commonAncestor: null,

    /**
     * @property nodesChanged
     */
    nodesChanged: null,

    /**
     * @cfg {Boolean} removeExistingStructuresOnSurround
     * True if existing structures of the surrounding tags should be removed; defaults to
     * true; example: Surrounding "This is &lt;b&gt;bold&lt;/b&gt;" will result in
     * "&lt;b&gt;This is bold&lt;/b&gt;" if this option has been set to true; else
     * "&lt;b&gt;This is &lt;b&gt;bold&lt;/b&gt;&lt;/b&gt;"
     */
    removeExistingStructuresOnSurround: false,


    construct: function (config) {
      config = config || {};
      CUI.rte.Utils.applyDefaults(config, {
        'removeExistingStructuresOnSurround': true
      });
      CUI.rte.Utils.apply(this, config);
      this.nodes = [];
      this.nodesChanged = [];
    },

    /**
     * @private
     */
    addChildNode: function (nodeToAdd, nodeList, index) {
      nodeToAdd.parentNode = null;
      nodeToAdd.nodeList = nodeList;
      if (!index || (index >= this.nodes.length)) {
        this.nodes.push(nodeToAdd);
      } else {
        this.nodes.splice(index, 0, nodeToAdd);
      }
    },

    /**
     * @private
     */
    removeChildNode: function (node) {
      var removeIndex = this.getTopLevelNodeIndex(node);
      if (removeIndex < 0) {
        return -1;
      }
      this.nodes.splice(removeIndex, 1);
      return removeIndex;
    },

    /**
     * @private
     */
    createTextNode: function (dom, startOffs, endOffs, parentNode) {
      var textLen = CUI.rte.Common.getNodeCharacterCnt(dom);
      if (textLen > 0) {
        var offset = 0;
        var charCnt = textLen;
        if (startOffs !== null && startOffs !== undefined) {
          offset = startOffs;
          charCnt -= startOffs;
        }
        if (endOffs !== null && endOffs !== undefined) {
          charCnt -= (textLen - endOffs);
        }
        // there are situations where charCnt can get invalid (when selecting the
        // [virtual] character "behind" an edit block), which we have to correct to
        // a charCnt inside the boundaries of the node
        if ((offset + charCnt) > textLen) {
          charCnt = textLen - offset;
        }
        var textNode = new CUI.rte.DomProcessor.TextNode(dom, offset, charCnt);
        if (!parentNode) {
          this.addChildNode(textNode, this);
        } else {
          parentNode.addChildNode(textNode, this);
        }
      }
    },

    /**
     * @private
     */
    createStructuralNode: function (dom, parentNode) {
      var strucNode = new CUI.rte.DomProcessor.StructuralNode(dom);
      if (!parentNode) {
        this.addChildNode(strucNode, this);
      } else {
        parentNode.addChildNode(strucNode, this);
      }
      return strucNode;
    },

    /**
     * @private
     */
    createAncestors: function (context, node, startOffs, endOffs) {
      var com = CUI.rte.Common;
      var isInitialNodeSkipped = com.isOneCharacterNode(node) && (startOffs === 0);
      var addNode = !isInitialNodeSkipped;
      var path = [];
      if (node === this.commonAncestor) {
        if (addNode) {
          path.push(node);
        }
      } else {
        do {
          if (addNode) {
            path.push(node);
          } else {
            addNode = true;
          }
          node = com.getParentNode(context, node);
        } while (node && (node !== this.commonAncestor));
      }
      var parentNode = null;
      var pathCnt = path.length;
      var commonNode = null;
      for (var pathIndex = pathCnt - 1; pathIndex >= 0; pathIndex--) {
        var i;
        if (pathIndex === (pathCnt - 1)) {
          for (i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].dom === path[pathIndex]) {
              commonNode = this.nodes[i];
              break;
            }
          }
        } else if (commonNode) {
          var newCommonNode = null;
          for (i = 0; i < commonNode.childNodes.length; i++) {
            if (commonNode.childNodes[i].dom === path[pathIndex]) {
              newCommonNode = commonNode.childNodes[i];
              break;
            }
          }
          commonNode = newCommonNode;
        }
        if (!commonNode) {
          if (path[pathIndex].nodeType === 1) {
            parentNode = this.createStructuralNode(path[pathIndex], parentNode);
          } else if (path[pathIndex].nodeType === 3) {
            this.createTextNode(path[pathIndex], startOffs, endOffs, parentNode);
          }
        } else {
          parentNode = commonNode;
        }
      }
      return {
        'parentNode': parentNode,
        'isInitialNodeSkipped': isInitialNodeSkipped
      };
    },

    /**
     * @private
     */
    createList: function (context, selection) {
      var com = CUI.rte.Common;
      var startNode = selection.startNode;
      var endNode = selection.endNode;
      if (endNode === null || endNode === undefined) {
        endNode = startNode;
      }
      var startOffs = selection.startOffset;
      var endOffs = null;
      // build ancestor nodes
      var processingNode = selection.startNode;
      if (processingNode.nodeType === 3) {
        if (startNode === endNode) {
          if (selection.endOffset !== null && selection.endOffset !== undefined) {
            endOffs = selection.endOffset + 1;
          } else {
            endOffs = selection.startOffset;
          }
        }
      }
      var ancestorDef = this.createAncestors(context, processingNode, startOffs, endOffs);
      var parentNode = ancestorDef.parentNode;
      if (startNode === endNode) {
        return;
      }

      var isInitialNodeSkipped = ancestorDef.isInitialNodeSkipped;
      var isFirstNode = true;
      while (true) {
        // determine next node to process
        var children = processingNode.childNodes;
        if (children.length > 0) {
          processingNode = processingNode.firstChild;
        } else {
          if (!(isInitialNodeSkipped && isFirstNode)) {
            if ((processingNode.nodeType === 1) && parentNode) {
              parentNode = parentNode.parentNode;
            }
          }
          if (processingNode.nextSibling) {
            processingNode = processingNode.nextSibling;
          } else {
            while (true) {
              processingNode = com.getParentNode(context, processingNode);
              parentNode = parentNode.parentNode;
              if (!processingNode) {
                break;
              }
              if (processingNode.nextSibling) {
                processingNode = processingNode.nextSibling;
                break;
              }
            }
          }
        }
        isFirstNode = false;
        // handle end node
        startOffs = null;
        endOffs = null;
        if (processingNode === endNode) {
          if (endNode.nodeType === 3) {
            endOffs = selection.endOffset + 1;
          }
        }
        // add node
        if (processingNode.nodeType === 1) {
          parentNode = this.createStructuralNode(processingNode, parentNode);
        } else if (processingNode.nodeType === 3) {
          this.createTextNode(processingNode, startOffs, endOffs, parentNode);
        }
        // check for end condition
        if (processingNode === endNode) {
          break;
        }
      }
    },

    createFromDocument: function (context, selection) {
      var dpr = CUI.rte.DomProcessor;
      var sel = CUI.rte.Selection;
      this.nodes.length = 0;
      // corner case: invalid selection - may happen on IE while focus transfer
      if (!selection.startNode) {
        return selection;
      }
      // work on a copy of the processing selection, as it gets altered
      selection = {
        'startNode': selection.startNode,
        'startOffset': selection.startOffset,
        'endNode': selection.endNode,
        'endOffset': selection.endOffset,
        'isEOT': selection.isEOT
      };
      // Use normalized selection if we have a selection to ensure
      // start node does not point "behind" a node, but points to the
      // first actually included node. If the selection represents a caret,
      // we'll have to use the un-normalized selection, because the position
      // behind a node may have different impact than the position before
      // the succeeding node (for example, t|<b>ex</b>t will insert a
      // character in plaintext, whereas t<b>|ex</b>t will insert a bold
      // character.
      if (sel.shouldNormalizePSelForNodeList(context, selection)) {
        sel.normalizeProcessingSelection(context, selection);
      }
      // corner case: caret at end of the text will create an empty list
      if (selection.isEOT) {
        var children = context.root.childNodes;
        this.commonAncestor = children[children.length - 1];
        return selection;
      }
      // adjust end node to point to the last inclusive node
      selection = sel.adaptToInclusiveEndNode(context, selection);
      if ((selection.startNode === selection.endNode) || (selection.endNode === null || selection.endNode === undefined)) {
        this.commonAncestor = selection.startNode.parentNode;
      } else {
        this.commonAncestor = dpr.getCommonAncestor(context, selection.startNode,
          selection.endNode);
      }
      if (!this.commonAncestor) {
        throw new Error('No common ancestor found, cannot continue.');
      }
      this.createList(context, selection);
      return selection;
    },

    /**
     * @private
     */
    createDomChildren: function (dom, parentNode) {
      var children = dom.childNodes;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.nodeType === 1) {
          var listNode = this.createStructuralNode(child, parentNode);
          this.createDomChildren(child, listNode);
        } else if (child.nodeType === 3) {
          this.createTextNode(child, null, null, parentNode);
        }
      }
    },

    createFromDomNodes: function (context, domNodes) {
      var dpr = CUI.rte.DomProcessor;
      this.commonAncestor = domNodes[0];
      var nodeCnt = domNodes.length;
      for (var i = 1; i < nodeCnt; i++) {
        if (!CUI.rte.Common.isAncestor(context, this.commonAncestor, domNodes[i])) {
          this.commonAncestor = dpr.getCommonAncestor(context, this.commonAncestor,
            domNodes[i]);
        }
      }
      if (!this.commonAncestor) {
        throw new Error('No common ancestor found, cannot continue.');
      }
      for (i = 0; i < nodeCnt; i++) {
        var dom = domNodes[i];
        var ancestorDef = this.createAncestors(context, dom, null, null);
        this.createDomChildren(dom, ancestorDef.parentNode);
      }
    },

    /**
     * <p>Removes empty side-structures from the node list.</p>
     * <p>Side-structures are selection-leftovers, for example if a selection begins after
     * the last character of an editing block.</p>
     */
    removeEmptySideStructures: function () {
      var com = CUI.rte.Common;
      if (this.nodes.length > 0) {
        var nodeToCheck = this.nodes[0];
        if (nodeToCheck.isEmptySideStructure()) {
          this.nodes.splice(0, 1);
        }
        if (this.nodes.length > 0) {
          var nodeIndex = this.nodes.length - 1;
          nodeToCheck = this.nodes[nodeIndex];
          if (nodeToCheck.isEmptySideStructure()) {
            this.nodes.splice(nodeIndex, 1);
          }
        }
        // adjust to new ancestor if possible
        while (this.nodes.length === 1) {
          var newCommonAncestor = this.nodes[0];
          if (!com.isCharacterNode(newCommonAncestor.dom)) {
            this.commonAncestor = newCommonAncestor.dom;
            this.nodes.length = 0;
            if (newCommonAncestor.childNodes) {
              var childCnt = newCommonAncestor.childNodes.length;
              for (var c = 0; c < childCnt; c++) {
                var childToMove = newCommonAncestor.childNodes[c];
                childToMove.parentNode = null;
                this.nodes.push(childToMove);
              }
            }
          } else {
            break;
          }
        }
      }
    },

    hasContainers: function () {
      var nodeCnt = this.nodes.length;
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        var nodeToProcess = this.nodes[nodeIndex];
        if (nodeToProcess.hasContainers()) {
          return true;
        }
      }
      return false;
    },

    isAligned: function (fn) {
      if (!fn) {
        fn = function (node) {
          return node.isAligned();
        };
      }
      var nodeCnt = this.nodes.length;
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        var nodeToProcess = this.nodes[nodeIndex];
        if (!fn(nodeToProcess)) {
          return false;
        }
      }
      return true;
    },

    /**
     * Creates a list of all edit blocks contained in the node list.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Boolean} considerAncestors True if ancestor nodes should also be considered
     *        if no edit blocks were found in the node list itself
     */
    getEditBlocksByAuxRoots: function (context, considerAncestors) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var nodeCnt = this.nodes.length;
      var b, editBlocks;
      var segmentedBlocks = [];
      var currentAuxRoot = null;
      var findBlocks = function (node) {
        var dom = node.dom;
        if (com.isTag(dom, dpr.AUXILIARY_ROOT_TAGS)) {
          editBlocks = [];
          segmentedBlocks.push(editBlocks);
          editBlocks.push(dom);
          currentAuxRoot = dom;
        } else if (com.isTag(dom, com.EDITBLOCK_TAGS)) {
          var nodeAuxRoot = dpr.getAuxRootNode(context, dom);
          if (nodeAuxRoot !== currentAuxRoot) {
            editBlocks = [];
            segmentedBlocks.push(editBlocks);
            currentAuxRoot = nodeAuxRoot;
          }
          editBlocks.push(dom);
        }
      };
      for (var n = 0; n < nodeCnt; n++) {
        this.nodes[n].execRecursively(findBlocks);
      }
      if ((segmentedBlocks.length === 0) && considerAncestors) {
        var domToCheck = this.commonAncestor;
        while (domToCheck) {
          if (com.isTag(domToCheck, com.EDITBLOCK_TAGS)) {
            segmentedBlocks.push([domToCheck]);
            break;
          }
          domToCheck = com.getParentNode(context, domToCheck);
        }
      }
      for (b = segmentedBlocks.length - 1; b >= 0; b--) {
        var blocks = segmentedBlocks[b];
        var bl = blocks.length;
        if (bl === 0) {
          segmentedBlocks.splice(b, 1);
        } else if (com.isTag(blocks[0], dpr.AUXILIARY_ROOT_TAGS)) {
          if (bl > 1) {
            blocks.splice(0, 1);
          } else if (dpr.hasEditBlocks(blocks[0])) {
            segmentedBlocks.splice(b, 1);
          }
        }
      }
      return segmentedBlocks;
    },

    normalize: function () {
      var invalidatedNodes = [];
      var childCnt = this.nodes.length;
      for (var c = 0; c < childCnt; c++) {
        this.nodes[c].normalize(this, invalidatedNodes);
      }
      var removeCnt = invalidatedNodes.length;
      for (var r = 0; r < removeCnt; r++) {
        this.remove(invalidatedNodes[r]);
      }
    },

    /**
     * @private
     */
    createTopLevelDomNodes: function () {
      var domNodes = [];
      var nodeCnt = this.nodes.length;
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        domNodes.push(this.nodes[nodeIndex].dom);
      }
      return domNodes;
    },

    /**
     * @private
     */
    getTopLevelNodeIndex: function (node) {
      var nodeCnt = this.nodes.length;
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        var nodeToProcess = this.nodes[nodeIndex];
        if (nodeToProcess === node) {
          return nodeIndex;
        }
      }
      return -1;
    },

    /**
     * <p>"Surrounds" the node list (document range) with the given tag.</p>
     * <p>The method can handle the following use-cases ("|" marks the start/end of the
     * document range; surrounding tag is &lt;span class="test"&gt;:</p>
     * <ul>
     *   <li>Splitting simple text nodes: <i>Ex|amp|le</i> -&gt;
     *   <i>Ex&lt;span class="test"&gt;amp&lt;/span&gt;le</i></li>
     *   <li>Handling structural nodes (as "b", "i", "u", ...): <i>This |is
     *   &lt;b&gt;bold&lt;/b&gt;| text</i> -&gt; <i>This &lt;span class="test"&gt;i
     *   &lt;b&gt;bold&lt;/b&gt;&lt;/span&gt; text</i></li>
     *   <li>Handling container nodes (as "div", "p"): <i>|&lt;p&gt;Paragraph 1&lt;/p&gt;
     *   &lt;p&gt;Paragraph 2&lt;/p&gt;|</i> -&gt; <i>|&lt;p&gt;&lt;span class="test"&gt;
     *   Paragraph 1&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span class="test"&gt;Paragraph 2
     *   &lt;/span&gt;&lt;/p&gt;|</i></li>
     * </ul>
     * <p>This method does not optimize the sub tree (for example, remove unnecessary nodes
     * that will be created if for example <i>|this is &lt;b&gt;bold&lt;/b&gt;|</i> is
     * surrounded by another "b" tag (the result would then be
     * <i>&lt;b&gt;this is &lt;b&gt;bold&lt;/b&gt;&lt;/b&gt;</i>).</p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {String} tag Name of tag the document range has to be surrounded with
     * @param {Object} attribs Table of attributes to be used with the surrounding tag
     * @return {Array} Array with all additionally created nodes
     */
    surround: function (context, tag, attribs) {
      var dpr = CUI.rte.DomProcessor;
      var com = CUI.rte.Common;
      var sel = CUI.rte.Selection;
      this.removeEmptySideStructures();
      this.nodesChanged.length = 0;
      var nodeCnt, nodeIndex;
      var nodesAdded = [];
      // normalize text nodes
      this.normalize();
      // if everything is "aligned" and there are no containers, we can simply
      // insert a new structure node in between the existing nodes
      var doComplexSurround = true;
      if (this.isAligned() && !this.hasContainers()) {
        var containerNode = dpr.restructureAsChild(context, this.commonAncestor,
          this.createTopLevelDomNodes(), tag, attribs);
        var nodesToCopy = this.nodes;
        this.nodes = [];
        var parentNode = this.createStructuralNode(containerNode, null);
        this.nodes.push(parentNode);
        nodeCnt = nodesToCopy.length;
        for (nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
          parentNode.addChildNode(nodesToCopy[nodeIndex], this);
        }
        this.nodesChanged.push(containerNode);
        doComplexSurround = false;
        nodesAdded.push(containerNode);
      }
      if (doComplexSurround) {
        // must do the surround node by node, unfortunately ...
        nodeCnt = this.nodes.length;
        var surroundingNode = null;
        for (nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
          var nodeToSurround = this.nodes[nodeIndex];
          surroundingNode = nodeToSurround.surround(context, surroundingNode, tag,
            attribs, nodesAdded);
        }
      }
      if (this.nodesChanged.length > 0) {
        var startNode = this.nodesChanged[0];
        var endNode = this.nodesChanged[this.nodesChanged.length - 1];
        if (startNode === endNode) {
          endNode = com.getLastChild(startNode);
        }
        var selection = dpr.removeDuplicateStructures(context, startNode, endNode);
        dpr.joinIdenticalStructures(context, selection.startNode, true);
        dpr.joinIdenticalStructures(context, selection.endNode, false);
        if (doComplexSurround) {
          // todo table cell selection cannot work this way, as selection is derived from changed nodes
          if (selection.cellSelection && selection.cellSelection.cells) {
            this.createFromDomNodes(context, selection.cellSelection.cells);
          } else {
            var normalizeNode = function (node, isStart) {
              var offset = null;
              if (com.isOneCharacterNode(node)) {
                offset = (isStart ? null : 0);
              } else if (node.nodeType === 3) {
                offset = (isStart ? 0 : node.nodeValue.length);
              } else if (node.nodeType === 1) {
                var ftn = com.getFirstTextChild(node, true);
                if (ftn) {
                  node = ftn;
                  offset = (isStart ?
                    sel.getFirstSelectionOffset(context, ftn)
                    : sel.getLastSelectionOffset(context, ftn, true));
                }
              }
              return {
                'node': node,
                'offset': offset
              };
            };
            var startDef = normalizeNode(selection.startNode, true);
            selection.startNode = startDef.node;
            selection.startOffset = startDef.offset;
            var endDef = normalizeNode(selection.endNode, false);
            selection.endNode = endDef.node;
            selection.endOffset = endDef.offset;
            this.createFromDocument(context, selection);
          }
        }
      }
      return nodesAdded;
    },

    removeUnnecessaryLinebreaks: function (context, processAncestors) {
      var ancestorContainer;
      var dpr = CUI.rte.DomProcessor;
      var com = CUI.rte.Common;
      if (processAncestors) {
        var dom = this.commonAncestor;
        while (dom) {
          if (dom.nodeType === 1) {
            if (com.isRootNode(context, dom)) {
              break;
            }
            if (dpr.getTagType(dom) === dpr.CONTAINER) {
              ancestorContainer = dom;
              break;
            }
          }
          dom = com.getParentNode(context, dom);
        }
      }
      var nodeCnt = this.nodes.length;
      var nodesToRemove = [];
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        var nodeToProcess = this.nodes[nodeIndex];
        if (nodeToProcess.nodeType === dpr.DOM_NODE) {
          nodeToProcess.getUnnecessaryLinebreaks(ancestorContainer, nodesToRemove);
        }
      }
      var removeCnt = nodesToRemove.length;
      for (var removeIndex = 0; removeIndex < removeCnt; removeIndex++) {
        var nodeToRemove = nodesToRemove[removeIndex];
        var parent = nodeToRemove.parentNode;
        parent = (parent ? parent : this);
        dpr.removeWithoutChildren(nodeToRemove.dom);
        parent.removeChildNode(nodeToRemove);
      }
    },

    /**
     * @private
     */
    getByDomRec: function (node, dom) {
      if (node.dom === dom) {
        return node;
      }
      if (node.childNodes) {
        var childCnt = node.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          var nodeFound = this.getByDomRec(node.childNodes[c], dom);
          if (nodeFound) {
            return nodeFound;
          }
        }
      }
      return null;
    },

    /**
     * Determine a node by the DOM object it represents.
     * @param {HTMLElement} dom The DOM element
     * @param {Boolean} isRecursive True if the node should be determined recursively
     * @returns {*} The node; null if the node could not be found
     */
    getByDom: function (dom, isRecursive) {
      var nodeCnt = this.nodes.length;
      for (var n = 0; n < nodeCnt; n++) {
        var nodeToCheck = this.nodes[n];
        if (nodeToCheck.dom === dom) {
          return nodeToCheck;
        }
        if (isRecursive) {
          var nodeFound = this.getByDomRec(nodeToCheck, dom);
          if (nodeFound) {
            return nodeFound;
          }
        }
      }
      return null;
    },

    /**
     * Checks if the specified DOM object is contained in the node list.
     * @param {HTMLElement} dom The DOM object
     * @param {Boolean} isRecursive True if the list should be searched recursively
     * @returns {Boolean} True if the specified DOM object is part of the node list
     */
    contains: function (dom, isRecursive) {
      var domNode = this.getByDom(dom, isRecursive);
      return (domNode !== null && domNode !== undefined);
    },

    /**
     * <p>"Isolates" a node by moving "adjacent content" to adjacent structures left or
     * right.</p>
     * <p>For a definition of "adjacent content": see (for example)
     * @link{CUI.rte.NodeList#handleAlignment}.</p>
     * @private
     */
    isolateNode: function (node, leftTarget, rightTarget) {
      var com = CUI.rte.Common;
      var childIndex = com.getChildIndex(node);
      var parent = node.parentNode;
      var childToMove, c;
      for (c = 0; c < childIndex; c++) {
        childToMove = parent.childNodes[0];
        parent.removeChild(childToMove);
        leftTarget.appendChild(childToMove);
      }
      var childCnt = parent.childNodes.length;
      for (c = childCnt - 1; c >= 1; c--) {
        childToMove = parent.childNodes[c];
        parent.removeChild(childToMove);
        rightTarget.insertBefore(childToMove, rightTarget.firstChild);
      }
    },

    /**
     * <p>Ensures that the node list parent contains the node list exclusively.</p>
     * <p>Adjacent nodes will be moved out to the "adjactent parents" left and right of the
     * node list parent. Text nodes that are not "aligned" will be split and the unaligned
     * parts will be moved out to the adjacent parents.</p>
     * <p>For example: Node list initially looks like <i>&lt;p&gt;ABC &lt;b&gt;DEF |GHI| JKL
     * &lt;/b&gt; MNO&lt;/p&gt;</i> (<i>|</i> denoting the start and the end of the node
     * list). This needs to be transformed into <i>&lt;p&gt;ABC &gt;b&lt;&lt;/b&gt;&lt;b&gt;
     * DEF |GHI| JKL&lt;/b&gt;&lt;b&gt;&lt;/b&gt; MNO&lt;/p&gt;</i> first (not part of this
     * method).<br>
     * This method will transform this into <i>&lt;p&gt;ABC &gt;b&lt;DEF &lt;/b&gt;&lt;b&gt;
     * |GHI|&lt;/b&gt;&lt;b&gt; JKL&lt;/b&gt; MNO&lt;/p&gt;</i>. Note that the original
     * &lt;b&gt; tag represents the node list exclusively afterwards.</p>
     * @param {CUI.rte.EditContext} context The editor context
     * @param {[]} parentNodes Array with the parent nodes; first element: the node list's
     *        parent; second element: the parent for adjacent nodes on the left; third
     *        element: the parent for adjacent nodes on the right
     * @private
     */
    handleAlignment: function (context, parentNodes) {
      var nodeListParent = parentNodes[0];
      var parentLeft = parentNodes[1];
      var parentRight = parentNodes[2];
      // handle stuff that is completely outside the node list (needs to be moved out to
      // the respective "adjacent parent")
      CUI.rte.NodeList.moveToAdjacentParents(this.nodes, nodeListParent, parentLeft,
        parentRight);
      // handle stuff inside the node list (text nodes that are not aligned need to be
      // split and the fragment that is not part of the node list needs to be moved
      // out to the respective "adjacent parent")
      var childCnt = this.nodes.length;
      for (var c = 0; c < childCnt; c++) {
        this.nodes[c].split(context, parentLeft, parentRight);
      }
    },

    /**
     * Removes all instances the specified element from the node list.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {String} tag Name of the tag to be removed
     * @param {Object} attribs Attribute list; may be null
     * @param {Boolean} processAncestors True, if the node list's ancestor nodes should also
     *        be considered for removing
     */
    removeNodesByTag: function (context, tag, attribs, processAncestors) {
      var dpr = CUI.rte.DomProcessor;
      var com = CUI.rte.Common;
      // normalize text nodes
      this.normalize();
      var c, childCnt;
      var pNode = null;
      if (processAncestors) {
        // handle removals in ancestor nodes
        var nodeToProcess = this.commonAncestor;
        var path = [];
        var copy1, copy2, pNode1, pNode2;
        while (nodeToProcess) {
          // first, we need to create the "adjacent parents", where we put the
          // the content that is not part of the node list; for example (| denotes
          // start and end of the node list):
          // <p>ABC <b>DEF <i>GHI |JKL| MNO</i> PQR</b> STU</p>
          // will be updated to
          // <p>ABC <b><i></i></b><b><i>GHI |JKL| MNO</i></b><b><i></i></b><b> PQR</b>
          // STU</p>
          var nodeParent = com.getParentNode(context, nodeToProcess);
          if (nodeToProcess.nodeType === 1) {
            if (dpr.getTagType(nodeToProcess) === dpr.CONTAINER) {
              break;
            }
            if (com.isTag(nodeToProcess, tag) &&
              (!attribs || com.hasAttributes(nodeToProcess, attribs))) {
              pNode = nodeToProcess.parentNode;
              pNode1 = nodeToProcess.cloneNode(false);
              pNode.insertBefore(pNode1, nodeToProcess);
              pNode2 = nodeToProcess.cloneNode(false);
              pNode.insertBefore(pNode2, nodeToProcess.nextSibling);
              pNode = nodeToProcess;
              while (path.length > 0) {
                pNode = path.pop();
                this.isolateNode(pNode, pNode1, pNode2);
                copy1 = pNode.cloneNode(false);
                pNode1.appendChild(copy1);
                pNode1 = copy1;
                copy2 = pNode.cloneNode(false);
                pNode2.insertBefore(copy2, pNode2.firstChild);
                pNode2 = copy2;
              }
              // here, we'll move the adjacent parts of the node list's parent
              // to the respective "adjacent parent", for example:
              // <p>ABC <b><i></i></b><b><i>GHI |JKL| MNO</i></b><b><i></i></b><b>
              // PQR</b> STU</p>
              // will be changed to
              // <p>ABC <b><i>GHI </i></b><b><i>|JKL|</i></b><b><i> MNO</i></b><b>
              // PQR</b> STU</p>
              this.handleAlignment(context, [pNode, pNode1, pNode2]);
              // and finally we can remove the node list's parent, which only
              // contains the node list's parent; for example:
              // <p>ABC <b><i>GHI </i></b><b><i>|JKL|</i></b><b><i> MNO</i></b><b>
              // PQR</b> STU</p>
              // will be changed to the desired
              // <p>ABC <b><i>GHI </i></b><i>|JKL|</i><b><i> MNO</i></b><b>
              // PQR</b> STU</p>
              com.removeNodesWithoutContent(context, pNode1);
              com.removeNodesWithoutContent(context, pNode2);
              dpr.removeWithoutChildren(nodeToProcess);
              break;
            }
            path.push(nodeToProcess);
          }
          nodeToProcess = nodeParent;
        }
      }
      // handle child removal
      childCnt = this.nodes.length;
      for (c = childCnt - 1; c >= 0; c--) {
        var childToProcess = this.nodes[c];
        if (childToProcess.nodeType === dpr.DOM_NODE) {
          childToProcess.removeNodesByTag(context, tag, attribs, this);
        }
      }
    },

    /**
     * <p>Removes a node from the list and the DOM.</p>
     * <p>Child nodes are preserved.</p>
     * @param {Node} node The node to be removed
     */
    remove: function (node) {
      var removeIndex = this.getTopLevelNodeIndex(node);
      if (removeIndex < 0) {
        node.parentNode.removeChild(node);
        return;
      }
      // DOM processing
      if (!node.isInvalidatedByNormalization) {
        CUI.rte.DomProcessor.removeWithoutChildren(node.dom);
      }
      // node list processing
      this.nodes.splice(removeIndex, 1);
      if (node.childNodes) {
        var childrenToMove = node.childNodes;
        var childCnt = childrenToMove.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          var childToMove = childrenToMove[childIndex];
          childToMove.parentNode = this;
          this.nodes.splice(removeIndex + childIndex, 0, childToMove);
        }
      }
    },

    getAnchors: function (context, anchors, checkAncestors) {
      var com = CUI.rte.Common;
      if (checkAncestors) {
        var nodeToCheck = this.commonAncestor;
        while (nodeToCheck) {
          if (nodeToCheck.nodeType === 1) {
            if (com.isRootNode(context, nodeToCheck)) {
              break;
            }
            var tagLC = nodeToCheck.tagName.toLowerCase();
            if (tagLC === 'a') {
              if (com.isAttribDefined(nodeToCheck, 'href')) {
                var anchor = {
                  'dom': nodeToCheck,
                  'href': com.getAttribute(nodeToCheck, com.HREF_ATTRIB) ||
                  com.getAttribute(nodeToCheck, 'href')
                };
                if (nodeToCheck.className) {
                  anchor['cssClass'] = nodeToCheck.className;
                }
                if (nodeToCheck.target) {
                  anchor['target'] = nodeToCheck.target;
                }
                anchors.push(anchor);
              }
            }
          }
          nodeToCheck = com.getParentNode(context, nodeToCheck);
        }
      }
      var nodeCnt = this.nodes.length;
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        var nodeToProcess = this.nodes[nodeIndex];
        if (nodeToProcess.nodeType === CUI.rte.DomProcessor.DOM_NODE) {
          nodeToProcess.getAnchors(anchors);
        }
      }
    },

    getNamedAnchors: function (context, namedAnchors, checkAncestors) {
      var com = CUI.rte.Common;
      if (checkAncestors) {
        var nodeToCheck = this.commonAncestor;
        while (nodeToCheck) {
          if (nodeToCheck.nodeType === 1) {
            if (com.isRootNode(context, nodeToCheck)) {
              break;
            }
            var anchorDef = CUI.rte.DomProcessor.checkNamedAnchor(nodeToCheck);
            if (anchorDef) {
              namedAnchors.push(anchorDef);
            }
          }
          nodeToCheck = com.getParentNode(context, nodeToCheck);
        }
      }
      var nodeCnt = this.nodes.length;
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        var nodeToProcess = this.nodes[nodeIndex];
        if (nodeToProcess.nodeType === CUI.rte.DomProcessor.DOM_NODE) {
          nodeToProcess.getNamedAnchors(namedAnchors);
        }
      }
    },

    getStyles: function (context, stylesDef, checkAncestors) {
      var com = CUI.rte.Common;
      var styles = stylesDef.styles;
      if (!styles) {
        styles = [];
        stylesDef.styles = styles;
      }
      var hasParentStyle = false;
      if (checkAncestors) {
        var nodeToCheck = this.commonAncestor;
        while (nodeToCheck) {
          if (nodeToCheck.nodeType === 1) {
            if (com.isRootNode(context, nodeToCheck)) {
              break;
            }
            var tagLC = nodeToCheck.tagName.toLowerCase();
            if (tagLC === 'span') {
              if (nodeToCheck.className) {
                hasParentStyle = true;
                styles.push({
                  'dom': nodeToCheck,
                  'className': nodeToCheck.className
                });
              }
            }
          }
          nodeToCheck = com.getParentNode(context, nodeToCheck);
        }
      }
      var continuousStyle = null;
      var hasTopLevelText = false;
      var nodeCnt = this.nodes.length;
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        var nodeToProcess = this.nodes[nodeIndex];
        if (nodeToProcess.nodeType === CUI.rte.DomProcessor.DOM_NODE) {
          var nodeState = nodeToProcess.getStyles(styles);
          continuousStyle = CUI.rte.NodeList.calcNewContState(
            continuousStyle, nodeState);
        } else {
          hasTopLevelText = true;
        }
      }
      if (continuousStyle === null || continuousStyle === undefined) {
        continuousStyle = 'unstyled';
      }
      stylesDef.isContinuousStyle = (hasParentStyle && (continuousStyle === 'unstyled')) ||
      (!hasParentStyle && (continuousStyle === 'single') && !hasTopLevelText);
    },

    containsTag: function (tagName) {
      tagName = tagName.toLowerCase();
      var nodeCnt = this.nodes.length;
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        var nodeToProcess = this.nodes[nodeIndex];
        if (nodeToProcess.nodeType === CUI.rte.DomProcessor.DOM_NODE) {
          if (nodeToProcess.containsTag(tagName)) {
            return true;
          }
        }
      }
      return false;
    },

    /**
     * @private
     */
    executeMatcherOnDom: function (dom, tagMatcher) {
      var com = CUI.rte.Common;
      var isMatching = false;
      var matcherCnt = tagMatcher.length;
      for (var matcherIndex = 0; matcherIndex < matcherCnt; matcherIndex++) {
        var matcher = tagMatcher[matcherIndex];
        if (matcher.extMatcher) {
          var result = matcher.extMatcher(dom);
          if (result.isMatching) {
            isMatching = true;
            break;
          }
        } else if (matcher.matcher) {
          if (matcher.matcher(dom)) {
            isMatching = true;
            break;
          }
        } else {
          if (com.matchesTagDef(dom, matcher)) {
            isMatching = true;
            break;
          }
        }
      }
      return isMatching;
    },

    /**
     * <p>Gets a list of all DOM nodes (contained in the node list) that are matched by the
     * specified tag matcher(s).</p>
     * <p>You can also include ancestor nodes that match the tag matcher to be included in
     * the results. If you are using this option, you can force the method to include only:
     * </p>
     * <ul>
     *   <li>Elements that are contained in the node list. If there are elements contained
     *     in the node list, the common ancestor is also checked and included if suitable
     *     (this is necessary for selections that contain a single item of a list + item(s)
     *     of a nested list, as the selection covers the text of that single item only, not
     *     the item itself).</li>
     *   <li>If no suitable elements are contained in the node list, take the first suitable
     *     ancestor element (if any).</li>
     * </ul>
     * <p>This behaviour is suitable for getting the most suitable, selected element(s)
     * inside nested structures; for example the actually selected cell(s) of a table or
     * item(s) of a list, rather than including all parent cells/list items.</p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Object[]} tagMatcher Array of tag matchers to be applied
     * @param {Boolean} checkAncestors True, if suitable ancestor elements should also be
     *        included in the results
     * @param {Boolean} breakOnFound True, if the rules defined above should be used
     *        (= consider first suitable ancestor element *only* if the node list (incl.
     *        child nodes) doesn't contain a suitable element); is considered only if
     *        checkAncestors == true
     * @return {Object[]} Array with all matching tags (properties: nodeType, isAncestor,
     *         dom)
     */
    getTags: function (context, tagMatcher, checkAncestors, breakOnFound) {
      var dpr = CUI.rte.DomProcessor;
      var com = CUI.rte.Common;
      var tags = [];
      var nodeCnt = this.nodes.length;
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        if (this.nodes[nodeIndex].nodeType === dpr.DOM_NODE) {
          this.nodes[nodeIndex].getTags(tagMatcher, tags);
        }
      }
      if (breakOnFound && (tags.length > 0)) {
        if (this.executeMatcherOnDom(this.commonAncestor, tagMatcher)) {
          tags.splice(0, 0, {
            'nodeType': null,
            'isAncestor': true,
            'dom': this.commonAncestor
          });
        }
        return tags;
      }
      if (checkAncestors) {
        var dom = this.commonAncestor;
        while (dom) {
          if (this.executeMatcherOnDom(dom, tagMatcher)) {
            tags.splice(0, 0, {
              'nodeType': null,
              'isAncestor': true,
              'dom': dom
            });
            if (breakOnFound) {
              return tags;
            }
          }
          dom = com.getParentNode(context, dom);
        }
      }
      return tags;
    },

    hasContent: function () {
      var nodeCnt = this.nodes.length;
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        if (this.nodes[nodeIndex].nodeType === CUI.rte.DomProcessor.TEXT_NODE) {
          return true;
        } else {
          if (this.nodes[nodeIndex].hasContent()) {
            return true;
          }
        }
      }
      return false;
    },

    hasCharacterNodes: function () {
      var nodeCnt = this.nodes.length;
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        if (this.nodes[nodeIndex].hasCharacterNodes()) {
          return true;
        }
      }
      return false;
    },

    /**
     * Gets the first node (deep) of the node list.
     * @return {CUI.rte.DomProcessor.TextNode|CUI.rte.DomProcessor.StructuralNode}
     *         The first node (deep) of the node list; null if the node list is empty
     */
    getFirstNode: function () {
      if (this.nodes.length === 0) {
        return null;
      }
      var node = this.nodes[0];
      while (node.nodeType === CUI.rte.DomProcessor.DOM_NODE) {
        if (!node.childNodes || (node.childNodes.length === 0)) {
          break;
        }
        node = node.childNodes[0];
      }
      return node;
    },

    /**
     * Gets the last node (deep) of the node list.
     * @return {CUI.rte.DomProcessor.TextNode|CUI.rte.DomProcessor.StructuralNode}
     *         The last node (deep) of the node list; null if the node list is empty
     */
    getLastNode: function () {
      var nodeCnt = this.nodes.length;
      if (nodeCnt === 0) {
        return null;
      }
      var node = this.nodes[nodeCnt - 1];
      while (node.nodeType === CUI.rte.DomProcessor.DOM_NODE) {
        if (!node.childNodes) {
          break;
        }
        var childCnt = node.childNodes.length;
        if (childCnt === 0) {
          break;
        }
        node = node.childNodes[childCnt - 1];
      }
      return node;
    },

    createDump: function () {
      var nodeCnt = this.nodes.length;
      var ancestorDef = '---';
      if (this.commonAncestor.nodeType === 1) {
        ancestorDef = this.commonAncestor.tagName;
      } else {
        ancestorDef = this.commonAncestor.nodeValue;
      }
      var dump = 'Common ancestor: ' + ancestorDef + '\n';
      dump += 'Nodes in list: ' + nodeCnt + '\n';
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        var nodeToDump = this.nodes[nodeIndex];
        dump += nodeToDump.createDump() + '\n';
      }
      return dump;
    }

  });

  /**
   * @private
   * @static
   */
  CUI.rte.NodeList.calcNewContState = function (state, stateToAdd) {
    if (state === null || state === undefined) {
      state = stateToAdd;
    } else if (state === 'single') {
      // if styleToAdd is "unstyled", the 'merged style' must not be changed;
      // if a single or multiple styles are added, we need to change the
      // merged state to multiple styles
      if ((stateToAdd === 'single') || (stateToAdd === 'multiple')) {
        state = 'multiple';
      }
    } else if (state === 'unstyled') {
      // if merged style does not have any style set, then we can simply
      // set merged style to styleToAdd
      state = stateToAdd;
    }
    return state;
  };

  /**
   * Moves DOM child nodes of the provided base DOM object to the respective adjacent parent
   * if they are not part of the specified node list.
   * @param {[]} nodeList Array defining the (child) node list to process
   * @param {HTMLElement} parentDom The DOM element that represents the parent DOM of the
   *        (child) node list
   * @param {HTMLElement} adjacentLeft The parent element for child DOM elements that are
   *        "left" of the node list
   * @param {HTMLElement} adjacentRight The parent element for child DOM elements that are
   *        "right" of the node list
   * @private
   * @static
   */
  CUI.rte.NodeList.moveToAdjacentParents = function (nodeList, parentDom,
                                                     adjacentLeft, adjacentRight) {
    var isRightOfNodeList = true;
    var isInNodeList = false;
    var childNodes = parentDom.childNodes;
    var firstInList = nodeList[0].dom;
    var lastInList = nodeList[nodeList.length - 1].dom;
    for (var c = childNodes.length - 1; c >= 0; c--) {
      var childDom = childNodes[c];
      if (isRightOfNodeList) {
        if (childDom === lastInList) {
          isRightOfNodeList = false;
          isInNodeList = true;
        } else {
          parentDom.removeChild(childDom);
          adjacentRight.insertBefore(childDom, adjacentRight.firstChild);
        }
      }
      if (isInNodeList) {
        if (childDom === firstInList) {
          isInNodeList = false;
        }
      } else if (!isRightOfNodeList) {
        parentDom.removeChild(childDom);
        adjacentLeft.insertBefore(childDom, adjacentLeft.firstChild);
      }
    }
  };


  /**
   * @class CUI.rte.DomProcessor.TextNode
   * @private
   * This class represents a text node inside a node list.
   */
  CUI.rte.DomProcessor.TextNode = new Class({

    toString: 'TextNode',

    nodeType: CUI.rte.DomProcessor.TEXT_NODE,

    nodeList: null,

    parentNode: null,

    dom: null,

    startPos: 0,

    charCnt: 0,

    nodeLength: 0,

    /**
     * Flag if the node has been invalidated through text node normalization
     * @private
     * @type Boolean
     */
    isInvalidatedByNormalization: false,

    construct: function (dom, startPos, charCnt) {
      this.dom = dom;
      this.startPos = startPos;
      this.charCnt = charCnt;
      this.nodeLength = CUI.rte.Common.getNodeCharacterCnt(dom);
    },

    /**
     * Executes the specified function for the node and all child nodes.
     * @param {Function} fn The function to execute. Gets the node as parameter.
     */
    execRecursively: function (fn) {
      fn(this);
    },

    /**
     * <p>Determines if the structure is aligned at the start.</p>
     * <p>This is the case if the begin of the text content of the node is included.</p>
     * @returns {Boolean} True if the structure is aligned at the start
     */
    isStartAligned: function () {
      return (this.startPos === 0);
    },

    /**
     * <p>Determines if the structure is aligned at the end.</p>
     * <p>This is the case if the end of the text content of the node is included.</p>
     * @returns {Boolean} True if the structure is aligned at the end
     */
    isEndAligned: function () {
      return ((this.startPos + this.charCnt) === this.nodeLength);
    },

    /**
     * <p>Determines if the structure is aligned at both ends.</p>
     * @returns {Boolean} True if the entire text is included in the node list
     */
    isAligned: function () {
      return this.isStartAligned() && this.isEndAligned();
    },

    /**
     * <p>Checks if the node has "adjacent content".</p>
     * <p>Text nodes don't have children, so they don't have "adjacent content" by
     * definition.</p>
     * @returns {Boolean} False as text nodes cannot have adjacent content by definition
     */
    hasAdjacentContent: function () {
      return false;
    },

    hasContainers: function () {
      return false;
    },

    /**
     * Gets the actual text content that is included by this node (considering the
     * alignment of the node).
     * @return {String} The actual content of the node
     */
    getActualTextContent: function () {
      var nodeText = this.dom.nodeValue;
      if (this.startPos >= this.nodeLength) {
        return '';
      }
      return nodeText.substring(this.startPos, this.startPos + this.charCnt);
    },

    /**
     * Gets the text content of the underlying DOM text node that is <i>not</i> included
     * in this node.
     * @return {String} The excluded text content
     */
    getExcludedTextContent: function () {
      var nodeText = this.dom.nodeValue;
      if (this.startPos === 0) {
        return nodeText.substring(this.charCnt);
      }
      return nodeText.substring(0, this.startPos);
    },

    hasCharacterNodes: function () {
      return true;
    },

    isEmptySideStructure: function () {
      return (this.charCnt === 0);
    },

    normalize: function (nodeList, invalidatedNodes) {
      if (this.isInvalidatedByNormalization) {
        return;
      }
      var nodeInList;
      while (true) {
        var prevNode = this.dom.previousSibling;
        if (!prevNode || (prevNode.nodeType !== 3)) {
          break;
        }
        this.dom.nodeValue = prevNode.nodeValue + this.dom.nodeValue;
        this.startPos += prevNode.nodeValue.length;
        nodeInList = nodeList.getByDom(prevNode, true);
        if (nodeInList) {
          if (this.startPos !== 0) {
            throw new Error(
              'Trying to mormalize something that can\'t be normalized.');
          }
          this.startPos -= nodeInList.charCnt;
          this.charCnt += nodeInList.charCnt;
          nodeInList.isInvalidatedByNormalization = true;
          invalidatedNodes.push(nodeInList);
        }
        prevNode.parentNode.removeChild(prevNode);
        this.nodeLength = this.dom.nodeValue.length;
      }
      while (true) {
        var nextNode = this.dom.nextSibling;
        if (!nextNode || (nextNode.nodeType !== 3)) {
          break;
        }
        this.dom.nodeValue += nextNode.nodeValue;
        nodeInList = nodeList.getByDom(nextNode, true);
        if (nodeInList) {
          if ((this.startPos + this.charCnt) < this.nodeLength) {
            throw new Error(
              'Trying to mormalize something that can\'t be normalized.');
          }
          this.charCnt += nodeInList.charCnt;
          nodeInList.isInvalidatedByNormalization = true;
          invalidatedNodes.push(nodeInList);
        }
        nextNode.parentNode.removeChild(nextNode);
        this.nodeLength = this.dom.nodeValue.length;
      }
    },

    /**
     * "Surrounds" the text node with a tag of the given name/attribute or adds the text
     * node to an existing "surrounding node" in a suitable way.
     * <p>
     * The method handles the possibly necessary splitting of the node accordingly.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Node} surroundingNode "surrounding node" to work on; <code>null</code> if no
     *                               "surrounding node" is yet existing
     * @param {String} tagName tag name of the "surrounding node" (if one has to be created)
     * @param {Object} attributes attributes of the "surrounding node" (if one has to be
     *                            created)
     * @param nodesAdded array to which all additionally created nodes will be added
     * @return {Node} the "surrounding node" to continue working on
     */
    surround: function (context, surroundingNode, tagName, attributes, nodesAdded) {
      var insertNode = this.dom;
      var splitNodeIndex = 0;
      var splitPoints = [];
      if (!this.isStartAligned()) {
        splitPoints.push(this.startPos);
        splitNodeIndex = 1;
      }
      if (!this.isEndAligned()) {
        splitPoints.push(this.startPos + this.charCnt);
      }
      if (splitPoints.length > 0) {
        // this.dom gets invalid here
        var splitNodes = CUI.rte.DomProcessor.splitTextNode(context, this.dom,
          splitPoints);
        insertNode = splitNodes[splitNodeIndex];
      }
      if (surroundingNode !== null && surroundingNode !== undefined) {
        insertNode.parentNode.removeChild(insertNode);
        surroundingNode.appendChild(insertNode);
      } else {
        surroundingNode = CUI.rte.DomProcessor.insertAsParent(context,
          insertNode, tagName, attributes);
        nodesAdded.push(surroundingNode);
        this.nodeList.nodesChanged.push(surroundingNode);
      }
      this.dom = insertNode;
      this.nodeList.nodesChanged.push(insertNode);
      return surroundingNode;
    },

    /**
     * Creates a new DOM text node from the actual text of the node.
     * @param {CUI.rte.EditContext} context The edit context
     * @return {HTMLElement} The DOM text node
     */
    createNewTextNode: function (context) {
      return context.createTextNode(this.getActualTextContent());
    },

    /**
     * Splits the text node into "adjacent parents" if it is not aligned.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} outerLeft The adjacent parent on the left
     * @param {HTMLElement} outerRight The adjacent parent on the right
     */
    split: function (context, outerLeft, outerRight) {
      var com = CUI.rte.Common;
      var nodeText = this.dom.nodeValue;
      if (!this.isAligned()) {
        this.dom.nodeValue = nodeText.substring(this.startPos,
          this.startPos + this.charCnt);
        var textNode;
        if (!this.isStartAligned()) {
          textNode = context.createTextNode(nodeText.substring(0, this.startPos));
          com.addTextNode(textNode, outerLeft);
        }
        if (!this.isEndAligned()) {
          textNode = context.createTextNode(nodeText.substring(
            this.startPos + this.charCnt, nodeText.length));
          com.addTextNode(textNode, outerRight, outerRight.firstChild);
        }
        this.startPos = 0;
        this.charCnt = this.dom.nodeValue.length;
      }
    },

    createDump: function () {
      var content;
      var nodeText = this.dom.nodeValue;
      if (this.charCnt === 0) {
        if (this.startPos < (nodeText.length - 1)) {
          content = '(' + nodeText.substring(this.startPos, this.startPos + 1) + ')';
        } else {
          content = '(behind text)';
        }
      } else {
        content = nodeText.substring(this.startPos, this.startPos + this.charCnt);
      }
      content = content.replace(/ /g, '*');
      return 'Text node (s:' + this.startPos + '/l:' + this.charCnt + '/tl:' +
        this.nodeLength + '): ' + content;
    }

  });

  /**
   * @class CUI.rte.DomProcessor.StructuralNode
   * @private
   * This class represents a structural node (= tag) inside a node list.
   */
  CUI.rte.DomProcessor.StructuralNode = new Class({

    toString: 'DomProcessor.StructuralNode',

    nodeType: CUI.rte.DomProcessor.DOM_NODE,

    parentNode: null,

    tagName: null,

    dom: null,

    nodeList: null,

    type: null,

    childNodes: null,

    /**
     * Flag if the node has been invalidated through text node normalization; is always
     * false for structural nodes
     * @private
     * @type Boolean
     */
    isInvalidatedByNormalization: false,

    construct: function (dom) {
      this.dom = dom;
      this.tagName = dom.tagName.toLowerCase();
      this.type = CUI.rte.DomProcessor.getTagType(dom);
    },

    /**
     * Executes the specified function for the node and all child nodes.
     * @param {Function} fn The function to execute. Gets the node as parameter. If it
     *        returns true, the recursion is cancelled for the sub-tree starting at this
     *        node
     */
    execRecursively: function (fn) {
      var breakRecursion = fn(this);
      if (this.childNodes && (breakRecursion !== true)) {
        var childCnt = this.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          this.childNodes[c].execRecursively(fn);
        }
      }
    },

    addChildNode: function (nodeToAdd, nodeList, index) {
      if (!this.childNodes) {
        this.childNodes = [];
      }
      nodeToAdd.parentNode = this;
      nodeToAdd.nodeList = nodeList;
      if (!index || (index >= this.childNodes.length)) {
        this.childNodes.push(nodeToAdd);
      } else {
        this.childNodes.splice(index, 0, nodeToAdd);
      }
    },

    removeChildNode: function (nodeToRemove) {
      var removeIndex = this.getChildIndex(nodeToRemove);
      if (removeIndex < 0) {
        return -1;
      }
      this.childNodes.splice(removeIndex, 1);
      if (this.childNodes.length === 0) {
        this.childNodes = null;
      }
      return removeIndex;
    },

    /**
     * <p>Determines if the structure is aligned at the start.</p>
     * <p>This is the case if the start of the first content/text node is included in the
     * nodelist.</p>
     * <p>Note that this method only considers (child) nodes that are part of the node list.
     * If the DOM object represented by this StructuralNode has child nodes that are outside
     * the node list, they are neither considered for determining the alignment of the node,
     * nor the node is called "unaligned" if such "adjacent child nodes" exist. To handle
     * this case, use {@link CUI.rte.NodeList#hasAdjacentContent}.
     * @returns {Boolean} True if the structure is aligned at the start or doesn't have
     *          child nodes
     */
    isStartAligned: function () {
      if (this.childNodes === null || this.childNodes === undefined) {
        return true;
      }
      var childCnt = this.childNodes.length;
      for (var childIndex = 0; childIndex < childCnt; childIndex++) {
        var childToProcess = this.childNodes[childIndex];
        var isAligned = childToProcess.isStartAligned();
        if (!isAligned) {
          return false;
        }
      }
      return true;
    },

    /**
     * <p>Determines if the structure is aligned at the end.</p>
     * <p>This is the case if the end of the last content/text node is included in the
     * nodelist.</p>
     * @see CUI.rte.NodeList#isStartAligned
     * @returns {Boolean} True if the structure is aligned at the end or doesn't have
     *          child nodes
     */
    isEndAligned: function () {
      if (this.childNodes === null || this.childNodes === undefined) {
        return true;
      }
      var childCnt = this.childNodes.length;
      for (var childIndex = 0; childIndex < childCnt; childIndex++) {
        var childToProcess = this.childNodes[childIndex];
        var isAligned = childToProcess.isEndAligned();
        if (!isAligned) {
          return false;
        }
      }
      return true;
    },

    /**
     * <p>Determines if the structure is aligned at the end.</p>
     * <p>This is the case if the start of the first and the end of the last content/text
     * node are both included in the nodelist.</p>
     * @see CUI.rte.NodeList#isStartAligned
     * @returns {Boolean} True if the structure is aligned at both ends or doesn't have
     *          child nodes
     */
    isAligned: function () {
      if (this.childNodes === null || this.childNodes === undefined) {
        return true;
      }
      var childCnt = this.childNodes.length;
      for (var childIndex = 0; childIndex < childCnt; childIndex++) {
        var childToProcess = this.childNodes[childIndex];
        var isAligned = childToProcess.isAligned();
        if (!isAligned) {
          return false;
        }
      }
      return true;
    },

    /**
     * <p>Checks if the node has "adjacent content" at its start or end.</p>
     * <p>"Adjacent content" means that the DOM object represented by the node has children
     * that themselves are <i>not</i> part of the node list.</p>
     * <p>For example: given the node list based on the HTML <i>&lt;p&gt;ABC &lt;b&gt;DEF
     * &lt;i&gt;GHI&lt;/i&gt; J|KL&lt;/b&gt; MN|O&lt;/p&gt;</i> (<i>|</i> denoting start and
     * end of the node list) the StructuralNode representing the &lt;b&gt; will have two
     * adjacent DOM objects: The text node representing "DEF " and the &lt;i&gt; tag.</p>
     * @param {Boolean} atStart True if the method should check for adjacent content at the
     *        start of the node (false for checking the end of the node)
     * @returns {Boolean} True if the node has "adjacent content" at the specified position
     */
    hasAdjacentContent: function (atStart) {
      if (this.childNodes === null || this.childNodes === undefined) {
        return false;
      }
      var nodeToCheck = (atStart ? this.dom.firstChild : this.dom.lastChild);
      if (!this.getChildNodeForDom(nodeToCheck)) {
        return true;
      }
      var childCnt = this.childNodes.length;
      return this.childNodes[atStart ? 0 : childCnt - 1].hasAdjacentContent(atStart);
    },

    hasContainers: function (excludeSelf) {
      var dpr = CUI.rte.DomProcessor;
      var isContainer;
      if (this.type === dpr.DYNAMIC) {
        isContainer = true;
        if (dpr.TYPE_TABLE.hasOwnProperty(this.tagName)) {
          var tagDef = dpr.TYPE_TABLE[this.tagName];
          if (tagDef && tagDef.getDynamicType) {
            isContainer = (tagDef.getDynamicType(this.dom) === dpr.CONTAINER);
          }
        }
      } else {
        isContainer = (this.type === dpr.CONTAINER);
      }
      if ((excludeSelf !== true) && isContainer) {
        return true;
      }
      if (this.childNodes !== null && this.childNodes !== undefined) {
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          if (this.childNodes[childIndex].hasContainers()) {
            return true;
          }
        }
      }
      return false;
    },

    containsTag: function (tagName) {
      if (this.tagName === tagName) {
        return true;
      }
      if (this.childNodes) {
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          var childToProcess = this.childNodes[childIndex];
          if (childToProcess.nodeType === CUI.rte.DomProcessor.DOM_NODE) {
            if (childToProcess.containsTag(tagName)) {
              return true;
            }
          }
        }
      }
      return false;
    },

    getTags: function (tagMatcher, tags) {
      var dpr = CUI.rte.DomProcessor;
      var com = CUI.rte.Common;
      var matcherCnt = tagMatcher.length;
      var preventSubTreeRecursion = false;
      for (var matcherIndex = 0; matcherIndex < matcherCnt; matcherIndex++) {
        var matcher = tagMatcher[matcherIndex];
        if (matcher.extMatcher) {
          var result = matcher.extMatcher(this.dom);
          if (result.isMatching) {
            tags.push(this);
            preventSubTreeRecursion = result.preventRecursionIfMatching;
            break;
          }
          if (result.preventRecursion === true) {
            preventSubTreeRecursion = true;
          }
        } else if (matcher.matcher) {
          if (matcher.matcher(this.dom)) {
            tags.push(this);
            break;
          }
        } else {
          if (com.matchesTagDef(this.dom, matcher)) {
            tags.push(this);
            break;
          }
        }
      }
      if (this.childNodes && !preventSubTreeRecursion) {
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          if (this.childNodes[childIndex].nodeType === dpr.DOM_NODE) {
            this.childNodes[childIndex].getTags(tagMatcher, tags);
          }
        }
      }
      return tags;
    },

    normalize: function (nodeList, invalidatedNodes) {
      if (this.childNodes) {
        var childCnt = this.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          this.childNodes[c].normalize(nodeList, invalidatedNodes);
        }
      }
    },

    hasContent: function () {
      if (!this.childNodes) {
        return false;
      }
      var childCnt = this.childNodes.length;
      for (var childIndex = 0; childIndex < childCnt; childIndex++) {
        var childToProcess = this.childNodes[childIndex];
        if (childToProcess.nodeType === CUI.rte.DomProcessor.TEXT_NODE) {
          return true;
        } else {
          if (childToProcess.hasContent()) {
            return true;
          }
        }
      }
      return false;
    },

    hasCharacterNodes: function () {
      var com = CUI.rte.Common;
      if (com.isCharacterNode(this.dom)) {
        return true;
      }
      if (this.childNodes !== null && this.childNodes !== undefined) {
        var childCnt = this.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          if (this.childNodes[c].hasCharacterNodes()) {
            return true;
          }
        }
      }
    },

    isEmptySideStructure: function (excludeSelf) {
      var com = CUI.rte.Common;
      if (!excludeSelf) {
        if (com.isCharacterNode(this.dom)) {
          return false;
        }
        if (com.isEmptyEditingBlock(this.dom)) {
          return false;
        }
      }
      if (this.childNodes !== null && this.childNodes !== undefined) {
        var childCnt = this.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          if (!this.childNodes[c].isEmptySideStructure()) {
            return false;
          }
        }
      }
      return true;
    },

    /**
     * Determines the links (&lt;a href="..."&gt;...&lt;/a&gt;) that are contained in
     * this structural nodes recursively.
     * @param {[]} anchors The array the links will be added to
     */
    getAnchors: function (anchors) {
      var com = CUI.rte.Common;
      if ((this.tagName === 'a') && !this.isEmptySideStructure(true)) {
        if (com.isAttribDefined(this.dom, 'href')) {
          var anchor = {
            'dom': this.dom,
            'href': com.getAttribute(this.dom, com.HREF_ATTRIB) ||
            com.getAttribute(this.dom, 'href')
          };
          if (this.dom.target) {
            anchor['target'] = this.dom.target;
          }
          anchors.push(anchor);
        }
      }
      if (this.childNodes !== null && this.childNodes !== undefined) {
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          var childToProcess = this.childNodes[childIndex];
          if (childToProcess.nodeType === CUI.rte.DomProcessor.DOM_NODE) {
            childToProcess.getAnchors(anchors);
          }
        }
      }
    },

    /**
     * Determines the anchors (&lt;a name="..."&gt;&lt;/a&gt;) that are contained in this
     * structural node recursively.
     * @param {[]} anchors The array the links will be added to
     */
    getNamedAnchors: function (anchors) {
      var anchorDef = CUI.rte.DomProcessor.checkNamedAnchor(this.dom);
      if (anchorDef) {
        anchors.push(anchorDef);
      }
      if (this.childNodes !== null && this.childNodes !== undefined) {
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          var childToProcess = this.childNodes[childIndex];
          if (childToProcess.nodeType === CUI.rte.DomProcessor.DOM_NODE) {
            childToProcess.getNamedAnchors(anchors);
          }
        }
      }
    },

    /**
     * <p>Determines the styles (&lt;span class="[style]"&gt; ... &lt;/span&gt; that are
     * contained in this structural node recursively.</p>
     * <p>This method will return a "style type", which is one of the following:</p>
     * <ul>
     *   <li><i>unstyled</i> - The content of the structural node (and its child nodes) is
     *     unstyled</li>
     *   <li><i>single</i> - The content of the structural node (and its child nodes) is
     *     styled with a single style (but parts of the content may be unstyled as well)
     *     </li>
     *   <li><i>multiple</i> - The content of the structural node (and its child nodes) is
     *     styled with multiple styles (and can also contain unstyled parts).</li>
     * </ul>
     * @param {[]} styles The array the styles will be added to
     * @returns {String} Style type; possible states are: "single", "unstyled", "multiple"
     */
    getStyles: function (styles) {
      var continuousState = 'unstyled';
      if (this.tagName === 'span') {
        if (this.dom.className) {
          styles.push({
            'dom': this.dom,
            'className': this.dom.className
          });
          continuousState = 'single';
        }
      }
      if (this.childNodes !== null && this.childNodes !== undefined) {
        var hasText = false;
        var childrenState = null;
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          var childToProcess = this.childNodes[childIndex];
          if (childToProcess.nodeType === CUI.rte.DomProcessor.DOM_NODE) {
            var childState = childToProcess.getStyles(styles);
            childrenState = CUI.rte.NodeList.calcNewContState(childrenState,
              childState);
          } else {
            hasText = true;
          }
        }
        if (childrenState === null || childrenState === undefined) {
          childrenState = 'unstyled';
        }
        if (continuousState === 'unstyled') {
          if (childrenState !== 'unstyled') {
            continuousState = (hasText ? 'multiple' : childrenState);
          }
        } else {
          continuousState = (childrenState === 'unstyled' ? continuousState
            : 'multiple');
        }
      }
      return continuousState;
    },

    /**
     * @private
     */
    createChildDomNodes: function () {
      var nodes = [];
      if (this.childNodes === null || this.childNodes === undefined) {
        return nodes;
      }
      var childCnt = this.childNodes.length;
      for (var childIndex = 0; childIndex < childCnt; childIndex++) {
        nodes.push(this.childNodes[childIndex].dom);
      }
      return nodes;
    },

    /**
     * @private
     */
    addChangedNodes: function (root) {
      this.nodeList.nodesChanged.push(root);
      if (root.nodeType === 1) {
        var childCnt = root.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          this.addChangedNodes(root.childNodes[childIndex]);
        }
      }
    },

    /**
     * Implementation of <code>surround()</code> for structural nodes.
     * @private
     */
    surroundStructure: function (context, surroundingNode, tag, attribs, nodesAdded,
                                 config) {
      var dpr = CUI.rte.DomProcessor;
      var isApplicable = true;
      if (config && config.isApplicable) {
        isApplicable = config.isApplicable(this.dom, tag, attribs);
      }
      if (!isApplicable) {
        return null;
      }
      if (this.isAligned()) {
        // if the whole structure is aligned, we can just change the structure
        if (surroundingNode !== null && surroundingNode !== undefined) {
          this.dom.parentNode.removeChild(this.dom);
          surroundingNode.appendChild(this.dom);
          this.nodeList.nodesChanged.push(this.dom);
        } else {
          surroundingNode = dpr.insertAsParent(context, this.dom, tag, attribs);
          nodesAdded.push(surroundingNode);
          this.nodeList.nodesChanged.push(surroundingNode);
          this.nodeList.nodesChanged.push(this.dom);
        }
      } else {
        // if the structure is unaligned, we'll have to process the "left" and "right"
        // subtrees accordingly
        var subtreeToMove;
        if (!this.isStartAligned()) {
          // console.log("processLeftSubtree");
          subtreeToMove = this.processLeftSubtree(context);
          surroundingNode = dpr.createNode(context, tag, attribs);
          nodesAdded.push(surroundingNode);
          surroundingNode.appendChild(subtreeToMove);
          this.dom.parentNode.insertBefore(surroundingNode, this.dom.nextSibling);
          this.addChangedNodes(surroundingNode);
        }
        if (!this.isEndAligned()) {
          // console.log("processRightSubtree");
          subtreeToMove = this.processRightSubtree(context);
          surroundingNode.appendChild(subtreeToMove);
          this.addChangedNodes(subtreeToMove);
        }
      }
      return surroundingNode;
    },

    /**
     * Implementation of <code>surround()</code> for container nodes.
     * @private
     */
    surroundContainer: function (context, surroundingNode, tag, attribs, nodesAdded,
                                 config) {
      var dpr = CUI.rte.DomProcessor;
      var isApplicable = true;
      if (config && config.isApplicable) {
        isApplicable = config.isApplicable(this.dom, tag, attribs);
      }
      if (!isApplicable) {
        return null;
      }
      if (this.childNodes === null || this.childNodes === undefined) {
        return surroundingNode;
      }
      if (this.isAligned()) {
        if (!this.hasContainers(true)) {
          // if the whole structure is aligned, we can just change the structure
          var childNodes = this.createChildDomNodes();
          var nodeAdded = dpr.restructureAsChild(context, this.dom, childNodes, tag,
            attribs);
          nodesAdded.push(nodeAdded);
          this.addChangedNodes(nodeAdded);
        } else {
          if (this.childNodes !== null && this.childNodes !== undefined) {
            var childCnt = this.childNodes.length;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
              var childToProcess = this.childNodes[childIndex];
              childToProcess.surround(context, surroundingNode, tag, attribs,
                nodesAdded);
            }
          }
        }
      } else {
        surroundingNode = dpr.createNode(context, tag, attribs);
        nodesAdded.push(surroundingNode);
        // if the structure is unaligned, we'll have to process the "left" and "right"
        // subtrees accordingly
        if (!this.isStartAligned()) {
          this.processLeftContainerSubtree(context, surroundingNode, true);
          this.dom.appendChild(surroundingNode);
        }
        if (!this.isEndAligned()) {
          this.processRightContainerSubtree(context, surroundingNode, true);
          this.dom.insertBefore(surroundingNode, this.dom.firstChild);
        }
        this.addChangedNodes(surroundingNode);
      }
      return null;
    },

    /**
     * "Surrounds" the structural node (and all of its successor nodes) with a tag of the
     * given name/attribute or adds the represented structure to an existing "surrounding
     * node" in a suitable way.
     * <p>
     * The method handles the possibly necessary splitting of text nodes accordingly.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Node} surroundingNode "surrounding node" to work on; <code>null</code> if no
     *                               "surrounding node" is yet existing
     * @param {String} tag tag name of the "surrounding node" (if one has to be created)
     * @param {Object} attribs attributes of the "surrounding node" (if one has to be
     *                         created)
     * @param {Array} nodesAdded Array where all newly created nodes are recorded to
     * @return {Node} the "surrounding node" to continue working on
     */
    surround: function (context, surroundingNode, tag, attribs, nodesAdded) {
      var dpr = CUI.rte.DomProcessor;
      switch (this.type) {
      case dpr.STRUCTURE:
        surroundingNode = this.surroundStructure(context, surroundingNode, tag,
          attribs, nodesAdded);
        break;
      case dpr.CONTAINER:
        surroundingNode = this.surroundContainer(context, surroundingNode, tag,
          attribs, nodesAdded);
        break;
      case dpr.DYNAMIC:
        var config = null;
        var containerTag = this.tagName;
        var typeTable = dpr.TYPE_TABLE;
        if (typeTable.hasOwnProperty(containerTag)) {
          var tagDef = typeTable[containerTag];
          if (typeof(tagDef) === 'object') {
            config = tagDef;
          }
        }
        var isContainer = true;
        if (config && config.getDynamicType) {
          isContainer = (config.getDynamicType(this.dom) === dpr.CONTAINER);
        }
        if (isContainer) {
          surroundingNode = this.surroundContainer(context, surroundingNode, tag,
            attribs, nodesAdded, config);
        } else {
          surroundingNode = this.surroundStructure(context, surroundingNode, tag,
            attribs, nodesAdded, config);
        }
        break;
      case dpr.IGNORE:
        if (this.childNodes) {
          var childCnt = this.childNodes.length;
          for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            var child = this.childNodes[childIndex];
            if (child.nodeType === dpr.DOM_NODE) {
              surroundingNode = child.surround(context, surroundingNode, tag,
                attribs, nodesAdded);
            }
          }
        }
        break;
      }
      return surroundingNode;
    },

    /**
     * This method does the necessary processing for surrounding structures that are
     * unaligned at the start ("left" subtree).
     * <p>
     * For example, <i>&lt;b&gt;Bold |text&lt;/b&gt; is great!|</i> has to be processed as
     * follows to preserve a valid tag nesting: <i>&lt;b&gt;Bold &lt;span class="test"&gt;
     * text&lt;/span&gt;&lt;/b&gt;&lt;span class="test"&gt; is great!&lt;/span&gt;</i>.
     * <p>
     * This method processes the initial "b" structure and:
     * <ul>
     * <li>Splits the "Bold text" DOM text node in two separate "Bold " and "text" nodes.
     * </li>
     * <li>Removes the "Bold text" DOM text node from the existing DOM tree and adds
     * the "Bold " text node instead.</li>
     * <li>Creates a copy of the DOM structure (the "b" node in this case).</li>
     * <li>Adds the "text" DOM text node to the copy of the "b" node).</li>
     * <li>Returns the copied DOM structure, including the split text node, so the caller
     * can use this for executing the surrounding operation.</li>
     * </ul>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} subTreeRoot (optional) root node to start with
     * @return {HTMLElement} the DOM subtree to be used for the surrounding operation
     */
    processLeftSubtree: function (context, subTreeRoot) {
      var dpr = CUI.rte.DomProcessor;
      var com = CUI.rte.Common;
      // we'll create a clone of the current node as part of the subtree that actually
      // gets surrounded
      var clonedNode = this.dom.cloneNode(false);
      if (!subTreeRoot) {
        subTreeRoot = clonedNode;
      } else {
        subTreeRoot.appendChild(clonedNode);
      }
      // process child nodes
      if (this.childNodes === null || this.childNodes === undefined) {
        return subTreeRoot;
      }
      var childCnt = this.childNodes.length;
      for (var childIndex = 0; childIndex < childCnt; childIndex++) {
        var childToProcess = this.childNodes[childIndex];
        var nodeType = childToProcess.nodeType;
        if (nodeType === dpr.DOM_NODE) {
          var dom = childToProcess.dom;
          if (com.isOneCharacterNode(dom)) {
            // br, img, etc.: move to cloned subtrees if included in node list;
            // keep it otherwise
            if (childToProcess.isAligned()) {
              dom.parentNode.removeChild(dom);
              clonedNode.appendChild(dom);
            }
          } else {
            childToProcess.processLeftSubtree(context, clonedNode);
          }
        } else if (nodeType === dpr.TEXT_NODE) {
          var childText = childToProcess.dom;
          if (childToProcess.isAligned()) {
            // here we can handle the entire node "at once"
            var removalParent = childText.parentNode;
            removalParent.removeChild(childText);
            com.removeNodesWithoutContent(context, removalParent);
            com.addTextNode(childText, clonedNode);
          } else {
            // here we must split the text node and assign one half to the
            // sub tree that stays the same and the other one to the sub tree
            // that gets actually surrounded
            clonedNode.appendChild(childToProcess.createNewTextNode(context));
            var overflowParent = childText.parentNode;  // == this.dom
            var overflowRef = childText.nextSibling;
            overflowParent.removeChild(childText);
            if (childToProcess.startPos > 0) {
              var overflowText = childToProcess.getExcludedTextContent();
              com.addTextNode(context.createTextNode(overflowText),
                overflowParent, overflowRef);
            } else {
              com.removeNodesWithoutContent(context, overflowParent);
            }
          }
        }
      }
      return subTreeRoot;
    },

    /**
     * This method does the necessary processing for surrounding structures that are
     * unaligned at the end ("right" subtree).
     * <p>
     * For example, <i>Let's try |some &lt;i&gt;italic| text&lt;/i&gt;.</i> has to be
     * processed as follows to preserve a valid tag nesting: <i>Let's try
     * &lt;span class="test"&gt;some &lt;/span&gt;&lt;i&gt;&lt;span class="test"&gt;italic
     * &lt;/span&gt; text&lt;/i&gt;</i>.
     * <p>
     * This method processes the "i" structure at the end and:
     * <ul>
     * <li>Splits the "italic text" DOM text node in two separate "italic " and "text"
     * nodes.
     * </li>
     * <li>Removes the "italic text" DOM text node from the existing DOM tree and adds
     * the " text" text node instead.</li>
     * <li>Creates a copy of the DOM structure (the "i" node in this case).</li>
     * <li>Adds the "italic " DOM text node to the copy of the "i" node).</li>
     * <li>Returns the copied DOM structure, including the split text node, so the caller
     * can use this for executing the surrounding operation.</li>
     * </ul>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} subTreeRoot (optional) root node to start with
     * @return {HTMLElement} the DOM subtree to be used for the surrounding operation
     */
    processRightSubtree: function (context, subTreeRoot) {
      var dpr = CUI.rte.DomProcessor;
      var com = CUI.rte.Common;
      var clonedNode = this.dom.cloneNode(false);
      if (!subTreeRoot) {
        subTreeRoot = clonedNode;
      } else {
        subTreeRoot.appendChild(clonedNode);
      }
      // process child nodes
      if (this.childNodes === null || this.childNodes === undefined) {
        return subTreeRoot;
      }
      var childCnt = this.childNodes.length;
      for (var childIndex = 0; childIndex < childCnt; childIndex++) {
        var childToProcess = this.childNodes[childIndex];
        var nodeType = childToProcess.nodeType;
        if (nodeType === dpr.DOM_NODE) {
          var dom = childToProcess.dom;
          if (com.isOneCharacterNode(dom)) {
            // br, img, etc.: move to cloned subtrees if included in node list;
            // keep it otherwise
            if (childToProcess.isAligned()) {
              dom.parentNode.removeChild(dom);
              clonedNode.appendChild(dom);
            }
          } else {
            childToProcess.processRightSubtree(context, clonedNode);
          }
        } else if (nodeType === dpr.TEXT_NODE) {
          var childText = childToProcess.dom;
          if (childToProcess.isAligned()) {
            var removalParent = childText.parentNode;
            removalParent.removeChild(childText);
            com.removeNodesWithoutContent(context, removalParent);
            com.addTextNode(childText, clonedNode);
          } else {
            clonedNode.appendChild(childToProcess.createNewTextNode(context));
            var overflowParent = childText.parentNode;
            var overflowRef = childText.nextSibling;
            overflowParent.removeChild(childText);
            var actualCharCnt = childToProcess.startPos + childToProcess.charCnt;
            if (actualCharCnt < childToProcess.nodeLength) {
              var overflowText = childToProcess.getExcludedTextContent();
              com.addTextNode(context.createTextNode(overflowText),
                overflowParent, overflowRef);
            } else {
              com.removeNodesWithoutContent(context, overflowParent);
            }
          }
        }
      }
      return subTreeRoot;
    },

    /**
     * This method does the necessary processing for surrounding containers that are
     * unaligned at the start ("left" subtree).
     * <p>
     * This method works similar to <code>processLeftContainer()</code>, but is
     * adjusted to work with containers correctly (other move rules apply there).
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} subTreeRoot root node to start with
     * @param {Boolean} skipContent True if the content of <code>this</code>
     *                              should be skipped, so only the content of child nodes
     *                              is getting processed
     */
    processLeftContainerSubtree: function (context, subTreeRoot, skipContent) {
      var dpr = CUI.rte.DomProcessor;
      var com = CUI.rte.Common;
      var baseNode;
      if (!skipContent) {
        if (this.isAligned()) {
          this.dom.parentNode.removeChild(this.dom);
          subTreeRoot.appendChild(this.dom);
          return;
        }
        baseNode = this.dom.cloneNode(false);
        subTreeRoot.appendChild(baseNode);
      } else {
        baseNode = subTreeRoot;
      }
      var childCnt = this.childNodes.length;
      for (var childIndex = 0; childIndex < childCnt; childIndex++) {
        var childToProcess = this.childNodes[childIndex];
        var nodeType = childToProcess.nodeType;
        if (nodeType === dpr.DOM_NODE) {
          childToProcess.processLeftContainerSubtree(context, baseNode);
        } else if (nodeType === dpr.TEXT_NODE) {
          var childText = childToProcess.dom;
          if (childToProcess.isAligned()) {
            var removalParent = childText.parentNode;
            removalParent.removeChild(childText);
            com.removeNodesWithoutContent(context, removalParent);
            com.addTextNode(childText, baseNode);
          } else {
            baseNode.appendChild(childToProcess.createNewTextNode(context));
            var overflowParent = childText.parentNode;
            var overflowRef = childText.nextSibling;
            overflowParent.removeChild(childText);
            if (childToProcess.startPos > 0) {
              var overflowText = childText.nodeValue.substring(0,
                childToProcess.startPos);
              com.addTextNode(context.createTextNode(overflowText),
                overflowParent, overflowRef);
            } else {
              com.removeNodesWithoutContent(context, overflowParent);
            }
          }
        }
      }
    },

    /**
     * This method does the necessary processing for surrounding containers that are
     * unaligned at the end ("right" subtree).
     * <p>
     * This method works similar to <code>processRightContainer()</code>, but is
     * adjusted to work with containers correctly (other move rules apply there).
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} subTreeRoot root node to start with
     * @param {Boolean} skipContent True if the content of <code>this</code>
     *                              should be skipped, so only the content of child nodes
     *                              is getting processed
     */
    processRightContainerSubtree: function (context, subTreeRoot, skipContent) {
      var dpr = CUI.rte.DomProcessor;
      var com = CUI.rte.Common;
      var baseNode;
      if (!skipContent) {
        if (this.isAligned()) {
          this.dom.parentNode.removeChild(this.dom);
          subTreeRoot.appendChild(this.dom);
          return;
        }
        baseNode = this.dom.cloneNode(false);
        subTreeRoot.appendChild(baseNode);
      } else {
        baseNode = subTreeRoot;
      }
      var childCnt = this.childNodes.length;
      for (var childIndex = 0; childIndex < childCnt; childIndex++) {
        var childToProcess = this.childNodes[childIndex];
        var nodeType = childToProcess.nodeType;
        if (nodeType === dpr.DOM_NODE) {
          childToProcess.processRightContainerSubtree(context, baseNode);
        } else if (nodeType === dpr.TEXT_NODE) {
          var childText = childToProcess.dom;
          if (childToProcess.isAligned()) {
            var removalParent = childText.parentNode;
            removalParent.removeChild(childText);
            com.removeNodesWithoutContent(context, removalParent);
            com.addTextNode(childText, baseNode);
          } else {
            baseNode.appendChild(childToProcess.createNewTextNode(context));
            var overflowParent = childText.parentNode;
            overflowParent.removeChild(childText);
            var actualCharCnt = childToProcess.startPos + childToProcess.charCnt;
            if (actualCharCnt < childToProcess.nodeLength) {
              var overflowText = childText.nodeValue.substring(
                actualCharCnt, childToProcess.nodeLength);
              com.addTextNode(context.createTextNode(overflowText),
                overflowParent, overflowParent.firstChild);
            } else {
              com.removeNodesWithoutContent(context, overflowParent);
            }
          }
        }
      }
    },

    matches: function (tag, attribs) {
      var com = CUI.rte.Common;
      if (com.isTag(this.dom, tag)) {
        if (!attribs || com.hasAttributes(this.dom, attribs)) {
          return true;
        }
      }
      return false;
    },

    removeNodesByTag: function (context, tag, attribs, nodeList) {
      var dpr = CUI.rte.DomProcessor;
      if (this.childNodes) {
        var childCnt = this.childNodes.length;
        for (var c = childCnt - 1; c >= 0; c--) {
          var childToProcess = this.childNodes[c];
          if (childToProcess.nodeType === dpr.DOM_NODE) {
            childToProcess.removeNodesByTag(context, tag, attribs, nodeList);
          }
        }
      }
      if (this.matches(tag, attribs)) {
        var overflow;
        if (!this.isStartAligned()) {
          if (this.type === dpr.STRUCTURE) {
            overflow = this.processLeftSubtree(context);
            if (overflow) {
              this.dom.parentNode.insertBefore(overflow, this.dom.nextSibling);
              this.dom = overflow;
            }
          }
        }
        if (!this.isEndAligned()) {
          if (this.type === dpr.STRUCTURE) {
            overflow = this.processRightSubtree(context);
            if (overflow) {
              this.dom.parentNode.insertBefore(overflow, this.dom);
              this.dom = overflow;
            }
          }
        }
        nodeList.remove(this);
      }
    },

    getUnnecessaryLinebreaks: function (container, nodesToRemove) {
      var dpr = CUI.rte.DomProcessor;
      var com = CUI.rte.Common;
      if (this.tagName === 'br') {
        // this node may potentially be removed if:
        // - there is a container node
        // - the linebreak is the last child node of this container
        if (container) {
          if (com.getLastChild(container) === this.dom) {
            nodesToRemove.push(this);
          }
        }
      } else if (this.type === dpr.CONTAINER) {
        container = this.dom;
      }
      if (this.childNodes) {
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          var childToProcess = this.childNodes[childIndex];
          if (childToProcess.nodeType === dpr.DOM_NODE) {
            childToProcess.getUnnecessaryLinebreaks(container, nodesToRemove);
          }
        }
      }
    },

    /**
     * @private
     */
    getChildIndex: function (node) {
      if (!this.childNodes) {
        return -1;
      }
      var childCnt = this.childNodes.length;
      for (var childIndex = 0; childIndex < childCnt; childIndex++) {
        var childToProcess = this.childNodes[childIndex];
        if (childToProcess === node) {
          return childIndex;
        }
      }
      return -1;
    },

    getChildNodeForDom: function (dom) {
      if (this.childNodes) {
        var childCnt = this.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          var child = this.childNodes[c];
          if (child.dom === dom) {
            return child;
          }
        }
      }
      return undefined;
    },

    /**
     * @private
     */
    removeChild: function (childToRemove) {
      var childIndex, childCnt;
      if (this.childNodes) {
        var removeIndex = this.getChildIndex(childToRemove);
        if (removeIndex >= 0) {
          // DOM processing
          if (!childToRemove.isInvalidatedByNormalization) {
            CUI.rte.DomProcessor.removeWithoutChildren(childToRemove.dom);
          }
          // node list processing
          this.childNodes.splice(removeIndex, 1);
          if (childToRemove.childNodes) {
            var childrenToMove = childToRemove.childNodes;
            childCnt = childrenToMove.length;
            for (childIndex = 0; childIndex < childCnt; childIndex++) {
              var childToMove = childrenToMove[childIndex];
              childToMove.parentNode = this;
              this.childNodes.splice(removeIndex + childIndex, 0, childToMove);
            }
          }
        }
      }
    },

    /**
     * Splits the contents of this structural node into "adjacent parents" if the content
     * is not aligned.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} outerLeft The adjacent parent on the left
     * @param {HTMLElement} outerRight The adjacent parent on the right
     */
    split: function (context, outerLeft, outerRight) {
      // if the structure as a whole is not aligned, we have to do the movce to the
      // "adjacent parents" again (on each and every level of the DOM hierarchy we're
      // processing)
      var isAdjacentStart = this.hasAdjacentContent(true);
      var isAdjacentEnd = this.hasAdjacentContent(false);
      var isAlignedStart = this.isStartAligned();
      var isAlignedEnd = this.isEndAligned();
      var isAligned = isAlignedStart && isAlignedEnd && !(isAdjacentStart || isAdjacentEnd);
      if (!isAligned && this.childNodes) {
        var clonedSelf;
        // recreate structure in adjacent parents if necessary
        if (!this.isStartAligned() || isAdjacentStart) {
          clonedSelf = this.dom.cloneNode(false);
          outerLeft.appendChild(clonedSelf);
          outerLeft = clonedSelf;
        }
        if (!this.isEndAligned() || isAdjacentEnd) {
          clonedSelf = this.dom.cloneNode(false);
          outerRight.insertBefore(clonedSelf, outerRight.firstChild);
          outerRight = clonedSelf;
        }
        CUI.rte.NodeList.moveToAdjacentParents(this.childNodes, this.dom, outerLeft,
          outerRight);
        // split child nodes
        var childCnt = this.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          var childToProcess = this.childNodes[c];
          childToProcess.split(context, outerLeft, outerRight);
        }
      }
    },

    createDump: function (indent) {
      if (!this.childNodes) {
        return 'DOM node; tag name: ' + this.tagName;
      } else {
        var indentStr = '';
        if (indent) {
          for (var spc = 0; spc < indent; spc++) {
            indentStr += '   ';
          }
        } else {
          indent = 0;
        }
        var dump = 'DOM node; tag name: ' + this.tagName;
        indentStr += '   ';
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          var childToDump = this.childNodes[childIndex];
          dump += '\n' + indentStr + childToDump.createDump(indent + 1);
        }
        return dump;
      }
    }

  });

}(window.CUI));

/*************************************************************************
/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.Selection
 * @static
 * @private
 * <p>The RichText.Selection provides utility functions to handle
 * text selections/ranges in a browser-independent way.</p>
 * <p>Bookmarks provide means to persist selections even if the underlying DOM changes,
 * as they use character positions to determine the selection. Bookmarks are also
 * browser-independent - a given character position addresses the same DOM node/offset
 * on each browser platform.</p>
 * <p>Ranges/processing selections rely on the underlying DOM being persistent, as they use
 * nodes and offsets to address the actual text fragment.</p>
 * <p>Rules for calculating character positions:</p>
 * <ul>
 *   <li>There must be no "invisible" whitespace. Hence, no tabs and linefeeds must be
 *     present in the DOM at all!</li>
 *   <li>Each character of a text node is counted "as is".</li>
 *   <li>Several structural nodes (such as "br") are counted as a single character. These
 *     node types are defined by {@link CUI.rte.Common#ONE_CHARACTER_NODES}.</li>
 *   <li>At the end of each edit block ("p", "h1", ...), an additional character is added.
 *     Edit blocks are defined by {@link CUI.rte.Common#EDITBLOCK_TAGS}.</li>
 *   <li>Special attention should be put on nested structures: If there are paragraphs
 *     ("p") present in a table cell ("td"/"th"), two character positions are added
 *     after the last paragraph of that cell (one for the closing "p", the other for the
 *     closing "td"/"th").</li>
 *   <li>The end of the last cell of a nested table is counted as only one character (the
 *     closing "td"/"th" is only counted once, regardless of how much table cells get
 *     actually closed over the hierarchy).</li>
 * </ul>
 */
(function (CUI) {
  'use strict';
  CUI.rte.Selection = (function () {

    var com = CUI.rte.Common;

    var dpr = CUI.rte.DomProcessor;

    /**
     * Checks if the specified node definition is directly following up a DOM structure.
     * If so, the node definition is corrected to point behind the last character of that
     * structure (instead of pointing before the first character of the follow-up, which
     * is basically the same position, but described by a differend node/offset combination.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Object} nodeDef Node definition (will be adjusted accordingly)
     */
    var correctToPreviousStructure = function (context, nodeDef) {
      var node = nodeDef.node;
      var offs = nodeDef.offset;
      if (node && (offs === 0)) {
        // type: abc <b>def</b>| ghi -> abc <b>def|</b> ghi
        var prevSib = node.previousSibling;
        if (prevSib && (prevSib.nodeType === 1)) {
          if (com.getNodeCharacterCnt(prevSib) === 0) {
            // no rule without an exception: don't correct if we'd enter a link
            // (IE doesn't allow for that)
            if (com.isTag(prevSib, 'a') && com.isAttribDefined(prevSib, 'href')) {
              return;
            }
            node = com.getPreviousCharacterNode(context, node);
            if (node) {
              nodeDef.node = node;
              nodeDef.offset = (node.nodeType === 3 ? node.nodeValue.length : 0);
            }
          }
        }
        // type: <p>abc <b>|def</b> ghi -> <p>abc |<b>def</b> ghi
        else if (!prevSib && (offs === 0)) {
          node = com.getPreviousCharacterNode(context, node, com.EDITBLOCK_TAGS);
          if (node) {
            nodeDef.node = node;
            nodeDef.offset = (node.nodeType === 3 ? node.nodeValue.length : 0);
          }
        }
      }
    };

    /**
     * Determines if the specified node is an anchor (a name).
     * @param {HTMLElement} node The node to check
     */
    var isAnchor = function (node) {
      return com.isTag(node, 'a') && com.isAttribDefined(node, 'name');
    };

    /**
     * Adjusts, if necessary,  a node definition that references a structural node directly
     * to a pointer to its parent node + the child index of the originally referenced node.
     * This format is required by Gecko/Webkit to correctly handle selection on structural
     * nodes, such as "br" (which are handled as characters, but actually are structural
     * nodes).
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Object} nodeDef Node definition (will be adjusted accordingly)
     */
    var adjustNodeAndOffsetToParent = function (context, nodeDef) {
      var com = CUI.rte.Common;
      if ((nodeDef.node.nodeType === 1) && (nodeDef.offset === null || nodeDef.offset === undefined)) {
        nodeDef.offset = com.getChildIndex(nodeDef.node);
        nodeDef.node = com.getParentNode(context, nodeDef.node);
      } else if (nodeDef.offset === 0) {
        // take special care for a name="" to prevent inserting into the anchor
        var isAnchor = (com.isTag(nodeDef.node, 'img') &&
          com.isAttribDefined(nodeDef.node, com.A_ID_REPLACEMENT_ATTRIB)) ||
          (com.isTag(nodeDef.node, 'a') &&
          com.isAttribDefined(nodeDef.node, 'id'));
        if (isAnchor) {
          nodeDef.offset = com.getChildIndex(nodeDef.node) + 1;
          nodeDef.node = com.getParentNode(context, nodeDef.node);
        }
      }
    };

    /**
     * Adjusts parent node and offset as required for setting a range on IE to a certain
     * position. IE got several problems regarding anchors that are handled using this
     * method.
     */
    var adjustParentNodeAndOffset = function (context, nodeDef) {
      var node = nodeDef.node;
      var processingOffset = 0;
      var correctingOffset = 0;
      while (node) {
        node = com.getNextNode(context, node);
        if (!node) {
          break;
        }
        // handle anchors
        if (isAnchor(node)) {
          correctingOffset++;
        }
        processingOffset += com.getNodeCharacterCnt(node);
        if (processingOffset >= nodeDef.offset) {
          break;
        }
      }
      nodeDef.offset += correctingOffset;
    };

    /**
     * Checks if the specified node is at the very end of a table cell. This is required
     * for IE to workaround an issue that handles the end of a table cell different from
     * the end of other blocks.
     */
    var isTableCellCorner = function (context, node) {
      while (node) {
        if (com.isTag(node, ['td', 'th'])) {
          return true;
        }
        var pNode = node.parentNode;
        if (com.getChildIndex(node) !== (pNode.childNodes.length - 1)) {
          return false;
        }
        node = com.getParentNode(context, node);
      }
      return false;
    };

    /**
     * Maps the specified node and offset to a character node and offset if possible and
     * necessary.
     */
    var mapToCharNodeEquiv = function (context, node, offset, isEndOfSelection) {
      var sel = CUI.rte.Selection;
      if (node === null || node === undefined) {
        return null;
      }
      var isEmptyBlock = false;
      if ((node.nodeType === 1) && !com.isOneCharacterNode(node)) {
        var children = node.childNodes;
        var childCnt = children.length;
        var ftn, ltn, fn, ln;
        if ((offset !== null && offset !== undefined) && (offset < childCnt)) {
          var child = children[offset];
          ftn = com.getFirstTextChild(child, true);
          if (ftn) {
            node = ftn;
            offset = sel.getFirstSelectionOffset(context, ftn);
          } else if (com.isEmptyEditingBlock(child)) {
            // for example, empty list items are handled here
            node = child;
            offset = null;
            isEmptyBlock = true;
          } else {
            fn = com.getFirstChild(node);
            if (fn) {
              node = fn;
              offset = null;
            }
          }
        } else {
          ltn = com.getLastTextChild(node, true);
          if (ltn) {
            node = ltn;
            offset = sel.getLastSelectionOffset(context, ltn, isEndOfSelection);
          } else {
            ln = com.getLastChild(node);
            if (ln) {
              node = ln;
              offset = null;
            } else {
              // empty top-level editing blocks (<p></p>, <h1></h1>, etc.)
              isEmptyBlock = com.isEmptyEditingBlock(node);
            }
          }
        }
        return {
          'node': node,
          'offset': offset,
          'isEmptyBlock': isEmptyBlock
        };
      }
      return null;
    };

    var sharedProps = {

      getScrollOffsets: function (context) {
        return {
          'scrollTop': context.root.scrollTop,
          'scrollLeft': context.root.scrollLeft
        };
      },

      setScrollOffsets: function (context, scrollingInfo) {
        if ((scrollingInfo.scrollTop !== undefined) &&
          (scrollingInfo.scrollLeft !== undefined)) {
          context.root.scrollTop = scrollingInfo.scrollTop;
          context.root.scrollLeft = scrollingInfo.scrollLeft;
        }
      },

      /**
       * @private
       */
      hasWhitespaceOnly: function (text) {
        var whitespaces = ' \n\r\t';
        if (com.ua.isGecko) {
          whitespaces += String.fromCharCode(160);
        }
        var charCnt = text.length;
        for (var charPos = 0; charPos < charCnt; charPos++) {
          var charToCheck = text.charAt(charPos);
          if (whitespaces.indexOf(charToCheck) < 0) {
            return false;
          }
        }
        return true;
      },

      bookmarkFromProcessingSelection: function (context, selection) {
        var com = CUI.rte.Common;
        selection = {
          'startNode': selection.startNode,
          'startOffset': selection.startOffset,
          'endNode': selection.endNode,
          'endOffset': selection.endOffset,
          'cellSelection': selection.cellSelection
        };
        CUI.rte.Selection.normalizeProcessingSelection(context, selection);
        var startPos = com.getCharacterOffsetForNode(context, selection.startNode);
        if (com.isOneCharacterNode(selection.startNode)) {
          if ((selection.startOffset !== null && selection.startOffset !== undefined) && (selection.startOffset === 0)) {
            startPos++;
          }
        } else if (selection.startOffset) {
          startPos += selection.startOffset;
        }
        var endPos = startPos;
        if (selection.endNode) {
          endPos = com.getCharacterOffsetForNode(context, selection.endNode);
          if (com.isOneCharacterNode(selection.endNode)) {
            if ((selection.endOffset !== null && selection.endOffset !== undefined) && (selection.endOffset === 0)) {
              endPos++;
            }
          } else if (selection.endOffset) {
            endPos += selection.endOffset;
          }
        }
        if(com.ua.isGecko){
          var cells = null;
          if(selection.cellSelection){
            cells=selection.cellSelection.cells;
          }
          return {
            'startPos': startPos,
            'charCnt': (endPos - startPos),
            'object': null,
            'insertObject': null,
            'cells': cells
          };
        }
        // todo probably at least insertObject should be calculated correctly
        return {
          'startPos': startPos,
          'charCnt': (endPos - startPos),
          'object': null,
          'insertObject': null
        };
      },

      /**
       * Compares the specified bookmarks.
       * @param {Object} bookmark1 First bookmark to compare (as created by
       *        {@link CUI.rte.Selection#createSelectionBookmark})
       * @param {Object} bookmark2 Second bookmark to compare (as created by
       *        {@link CUI.rte.Selection#createSelectionBookmark})
       */
      compareBookmarks: function (bookmark1, bookmark2) {
        if (bookmark1 === null || bookmark1 === undefined) {
          return (bookmark2 === null || bookmark2 === undefined);
        }
        if (bookmark2 === null || bookmark2 === undefined) {
          return false;
        }
        return (bookmark1.startPos === bookmark2.startPos) &&
          (bookmark1.charCnt === bookmark2.charCnt) &&
          (bookmark1.object === bookmark2.object) &&
          (bookmark1.insertObject === bookmark2.insertObject);
      },

      /**
       * @private
       */
      isLineDelimiter: function (dom) {
        if (dom.nodeType !== 1) {
          return false;
        }
        var lineDelimiters = CUI.rte.Selection.LINE_DELIMITING_TAGS;
        var lineDelTagCnt = lineDelimiters.length;
        var tagName = dom.tagName.toLowerCase();
        for (var tagIndex = 0; tagIndex < lineDelTagCnt; tagIndex++) {
          if (lineDelimiters[tagIndex] === tagName) {
            return true;
          }
        }
        return false;
      },

      /**
       * @private
       */
      getLineDelimiter: function (context, dom) {
        while (dom) {
          if (dom.nodeType === 1) {
            if (CUI.rte.Selection.isLineDelimiter(dom)) {
              return dom;
            }
          }
          dom = com.getParentNode(context, dom);
        }
        return null;
      },

      /**
       * <p>Calculates the actual end node of a (processing) selection.</p>
       * <p>As processing selections contain a pointer to the first character/node that
       * is not actually included in the selection, this method is required if you need
       * a hold on the last item that is actually included in the selection.</p>
       * @param {CUI.rte.EditContext} The edit context
       * @param {Object} selection The selection as created by
       *        {@link CUI.rte.Selection#createProcessingSelection}
       * @return {Object} The adapted selections
       */
      adaptToInclusiveEndNode: function (context, selection) {
        var sel = CUI.rte.Selection;
        var adapted = {
          startNode: selection.startNode,
          startOffset: selection.startOffset
        };
        if (com.isRootNode(context, selection.startNode) &&
          (selection.startOffset === selection.startNode.childNodes.length)) {
          adapted.isEOT = true;
          return adapted;
        }
        var endNode = selection.endNode;
        var endOffset = selection.endOffset;
        if (endNode) {
          var moveAfterPrevCharNode = function () {
            var pcn = com.getPreviousCharacterNode(context, endNode);
            if (pcn) {
              endNode = pcn;
              endOffset = sel.getLastSelectionOffset(context, pcn, true);
            }
          };
          if (com.isOneCharacterNode(endNode)) {
            // one character, "structural" node
            if (endOffset === 0) {
              // selection ends after a "one character node" -> inclusive
              // selection must contain the begin of the "one character node"
              endOffset = null;
            } else {
              moveAfterPrevCharNode();
            }
          } else if ((endNode.nodeType === 1) && !com.isEmptyEditingBlock(endNode, true)) {
            var ltn;
            // other structural nodes
            if ((endOffset === undefined) ||
              (endNode.childNodes.length === endOffset)) {
              // EOB
              ltn = com.getLastTextChild(endNode, true);
              if (ltn) {
                endNode = ltn;
                endOffset = sel.getLastSelectionOffset(context, endNode, true);
              } else {
                // should not happen, as there should always be a character
                // node
                moveAfterPrevCharNode();
              }
            } else {
              // directly pointing at (= before) a node
              endNode = endNode.childNodes[endOffset];
              endOffset = null;
              ltn = com.getPreviousTextNode(context, endNode);
              if (ltn) {
                endNode = ltn;
                endOffset = sel.getLastSelectionOffset(context, ltn, true);
              }
            }
          } else if (endNode.nodeType === 3) {
            // text nodes
            if (endOffset > 0) {
              // adjusting inside a single text node
              endOffset--;
            } else {
              // adjusting to previous character node; move over block borders
              // must be handled as corner cases
              moveAfterPrevCharNode();
              var nextCharNode = com.getNextCharacterNode(context, endNode, com.EDITBLOCK_TAGS);
              var isBlockMove = (nextCharNode === null || nextCharNode === undefined);
              if (!isBlockMove) {
                if (com.isOneCharacterNode(endNode)) {
                  endOffset = null;
                } else {
                  endOffset--;
                }
              }
            }
          }
          // check for IE problem with empty blocks that might be between old
          // and new end node and must be taken instead
          var nodeToCheck = selection.endNode;
          if (nodeToCheck !== endNode) {
            // (don't consider end node itself!)
            nodeToCheck = com.getPreviousNode(context, nodeToCheck);
            while (nodeToCheck && (nodeToCheck !== endNode)) {
              if (com.isEmptyEditingBlock(nodeToCheck)) {
                if ((selection.startNode === nodeToCheck) &&
                  (selection.startOffset === null || selection.startOffset === undefined)) {
                  endNode = null;
                } else {
                  endNode = nodeToCheck;
                  endOffset = null;
                }
                break;
              }
              nodeToCheck = com.getPreviousNode(context, nodeToCheck);
            }
          }
          if (endNode !== null && endNode !== undefined) {
            adapted.endNode = endNode;
            adapted.endOffset = endOffset;
          }
        }
        return adapted;
      },

      /**
       * <p>Expands the given selection to cover whole lines.</p>
       * <p>Multiline selections are handled correctly. Note that the trailing linefeed
       * (&lt;br&gt;) is included in the selection and has to be handled by the calling
       * method.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Object} selection The selection to be expanded
       * @deprecated
       */
      expandToLineBorders: function (context, selection) {
        var isLineDelimiter = CUI.rte.Selection.isLineDelimiter;
        var getLineDelimiter = CUI.rte.Selection.getLineDelimiter;
        var prevNode, tagNameLC;
        var startNode = selection.startNode;
        var endNode = selection.endNode;
        if (endNode === null || endNode === undefined) {
          endNode = startNode;
        }
        // expand start
        var lineStartNode = getLineDelimiter(context, startNode);
        if (lineStartNode === null || lineStartNode === undefined) {
          var checkStartNode = startNode;
          while (checkStartNode) {
            do {
              prevNode = checkStartNode;
              checkStartNode = com.getPreviousNode(context, checkStartNode);
              if (!checkStartNode) {
                break;
              }
              if (com.isRootNode(context, checkStartNode)) {
                checkStartNode = null;
                break;
              }
              var lineDelimiter = getLineDelimiter(context, checkStartNode);
              if (lineDelimiter !== null && lineDelimiter !== undefined) {
                checkStartNode = null;
                break;
              }
            } while (checkStartNode.nodeType === 3);
            if (!checkStartNode) {
              lineStartNode = prevNode;
              break;
            }
            tagNameLC = checkStartNode.tagName.toLowerCase();
            if (tagNameLC === 'br') {
              lineStartNode = prevNode;
              break;
            }
          }
        }

        // expand end
        var lineEndNode = getLineDelimiter(context, endNode);
        if (lineEndNode === null || lineEndNode === undefined) {
          // corner case: whole line (incl. trailing "br") is already selected -
          // then we already found our end node
          if ((endNode.nodeType === 1) && (endNode.tagName.toLowerCase() === 'br')) {
            // handle empty lines correctly
            lineEndNode = endNode;
          } else {
            var checkEndNode = endNode;
            while (checkEndNode) {
              do {
                prevNode = checkEndNode;
                checkEndNode = com.getNextNode(context, checkEndNode);
                if (!checkEndNode) {
                  break;
                }
                if (com.isRootNode(context, checkEndNode)) {
                  checkEndNode = null;
                  break;
                }
              } while (checkEndNode.nodeType === 3);
              if (!checkEndNode || isLineDelimiter(checkEndNode)) {
                lineEndNode = prevNode;
                break;
              }
              tagNameLC = checkEndNode.tagName.toLowerCase();
              if (tagNameLC === 'br') {
                lineEndNode = checkEndNode;
                break;
              }
            }
          }
        }
        // handle container tags with content
        if (isLineDelimiter(lineStartNode)) {
          if (lineStartNode.childNodes.length > 0) {
            lineStartNode = lineStartNode.childNodes[0];
          }
        }
        if (isLineDelimiter(lineEndNode)) {
          if (lineEndNode.childNodes.length > 0) {
            lineEndNode = com.getLastChild(lineEndNode);
          }
        }
        return {
          'startNode': lineStartNode,
          'startOffset': (lineStartNode.nodeType === 3 ? 0 : null),
          'endNode': lineEndNode,
          'endOffset': (lineEndNode && lineEndNode.nodeType === 3 ?
            com.getNodeCharacterCnt(lineEndNode) : null)
        };
      },

      isNoInsertNode: function (node, isDomInsert) {
        if (node.nodeType === 3) {
          return false;
        }
        var sel = CUI.rte.Selection;
        var tagList = (isDomInsert === true ? sel.NO_INSERT_TAGS_DOM
          : sel.NO_INSERT_TAGS);
        for (var i = 0; i < tagList.length; i++) {
          var isMatching = com.matchesTagDef(node, tagList[i]);
          if (isMatching) {
            return true;
          }
        }
        return false;
      },

      /**
       * <p>Checks if the specified processing selection is a selection of at least one
       * character.</p>
       * <p>If this method returns false, either an object (for example an image)
       * is selected or the selection currently represents the caret. Note that this
       * method returns true if table cells are selected.</p>
       * @param {Object} selection The processing selection to be analyzed (as created by
       *        {@link CUI.rte.Selection#createProcessingSelection})
       * @return {Boolean} True if the specified processing selection represents an
       *         actual text selection as described above
       */
      isSelection: function (selection) {
        return (selection.endNode !== null && selection.endNode !== undefined) ||
          (selection.cellSelection !== null && selection.cellSelection !== undefined);
      },

      /**
       * <p>Gets a single object that is currently selected through the specified
       * processing selection.</p>
       * <p>Note that this method only returns a valid DOM object if it is the only
       * selected object and no text selection exists.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Object} selection The processing selection to be analyzed (as created by
       *        {@link CUI.rte.Selection#createProcessingSelection})
       * @return {HTMLElement} The solely selected DOM element; null if there is no such
       *         element selected
       */
      getSelectedDom: function (context, selection) {
        var selectedDom = null;
        if (selection.startNode && (selection.startOffset === null || selection.startOffset === undefined)) {
          if (!selection.endNode) {
            selectedDom = selection.startNode;
          }
        }
        return selectedDom;
      },

      /**
       * <p>Gets the first possible selectable offset for the specified node.</p>
       * <p>This is 0 for a text node and null for structural nodes.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The node to check
       * @return {Number} The last possible selection offset for the specified node
       */
      getFirstSelectionOffset: function (context, node) {
        return (node.nodeType === 3 ? 0 : null);
      },

      /**
       * <p>Gets the last possible selectable offset for the specified node.</p>
       * <p>This is the length of a text node, null for structural nodes, 0 for
       * structural nodes that are representing a character (img, a name, br).</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The node to check
       * @param {Boolean} isEndOfSelection (optional) True if the last selection offset
       *        for the end of a selection should be determined. Due to limitations in a
       *        browser's implementation, the values might differ.
       * @return {Number} The last possible selection offset for the specified node
       */
      getLastSelectionOffset: function (context, node, isEndOfSelection) {
        if (node.nodeType === 3) {
          return node.nodeValue.length;
        }
        if (com.isOneCharacterNode(node)) {
          // Gecko cannot select "behind" a br at the end of a block
          if (com.ua.isGecko && com.isTag(node, 'br') && !isEndOfSelection) {
            var nextCharNode = com.getNextCharacterNode(context, node,
              com.EDITBLOCK_TAGS);
            if (nextCharNode === null || nextCharNode === undefined) {
              return null;
            }
          }
          return 0;
        }
        return null;
      },

      /**
       * <p>Checks if the selection should be normalized before it is used for creating a
       * {@link CUI.rte.NodeList}).</p>
       * <p>A selection should be normalized if it represents a selection rather than
       * a caret and in some corner cases even if it is representing a caret (for example,
       * if it points behind a "br").</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Object} selection The processing selection to check
       */
      shouldNormalizePSelForNodeList: function (context, selection) {
        var sel = CUI.rte.Selection;
        if (sel.isSelection(selection)) {
          return true;
        }
        var startNode = selection.startNode;
        if (!startNode) {
          // Invalid start node might occur in several focus edge cases on IE -
          // simply ignore them
          return false;
        }
        var startOffset = selection.startOffset;
        if (com.isOneCharacterNode(startNode) && (startOffset === 0)) {
          // we should normalize if we are after the end of an object
          return true;
        }
        if ((startNode.nodeType === 3) && (startOffset >= startNode.nodeValue.length)) {
          // we should also normalize if we are after the end of a text node
          return true;
        }
        if (startNode.nodeType === 1) {
          // of course we must normalize EOT/EOB situations as well ...
          return true;
        }
        return false;
      },

      /**
       * <p>Checks if the selection should be normalized before using (for example for
       * analyzing a selection).</p>
       * <p>A selection should be normalized if it represents a selection rather than
       * a caret and in some corner cases even if it is representing a caret (for example,
       * if it represents an EOB/EOT situation).</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Object} selection The processing selection to check
       */
      shouldNormalizePSel: function (context, selection) {
        if (CUI.rte.Selection.isSelection(selection)) {
          return true;
        }
        // we must normalize EOT/EOB situations as well ...
        var startNode = selection.startNode;
        return startNode && (startNode.nodeType === 1) && !com.isOneCharacterNode(startNode);
      },

      /**
       * <p>Normalizes the specified processing selection as far as possible.</p>
       * <p>It is ensured that start and end node both point to character nodes as far
       * as it is somehow possible.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Object} selection The processing selection to be normalized (will be
       *        modified directly)
       */
      normalizeProcessingSelection: function (context, selection) {
        var sel = CUI.rte.Selection;
        var startNode = selection.startNode;
        var startOffset = selection.startOffset;
        var endNode = selection.endNode;
        var endOffset = selection.endOffset;
        if (startNode) {
          // map structural nodes to their character node equivalent
          var startDef = mapToCharNodeEquiv(context, startNode, startOffset, false);
          if (startDef !== null && startDef !== undefined) {
            startNode = startDef.node;
            startOffset = startDef.offset;
          }
          var endDef = mapToCharNodeEquiv(context, endNode, endOffset, true);
          if (endDef !== null && endDef !== undefined) {
            endNode = endDef.node;
            endOffset = endDef.offset;
          }
          // adjust start node if it points behind a character node
          if (com.isCharacterNode(startNode)) {
            var mustCorrect = false;
            var isCollapsed = false;
            if (com.isOneCharacterNode(startNode)) {
              mustCorrect = (startOffset === 0);
            } else {
              mustCorrect = (startOffset >= startNode.nodeValue.length);
              isCollapsed = (startNode === endNode) && (startOffset === endOffset);
            }
            if (mustCorrect) {
              var ntn = com.getNextCharacterNode(context, startNode,
                com.EDITBLOCK_TAGS);
              if (ntn) {
                startNode = ntn;
                startOffset = sel.getFirstSelectionOffset(context, ntn);
                if (!isCollapsed) {
                  isCollapsed = (startNode === endNode) &&
                    (startOffset === endOffset);
                }
                if (isCollapsed) {
                  endNode = null;
                  endOffset = null;
                }
              }
            }
          }
          selection.startNode = startNode;
          selection.startOffset = startOffset;
          selection.endNode = endNode;
          selection.endOffset = endOffset;
        }
      },

      /**
       * Creates a dump (for debugging) of the specified processing selection.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {Object} selection The processing selection
       * @param {Boolean} html True to create HTML output
       * @return {String} The dump
       */
      dumpPSel: function (context, selection, html) {

        function convert(str) {
          if (!str) {
            return '';
          }
          if (html) {
            var sl = str.length;
            if (str.charAt(sl - 1) === '\n') {
              str = str.substring(0, sl - 1);
            }
            str = CUI.rte.Utils.htmlEncode(str);
            str = str.replace(/\n/gi, '<br>');
          }
          return str;
        }

        function createTagDescr(node, isShort, isEndOfTag) {
          if (node.nodeType !== 1) {
            return '[no tag]';
          }
          if (isShort) {
            return '<' + node.tagName + '>';
          }
          var text = node.innerText;
          if (text.length > 15) {
            text = text.substring(0, 12) + '...';
          }
          return '<' + node.tagName + ':' + text + (isEndOfTag === true ? '|>' : '>');
        }

        function createNodeDescr(node, offset, isObjSel) {
          var text;
          if (node.nodeType === 3) {
            text = node.nodeValue;
            if (text.length > 20) {
              var lastChar = Math.min(offset + 10, text.length);
              var firstChar = lastChar - 20;
              if (firstChar < 0) {
                lastChar = Math.min(lastChar - firstChar, text.length);
                firstChar = 0;
              }
              var hasMoreText = (lastChar < text.length);
              text = text.substring(firstChar, offset) + '|' +
                text.substring(offset, lastChar);
              if (hasMoreText) {
                text += '...';
              }
              if (firstChar > 0) {
                text = '...' + text;
              }
            } else {
              text = text.substring(0, offset) + '|' + text.substring(offset);
            }
            return text;
          }
          if (com.isOneCharacterNode(node)) {
            var tag = createTagDescr(node, true);
            if (isObjSel) {
              return tag;
            }
            return ((offset === null || offset === undefined) ? '|' + tag : tag + '|');
          }
          if (com.isTag(node, com.EDITBLOCK_TAGS ||
              com.isTag(node, com.BLOCK_TAGS))) {
            var cn = node.childNodes;
            if (com.isNull(offset)) {
              // end of ... situation
              return createTagDescr(node, false, true);
            }
            var prevNode = (offset > 0 ? cn[offset - 1] : undefined);
            var insertNode = (offset < cn.length ? cn[offset] : undefined);
            if (prevNode) {
              if (prevNode.previousSibling) {
                text += '...';
              }
              text += createTagDescr(prevNode);
            }
            text += '|';
            if (insertNode) {
              text += createTagDescr(insertNode);
              if (insertNode.nextSibling) {
                text += '...';
              }
            }
            return '#' + text;
          }
          return '[not yet implemented]';
        }

        if (!selection) {
          return convert('<invalid>');
        }

        var dump = '';
        var startNode = selection.startNode;
        var startOffs = selection.startOffset;
        var endNode = selection.endNode;
        var endOffs = selection.endOffset;
        if (startNode) {
          var isObjSel = (com.isOneCharacterNode(startNode) && com.isNull(startOffs) && !endNode);
          dump += (isObjSel ? 'object: ' : 'start: ') +
            createNodeDescr(startNode, startOffs, isObjSel) + '\n';
          if (endNode) {
            dump += 'end: ' + createNodeDescr(endNode, endOffs) + '\n';
          }
        }
        if (selection.cellSelection) {
          var cellStr = '';
          var cs = selection.cellSelection;
          var cells = cs.cells;
          var cellCnt = cells.length;
          for (var c = 0; c < cellCnt; c++) {
            if (c > 0) {
              cellStr += '; ';
            }
            var td = cells[c];
            var cellContent = td.innerText;
            if (cellContent.length > 10) {
              cellContent = cellContent.substring(0, 7) + '...';
            }
            var cell = 0;
            var toCheck = td;
            while (toCheck.previousSibling) {
              toCheck = toCheck.previousSibling;
              if (com.isTag(toCheck, ['td', 'th'])) {
                cell++;
              }
            }
            cellStr += cell + '/';
            toCheck = com.getTagInPath(context, toCheck, 'tr');
            if (toCheck) {
              var row = 0;
              while (toCheck.previousSibling) {
                toCheck = toCheck.previousSibling;
                if (com.isTag(toCheck, 'tr')) {
                  row++;
                }
              }
              cellStr += row;
            } else {
              cellStr += '?';
            }
            cellStr += ': ' + cellContent;
          }
          dump += 'cells (td/tr): ' + cellStr + '\n';
        }
        return convert(dump);
      },


      /**
       * @private
       */
      LINE_DELIMITING_TAGS: [
        'p', 'li', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'
      ],

      NO_INSERT_TAGS: [{
        'tagName': 'a',
        'attribsDefined': ['name'],
        'attribsUndefined': ['href']
      }, {
        'tagName': 'img'
      }, {
        'tagName': 'span',
        'empty': true
      }
      ],

      NO_INSERT_TAGS_DOM: [{
        'tagName': 'a',
        'attribsDefined': ['name'],
        'attribsUndefined': ['href']
      }, {
        'tagName': 'img'
      }
      ],

      /**
       * This list contains tag definitions for DOM objects that are individual items
       * of a selection.
       */
      SELECTION_INCLUSION_TAGS: [{
        'tagName': 'a',
        'attribsDefined': ['name'],
        'attribsUndefined': ['href']
      }
      ]

    };

    // create browser specific variant of the helper class (using merge
    // is safe during initialization)
    return CUI.rte.Utils.merge(sharedProps, com.ua.isOldIE ? {

      /**
       * @private
       */
      getRangePosition: function (context, range) {
        if (range.item) {
          return com.getCharacterOffsetForNode(context, range.item(0));
        }
        range.collapse(true);
        var node = range.parentElement();
        // workaround for another IE problem: caret may be positioned directly
        // before/after a table, which leads to several problems
        if (node === context.root) {
          if ((range.htmlText.length === 0) && (range.text.length === 0)) {
            var tmpRange = range.duplicate();
            if (tmpRange.move('character', 1) === 1) {
              range = tmpRange;
              node = range.parentElement();
            }
          }
        }
        var childCnt = node.childNodes.length;
        var nodePos = com.getCharacterOffsetForNode(context, node);
        // as always, there is a special case: if we got an "a name" as parent
        // element, actually the character behind that anchor is addressed
        if (com.isTag(node, 'a') && com.isAttribDefined(node, 'name')) {
          return nodePos + 1;
        }
        // text selection
        var textRange = range.duplicate();
        textRange.moveToElementText(node);
        textRange.collapse(true);
        textRange.setEndPoint('StartToEnd', range);
        var nodeRef = 0;
        var tmpOffs = 0;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          var childToCheck = node.childNodes[childIndex];
          if (childToCheck.nodeType === 1) {
            var correctingRange = textRange.duplicate();
            correctingRange.moveToElementText(childToCheck);
            correctingRange.collapse(false);
            var cmp = (correctingRange.compareEndPoints('StartToStart', range));
            if (cmp <= 0) {
              nodeRef = childIndex + 1;
              textRange.setEndPoint('StartToStart', correctingRange);
              nodePos += tmpOffs;
              if (cmp < 0) {
                nodePos += com.getNodeTextLength(childToCheck);
                tmpOffs = 0;
              } else {
                // there are cases where the range matches to the end of
                // a non-character structure (for example at the end of a
                // link, but not for "normal" structure tags as b, i, u, ...),
                // hence this case covers these as well as "behind one-character
                // structures" situations
                if (!isAnchor(childToCheck) || !com.ua.isIE8) {
                  nodePos += com.getNodeTextLength(childToCheck);
                }
                break;
              }
            } else {
              break;
            }
          } else {
            tmpOffs += com.getNodeTextLength(childToCheck);
          }
        }
        var text = textRange.text.replace(/[\n\t\r]/g, '');
        nodePos += text.length;
        return nodePos;
      },

      /**
       * @private
       */
      setRangePosition: function (context, charPos, ensureEndPoint) {
        var sel = CUI.rte.Selection;
        var range = context.doc.selection.createRange();
        var nodeDef = com.getNodeAtPosition(context, charPos);
        if (nodeDef === null || nodeDef === undefined) {
          // EOT
          range.moveToElementText(context.root);
          range.collapse(false);
          return range;
        }
        if (nodeDef.isNodeSelection) {
          // A structural node is selected - this is rather easy (relative to the
          // usual IE standards ...)
          var isRoot = (context.root === nodeDef.dom);
          if (nodeDef.startOfElement ||
            (!isRoot && com.isEmptyEditingBlock(nodeDef.dom, true))) {
            sel.setNodeToRange(context, range, nodeDef.dom, true);
          } else {
            if (sel.isNoInsertNode(nodeDef.dom)) {
              range.moveToElementText(nodeDef.dom.parentNode);
            } else {
              range.moveToElementText(nodeDef.dom);
            }
            range.collapse(false);
            // EOB must "of course" be handled different, but beware of table
            // cells and anchors ("a name") ... additionally, IPE adds some more
            // complexity (must not correct the corrected selection if the
            // parentElement already points to the context root)
            var pNode = range.parentElement();
            var checkRange = range.duplicate();
            if (sel.isNoInsertNode(pNode)) {
              range.move('character', -1);
              range.move('character', 1);
            } else if (!isTableCellCorner(context, pNode) &&
              (checkRange.move('character', 1) === 1) &&
              (checkRange.parentElement() !== context.root)) {
              range.move('character', -1);
            }
          }
          return range;
        }
        // On IE, we cannot select a text node directly. Hence we select the parent
        // node (for example, a <p>), collapse to the start and move the caret the
        // required number of characters to the right.
        var parentNode = nodeDef.parentDom;
        var parentOffset = nodeDef.parentOffset;
        if (!parentNode) {
          // handle end of text situation correctly (if no parent node is available)
          var nodeBefore = nodeDef.nodeBefore;
          if (nodeBefore) {
            if (nodeBefore.nodeType === 3) {
              range.moveToElementText(nodeBefore.parentNode);
            } else {
              range.moveToElementText(nodeBefore);
            }
          } else {
            range.moveToElementText(context.root);
          }
          range.collapse(false);
          return range;
        }
        var requiresNestedListWorkaround = nodeDef.isUnregularNestedIssue;
        var nestedItem;
        if (requiresNestedListWorkaround) {
          nestedItem = nodeDef.nestedItemDom;
        }
        nodeDef = {
          'node': parentNode,
          'offset': parentOffset
        };
        adjustParentNodeAndOffset(context, nodeDef);
        sel.setNodeToRange(context, range, nodeDef.node, true);
        // There's another IE bug with standard-compliantly nested lists: The selection
        // may only be moved behind the last character of the list if the range is
        // collpsed. Found no workaround yet. It seems to work with non-collapsed
        // ranges, so we may create a range that can be used for setting the end point
        // of such a node
        if (requiresNestedListWorkaround) {
          range.moveToElementText(nestedItem);
          range.collapse(true);
          if (ensureEndPoint) {
            range.move('character', -2);
            range.moveEnd('character', 1);
          }
          return range;
        }
        if (nodeDef.offset > 0) {
          range.move('character', nodeDef.offset);
        }
        return range;
      },

      getSelection: function (context) {
        return context.doc.selection;
      },

      getLeadRange: function (context) {
        return context.doc.selection.createRange();
      },

      getCaretPos: function (context) {
        var range = context.doc.selection.createRange();
        return CUI.rte.Selection.getRangePosition(context, range);
      },

      setCaretPos: function (context, charPos) {
        var range = CUI.rte.Selection.setRangePosition(context, charPos);
        if (range) {
          range.select();
        }
      },

      createRange: function (context) {
        return context.doc.selection.createRange();
      },

      selectRange: function (context, rangeToSelect) {
        rangeToSelect.select();
      },

      createRangeBookmark: function (context) {
        return {
          'single': true,
          'bookmark': context.doc.selection.createRange()
        };
      },

      selectRangeBookmark: function (context, bookmark) {
        if (bookmark && bookmark.single && bookmark.bookmark) {
          bookmark.bookmark.select();
        }
      },

      getRangeTextContent: function (context, range) {
        return range.text;
      },

      createSelectionBookmark: function (context) {
        var sel = CUI.rte.Selection;
        var range = context.doc.selection.createRange();
        var selectionObject = null;
        var insertObject = null;
        var startPos, endPos;
        if (range.item) {
          selectionObject = range.item(0);
          startPos = com.getCharacterOffsetForNode(context, selectionObject);
          endPos = startPos;
        } else {
          var startRange = range.duplicate();
          startRange.collapse(true);
          startPos = sel.getRangePosition(context, startRange);
          var endRange = range.duplicate();
          endRange.collapse(false);
          endPos = sel.getRangePosition(context, endRange);
          if (startPos === endPos) {
            var parentEl = range.parentElement();
            if (parentEl) {
              if (parentEl.childNodes.length === 0) {
                insertObject = parentEl;
                if (sel.isNoInsertNode(insertObject)) {
                  insertObject = null;
                }
              }
            }
          }
        }
        return CUI.rte.Utils.apply({
          'startPos': startPos,
          'charCnt': (endPos - startPos),
          'object': selectionObject,
          'insertObject': insertObject
        }, sel.getScrollOffsets(context));
      },

      selectBookmark: function (context, bookmark) {
        var sel = CUI.rte.Selection;
        var objectToSelect = null;
        var isControlRange = false;
        if (bookmark.object) {
          objectToSelect = bookmark.object;
          isControlRange = true;
        } else if (bookmark.insertObject) {
          objectToSelect = bookmark.insertObject;
        }
        var range;
        if (objectToSelect) {
          try {
            if (isControlRange) {
              // todo check if correct
              range = context.root.createControlRange();
              range.addElement(objectToSelect);
            } else {
              range = context.doc.selection.createRange();
              range.moveToElementText(objectToSelect);
              range.collapse(true);
            }
          } catch (e) {
            // if the object is not available anymore (which might be the case
            // when undoing), use the caret-position instead
            if (bookmark.startPos) {
              objectToSelect = undefined;
            }
          }
        }
        if (!objectToSelect) {
          range = sel.setRangePosition(context, bookmark.startPos);
          if (bookmark.charCnt > 0) {
            // as IE selection module has a bug with correctly nested lists, we'll
            // use the ensureEndPoint flag to ensure that the range has a valid end
            // marker (but an invalid start marker, if the range is behind the
            // last character of an item containing a nested list)
            var endRange = sel.setRangePosition(context,
              bookmark.startPos + bookmark.charCnt, true);
            range.setEndPoint('EndToEnd', endRange);
          }
        }
        if (range) {
          range.select();
        }
        sel.setScrollOffsets(context, bookmark);
      },

      /**
       * Trims leading and trailing whitespace from the given range.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {TextRange} range The range to trim
       * @return {TextRange} A range that has no more trailing and/or leading whitespace
       */
      trimRangeWhitespace: function (context, range) {
        var sel = CUI.rte.Selection;
        var checkRange, tempRange;
        // don't do anything on object selections
        if (range.item) {
          return range;
        }
        // leading whitespace
        checkRange = range.duplicate();
        checkRange.collapse(true);
        var leadingCharsToTrim = 0;
        while (true) {
          tempRange = checkRange.duplicate();
          tempRange.moveEnd('character', leadingCharsToTrim + 1);
          if (!sel.hasWhitespaceOnly(tempRange.text)) {
            break;
          }
          leadingCharsToTrim++;
        }
        // trailing whitespace
        checkRange = range.duplicate();
        checkRange.collapse(false);
        var trailingCharsToTrim = 0;
        while (true) {
          tempRange = checkRange.duplicate();
          tempRange.moveStart('character', -(trailingCharsToTrim + 1));
          if (!sel.hasWhitespaceOnly(tempRange.text)) {
            break;
          }
          trailingCharsToTrim++;
        }
        // change range if necessary
        tempRange = range.duplicate();
        if (leadingCharsToTrim > 0) {
          tempRange.moveStart('character', leadingCharsToTrim);
        }
        if (trailingCharsToTrim > 0) {
          tempRange.moveEnd('character', -trailingCharsToTrim);
        }
        if (tempRange.text.length > 0) {
          range = tempRange;
        }
        return range;
      },

      /**
       * @private
       */
      getRangeNodeAndOffset: function (context, range, isSelection, isBeginOfSel) {
        // workaround for another IE bug: if the range is reported to be in some
        // container tags as <a name="">, take the first character of the next text node
        // as selection anchor
        var com = CUI.rte.Common;
        var sel = CUI.rte.Selection;
        var offset;
        var parentNode = range.parentElement();
        var parentRoot = (com.isRootNode(context, parentNode) ? parentNode : null);
        if (sel.isNoInsertNode(parentNode)) {
          var actualBlockNode = com.getTagInPath(context, parentNode,
            com.EDITBLOCK_TAGS);
          var isEOT = false;
          parentNode = com.getNextCharacterNode(context, parentNode);
          // handle EOT corner case (where we won't get a succeeding character node)
          if (!parentNode) {
            parentNode = actualBlockNode;
            isEOT = true;
          }
          offset = sel.getFirstSelectionOffset(context, parentNode);
          // Handle EOL corner case
          var blockNode = com.getTagInPath(context, parentNode, com.EDITBLOCK_TAGS);
          if (!isEOT && (blockNode !== actualBlockNode)) {
            parentNode = actualBlockNode;
            offset = null;
          }
          return {
            'dom': parentNode,
            'offset': offset
          };
        }
        // editElRange determines the character (or character node) that is
        // right-adjacent to the caret
        var editElRange = range.duplicate();
        editElRange.moveEnd('character', 1);
        var colEditElRange = editElRange.duplicate();
        colEditElRange.collapse(false);
        var colEditElParent = colEditElRange.parentElement();
        var checkRange = range.duplicate();
        var node = range.parentElement();
        checkRange.moveToElementText(node);
        checkRange.collapse(true);
        if (checkRange.move('character', 1) === 1) {
          checkRange.move('character', -1);
        }
        // IE 8 needs quite a few more workarounds when run in a non-iframe context
        // (= inplace editing). Determine if we need to apply those workarounds.
        var isIE8InDivContext = (com.ua.isIE8 && !context.iFrame);
        // check if the selection is a structural node by checking the bounds of each
        // structural child nodes against the destination range
        var elNode = null;
        var elOffset = null;
        var childCnt = node.childNodes.length;
        var isStartToStart = false;
        var prevCharNode;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
          var childToProcess = node.childNodes[childIndex];
          if (childToProcess.nodeType === 1) {
            var backupRange = checkRange.duplicate();
            checkRange.moveToElementText(childToProcess);
            var endRange = checkRange.duplicate();
            checkRange.collapse(true);
            endRange.collapse(false);
            if (checkRange.compareEndPoints('StartToStart', editElRange) === 0) {
              elNode = childToProcess;
              isStartToStart = true;
              break;
            } else if (endRange.compareEndPoints('EndToEnd', editElRange) === 0) {
              var checkPNode = checkRange.parentElement();
              var isInvalid = false;
              var enforceBefore = false;
              var endParent = endRange.parentElement();
              var editParent = editElRange.parentElement();
              if (com.isTag(childToProcess, 'img') && isAnchor(checkPNode)) {
                // another lovely IE bug: if the last previous character node
                // is a "a name", then a "img" at the begin of the succeeding
                // block is reported as "EndToEnd", but has to be handled as
                // "StartToStart"
                var prevCharSibling = com.getPreviousCharacterNode(context,
                  childToProcess, com.EDITBLOCK_TAGS);
                if (prevCharSibling !== checkPNode) {
                  isStartToStart = true;
                }
                // IE 8 in a non-iframe context issue: if an anchor ist the last
                // character of the previous block and an image is the first
                // character of the next block, we'll have to use the parents to
                // detect if the range ends before or after the image
                if (isIE8InDivContext) {
                  if (editParent !== endParent) {
                    enforceBefore = true;
                  }
                }
              } else if (isAnchor(checkPNode)) {
                // yet another little, adorable IE inconsistency, this time only
                // if in IPE mode and only on IE 8: If editElRange spans the
                // character right before an anchor (<a name="...">), then
                // comparing the ends of editElRange and endRange returns
                // "equalness", whereas it doesn't on other IE versions and
                // even on IE in iframe mode and is basically wrong (endRange
                // should point at the end of the anchor, wheres the end of
                // editElRange shoudld point "towards" the begin of the anchor)
                if (isIE8InDivContext) {
                  if (editParent !== endParent) {
                    isInvalid = true;
                  }
                }
              } else if (com.isTag(editParent, 'img') &&
                com.isTag(endParent, com.EDITBLOCK_TAGS) &&
                com.getTagInPath(context, endParent, 'table')) {
                // and again, IE 8 in a non-iframe context goes weird ...
                // images at the beginning of a table cell (and other
                // edit blocks contained in tables) are reported differently
                if (isIE8InDivContext) {
                  isStartToStart = true;
                  enforceBefore = true;
                }
              }
              if (!isInvalid) {
                elNode = childToProcess;
                // Reg. 3rd parameter: this is required for the anchor at the
                // end of a block/image at the start of the next block, which
                // triggers different elNodes on IE 8/non-frame context then
                // elsewhere
                var ltn = com.getLastTextChild(elNode, true, isIE8InDivContext);
                if (ltn) {
                  elNode = ltn;
                  elOffset = enforceBefore ? undefined
                    : sel.getLastSelectionOffset(context, elNode,
                    !isBeginOfSel);
                }
                break;
              }
            } else if (colEditElParent === childToProcess) {
              if (com.isTag(colEditElParent, 'table') && parentRoot) {
                elNode = parentRoot;
                elOffset = com.getChildIndex(colEditElParent);
              } else {
                elNode = childToProcess;
              }
              break;
            }
            var hasContent = com.hasTextChild(childToProcess);
            if (com.isOneCharacterNode(childToProcess) || hasContent) {
              checkRange.moveToElementText(childToProcess);
              checkRange.collapse(false);
            } else {
              backupRange.move('character', 2);
              checkRange = backupRange;
            }
          }
        }
        if (!elNode) {
          // text selection - determine offset to the last directly selectable node
          var textRange = range.duplicate();
          textRange.moveToElementText(parentNode);
          textRange.collapse(true);
          textRange.setEndPoint('StartToEnd', range);
          var nodeRef = 0;
          var childToCheck;
          for (childIndex = 0; childIndex < childCnt; childIndex++) {
            childToCheck = node.childNodes[childIndex];
            if (childToCheck.nodeType === 1) {
              var correctingRange = textRange.duplicate();
              correctingRange.moveToElementText(childToCheck);
              correctingRange.collapse(false);
              var cmp = (correctingRange.compareEndPoints('StartToStart', range));
              if (cmp < 0) {
                nodeRef = childIndex + 1;
                textRange.setEndPoint('StartToStart', correctingRange);
              } else {
                break;
              }
            }
          }
          var text = textRange.text.replace(/[\n\t\r]/g, '');
          var textLen = text.length;
          var offs = 0;
          for (childIndex = nodeRef; childIndex < childCnt; childIndex++) {
            childToCheck = node.childNodes[childIndex];
            var childLen = (com.isTag(childToCheck, 'br') ?
              0 : com.getNodeTextLength(childToCheck));
            if ((offs + childLen) > textLen) {
              elNode = childToCheck;
              elOffset = textLen - offs;
              // the start of a text node is actually handled as the end of the
              // previous text node (if applicable) - handle this as well
              if ((elNode.nodeType === 3) && (elOffset === 0)) {
                prevCharNode = com.getPreviousCharacterNode(context, elNode,
                  com.EDITBLOCK_TAGS);
                if (prevCharNode && !com.isOneCharacterNode(prevCharNode)) {
                  elNode = prevCharNode;
                  elOffset = com.getNodeCharacterCnt(elNode);
                }
              }
              break;
            }
            offs += childLen;
          }
        }
        // handle structural nodes correctly
        if (elNode && (elNode.nodeType === 1) && !com.isRootNode(context, elNode)) {
          if (!com.isOneCharacterNode(elNode)) {
            // get first child node for structural nodes that may have content
            var textNode = com.getFirstTextChild(elNode);
            if (textNode) {
              // actually, IE handles this as last character of previous text
              // node (style is the same), so reflecting it accordingly
              prevCharNode = com.getPreviousCharacterNode(context, textNode,
                com.EDITBLOCK_TAGS);
              if (prevCharNode && !com.isOneCharacterNode(prevCharNode)) {
                elNode = prevCharNode;
                elOffset = com.getNodeCharacterCnt(elNode);
              } else {
                elNode = textNode;
                elOffset = 0;
              }
            }
          } else if (com.isTag(elNode, 'img')) {
            // for images: adjust offset if we are handling the end of a selection
            // to exclude the image
            if (!isStartToStart) {
              elOffset = 0;
            }
          }
        }
        if (!elNode) {
          // element is not directly text-related; may be EOT or EOB/EOL
          if (parentRoot) {
            // EOT
            elNode = parentRoot;
            elOffset = parentRoot.childNodes.length;
          } else {
            elNode = com.getLastTextChild(parentNode, true);
            // if range is between two nodes, prefer first character of succeeding
            // node (if available) for the begin of a selection
            if (elNode) {
              if (isSelection && isBeginOfSel &&
                ((elNode.nodeType === 3) || com.isTag(elNode, 'br'))) {
                var nextTextNode = com.getNextCharacterNode(context, elNode,
                  com.EDITBLOCK_TAGS);
                if (nextTextNode) {
                  elNode = nextTextNode;
                  elOffset = sel.getFirstSelectionOffset(context, elNode);
                } else {
                  elOffset = com.getNodeTextLength(elNode);
                }
              } else {
                elOffset = sel.getLastSelectionOffset(context, elNode,
                  !isBeginOfSel);
              }
            } else {
              elNode = parentNode;
            }
          }
        }
        return {
          'dom': elNode,
          'offset': elOffset
        };
      },

      createProcessingSelection: function (context) {
        var sel = CUI.rte.Selection;
        var range = context.doc.selection.createRange();
        if (range.item) {
          var item = range.item(0);
          // check if selection is actually valid (IE sometimes returns invalid
          // selections!)
          if (!com.isAncestor(context, context.root, item)) {
            return null;
          }
          return {
            'startNode': item
          };
        }
        var startRange = range.duplicate();
        startRange.collapse(true);
        var endRange = range.duplicate();
        endRange.collapse(false);
        var startDef;
        var endDef = {
          'dom': null,
          'offset': null
        };
        // IE 8 bug when used outside an iframe context: selecting an anchor by
        // setting caret before the anchor and then extending the selection will
        // return that both start and end ranges match (which they actually do not
        // do; startRange points before the anchor, whereas endRange behind)
        var isCaret = (startRange.compareEndPoints('StartToStart', endRange) === 0);
        if (isCaret && com.ua.isIE8 && !context.iFrame) {
          isCaret = (range.htmlText === '') && (range.boundingWidth === 0);
        }
        if (isCaret) {
          startDef = sel.getRangeNodeAndOffset(context, startRange, false);
        } else {
          startDef = sel.getRangeNodeAndOffset(context, startRange, true, true);
          endDef = sel.getRangeNodeAndOffset(context, endRange, true, false);
          // if an empty editing block is caught as end node, we'll have to move
          // further, as the editing block has to be included in the selection
          if (com.isEmptyEditingBlock(endDef.dom)) {
            var nextNode = com.getNextNode(context, endDef.dom);
            while (nextNode) {
              var isSuitableNext = com.isEmptyEditingBlock(nextNode) ||
                com.isCharacterNode(nextNode);
              if (isSuitableNext) {
                break;
              }
              nextNode = com.getNextNode(context, nextNode);
            }
            if (!nextNode) {
              // EOT situation
              endDef.offset = com.getChildIndex(endDef.dom);
              endDef.dom = com.getParentNode(context, endDef.dom);
            } else {
              endDef.dom = nextNode;
              endDef.offset = sel.getFirstSelectionOffset(context, nextNode);
            }
          }
        }
        if ((startDef.dom === endDef.dom) && (startDef.offset === endDef.offset)) {
          endDef.dom = null;
          endDef.offset = null;
        }
        // check if selection is actually valid (IE 8 sometimes returns invalid
        // selections!)
        if (!com.isAncestor(context, context.root, startDef.dom)) {
          return null;
        }
        return {
          'startNode': startDef.dom,
          'startOffset': startDef.offset,
          'endNode': endDef.dom,
          'endOffset': endDef.offset
        };
      },

      /**
       * @private
       */
      setNodeToRange: function (context, range, dom, asInsertPoint) {
        if (dom.nodeType === 3) {
          throw new Error('Cannot select text node');
        }
        try {
          // IE is extremely buggy here: collapse() alone does not work if a
          // paragraph gets selected and the last element of the previous paragraph
          // is an an anchor
          range.moveToElementText(dom);
          var pNode = range.parentElement();
          if (asInsertPoint) {
            if (isAnchor(pNode)) {
              range.collapse(true);
              range.move('character', -1);
              if (isAnchor(range.parentElement())) {
                // even more nasty: if collapsing a paragraph to it's start and
                // the preceding paragraph has an anchor as last object, the
                // anchor of the preceding paragraph is selected instead ...
                if (range.move('character', 2) === 2) {
                  range.move('character', -1);
                }
                // with multiple anchors directly following each other, things
                // are getting nearly incredible nasty
                if (isAnchor(range.parentElement())) {
                  range.move('character', -1);
                }
              } else {
                // another kind of nastyness: the block has an object at its
                // end and the preceding block has an object at its beginning
                // then the workaround used above selects the beginning of the
                // preceding block
                pNode = range.parentElement();
                if ((dom !== pNode) && !com.isAncestor(context, dom, pNode)) {
                  if (!isAnchor(dom)) {
                    range.moveToElementText(dom);
                    range.collapse(true);
                  }
                }
              }
            } else {
              range.collapse(true);
              var ptn = com.getPreviousCharacterNode(context, dom);
              // positioning the caret doesn't work as expected if an anchor is at
              // the end of the previous block or the previous block is a list and
              // we'll try to position the caret on an empty block, hence we'll
              // once more have to work around that issue accordingly
              var requiresWorkaround = (com.isTag(dom, com.EDITBLOCK_TAGS) &&
                isAnchor(ptn)) ||
                (com.isEmptyEditingBlock(dom, true) &&
                com.isTag(dom.previousSibling, com.LIST_TAGS));
              if (requiresWorkaround) {
                if (range.move('character', '-1') === -1) {
                  // offset of 1 doesn't work, but 2 does move the caret one
                  // block too far, so we'll correct that later
                  if (range.move('character', '2') === 2) {
                    // handle EOT accordingly
                    var nextDomNode = com.getNextNode(context, dom);
                    if (nextDomNode !== null && nextDomNode !== undefined) {
                      range.move('character', '-1');
                    }
                  }
                }
              } else {
                // workaround is contraproductive for empty editing blocks
                if (!com.isEmptyEditingBlock(dom, true)) {
                  // todo document which IE bug requires this to be worked around
                  if (range.move('character', 1) === 1) {
                    range.move('character', -1);
                  }
                } else if (com.isTag(dom, 'li')) {
                  // todo probably needs to be more conditional than now
                  range.move('character', 1);
                }
              }
            }
          }
        } catch (e) {
          // There are situations where IE doesn't recognize range objects previously
          // created. At the moment, we're just ignoring that, as it occurs only in
          // situations where it doesn't really matter (when editing an anchor)
        }
      },

      selectNode: function (context, dom, asInsertPoint) {
        if (dom.nodeType === 3) {
          throw new Error('Selecting a text node is not supported.');
        }
        var range = context.doc.selection.createRange();
        CUI.rte.Selection.setNodeToRange(context, range, dom, asInsertPoint);
        range.select();
      },

      selectEmptyNode: function (context, dom) {
        var tempSpan;
        if (dpr.isZeroSizePlaceholder(dom)) {
          tempSpan = (dom.nodeType === 3 ? dom.parentNode : dom);
        } else {
          tempSpan = dpr.createTempSpan(context, true, false, true);
          tempSpan.appendChild(context.createTextNode(dpr.ZERO_WIDTH_NBSP));
          dom.appendChild(tempSpan);
        }
        var range = context.doc.selection.createRange();
        range.moveToElementText(tempSpan);
        // required for the caret to appear/blink
        range.move('character', 1);
        range.select();
      },

      selectBeforeNode: function (context, dom) {
        var tempSpan = dpr.createTempSpan(context, true, false, true);
        tempSpan.appendChild(context.createTextNode(dpr.ZERO_WIDTH_NBSP));
        dom.parentNode.insertBefore(tempSpan, dom);
        var range = context.doc.selection.createRange();
        range.moveToElementText(tempSpan);
        range.collapse(true);
        range.select();
      },

      selectAfterNode: function (context, dom) {
        var range = context.doc.selection.createRange();
        var tempSpan = dpr.createTempSpan(context, true, false, true);
        tempSpan.appendChild(context.createTextNode(dpr.ZERO_WIDTH_NBSP));
        dom.parentNode.insertBefore(tempSpan, dom.nextSibling);
        range.moveToElementText(tempSpan);
        range.collapse(false);
        range.select();
      },

      resetSelection: function (context, mode) {
        try {
          var sel = CUI.rte.Selection;
          var range = context.doc.selection.createRange();
          var nodeToSelect = context.root;
          if (mode === 'all') {
            range.moveToElementText(nodeToSelect);
          } else if (mode === 'start') {
            var ftn = com.getNextEditableNode(context, context.root);
            if (ftn) {
              nodeToSelect = ftn.parentNode;
            }
            sel.setNodeToRange(context, range, nodeToSelect, true);
          } else if (mode === 'end') {
            var ltn = null;
            var ln = com.getLastChild(context.root);
            if (ln) {
              if (com.isEditableNode(ln)) {
                ltn = ln;
              } else {
                ltn = com.getPreviousEditableNode(context, context.root);
              }
              if (ltn) {
                nodeToSelect = ltn.parentNode;
              }
            }
            sel.setNodeToRange(context, range, nodeToSelect, false);
            range.collapse(false);
          }
          range.select();
        } catch (e) {
          // ignore
        }
      },

      /**
       * This method is currently Gecko-only. May be implemented if required by IE
       */
      flushSelection: function (context, keepSelection) {
        // may be implemented if necessary
      },

      /**
       * IE-only method to determine if the range specified is collapsed and therefore
       * represents a caret.
       * @param {TextRange} range The range to be checked
       * @return {Boolean} True if the range is collapsed
       */
      isCollapsed: function (range) {
        if (range.item) {
          return false;
        }
        var startRange = range.duplicate();
        startRange.collapse(true);
        var endRange = range.duplicate();
        endRange.collapse(false);
        return startRange.isEqual(endRange);
      },

      saveNativeSelection: function (context) {
        return context.doc.selection.createRange();
      },

      restoreNativeSelection: function (context, nativeRange) {
        if (nativeRange) {
          nativeRange.select();
        }
      }

    } : {

      /**
       * @private
       */
      getNodeCharacters: function (node) {
        var nodeText = node.nodeValue;
        if (nodeText) {
          return nodeText;
        }
        return '';
      },

      /**
       * @private
       */
      getCharPosition: function (context, node, offset) {
        var charPos = 0;
        var domWalker, nodeToProcess;
        // corner case: offset relative to a tag
        if ((node.nodeType === 1) && !com.isOneCharacterNode(node)) {
          // todo may also be a point of failure with div as root
          if (!com.isRootNode(context, node)) {
            charPos = com.getCharacterOffsetForNode(context, node);
          }
          for (var childIndex = 0; childIndex < offset; childIndex++) {
            var childToProcess = node.childNodes[childIndex];
            charPos += com.getNodeCharacterCnt(childToProcess);
            domWalker = context.doc.createTreeWalker(childToProcess,
              NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, null, false);
            while (true) {
              try {
                nodeToProcess = domWalker.nextNode();
              } catch (ex) {
                // on purpose: ignore nextNode() error because IE9 crashes if there is no next node
              }
              if (!nodeToProcess) {
                break;
              }
              charPos += com.getNodeCharacterCnt(nodeToProcess);
              if (com.isTag(nodeToProcess, com.EDITBLOCK_TAGS)) {
                charPos++;
              }
            }
            if (com.isTag(childToProcess, com.EDITBLOCK_TAGS)) {
              charPos++;
            }
          }
          return charPos;
        }
        // handle one character nodes (br, img) as required: if they are pointed
        // to directly, with offset 0, the caret is actually placed behind the node
        // (character offset is 1 there, according to the caret positioning rules)
        if (node.nodeType === 1) {
          if (offset === 0) {
            offset = 1;
          }
        }
        // by default, calculate through text node and offset
        return com.getCharacterOffsetForNode(context, node) + offset;
      },

      /**
       * @private
       */
      calcNodeAndOffsetForPosition: function (context, charPos, handleSelectionEnd, dom,
                                              calcPos) {
        var sel = CUI.rte.Selection;
        // Parameters dom and calcPos are optional (used for recursion)
        if (!dom) {
          dom = context.root;
          if (com.ua.isWebKit) {
            dom.normalize();
          }
          calcPos = 0;
        }
        var isSuitableNodeEnd, offset;
        if (!com.isRootNode(context, dom)) {
          var charCnt = com.getNodeCharacterCnt(dom);
          // special case: The beginning of a nested list has also to be counted as
          // a single character
          var isNestedStruc = false;
          if (com.isTag(dom, com.EDITBLOCK_UNREGNEST_TAGS)) {
            if ((com.getChildIndex(dom) === 0) &&
              com.isFirstNestedList(context, dom.parentNode)) {
              var pNode = dom;
              do {
                pNode = com.getParentNode(context, pNode);
                if (pNode && com.isTag(pNode, com.EDITBLOCK_UNREGNEST_TAGS)) {
                  charCnt++;
                  isNestedStruc = true;
                  break;
                }
              } while (pNode);
            }
          }
          isSuitableNodeEnd = (charCnt > 0) &&
            (handleSelectionEnd ? (charPos <= (calcPos + charCnt))
              : (charPos < (calcPos + charCnt)));
          if ((charPos >= calcPos) && isSuitableNodeEnd) {
            // treat the end of a list item correctly when the next valid
            // position is in a nested list
            if (isNestedStruc) {
              // on IE, we have to differentiate between the last character
              // of the node and an empty list item of the nested list
              if (com.ua.isIE && (charPos !== calcPos)) {
                return {
                  'node': dom,
                  'offset': null
                };
              }
              offset = null;
              var textDom = com.getPreviousCharacterNode(context, dom);
              if (textDom) {
                dom = textDom;
                offset = sel.getLastSelectionOffset(context, dom,
                  handleSelectionEnd);
              }
              return {
                'node': dom,
                'offset': offset
              };
            }
            offset = charPos - calcPos;
            if (dom.nodeType === 1) {
              offset = (offset === 0 ? null : 0);
              // Gecko doesn't select "br"/0 as end of a selection as one would
              // expect, so use the first character of the next text node
              // instead (don't use break tags here, as we may encounter
              // empty paragraphs as well)
              if (com.isTag(dom, 'br') && (offset === 0) && handleSelectionEnd) {
                var nextTextNode = com.getNextCharacterNode(context, dom);
                if (nextTextNode) {
                  dom = nextTextNode;
                  offset = sel.getFirstSelectionOffset(context, dom);
                }
              }
            }
            return {
              'node': dom,
              'offset': offset
            };
          }
          calcPos += charCnt;
        }
        var childCnt = dom.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          var childToProcess = dom.childNodes[c];
          var ret = sel.calcNodeAndOffsetForPosition(context,
            charPos, handleSelectionEnd, childToProcess, calcPos);
          if (typeof(ret) === 'object') {
            return ret;
          }
          calcPos = ret;
          if (com.isTag(childToProcess, com.EDITBLOCK_TAGS)) {
            // "End of block" corner case
            if (charPos === calcPos) {
              var lastTextNode = com.getLastTextChild(childToProcess, true);
              if (lastTextNode) {
                offset = sel.getLastSelectionOffset(context, lastTextNode,
                  handleSelectionEnd);
                return {
                  'node': lastTextNode,
                  'offset': offset
                };
              }
              // on IE, this means that we have an empty edit block and must
              // continue to the next text node if possible
              offset = null;
              if (com.ua.isIE && !com.ua.isIEBRPlaceholder) {
                var nextEditBlock = com.getNextEditableNode(context,
                  childToProcess);
                if (nextEditBlock) {
                  childToProcess = nextEditBlock;
                } else {
                  // EOT
                  childToProcess = context.root;
                  offset = context.root.length;
                }
              }
              return {
                'node': childToProcess,
                'offset': offset
              };
            }
            // add another character at the end of a edit block, but no rule
            // without exception: don't add at the end of a nested list or an
            // empty edit block on W3C-compliant IE versions
            var isValidEOEB = true;
            var hasSpecialHandling = false;
            if (com.isTag(childToProcess, com.EDITBLOCK_UNREGNEST_TAGS)) {
              var itemParent = com.getParentNode(context, childToProcess);
              var pIndex = com.getChildIndex(childToProcess);
              var isLastChild = (pIndex === (itemParent.childNodes.length - 1));
              var isNestedList = com.containsTagInPath(context, itemParent,
                com.EDITBLOCK_UNREGNEST_TAGS);
              isValidEOEB = !(isLastChild && isNestedList &&
              com.isLastNestedList(context, itemParent));
              hasSpecialHandling = !isValidEOEB;
            } else if (com.isTag(childToProcess, com.EDITBLOCK_NESTED_TAGS)) {
              isValidEOEB = !com.isLastElementOfNestingLevel(context,
                childToProcess);
              hasSpecialHandling = !isValidEOEB;
            }
            if (com.ua.isIE && !com.ua.isIEBRPlaceholder && !hasSpecialHandling) {
              isValidEOEB = !com.isEmptyEditingBlock(childToProcess, true);
            }
            if (isValidEOEB) {
              calcPos++;
            }
          }
        }
        // handle EOT corner case somehow ...
        if (com.isRootNode(context, dom)) {
          var node = com.getLastChild(dom);
          offset = sel.getLastSelectionOffset(context, node, handleSelectionEnd);
          return {
            'node': node,
            'offset': offset
          };
        }
        return calcPos;
      },

      /**
       * @private
       */
      getSelectionObject: function (selection) {
        var anchorNode = selection.anchorNode;
        var anchorOffset = selection.anchorOffset;
        var focusNode = selection.focusNode;
        var focusOffset = selection.focusOffset;
        if (anchorNode !== focusNode) {
          return null;
        }
        if (Math.abs(anchorOffset - focusOffset) !== 1) {
          return null;
        }
        var offset = (anchorOffset < focusOffset ? anchorOffset : focusOffset);
        var selectedNode = anchorNode.childNodes[offset];
        if (!selectedNode) {
          return null;
        }
        if (selectedNode.nodeType === 3) {
          return null;
        }
        if (com.isTag(selectedNode, com.BLOCK_TAGS)) {
          return null;
        }
        return selectedNode;
      },

      /**
       * @private
       */
      getTableSelection: function (context) {
        var tableSelection = {
          'cells': [],
          'otherContent': false
        };
        var selection = context.win.getSelection();
        for (var i = 0; i < selection.rangeCount; i++) {
          var range = selection.getRangeAt(i);
          var cell = null;
          if (range.startContainer === range.endContainer) {
            cell = range.startContainer;
            if (com.isTag(cell, 'tr')) {
              if (range.startOffset === (range.endOffset - 1)) {
                cell = cell.childNodes[range.startOffset];
              } else {
                cell = null;
              }
            } else if (!com.isTag(range.startContainer, ['th', 'td'])) {
              cell = null;
            }
          }
          if (cell) {
            tableSelection.cells.push(cell);
          } else {
            tableSelection.otherContent = true;
          }
        }
        return ((tableSelection.cells.length > 0) ? tableSelection : null);
      },

      getSelection: function (context) {
        return context.win.getSelection();
      },

      getLeadRange: function (context) {
        return context.win.getSelection().getRangeAt(0);
      },

      getCaretPos: function (context) {
        var selection = context.win.getSelection();
        if ((selection.anchorNode !== selection.focusNode) ||
          (selection.anchorOffset !== selection.focusOffset)) {
          return -1;
        }
        return CUI.rte.Selection.getCharPosition(
          context, selection.anchorNode, selection.anchorOffset);
      },

      setCaretPos: function (context, charPos) {
        if (charPos < 0) {
          charPos = 0;
        }
        var selection = context.win.getSelection();
        var range = context.doc.createRange();
        var nodeAndOffset = CUI.rte.Selection.calcNodeAndOffsetForPosition(
          context, charPos);
        // to get similar results to IE, correct to previous structure if we are at the
        // character directly following such a structure
        correctToPreviousStructure(context, nodeAndOffset);
        adjustNodeAndOffsetToParent(context, nodeAndOffset);
        var node = nodeAndOffset.node;
        var offset = nodeAndOffset.offset;
        if (com.isTag(node, ['img', 'br']) && (offset === 0)) {
          // selecting images and brs at the end of an edit block fails on Webkit if
          // the parent element + offset is selected; selecting the image/br and
          // collapsing the selection to its end seems to work though
          range.selectNode(node);
          range.collapse(false);
        } else {
          // handle the selection of empty blocks on IE versions that support the DOM
          // selection model
          var isIEEmptyBlockSel = false;
          if (com.ua.isIE && !com.ua.isIEBRPlaceholder) {
            if ((node.nodeType === 1) && !isNaN(offset)) {
              var potentialBlock = node.childNodes[offset];
              if (potentialBlock &&
                com.isEmptyEditingBlock(potentialBlock, true)) {
                node = potentialBlock;
                isIEEmptyBlockSel = true;
              }
            }
          }
          if (!isIEEmptyBlockSel) {
            range.setStart(node, offset);
            range.setEnd(node, offset);
          } else {
            range.selectNodeContents(node);
          }
        }
        selection.removeAllRanges();
        selection.addRange(range);
      },

      createRange: function (context) {
        return context.doc.createRange();
      },

      selectRange: function (context, rangeToSelect) {
        var selection = context.win.getSelection();
        selection.removeAllRanges();
        selection.addRange(rangeToSelect);
      },

      createRangeBookmark: function (context) {
        var selection = context.win.getSelection();
        if (selection.rangeCount === 1) {
          return {
            'single': true,
            'bookmark': selection.getRangeAt(0)
          };
        } else {
          var ranges = [];
          for (var r = 0; r < selection.rangeCount; r++) {
            ranges.push(selection.getRangeAt(r));
          }
          return {
            'single': false,
            'bookmark': ranges
          };
        }
      },

      selectRangeBookmark: function (context, bookmark) {
        if (bookmark && bookmark.bookmark) {
          var selection = context.win.getSelection();
          selection.removeAllRanges();
          if (bookmark.single) {
            selection.addRange(bookmark.bookmark);
          } else {
            var ranges = bookmark.bookmark;
            for (var r = 0; r < ranges.length; r++) {
              selection.addRange(ranges[r]);
            }
          }
        }
      },

      getRangeTextContent: function (context, range) {
        var selectionFrag = range.cloneContents();
        var fragTreeWalker = context.doc.createTreeWalker(selectionFrag,
          NodeFilter.SHOW_TEXT, null, false);
        var textContent = '',
          nodeToProcess;
        while (true) {
          try {
            nodeToProcess = fragTreeWalker.nextNode();
          } catch (ex) {
            // on purpose: ignore nextNode() error because IE9 crashes if there is no next node
          }
          if (!nodeToProcess) {
            break;
          }
          textContent += CUI.rte.Selection.getNodeCharacters(nodeToProcess);
        }
        return textContent;
      },

      createSelectionBookmark: function (context) {
        var sel = CUI.rte.Selection;
        var selection = context.win.getSelection();
        var selectionObject = CUI.rte.Selection.getSelectionObject(selection);
        var insertObject = null;
        var cells = null;
        var startPos, endPos, range;
        var rangeCnt = selection.rangeCount;
        if (rangeCnt === 1) {
          startPos = sel.getCharPosition(context, selection.anchorNode,
            selection.anchorOffset);
          endPos = sel.getCharPosition(context, selection.focusNode,
            selection.focusOffset);
        } else if (rangeCnt > 1) {
          cells = [];
          for (var r = 0; r < rangeCnt; r++) {
            range = selection.getRangeAt(r);
            var cell = range.startContainer;
            if (com.isTag(cell, 'tr')) {
              cells.push(cell.childNodes[range.startOffset]);
            }
            var rangeStartPos = sel.getCharPosition(context, range.startContainer,
              range.startOffset);
            if ((r === 0) || (rangeStartPos < startPos)) {
              startPos = rangeStartPos;
              endPos = rangeStartPos;
            }
          }
        } else if (rangeCnt === 0) {
          // pre-init/unfocused state: no valid range available, assuming caret at
          // position 0
          startPos = 0;
          endPos = 0;
        }
        if (endPos < startPos) {
          var swap = endPos;
          endPos = startPos;
          startPos = swap;
        }
        if ((startPos === endPos) && !cells && (rangeCnt === 1)) {
          range = selection.getRangeAt(0);
          var parentEl = range.commonAncestorContainer;
          if (parentEl.nodeType === 1) {
            var childCnt = parentEl.childNodes.length;
            // workaround: FF may insert a br in an empty list item
            if ((childCnt === 0) || ((childCnt === 1) &&
              com.isTag(parentEl.childNodes[0], 'br'))) {
              insertObject = parentEl;
              if (CUI.rte.Selection.isNoInsertNode(insertObject)) {
                insertObject = null;
              }
            }
          }
        }
        return CUI.rte.Utils.apply({
          'startPos': startPos,
          'charCnt': endPos - startPos,
          'object': selectionObject,
          'insertObject': insertObject,
          'cells': cells
        }, CUI.rte.Selection.getScrollOffsets(context));
      },

      selectBookmark: function (context, bookmark) {
        var sel = CUI.rte.Selection;
        var doc = context.doc;
        var objectToSelect = null;
        var range, selection;
        var cells = bookmark.cells;

        // if table cells are bookmarked, we're trying to select them first and use
        // the caret position only if none of the cells are available
        if (cells) {
          selection = context.win.getSelection();
          selection.removeAllRanges();
          var hasValidCells = false;
          var cellCnt = cells.length;
          for (var c = 0; c < cellCnt; c++) {
            var cellToProcess = cells[c];
            if (cellToProcess && cellToProcess.ownerDocument === doc) {
              range = doc.createRange();
              var container = cellToProcess.parentNode;
              var offset = com.getChildIndex(cellToProcess);
              try {
                range.setStart(container, offset);
                range.setEnd(container, offset + 1);
                selection.addRange(range);
                hasValidCells = true;
              } catch (e) {
                // intentionally ignored; will be handled through hasValidCells
              }
            }
          }
          if (hasValidCells) {
            return;
          }
        }

        // the default selection process
        if (bookmark.object) {
          objectToSelect = bookmark.object;
        } else if (bookmark.insertObject) {
          objectToSelect = bookmark.insertObject;
        }
        range = doc.createRange();
        if (objectToSelect) {
          try {
            range.selectNode(objectToSelect);
            range.collapse(true);
          } catch (e) {
            // if the object is not available anymore (which might be the cause
            // when undoing), use the caret-position instead
            if (bookmark.startPos !== null && bookmark.startPos !== undefined) {
              objectToSelect = undefined;
            }
          }
        }

        var isRangeCreated = !!objectToSelect;
        var startNodeAndOffset;
        var endNodeAndOffset;
        if (!isRangeCreated) {
          startNodeAndOffset = sel.calcNodeAndOffsetForPosition(context,
            bookmark.startPos);
          endNodeAndOffset = startNodeAndOffset;
          if (bookmark.charCnt > 0) {
            endNodeAndOffset = sel.calcNodeAndOffsetForPosition(context,
              bookmark.startPos + bookmark.charCnt, true);
          } else if (com.ua.isIE) {
            // selecting an empty edit block on IE causes problems if the
            // setStart... methods are used
            if (com.isEmptyEditingBlock(startNodeAndOffset.node, true)) {
              if (com.isTag(startNodeAndOffset.node, 'li') ||
                com.isTag(startNodeAndOffset.node, com.TABLE_CELLS)) {
                // empty list items and table cells require another special
                // treatment
                range.setStart(startNodeAndOffset.node, 0);
              } else {
                range.selectNode(startNodeAndOffset.node);
                range.collapse(true);
              }
              isRangeCreated = true;
            }
          }
        }

        if (!isRangeCreated) {
          correctToPreviousStructure(context, startNodeAndOffset);
          if (com.ua.isGecko) {
            adjustNodeAndOffsetToParent(context, startNodeAndOffset);
          }
          if (bookmark.charCnt > 0) {
            if (com.ua.isGecko) {
              adjustNodeAndOffsetToParent(context, endNodeAndOffset);
            }
          }
          var startNode = startNodeAndOffset.node;
          var startOffset = startNodeAndOffset.offset;
          var endNode = endNodeAndOffset.node;
          var endOffset = endNodeAndOffset.offset;
          if (!com.ua.isGecko && (startNode.nodeType === 1)) {
            if (startOffset === null || startOffset === undefined) {
              // TODO probably needs "empty block/table cell" fix for IE (use setEnd?)
              range.setStartBefore(startNode);
            } else {
              range.setStartAfter(startNode);
            }
          } else {
            range.setStart(startNode, startOffset);
          }
          if (!com.ua.isGecko && (endNode.nodeType === 1)) {
            if (endOffset === null || endOffset === undefined) {
              // TODO probably needs "empty block/table cell" fix for IE (use setEnd?)
              range.setEndBefore(endNode);
            } else {
              range.setEndAfter(endNode);
            }
          } else {
            range.setEnd(endNode, endOffset);
          }
        }

        selection = context.win.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
      },

      /**
       * Trims leading and trailing whitespace from the given range.
       * @param {TextRange} range The range to trim
       * @return {TextRange} A range that has no more trailing and/or leading whitespace
       */
      trimRangeWhitespace: function (context, range) {
        var sel = CUI.rte.Selection;
        var rangeText = sel.getRangeTextContent(context, range);
        var leadingWhitespaceCnt = 0;
        var checkPos = 1;
        var fragToCheck;
        while (checkPos < rangeText.length) {
          fragToCheck = rangeText.substring(0, checkPos++);
          if (!sel.hasWhitespaceOnly(fragToCheck)) {
            break;
          }
          leadingWhitespaceCnt++;
        }
        var trailingWhitespaceCnt = 0;
        checkPos = rangeText.length;
        while (checkPos > 0) {
          fragToCheck = rangeText.substring(--checkPos, rangeText.length);
          if (!sel.hasWhitespaceOnly(fragToCheck)) {
            break;
          }
          trailingWhitespaceCnt++;
        }
        if ((rangeText.length - leadingWhitespaceCnt - trailingWhitespaceCnt) > 0) {
          if (leadingWhitespaceCnt > 0) {
            var startPos = sel.getCharPosition(context, range.startContainer,
              range.startOffset);
            startPos += leadingWhitespaceCnt;
            var startNodeAndOffset = sel.calcNodeAndOffsetForPosition(context,
              startPos);
            range.setStart(startNodeAndOffset.node, startNodeAndOffset.offset);
          }
          if (trailingWhitespaceCnt > 0) {
            var endPos = sel.getCharPosition(context, range.endContainer,
              range.endOffset);
            endPos -= trailingWhitespaceCnt;
            var endNodeAndOffset = sel.calcNodeAndOffsetForPosition(context,
              endPos);
            range.setEnd(endNodeAndOffset.node, endNodeAndOffset.offset);
          }
        }
        return range;
      },

      createProcessingSelection: function (context) {
        var startNode, startOffset, endNode, endOffset;
        var selection = context.win.getSelection();
        var sel = CUI.rte.Selection;
        // table cell selection "support"
        var cellSelection = null;
        var isSingleCellSelected = false;
        if ((selection.focusNode === selection.anchorNode) &&
          (com.isTag(selection.focusNode, 'tr'))) {
          isSingleCellSelected = true;
        }
        if ((selection.rangeCount > 1) || isSingleCellSelected) {
          cellSelection = sel.getTableSelection(context);
          var range = selection.getRangeAt(0);
          startNode = range.startContainer;
          startOffset = null;
          if (startNode.nodeType === 1) {
            startNode = startNode.childNodes[range.startOffset];
          } else {
            startOffset = range.startOffset;
          }
          range = selection.getRangeAt(selection.rangeCount - 1);
          endOffset = null;
          endNode = range.endContainer;
          if (endNode.nodeType === 1) {
            if (range.endOffset < endNode.childNodes.length) {
              endNode = com.getPreviousNode(context,
                endNode.childNodes[range.endOffset]);
            } else {
              endNode = com.getLastChild(endNode);
            }
            if (endNode.nodeType === 3) {
              endOffset = com.getNodeCharacterCnt(endNode);
            }
          } else {
            endOffset = range.endOffset;
          }
          // check if selection is actually valid (IE sometimes returns invalid
          // selections!)
          if (!com.isAncestor(context, context.root, startNode)) {
            return null;
          }
          return {
            'startNode': startNode,
            'startOffset': startOffset,
            'endNode': endNode,
            'endOffset': endOffset,
            'isDiscontinuousSelection': true,
            'cellSelection': cellSelection
          };
        }
        // selected "objects" (a name, img, etc.)
        var selectionObject = sel.getSelectionObject(selection);
        if (selectionObject) {
          // check if selection is actually valid (IE sometimes returns invalid
          // selections!)
          if (!com.isAncestor(context, context.root, selectionObject)) {
            return null;
          }
          return {
            'startNode': selectionObject
          };
        }
        startNode = selection.anchorNode;
        startOffset = selection.anchorOffset;
        endNode = selection.focusNode;
        endOffset = selection.focusOffset;
        var childCnt;
        // startNode might be null, so it's better to check for that first
        if (startNode && !com.isOneCharacterNode(startNode) && (startNode.nodeType === 1)) {
          childCnt = startNode.childNodes.length;
          if (childCnt === 0) {
            startOffset = null;
          } else if (startOffset < childCnt) {
            startNode = startNode.childNodes[startOffset];
            startNode = com.getFirstChild(startNode) || startNode;
            if ((startNode.nodeType === 1) && !com.isCharacterNode(startNode)) {
              // if we are on an empty structural tag (an empty span, b, i, etc.),
              // take the next character node if available (IE 9 might change
              // the selection to such a structure under some circumstances)
              var nextCharNode = com.getNextCharacterNode(context, startNode,
                com.EDITBLOCK_TAGS);
              if (nextCharNode) {
                startNode = nextCharNode;
              }
            }
            startOffset = sel.getFirstSelectionOffset(context, startNode);
          } else {
            startNode = com.getLastChild(startNode);
            if (startNode.nodeType === 3) {
              startOffset = com.getNodeCharacterCnt(startNode);
            } else if (com.isOneCharacterNode(startNode)) {
              startOffset = 0;
            } else {
              startOffset = null;
            }
          }
        }
        var isCollapsed = (startNode === endNode) && (startOffset === endOffset);
        if (isCollapsed) {
          if (com.ua.isW3cIE) {
            // on IE >= 9, the start of a text node is actually handled as the end
            // of the previous text node (if applicable) - handle this as well
            if (startNode && (startNode.nodeType === 3) && (startOffset === 0) && !dpr.isZeroSizePlaceholder(startNode)) {
              var prevCharNode = com.getPreviousCharacterNode(context, startNode,
                com.EDITBLOCK_TAGS);
              if (prevCharNode && !com.isOneCharacterNode(prevCharNode)) {
                startNode = prevCharNode;
                startOffset = com.getNodeCharacterCnt(startNode);
              }
            }
          }
          // check if selection is actually valid (IE sometimes returns invalid
          // selections!)
          if (!com.isAncestor(context, context.root, startNode)) {
            return null;
          }
          return {
            'startNode': startNode,
            'startOffset': startOffset,
            'cellSelection': cellSelection
          };
        }
        if (!com.isOneCharacterNode(endNode) && (endNode.nodeType === 1)) {
          childCnt = endNode.childNodes.length;
          if (childCnt === 0) {
            endOffset = null;
          } else if (endOffset < childCnt) {
            endNode = endNode.childNodes[endOffset];
            endNode = com.getFirstChild(endNode) || endNode;
            endOffset = ((endNode.nodeType === 1) && !com.hasTextChild(endNode, false) ? null : 0);
          } else {
            endNode = com.getLastChild(endNode);
            if (endNode.nodeType === 3) {
              endOffset = com.getNodeCharacterCnt(endNode);
            } else if (com.isOneCharacterNode(endNode)) {
              endOffset = 0;
            } else {
              endOffset = null;
            }
          }
        }
        var mustSwap = false;
        if (startNode === endNode) {
          if (startOffset === endOffset) {
            // actually, this is no selection, but a single caret, misrepresented
            // by the browser
            endNode = null;
            endOffset = null;
          } else {
            mustSwap = (endOffset < startOffset);
          }
        } else {
          var startIndex = com.createIndexPath(context, startNode);
          var endIndex = com.createIndexPath(context, endNode);
          mustSwap = (com.compareIndexPaths(startIndex, endIndex) < 0);
        }
        if (mustSwap) {
          var swap = endNode;
          endNode = startNode;
          startNode = swap;
          swap = endOffset;
          endOffset = startOffset;
          startOffset = swap;
        }
        // special case: one node characters, directly preceded/followed by a text or
        // a "one character" node must be normalized for IE >= 9, because they are
        // reported starting/ending at the last/first character of the
        // preceding/following text/"one character" node
        // TODO does checking for Edge separately make sense, or should it be "part of" isW3cIE?
        if (com.ua.isW3cIE || com.ua.isEdge) {
          //preceding text
          var startChars = sel.getNodeCharacters(startNode);
          if (startChars.length > 0) {
            if (startOffset === startChars.length) {
              var nextStartNode = com.getNextEditableNode(context, startNode,
                com.EDITBLOCK_TAGS);
              if (com.isOneCharacterNode(nextStartNode)) {
                startNode = nextStartNode;
                startOffset = null;
              }
            }
          }
          // follow-up text
          if (com.isOneCharacterNode(startNode) && com.isNull(startOffset)) {
            if ((com.isNull(endOffset) && com.isOneCharacterNode(endNode)) ||
                    ((endOffset === 0) && (endNode.nodeType === 3))) {
              var nextEditNode = com.getNextEditableNode(context, startNode,
                      com.EDITBLOCK_TAGS);
              if (endNode === nextEditNode) {
                endNode = null;
                endOffset = null;
              }
            }
          }
        }
        // check if selection is actually valid (IE sometimes returns invalid
        // selections!)
        if (!com.isAncestor(context, context.root, startNode)) {
          return null;
        }
        return {
          'startNode': startNode,
          'startOffset': startOffset,
          'endNode': endNode,
          'endOffset': endOffset,
          'cellSelection': cellSelection
        };
      },

      selectNode: function (context, dom, asInsertPoint) {
        if (dom.nodeType === 3) {
          throw new Error('Selecting a text node is not supported.');
        }
        var selection = context.win.getSelection();
        var range = context.doc.createRange();
        if (asInsertPoint) {
          var textNode = com.getFirstTextChild(dom);
          if (textNode) {
            range.setStart(textNode, 0);
            range.setEnd(textNode, 0);
          } else {
            // "empty line" handling
            if ((dom.childNodes.length === 1) &&
              (dom.childNodes[0].nodeType === 1)) {
              range.selectNode(dom.childNodes[0]);
              range.collapse(true);
            } else if (com.ua.isIE && com.isEmptyEditingBlock(dom, true)) {
              // IE supporting W3C selection model needs special treatment
              // for empty blocks
              range.selectNodeContents(dom);
            } else {
              range.selectNode(dom);
              range.collapse(true);
            }
          }
        } else {
          range.selectNode(dom);
        }
        selection.removeAllRanges();
        selection.addRange(range);
      },

      selectEmptyNode: function (context, dom) {
        var selection = context.win.getSelection();
        var range = context.doc.createRange();
        if (!dpr.isZeroSizePlaceholder(dom)) {
          var tempSpan = dpr.createTempSpan(context, true, false, true);
          tempSpan.appendChild(context.createTextNode(dpr.ZERO_WIDTH_NBSP));
          dom.appendChild(tempSpan);
        }
        if (com.ua.isWebKit) {
          range.selectNode(dom);
          range.collapse(false);
        } else {
          range.setStart(dom, 0);
          range.setEnd(dom, 0);
        }
        selection.removeAllRanges();
        selection.addRange(range);
      },

      selectBeforeNode: function (context, dom) {
        var selection = context.win.getSelection();
        var range = context.doc.createRange();
        // add a temporary node and select behind that one instead - this makes
        // it more stable and easier to handle
        var tempSpan = dpr.createTempSpan(context, true, false, true);
        tempSpan.appendChild(context.createTextNode(dpr.ZERO_WIDTH_NBSP));
        dom.parentNode.insertBefore(tempSpan, dom);
        dom = tempSpan;
        if (com.ua.isWebKit) {
          range.setStartAfter(dom);
          range.setEndAfter(dom);
        } else {
          range.setStartBefore(dom);
          range.setEndBefore(dom);
        }
        selection.removeAllRanges();
        selection.addRange(range);
      },

      selectAfterNode: function (context, dom) {
        var dpr = CUI.rte.DomProcessor;
        var selection = context.win.getSelection();
        var range = context.doc.createRange();
        // add a temporary node and select behind that one instead - this makes
        // it more stable and easier to handle
        var tempSpan = dpr.createTempSpan(context, true, false, true);
        tempSpan.appendChild(context.createTextNode(dpr.ZERO_WIDTH_NBSP));
        dom.parentNode.insertBefore(tempSpan, dom.nextSibling);
        dom = tempSpan;
        if (com.ua.isWebKit) {
          range.setStartAfter(dom);
          range.setEndAfter(dom);
        } else {
          range.setStartBefore(dom);
          range.setEndBefore(dom);
        }
        selection.removeAllRanges();
        selection.addRange(range);
      },

      /**
       * This method is Gecko only, as only Gecko seems to have problems with the caret
       * getting out of the visible area of the editor iframe.
       */
      getPreferredScrollOffset: function (context) {
        return context.root.scrollTop;
      },

      /**
       * This method is Gecko/Webkit only, as IE does not seem to have problems with the
       * caret getting out of the visible area of the editor iframe.
       */
      ensureCaretVisibility: function (context, preferredScrollOffset) {
        var sel = CUI.rte.Selection;
        var range = sel.getLeadRange(context).cloneRange();
        // workaround for selected cells (insertNode() doesn't handle them as expected)
        if (range.startContainer.nodeType === 1) {
          var nodeToCheck = range.startContainer.childNodes[range.startOffset];
          if (com.isTag(nodeToCheck, ['td', 'th'])) {
            range.selectNodeContents(nodeToCheck);
          }
        }
        // use a helper span to exactly determine current caret position/size in pixels
        if (context.iFrame) {
          var locSpan = context.createElement('span');
          var nbsp = context.createTextNode(dpr.NBSP);
          locSpan.appendChild(nbsp);
          range.insertNode(locSpan);
          var top = locSpan.offsetTop;
          var op = locSpan;
          while (op.offsetParent) {
            op = op.offsetParent;
            top += op.offsetTop;
          }
          var height = locSpan.offsetHeight;
          var scrollTop = context.root.scrollTop;
          var iframeHeight = context.iFrame.clientHeight;
          var scrollBottom = scrollTop + iframeHeight;
          var bottom = top + height;
          var maxScroll = context.root.scrollHeight;
          if ((maxScroll - bottom) < 8) {
            bottom = maxScroll;
          }
          if (preferredScrollOffset !== null && preferredScrollOffset !== undefined) {
            var preferredBottom = preferredScrollOffset + iframeHeight;
            if ((top >= preferredScrollOffset) && (bottom < preferredBottom)) {
              context.root.scrollTop = preferredScrollOffset;
            } else {
              if (top < preferredScrollOffset) {
                context.root.scrollTop = top;
              } else {
                context.root.scrollTop = bottom - iframeHeight;
              }
            }
          } else if (bottom > scrollBottom) {
            context.root.scrollTop = bottom - iframeHeight;
          } else if (top < scrollTop) {
            context.root.scrollTop = top;
          }
          var pNode = locSpan.parentNode;
          pNode.removeChild(locSpan);
          pNode.normalize();
        }
      },

      /**
       * This method is Gecko-only. Can be used as a workaround to ensure no selection
       * artifacts are displayed onscreen.
       */
      flushSelection: function (context, keepSelection) {
        var selection = context.win.getSelection();
        var savedRanges, r, rangeCnt;
        if (keepSelection) {
          savedRanges = [];
          rangeCnt = selection.rangeCount;
          for (r = 0; r < rangeCnt; r++) {
            savedRanges.push(selection.getRangeAt(r));
          }
        }
        selection.selectAllChildren(context.root);
        selection.collapseToStart();
        if (keepSelection) {
          selection.removeAllRanges();
          for (r = 0; r < rangeCnt; r++) {
            selection.addRange(savedRanges[r]);
          }
        }
      },

      resetSelection: function (context, mode) {
        try {
          var range;
          var selection = context.win.getSelection();
          var nodeToSelect = context.root;
          if (mode === 'all') {
            selection.selectAllChildren(nodeToSelect);
          } else if (mode === 'start') {
            var ftn = com.getNextEditableNode(context, context.root);
            if (ftn) {
              nodeToSelect = ftn.parentNode;
            }
            if (com.ua.isIE && com.isEmptyEditingBlock(ftn, true)) {
              range = context.doc.createRange();
              range.selectNodeContents(ftn);
              selection.removeAllRanges();
              selection.addRange(range);
            } else {
              selection.selectAllChildren(nodeToSelect);
              selection.collapseToStart();
            }
          } else if (mode === 'end') {
            var ltn = null;
            var ln = com.getLastChild(context.root);
            if (ln) {
              if (com.isEditableNode(ln)) {
                ltn = ln;
              } else {
                ltn = com.getPreviousEditableNode(context, context.root);
              }
              if (ltn) {
                nodeToSelect = ltn.parentNode;
              }
            }
            if (com.ua.isIE && com.isEmptyEditingBlock(ltn, true)) {
              range = context.doc.createRange();
              range.selectNodeContents(ltn);
              selection.removeAllRanges();
              selection.addRange(range);
            } else {
              selection.selectAllChildren(nodeToSelect);
              selection.collapseToEnd();
            }
          }
        } catch (e) {
          // ignore
        }
      },

      saveNativeSelection: function (context) {
        if (!CUI.rte.Common.ua.isIE) {
          return null;
        }
        return context.win.getSelection().getRangeAt(0);
      },

      restoreNativeSelection: function (context, nativeRange) {
        if (nativeRange) {
          context.win.getSelection().addRange(nativeRange);
        }
      }

    });

  }());
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.UndoManager
 * @private
 * This class implements undo/redo functionality for the RichText component.
 * @constructor
 * Creates a new UndoManager.
 * @param {Number} maxUndoSteps Number of maximum undo steps
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.UndoManager = new Class({

    toString: 'UndoManager',

    /**
     * Array that contains all currently available undo steps
     * @type CUI.rte.UndoManager.Step
     * @private
     */
    undoHistory: null,

    /**
     * Number of maximum undo steps
     * @type Number
     * @public
     */
    maxUndoSteps: 0,

    /**
     * Currently active undo step (as array index of array {@link #undoHistory})
     * @type Number
     * @private
     */
    activeUndoStep: 0,

    construct: function (maxUndoSteps) {
      this.undoHistory = [];
      this.maxUndoSteps = maxUndoSteps;
      this.activeUndoStep = 0;
    },

    /**
     * <p>Adds the specified undo step to the undo history.</p>
     * <p>The undo step is only added if it is different from the currently active
     * undo step.</p>
     * @param {CUI.rte.UndoManager.Step} stepToAdd The undo step to add
     * @return {Boolean} True if the step has actually been added
     */
    addStep: function (stepToAdd) {
      // special case: if we are somewhere in the history (except at their end) we
      // also have to check if the step to add is the same as the current step and leave
      // the history intact if this is the case.
      var activeStep;
      if (this.activeUndoStep > 0) {
        activeStep = this.undoHistory[this.activeUndoStep - 1];
        if (activeStep.hasEqualSnapshot(stepToAdd)) {
          // window.console.log("Skipping identical undo step.");
          if (CUI.rte.Selection.compareBookmarks(activeStep.bookmark, stepToAdd.bookmark) === false) {
            activeStep.bookmark = stepToAdd.bookmark;
          }
          return false;
        }
      }
      // remove all steps behind the currently active, as they become invalid through
      // the newly added
      this.clearRedoHistory();
      // finally add the step
      this.undoHistory.push(stepToAdd);
      // shorten history if it has grown too large
      if (this.undoHistory.length > this.maxUndoSteps) {
        var stepsToRemove = this.undoHistory.length - this.maxUndoSteps;
        /*
         window.console.log("Shortening undo history by " + stepsToRemove + " steps "
         + " to ensure maximum size.");
         */
        this.undoHistory.splice(0, stepsToRemove);
        this.activeUndoStep -= stepsToRemove;
      }
      this.activeUndoStep++;
      // window.console.log("Step added: " + this.createShortDump());
      return true;
    },

    /**
     * Checks if there are undo steps are defined (and thus undo is available).
     * @return {Boolean} True if undo is currently available
     */
    canUndo: function () {
      return (this.activeUndoStep > 1);
    },

    /**
     * Checks if there are undo steps behind the currently active undo step (and thus
     * redo is available).
     * @return {Boolean} True if redo is currently available
     */
    canRedo: function () {
      return (this.activeUndoStep < this.undoHistory.length);
    },

    /**
     * Executes a one-step undo, if there are undoable steps available.
     * @param {CUI.rte.EditContext} context The edit context
     */
    undo: function (context) {
      // try to add another undo step to reflect the changes that may have been
      // made since the last undo step was recorded
      if (this.addStep(new CUI.rte.UndoManager.Step(context))) {
        console.log('Recorded additional undo step');
      }
      if (this.canUndo()) {
        // the actual undo
        this.activeUndoStep--;
        this.undoHistory[this.activeUndoStep - 1].set(context);
        // window.console.log('After undo: ' + this.createShortDump());
      }
    },

    /**
     * Executes a one-step redo, if there are redoable steps available.
     * @param {CUI.rte.EditContext} context The edit context
     */
    redo: function (context) {
      if (this.addStep(new CUI.rte.UndoManager.Step(context))) {
        console.log('Recorded additional undo step');
      }
      if (this.canRedo()) {
        this.undoHistory[this.activeUndoStep].set(context);
        this.activeUndoStep++;
      }
      // window.console.log("After redo: " + this.createShortDump());
    },

    /**
     * <p>Initializes the undo manager from the given editor's iframe.</p>
     * <p>The undo history is cleared and re-initialized with a snapshot of the specified
     * editor content.</p>
     * @param {CUI.rte.EditContext} context The edit context
     */
    initialize: function (context) {
      // window.console.log("Initializing undo manager");
      this.undoHistory.length = 0;
      this.activeUndoStep = 0;
      this.addStep(new CUI.rte.UndoManager.Step(context));
    },

    /**
     * <p>Clears the undo history from the currently active undo step. This has the effect
     * that no more redo steps are available afterwards.</p>
     * <p>This method should be explicitly called if anything is changed after the last undo
     * and no undo step has yet been recorded for the change.</p>
     */
    clearRedoHistory: function () {
      var stepsToRemove = this.undoHistory.length - this.activeUndoStep;
      if (stepsToRemove > 0) {
        // window.console.log("Removing " + stepsToRemove + " steps.");
        this.undoHistory.splice(this.activeUndoStep, stepsToRemove);
      }
    },

    /**
     * Creates a clone of the current history array. The included steps are not cloned!
     * @return {Array} Cloned history
     */
    cloneHistory: function () {
      var clonedHistory = [];
      for (var h = 0; h < this.undoHistory.length; h++) {
        clonedHistory.push(this.undoHistory[h]);
      }
      return clonedHistory;
    },

    /**
     * Creates a (short) dump of the current undo history
     * @return {String} A short dump of the current undo history
     * @private
     */
    createShortDump: function () {
      var stepCnt = this.undoHistory.length;
      return 'Undo history (' + stepCnt + ' steps; active step: #' +
        this.activeUndoStep + '; maximum steps: ' + this.maxUndoSteps + ')';
    },

    /**
     * Creates a (full) dump of the current undo history
     * @return {String} A full dump of the current undo history
     * @private
     */
    createDump: function () {
      var stepCnt = this.undoHistory.length;
      var dump = this.createShortDump() + ':\n';
      for (var s = 0; s < stepCnt; s++) {
        dump += '#' + s + ': ' + this.undoHistory[s].createDump();
      }
      return dump;
    }
  });


  /**
   * @class CUI.rte.UndoManager.Step
   * @private
   * The UndoManager.Step represents a single undoable step of the undo history.
   * @constructor
   * Creates a new UndoManager.Step from the specified RichText edit frame.
   * @param {CUI.rte.EditContext} context The edit context
   * @param {Object} bookmark (optional) A selection bookmark to be used; if none is
   *        specified, the bookmark is created through the specified edit context
   */
  CUI.rte.UndoManager.Step = new Class({

    toString: 'UndoManager.Step',

    /**
     * The HTML snapshot representing the undo step
     */
    htmlSnapshot: null,

    /**
     * The bookmark representing the editor's selection at the time of the snapshot taken
     */
    bookmark: null,

    construct: function (context, bookmark) {
      var sel = CUI.rte.Selection;
      this.bookmark = (bookmark ? bookmark : sel.createSelectionBookmark(context));
      // delete object references from bookmark, as they would point to "zombie nodes"
      // after a undo/redo
      this.bookmark.insertObject = undefined;
      this.bookmark.object = undefined;
      var cleanupRoot = context.root.cloneNode(true);
      this.cleanup(cleanupRoot);
      this.htmlSnapshot = cleanupRoot.innerHTML;
    },

    /**
     * Removes temporary stuff from the DOM
     * @private
     */
    cleanup: function (dom) {
      var com = CUI.rte.Common;
      if (dom.nodeType === 1) {
        com.removeClass(dom, CUI.rte.Theme.TABLESELECTION_CLASS);
        var childCnt = dom.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          this.cleanup(dom.childNodes[c]);
        }
      }
    },

    /**
     * Sets the represented undo step to the RichText represented by the specified edit
     * context.
     * @param {CUI.rte.EditContext} context The edit context
     */
    set: function (context) {
      context.root.innerHTML = this.htmlSnapshot;
      CUI.rte.Selection.selectBookmark(context, this.bookmark);
    },

    /**
     * Compares the HTML snapshot of this undo step with the snapshot of the specified
     * undo step.
     * @param {CUI.rte.UndoManager.Step} stepToCompareWith The undo step to compare with
     * @return {Boolean} True if both steps have the same HTML snapshot
     */
    hasEqualSnapshot: function (stepToCompareWith) {
      return this.htmlSnapshot === stepToCompareWith.htmlSnapshot;
    },

    /**
     * Compares this undo step with the specified undo step.
     * @param {CUI.rte.UndoManager.Step} stepToCompareWith The undo step to compare with
     * @return {Boolean} True if both steps are identical
     */
    equals: function (stepToCompareWith) {
      var sel = CUI.rte.Selection;
      if (this.htmlSnapshot !== stepToCompareWith.htmlSnapshot) {
        return false;
      }
      return sel.compareBookmarks(this.bookmark, stepToCompareWith.bookmark);
    },

    /**
     * Creates a dump of the undo step
     * @return {String} A dump of the undo step
     * @private
     */
    createDump: function () {
      var dump = '\n';
      dump += 'Bookmark:\n' + CUI.rte.Common.dumpObject(this.bookmark, 4);
      dump += '\nHTML-Snapshot:\n' + this.htmlSnapshot;
      dump += '\n\n';
      return dump;
    }

  });

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.TableMatrix
 * @private
 * <p>This class implements an abstract representation of a table for easier processing
 * &amp; editing (especially regarding colspan/rowspan settings).</p>
 * <p>A table matrix basically consists of a two dimensional array which represents the
 * actual cells of the table. In contrast to the DOM representation of a table, cells are
 * actually adressable via their linear row/column numbers, even with
 * complex rowspan/colspan settings.</p>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.TableMatrix = new Class({

    toString: 'TableMatrix',

    /**
     * The table matrix
     * @private
     */
    matrix: null,

    /**
     * Row definitions
     * @private
     */
    rows: null,

    /**
     * The full table matrix
     * @private
     */
    fullMatrix: null,

    /**
     * The table
     * @private
     */
    tableDom: null,

    /**
     * @private
     */
    getPreviousRowCellDef: function (row, cellPos) {
      while (row > 0) {
        row--;
        var cellDefToCheck = this.matrix[row][cellPos];
        if (cellDefToCheck !== null && cellDefToCheck !== undefined) {
          return {
            'row': row,
            'col': cellPos,
            'cell': cellDefToCheck
          };
        }
        var prevCellPos = cellPos - 1;
        while (prevCellPos >= 0) {
          var cellDef = this.matrix[row][prevCellPos];
          if (cellDef) {
            if ((prevCellPos + cellDef.colSpan) > cellPos) {
              return {
                'row': row,
                'col': prevCellPos,
                'cell': cellDef
              };
            }
            break;
          }
          prevCellPos--;
        }
      }
      return null;
    },

    /**
     * Creates a table matrix for easier calculation of merged cells.
     * @param {HTMLElement} tableDom DOM node that represents the table
     */
    createTableMatrix: function (tableDom) {
      var com = CUI.rte.Common;
      this.tableDom = tableDom;
      this.matrix = [];
      this.fullMatrix = null;
      this.rows = com.getChildNodesByType(tableDom, 'tr', true, 'table');
      for (var r = 0; r < this.rows.length; r++) {
        var rowDefs = [];
        this.matrix.push(rowDefs);
        var cells = com.getChildNodesByType(this.rows[r], ['th', 'td'], false);
        var cellPos = 0;
        for (var c = 0; c < cells.length; c++) {
          var cell = cells[c];
          var colSpanAttr = com.getAttribute(cell, 'colspan');
          var rowSpanAttr = com.getAttribute(cell, 'rowspan');
          var colSpan = (colSpanAttr ? parseInt(colSpanAttr, 10) : 1);
          var rowSpan = (rowSpanAttr ? parseInt(rowSpanAttr, 10) : 1);
          while (true) {
            var prevRowCell = this.getPreviousRowCellDef(r, cellPos);
            if (prevRowCell) {
              var prevRow = prevRowCell.row;
              var prevRowSpan = prevRowCell.cell.rowSpan;
              if ((prevRow + prevRowSpan) <= r) {
                rowDefs[cellPos] = {
                  'col': cellPos,
                  'row': r,
                  'colSpan': colSpan,
                  'rowSpan': rowSpan,
                  'cellDom': cell
                };
                cellPos += colSpan;
                break;
              }
            } else {
              rowDefs[cellPos] = {
                'col': cellPos,
                'row': r,
                'colSpan': colSpan,
                'rowSpan': rowSpan,
                'cellDom': cell
              };
              cellPos += colSpan;
              break;
            }
            cellPos++;
          }
        }
      }
    },

    /**
     * <p>Creates a "full" matrix from the (basic) matrix previously created by
     * {@link CUI.rte.TableMatrix#createTableMatrix}.</p>
     * <p>The "full matrix" is a different representation of the table. You usually don't
     * have to call this method explicitly, as all methods requiring the full matrix will
     * invoke it implicitly if necessary.</p>
     * @private
     */
    createFullMatrix: function () {
      if (this.matrix === null || this.matrix === undefined) {
        throw new Error('No basic matrix calculated; use createTableMatrix() before.');
      }
      this.fullMatrix = [];
      for (var i = 0; i < this.matrix.length; i++) {
        for (var j = 0; j < this.matrix[i].length; j++) {
          if (this.matrix[i][j] !== null && this.matrix[i][j] !== undefined) {
            var cell = this.matrix[i][j];
            for (var c = 0; c < cell.colSpan; c++) {
              for (var r = 0; r < cell.rowSpan; r++) {
                var row;
                if (this.fullMatrix[r + i]) {
                  row = this.fullMatrix[r + i];
                } else {
                  row = [];
                  this.fullMatrix[r + i] = row;
                }
                row[c + j] = {
                  'isOrigin': (c === 0) && (r === 0),
                  'cellRef': cell
                };
              }
            }
          }
        }
      }
    },

    /**
     * Get the actual table size (considering all colspan/rowspan settings).
     * @return {Object} The table site (properties: cols, rows)
     */
    getTableSize: function () {
      if (this.matrix === null || this.matrix === undefined) {
        throw new Error('No basic matrix calculated; use createTableMatrix() before.');
      }
      var rows = this.rows.length;
      var cols = 0;
      for (var c = 0; c < this.matrix[0].length; c++) {
        if (this.matrix[0][c]) {
          cols += this.matrix[0][c].colSpan;
        }
      }
      return {
        'cols': cols,
        'rows': rows
      };
    },

    /**
     * Get the cell definition for the specified row/column.
     * @param {Number} col column (0-based)
     * @param {Number} row row (0-based)
     * @return {Object} cell definition (properties: col, row, colSpan, rowSpan, cellDom;
     *         note that the column/row specified here might be different to the col/row
     *         specified by the caller as it always specifies the first col/row a cell
     *         occupies)
     */
    getCellForCoords: function (col, row) {
      if (this.fullMatrix === null || this.fullMatrix === undefined) {
        this.createFullMatrix();
      }
      if (row >= this.fullMatrix.length) {
        return null;
      }
      var cells = this.fullMatrix[row];
      if (col >= cells.length) {
        return null;
      }
      return cells[col].cellRef;
    },

    /**
     * Get the cell definition for the specified DOM cell object.
     * @param {HTMLTableCellElement} cellDom The cell
     * @return {Object} cell definition (properties: col, row, colSpan, rowSpan, cellDom)
     */
    getCellDef: function (cellDom) {
      if (this.matrix === null || this.matrix === undefined) {
        throw new Error('No basic matrix calculated; use createTableMatrix() before.');
      }
      for (var r = 0; r < this.matrix.length; r++) {
        for (var c = 0; c < this.matrix[r].length; c++) {
          var cellDef = this.matrix[r][c];
          if (cellDef && (cellDef.cellDom === cellDom)) {
            return cellDef;
          }
        }
      }
      return null;
    },

    /**
     * Calculate some additional information about the specified table cell.
     * @param {HTMLTableCellElement} cellDom The cell
     * @return {Object} cell definition (properties: isFirstCol, isFirstRow, isLastCol,
     *         isLastRow, cellDef)
     */
    getCellInfo: function (cellDom) {
      if (this.matrix === null || this.matrix === undefined) {
        throw new Error('No basic matrix calculated; use createTableMatrix() before.');
      }
      for (var r = 0; r < this.matrix.length; r++) {
        for (var c = 0; c < this.matrix[r].length; c++) {
          var cellDef = this.matrix[r][c];
          if (cellDef && (cellDef.cellDom === cellDom)) {
            var maxRowExcl = r + cellDef.rowSpan;
            var maxColExcl = c + cellDef.colSpan;
            return {
              'isFirstCol': (c === 0),
              'isFirstRow': (r === 0),
              'isLastCol': (maxColExcl >= this.matrix[r].length),
              'isLastRow': (maxRowExcl >= this.matrix.length),
              'cellDef': cellDef
            };
          }
        }
      }
      return null;
    },

    /**
     * Creates a cell selection object ({@link CUI.rte.CellSelection}) from the
     * specified array of table cells.
     * @param {Array} selectedDomCells Array of table cells to create the selection from;
     *        elements of type HTMLTableCellElement
     * @return {CUI.rte.CellSelection} The cell selection object
     */
    createSelection: function (selectedDomCells) {
      if (!CUI.rte.Utils.isArray(selectedDomCells)) {
        selectedDomCells = [selectedDomCells];
      }
      var cellSelection = new CUI.rte.CellSelection(this);
      for (var i = 0; i < selectedDomCells.length; i++) {
        var cellDef = this.getCellDef(selectedDomCells[i]);
        if (!cellDef) {
          throw new Error('Invalid cell');
        }
        cellSelection.addCell(cellDef);
      }
      cellSelection.process();
      return cellSelection;
    },

    /**
     * Get the DOM object for the specified table row.
     * @param {Number} rowIndex number of the row (0-based)
     * @return {HTMLTableRowElement} the table row DOM object
     */
    getRowDom: function (rowIndex) {
      return this.rows[rowIndex];
    },

    /**
     * <p>Get an array of all table cells that intersect the specified table column.</p>
     * <p>Note that even cells that do not start at the given column, but intersect it by
     * their colspan setting, are returned by this method.</p>
     * @param {Number} colIndex number of the column (0-based)
     * @return {Array} all columns intersecting the specified column; element properties
     *         are: col, row, colSpan, rowSpan, cellDom)
     */
    getColumn: function (colIndex) {
      var com = CUI.rte.Common;
      if (this.fullMatrix === null || this.fullMatrix === undefined) {
        this.createFullMatrix();
      }
      var columnCells = [];
      for (var r = 0; r < this.fullMatrix.length; r++) {
        var row = this.fullMatrix[r];
        if (row) {
          var cell = row[colIndex];
          if (cell && !com.arrayContains(columnCells, cell.cellRef)) {
            columnCells.push(cell.cellRef);
          }
        }
      }
      return columnCells;
    },

    /**
     * <p>Get an array of all table cells that intersect the specified table row.</p>
     * <p>Note that even cells that do not start at the given row, but intersect it by
     * their rowspan setting, are returned by this method.</p>
     * @param {Number} rowIndex number of the row (0-based)
     * @return {Array} all rows intersecting the specified column; element properties
     *         are: col, row, colSpan, rowSpan, cellDom)
     */
    getRow: function (rowIndex) {
      var com = CUI.rte.Common;
      if (this.fullMatrix === null || this.fullMatrix === undefined) {
        this.createFullMatrix();
      }
      var rowCells = [];
      var row = this.fullMatrix[rowIndex];
      if (row) {
        for (var c = 0; c < row.length; c++) {
          var cell = row[c];
          if (cell && !com.arrayContains(rowCells, cell.cellRef)) {
            rowCells.push(cell.cellRef);
          }
        }
      }
      return rowCells;
    },

    /**
     * Get the next cell that actually starts in the specified row. If a cell starts at
     * the specified row/col, this cell is return.
     * @param {Number} colIndex column position (0-based)
     * @param {Number} rowIndex row position (0-based)
     */
    getRowCellForCoords: function (colIndex, rowIndex) {
      if (this.matrix === null || this.matrix === undefined) {
        throw new Error('No basic matrix calculated; use createTableMatrix() before.');
      }
      var row = this.matrix[rowIndex];
      if (!row) {
        return null;
      }
      for (var c = colIndex; c < row.length; c++) {
        if (row[c] !== null && row[c] !== undefined) {
          return row[c];
        }
      }
      return null;
    },

    /**
     * Get the next cell "on the right" for the specified table coordinates.
     * @param {Number} colIndex column position (0-based)
     * @param {Number} rowIndex row position (0-based)
     */
    getFollowUpCell: function (colIndex, rowIndex) {
      if (this.fullMatrix === null || this.fullMatrix === undefined) {
        this.createFullMatrix();
      }
      var row = this.fullMatrix[rowIndex];
      if (!row) {
        return null;
      }
      var baseCell = row[colIndex];
      if (!baseCell) {
        return null;
      }
      baseCell = baseCell.cellRef;
      for (var c = colIndex + 1; c < row.length; c++) {
        if (row[c] && (row[c].cellRef !== baseCell)) {
          return row[c].cellRef;
        }
      }
      return null;
    },

    /**
     * <p>Extends the represented table (DOM and matrix representation) by the specified
     * amount of rows and columns.</p>
     * <p>Note that all cells are added with a colspan/rowspan of 1, so this is probably
     * not what the user expects when extending the table via "add column/row" commands.
     * </p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Number} cols Number of columns to add
     * @param {Number} rows Number of rows to add
     */
    extendBy: function (context, cols, rows) {
      var tm = CUI.rte.TableMatrix;
      var cellToAdd, cellDef, rowDef, fmRowDef, c, r, row;
      // first, add missing rows
      var size = this.getTableSize();
      var tBody = this.rows[this.rows.length - 1].parentNode;
      for (r = 0; r < rows; r++) {
        var rowToAdd = context.createElement('tr');
        row = this.rows.length;
        this.rows.push(rowToAdd);
        tBody.appendChild(rowToAdd);
        rowDef = [];
        this.matrix.push(rowDef);
        fmRowDef = null;
        if (this.fullMatrix) {
          fmRowDef = [];
          this.fullMatrix.push(fmRowDef);
        }
        for (c = 0; c < size.cols; c++) {
          cellToAdd = tm.createEmptyCell(context);
          rowToAdd.appendChild(cellToAdd);
          cellDef = {
            'col': c,
            'row': row,
            'colSpan': 1,
            'rowSpan': 1,
            'cellDom': cellToAdd
          };
          rowDef.push(cellDef);
          if (fmRowDef) {
            fmRowDef.push({
              'isOrigin': true,
              'cellRef': cellDef
            });
          }
        }
      }
      // add columns
      var rowCnt = this.matrix.length;
      for (r = 0; r < rowCnt; r++) {
        rowDef = this.matrix[r];
        fmRowDef = (this.fullMatrix ? this.fullMatrix[r] : null);
        var rowDom = this.rows[r];
        for (c = 0; c < cols; c++) {
          cellToAdd = tm.createEmptyCell(context, rowDom.lastChild);
          rowDom.appendChild(cellToAdd);
          cellDef = {
            'col': c + size.cols,
            'row': row,
            'colSpan': 1,
            'rowSpan': 1,
            'cellDom': cellToAdd
          };
          rowDef[c + size.cols] = cellDef;
          if (fmRowDef) {
            fmRowDef[c + size.cols] = {
              'isOrigin': true,
              'cellRef': cellDef
            };
          }
        }
      }
    },

    /**
     * <p>Merges the given cell area to a single cell.</p>
     * <p>If the cell area is not mergeable, an Exception is thrown. Also note that the
     * matrix itself is not adjusted accordingly; this operation processes DOM only.</p>
     */
    mergeToSingleCell: function (context, startCol, startRow, cols, rows) {
      var tm = CUI.rte.TableMatrix;
      var com = CUI.rte.Common;
      if (!this.fullMatrix) {
        this.createFullMatrix();
      }
      var endColExcl = startCol + cols;
      var endRowExcl = startRow + rows;
      var endColIncl = endColExcl - 1;
      var endRowIncl = endRowExcl - 1;
      // check corner cases
      var baseCell = this.matrix[startRow][startCol];
      if (!baseCell) {
        throw new Error('Invalid table structure.');
      }
      var topRight = this.fullMatrix[startRow][endColIncl];
      if (!topRight.isOrigin) {
        var topRightDef = topRight.cellRef;
        if ((topRightDef.row < startRow) &&
          ((topRightDef.col + topRightDef.colSpan) > endColExcl)) {
          throw new Error('Invalid table structure.');
        }
      }
      var bottomLeft = this.fullMatrix[endRowIncl][startCol];
      if (!bottomLeft.isOrigin) {
        var bottomLeftDef = bottomLeft.cellRef;
        if ((bottomLeftDef.col < startCol) &&
          ((bottomLeftDef.row + bottomLeftDef.rowSpan) > endRowExcl)) {
          throw new Error('Invalid table structure.');
        }
      }
      var bottomRight = this.fullMatrix[endRowIncl][endColIncl];
      if (!bottomRight.isOrigin) {
        var bottomRightDef = bottomRight.cellRef;
        if (((bottomRightDef.col + bottomRightDef.colSpan) > endColExcl) &&
          (bottomRightDef.row + bottomRightDef.rowSpan > endRowExcl)) {
          throw new Error('Invalid table structure.');
        }
      }
      for (var r = 0; r < rows; r++) {
        var row = r + startRow;
        var rowToProcess = this.fullMatrix[row];
        for (var c = 0; c < cols; c++) {
          var col = c + startCol;
          var cell = rowToProcess[col];
          var cellDef = cell.cellRef;
          var cellDom = cellDef.cellDom;
          var removeChild = false;
          if (!cell.isOrigin) {
            if ((c === 0) && (cellDef.col < col)) {
              com.setAttribute(cellDom, 'colspan',
                cellDef.col + cellDef.colSpan - col);
            }
            if ((r === 0) && (cellDef.row < row)) {
              com.setAttribute(cellDom, 'rowSpan',
                cellDef.row + cellDef.rowSpan - row);
            }
          } else {
            removeChild = (c !== 0) || (r !== 0);
            if ((cellDef.col + cellDef.colSpan) > endColExcl) {
              removeChild = false;
              com.setAttribute(cellDom, 'colspan',
                cellDef.col + cellDef.colSpan - endColExcl);
              com.removeAllChildren(cellDom);
              tm.addCellPlaceholder(context, cellDom);
            }
            if ((cellDef.row + cellDef.rowSpan) > endRowExcl) {
              removeChild = false;
              var newRowSpan = cellDef.row + cellDef.rowSpan - endRowExcl;
              var rowDelta = cellDef.rowSpan - newRowSpan;
              com.setAttribute(cellDom, 'rowspan', newRowSpan);
              cellDom.parentNode.removeChild(cellDom);
              com.removeAllChildren(cellDom);
              tm.addCellPlaceholder(context, cellDom);
              var insertCellDef = this.getFollowUpCell(col, row + rowDelta);
              var rowDom = this.rows[row + rowDelta];
              if (insertCellDef) {
                rowDom.insertBefore(cellDom, insertCellDef.cellDom);
              } else {
                rowDom.appendChild(cellDom);
              }
            }
          }
          if (removeChild) {
            cellDom.parentNode.removeChild(cellDom);
          }
        }
      }
      var baseDom = baseCell.cellDom;
      com.setAttribute(baseDom, 'colspan', cols);
      com.setAttribute(baseDom, 'rowspan', rows);
      return baseDom;
    },

    /**
     * <p>Optimizes the column and row spans of the table.</p>
     * <p>Both the abstraction and the DOM get optimized.</p>
     */
    optimizeSpans: function () {
      if (this.matrix === null || this.matrix === undefined) {
        throw new Error('No basic matrix calculated; use createTableMatrix() before.');
      }
      var com = CUI.rte.Common;
      var tableSize = this.getTableSize();
      var rows = tableSize.rows;
      var cols = tableSize.cols;
      var c, col, r, row, spansToMerge;

      // optimize column spans - we're marking each column where a cell begins. If there
      // are columns where no cell begins, the colspans of the preceding cells can be
      // adjusted and the column therefore implicitly deleted
      var colStarts = [];
      for (r = 0; r < rows; r++) {
        row = this.matrix[r];
        for (c = 0; c < cols; c++) {
          if (row[c]) {
            colStarts[c] = true;
          }
        }
      }
      c = 0;
      while (c < cols) {
        var baseCol = c;
        spansToMerge = 0;
        while ((c < cols) && !colStarts[c++]) {
          spansToMerge++;
        }
        if (spansToMerge > 0) {
          var colsToAdjust = this.getColumn(baseCol);
          for (r = 0; r < colsToAdjust.length; r++) {
            var colToMerge = colsToAdjust[r];
            colToMerge.colSpan -= spansToMerge;
            if (colToMerge.colSpan > 1) {
              com.setAttribute(colToMerge.cellDom, 'colspan', colToMerge.colSpan);
            } else {
              com.removeAttribute(colToMerge.cellDom, 'colspan');
            }
          }
        }
      }

      // optimize row spans - works basically the same as optimizing column spans
      // (we could also use empty DOM rows for determining optimizable row spans, but
      // we stay in the TableMatrix system for now)
      var rowStarts = [];
      for (c = 0; c < cols; c++) {
        col = this.getColumn(c);
        for (r = 0; r < col.length; r++) {
          rowStarts[col[r].row] = true;
        }
      }
      r = 0;
      while (r < rows) {
        var baseRow = r;
        spansToMerge = 0;
        while ((r < rows) && !rowStarts[r++]) {
          spansToMerge++;
        }
        if (spansToMerge > 0) {
          var rowsToAdjust = this.getRow(baseRow);
          for (c = 0; c < rowsToAdjust.length; c++) {
            var rowToMerge = rowsToAdjust[c];
            rowToMerge.rowSpan -= spansToMerge;
            if (rowToMerge.rowSpan > 1) {
              com.setAttribute(rowToMerge.cellDom, 'rowspan', rowToMerge.rowSpan);
            } else {
              com.removeAttribute(rowToMerge.cellDom, 'rowspan');
            }
          }
        }
      }

      // finally, remove empty rows - by adjusting the rowspan settings, those can
      // finally be removed
      for (r = this.rows.length - 1; r >= 0; r--) {
        var rowToCheck = this.rows[r];
        if (rowToCheck.childNodes.length === 0) {
          rowToCheck.parentNode.removeChild(rowToCheck);
          this.rows.splice(r, 1);
          this.matrix.splice(r, 1);
          var mr, mc, rowToAdjust;
          for (mr = r; mr < this.matrix.length; mr++) {
            rowToAdjust = this.matrix[mr];
            for (mc = 0; mc < rowToAdjust.length; mc++) {
              if (rowToAdjust[mc]) {
                rowToAdjust[mc].row--;
              }
            }
          }
          if (this.fullMatrix) {
            this.fullMatrix.splice(r, 1);
          }
        }
      }
    }

  });

  /**
   * @private
   * @static
   */
  CUI.rte.TableMatrix.createEmptyCell = function (context, refNode) {
    var tagName = 'td';
    if (typeof(refNode) === 'string') {
      tagName = refNode;
    } else if (refNode) {
      tagName = refNode.tagName;
    }
    var tdDom = context.createElement(tagName);
    var placeholder = CUI.rte.DomProcessor.createEmptyLinePlaceholder(context, false);
    if (placeholder) {
      tdDom.appendChild(placeholder);
    }
    return tdDom;
  };

  /**
   * @private
   * @static
   */
  CUI.rte.TableMatrix.addCellPlaceholder = function (context, cellDom) {
    cellDom.appendChild(context.createTextNode(CUI.rte.DomProcessor.NBSP));
  };

  /**
   * @private
   * @static
   */
  CUI.rte.TableMatrix.createEmptyCellMarkup = function () {
    var com = CUI.rte.Common;
    if (com.ua.isIE && !com.ua.isIE11) {
      return '<td></td>';
    }
    return '<td><br ' + com.BR_TEMP_ATTRIB + '=\"brEOB\"></td>';
  };

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.ListUtils
 * @static
 * @private
 * The ListUtils provides utility functions for handling lists.
 */
(function (CUI) {
  'use strict';
  CUI.rte.ListUtils = (function () {

    var com = CUI.rte.Common;

    var dpr = CUI.rte.DomProcessor;

    return {

      // --- selection-related stuff -----------------------------------------------------

      /**
       * <p>Postprocesses a list of selected items that was created from a
       * {@link CUI.rte.NodeList NodeList}, using the
       * {@link CUI.rte.NodeList#getTags getTags} method.</p>
       * <p>This is required to remove parent items that are included in the node list
       * (as they are actually part of the DOM structure), but are not really selected
       * (instead, one or more nested list item is selected).</p>
       * @param {Object[]} listItems Array containing list items, as created by
       *        {@link CUI.rte.NodeList#getTags}
       */
      postprocessSelectedItems: function (listItems) {
        var nodeCnt = listItems.length;
        for (var n = nodeCnt - 1; n >= 0; n--) {
          var node = listItems[n];
          if (!node.isAncestor) {
            var mustRemove = true;
            var children = node.childNodes;
            if (children) {
              var childCnt = children.length;
              for (var c = 0; c < childCnt; c++) {
                var childDom = children[c].dom;
                if (!com.isTag(childDom, com.LIST_TAGS)) {
                  mustRemove = false;
                  break;
                }
              }
            } else {
              // empty list tags must also be kept (may occur on IE)
              mustRemove = false;
            }
            if (mustRemove) {
              listItems.splice(n, 1);
            }
          }
        }
      },


      // --- processing-related stuff ----------------------------------------------------

      /**
       * <p>Creates a new list from the specified list of edit blocks.</p>
       * <p>This method handles auxiliary root correctly by adding their content as
       * separate lists.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement[]} blockList List with edit blocks to be used for creating
       *        the list
       * @param {String} listType The list type ("ul", "ol")
       */
      createList: function (context, blockList, listType) {
        var lut = CUI.rte.ListUtils;
        // preprocess if a table cell is reported as the only edit block
        if ((blockList.length === 1) && com.isTag(blockList[0], com.TABLE_CELLS)) {
          var tempBlock = context.createElement('div');
          com.moveChildren(blockList[0], tempBlock);
          blockList[0].appendChild(tempBlock);
          blockList[0] = tempBlock;
        }
        // simplify block list by using lists instead of their respective list items
        var blockCnt = blockList.length;
        for (var b = 0; b < blockCnt; b++) {
          if (com.isTag(blockList[b], 'li')) {
            var listNode = blockList[b].parentNode;
            blockList[b] = listNode;
            for (var b1 = 0; b1 < b; b1++) {
              if (blockList[b1] === listNode) {
                blockList[b] = null;
                break;
              }
            }
          }
        }
        // common list creation
        var listDom = context.createElement(listType);
        com.addInlineStyles(listDom, {'list-style-position': 'inside'});
        blockCnt = blockList.length;
        for (b = 0; b < blockCnt; b++) {
          var blockToProcess = blockList[b];
          if (blockToProcess) {
            var mustRecurse = com.isTag(blockToProcess, dpr.AUXILIARY_ROOT_TAGS);
            if (!mustRecurse) {
              if (listDom.childNodes.length === 0) {
                // first, insert the list
                blockToProcess.parentNode.insertBefore(listDom, blockToProcess);
              }
              if (!com.isTag(blockToProcess, com.LIST_TAGS)) {
                // normal blocks
                var listItemDom = context.createElement('li');
                listDom.appendChild(listItemDom);
                com.moveChildren(blockToProcess, listItemDom, 0, true);
                blockToProcess.parentNode.removeChild(blockToProcess);
              } else {
                // pre-existing list
                com.moveChildren(blockToProcess, listDom, 0, true);
                blockToProcess.parentNode.removeChild(blockToProcess);
              }
            } else {
              // create list recursively
              var subBlocks = [];
              var sbCnt = blockToProcess.childNodes.length;
              for (var c = 0; c < sbCnt; c++) {
                var subBlock = blockToProcess.childNodes[c];
                if (com.isTag(subBlock, com.EDITBLOCK_TAGS)) {
                  subBlocks.push(subBlock);
                }
                // @todo nested tables
                //else if (com.isTag(com.BLOCK_TAGS)) {
                // }
              }
              if (subBlocks.length === 0) {
                subBlocks.push(blockToProcess);
              }
              lut.createList(context, subBlocks, listType);
              // start a new list if a non-listable tag has been encountered
              listDom = context.createElement(listType);
              com.addInlineStyles(listDom, {'list-style-position': 'inside'});
            }
          }
        }
        // check if we can join adjacent lists
        var prevSib = listDom.previousSibling;
        if (prevSib && com.isTag(prevSib, listType)) {
          com.moveChildren(listDom, prevSib, 0, true);
          listDom.parentNode.removeChild(listDom);
          listDom = prevSib;
        }
        var nextSib = listDom.nextSibling;
        if (nextSib && com.isTag(nextSib, listType)) {
          com.moveChildren(nextSib, listDom, 0, true);
          nextSib.parentNode.removeChild(nextSib);
        }
      },

      /**
       * Converts the specified list item (which must be part of a top-level list) to
       * a edit block of the specified type.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} liDom The list item to be converted
       * @param {String} tagName The edit block tag to convert the item to
       * @param {Object} attribs Attribute definition for the edit block tag
       */
      convertListItem: function (context, liDom, tagName, attribs) {
        var itemIndex = com.getChildIndex(liDom);
        var originList = liDom.parentNode;
        var itemCnt = originList.childNodes.length;
        var pNode = dpr.createNode(context, tagName, attribs);
        com.moveChildren(liDom, pNode);
        originList.removeChild(liDom);
        if (itemIndex === 0) {
          // first item - can be simply removed without splitting the list in two
          originList.parentNode.insertBefore(pNode, originList);
        } else if (itemIndex === (itemCnt - 1)) {
          // last item
          originList.parentNode.insertBefore(pNode, originList.nextSibling);
        } else {
          // split list
          var splitList = originList.cloneNode(false);
          com.moveChildren(originList, splitList, itemIndex);
          originList.parentNode.insertBefore(splitList, originList.nextSibling);
          originList.parentNode.insertBefore(pNode, splitList);
        }
        return pNode;
      },

      /**
       * <p>Gets the list item (if available) the specified DOM element is contained in.
       * </p>
       * <p>If the specified DOM element is a list item, the DOM element (and not its
       * "super item") is returned.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The DOM element to determine the list item for
       * @return {HTMLElement} The respective list item; null if the DOM element is not
       *         contained in a list item
       */
      getItemForDom: function (context, dom) {
        while (dom) {
          if (com.isTag(dom, 'li')) {
            return dom;
          }
          dom = com.getParentNode(context, dom);
        }
        return null;
      },

      /**
       * <p>Gets the list the specified list item is contained in.</p>
       * <p>The specified list item may be any DOM element of the corresponding list item.
       * If a list is specified as list item, the "super list" (if available) is returned.
       * </p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} itemDom The list item to determine the corresponding list
       *        for; null if the DOM element is not contained in a list
       */
      getListForItem: function (context, itemDom) {
        itemDom = CUI.rte.ListUtils.getItemForDom(context, itemDom);
        var listDom = (itemDom ? com.getParentNode(context, itemDom) : null);
        if (listDom && !com.isTag(listDom, com.LIST_TAGS)) {
          listDom = null;
        }
        return listDom;
      },

      /**
       * Gets the top-level list the specified DOM element is part of.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The DOM element
       * @return {HTMLElement} The top-level list element; null if the specified DOM
       *         element is not part of a list
       */
      getTopListForItem: function (context, dom) {
        var listDom = null;
        while (dom) {
          if (com.isTag(dom, com.LIST_TAGS)) {
            listDom = dom;
          }
          dom = com.getParentNode(context, dom);
        }
        return listDom;
      },

      /**
       * Gets the nesting level of the specified DOM element.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The DOM element
       * @return {Number} Nesting level (0 for top-level list; -1 if the specified DOM
       *         element is not part of a list
       */
      getNestingLevel: function (context, dom) {
        var nestingLevel = -1;
        while (dom) {
          if (com.isTag(dom, com.LIST_TAGS)) {
            nestingLevel++;
          }
          dom = com.getParentNode(context, dom);
        }
        return nestingLevel;
      },

      /**
       * Checks if the specified DOM element is part of a top-level list.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The DOM element
       * @return {Boolean} True if the DOM element is part of a top-level list
       */
      isTopLevelList: function (context, dom) {
        return (CUI.rte.ListUtils.getNestingLevel(context, dom) === 0);
      },

      /**
       * Checks if the specified DOM element is (part of) the very first list item of its
       * top-level list.
       * @param {CUI.rte.EditContext} context
       * @param {HTMLElement} dom The DOM element to check
       * @return {Boolean} true if the specified DOM element is the very first list item
       *         of its top-level list
       */
      isFirstListItem: function (context, dom) {
        var lut = CUI.rte.ListUtils;
        var tll = lut.getTopListForItem(context, dom);
        if (tll === null || tll === undefined) {
          return false;
        }
        var itemDom = lut.getItemForDom(context, dom);
        return (tll.childNodes.length > 0) && (tll.childNodes[0] === itemDom);
      },

      /**
       * Checks if the specified DOM element is (part of) the very last list item of its
       * top-level list.
       * @param {CUI.rte.EditContext} context
       * @param {HTMLElement} dom The DOM element to check
       * @return {Boolean} true if the specified DOM element is the very last list item
       *         of its top-level list
       */
      isLastListItem: function (context, dom) {
        var lut = CUI.rte.ListUtils;
        var tll = lut.getTopListForItem(context, dom);
        var lastListNode = com.getLastChild(tll);
        if (lastListNode === null || lastListNode === undefined) {
          return false;
        }
        var lastItemNode = com.getTagInPath(context, lastListNode, 'li');
        return (lastItemNode === dom);
      },

      /**
       * Moves the content of the specified list item to the specfied destination
       * element.
       * @param {HTMLElement} srcItem The list item to move content from
       * @param {HTMLElement} destDom The DOM element to move content to
       */
      moveItemContent: function (srcItem, destDom) {
        while (srcItem.childNodes.length > 0) {
          var childToMove = srcItem.childNodes[0];
          srcItem.removeChild(childToMove);
          destDom.appendChild(childToMove);
        }
      },

      /**
       * Checks if the specified list item has content other than nested lists.
       * @param {HTMLElement} itemDom The DOM element representing the list item
       * @return {Boolean} True if the specified list item has content other than
       *         nested lists
       */
      hasItemContent: function (itemDom) {
        var childCnt = itemDom.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          var childToProcess = itemDom.childNodes[c];
          if (!com.isTag(childToProcess, com.LIST_TAGS)) {
            return true;
          }
        }
        return false;
      },

      /**
       * <p>Checks if the specified list is empty.</p>
       * <p>A list is considered empty if it is actually empty or all items and nested
       * lists are empty.</p>
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} listDom The list's DOM element
       * @return {Boolean} True if the specified list is empty
       */
      isListEmpty: function (context, listDom) {
        if (listDom.childNodes.length === 0) {
          return true;
        }
        var itemCnt = listDom.childNodes.length;
        for (var i = 0; i < itemCnt; i++) {
          var itemToCheck = listDom.childNodes[i];
          if (com.isTag(itemToCheck, 'li')) {
            var childCnt = itemToCheck.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
              var nodeToCheck = itemToCheck.childNodes[c];
              if (com.isTag(nodeToCheck, com.LIST_TAGS)) {
                var isListEmpty = CUI.rte.ListUtils.isListEmpty(context,
                  nodeToCheck);
                if (!isListEmpty) {
                  return false;
                }
              } else {
                return false;
              }
            }
            // IE might have empty items that count as content, in that case
            // the list is not really empty
            if ((com.ua.isIE && childCnt === 0)) {
              return false;
            }
          }
        }
        return true;
      },

      /**
       * Checks if the specified list item is empty (has no content or only empty
       * nested lists).
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} dom The list item to check
       */
      isItemEmpty: function (context, dom) {
        var lut = CUI.rte.ListUtils;
        dom = lut.getItemForDom(context, dom);
        var childCnt = dom.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          var childToProcess = dom.childNodes[c];
          if (com.isTag(childToProcess, com.LIST_TAGS)) {
            if (!lut.isListEmpty(context, childToProcess)) {
              return false;
            }
          } else {
            return false;
          }
        }
        return true;
      },

      /**
       * Cleans up the specified list by removing empty list items (and empty nested
       * lists as well).
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} listDom The list to be cleaned
       * @param {Boolean} removeHelperAttribs True if helper attributes on list items have
       *        also to be removed
       */
      cleanUpList: function (context, listDom, removeHelperAttribs) {
        var lut = CUI.rte.ListUtils;
        var itemCnt = listDom.childNodes.length;
        for (var i = itemCnt - 1; i >= 0; i--) {
          var itemToProcess = listDom.childNodes[i];
          var childCnt = itemToProcess.childNodes.length;
          for (var c = childCnt - 1; c >= 0; c--) {
            var childToProcess = itemToProcess.childNodes[c];
            if (com.isTag(childToProcess, com.LIST_TAGS)) {
              lut.cleanUpList(context, childToProcess, removeHelperAttribs);
            }
          }
          if (lut.isItemEmpty(context, itemToProcess) &&
            (com.isAttribDefined(itemToProcess, lut.REMOVAL_MARKER) ||
            com.isAttribDefined(itemToProcess, lut.CLONED_MARKER))) {
            listDom.removeChild(itemToProcess);
          } else if (removeHelperAttribs) {
            com.removeAttribute(itemToProcess, lut.REMOVAL_MARKER);
            com.removeAttribute(itemToProcess, lut.CLONED_MARKER);
          }
        }
        if (lut.isListEmpty(context, listDom)) {
          listDom.parentNode.removeChild(listDom);
        }
      },

      /**
       * Checks if both specified DOM elements are lists and both determine the same
       * list type.
       * @param {HTMLElement} dom1 First DOM element; may be null
       * @param {HTMLElement} dom2 Second DOM element; may be null
       * @return {Boolean} True if both elements are lists and the list type is the same
       */
      isSameType: function (dom1, dom2) {
        if (dom1 && dom2) {
          if (com.isTag(dom1, com.LIST_TAGS)) {
            return (dom1.tagName.toLowerCase() === dom2.tagName.toLowerCase());
          }
        }
        return false;
      },

      /**
       * Gets all nested lists of the specified item if available.
       * @param {HTMLElement} itemDom The item's DOM element
       * @return {HTMLElement[]} List with all nested lists
       */
      getNestedLists: function (itemDom) {
        var nestedLists = [];
        var childCnt = itemDom.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          var childToCheck = itemDom.childNodes[c];
          if (com.isTag(childToCheck, com.LIST_TAGS)) {
            nestedLists.push(childToCheck);
          }
        }
        return nestedLists;
      },

      /**
       * Removes the specified item from the list.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement[]} items Array of items to unlist; items must be adjacent
       *        (but may be on different hierarchical levels)
       * @param {Boolean} keepStructure True if the list structure should be kept if
       *        list splitting is required
       */
      unlistItems: function (context, items, keepStructure) {
        var lut = CUI.rte.ListUtils;
        var itemCnt = items.length;
        if (itemCnt === 0) {
          return;
        }
        var firstItem = items[0];
        var lastItem = items[itemCnt - 1];
        var tll = lut.getTopListForItem(context, firstItem.parentNode);
        var isFirstItemOfList = lut.isFirstListItem(context, firstItem);
        var isLastItemOfList = lut.isLastListItem(context, lastItem);
        var splitList = null;
        var insertRef = tll;
        var para, m, c;
        for (var i = 0; i < itemCnt; i++) {
          // move item content to paragraph & insert paragraph after top level list
          para = context.createElement('p');
          var item = items[i];
          com.setAttribute(item, lut.REMOVAL_MARKER, 'true');
          var childCnt = item.childNodes.length;
          for (c = childCnt - 1; c >= 0; c--) {
            var childToMove = item.childNodes[c];
            if (!com.isTag(childToMove, com.LIST_TAGS)) {
              item.removeChild(childToMove);
              com.insertBefore(para, childToMove, para.firstChild);
            }
          }
          if (isFirstItemOfList) {
            com.insertBefore(tll.parentNode, para, tll);
            splitList = tll;
          } else {
            com.insertBefore(tll.parentNode, para, insertRef.nextSibling);
            insertRef = para;
          }
          dpr.fixEmptyEditingBlockIE(context, para);
        }
        var listToClone = lastItem.parentNode;
        // detect content that has to be additionally moved to the split list
        var listIndex = com.getChildIndex(listToClone);
        var elementsToMove = [];
        if (lut.getNestingLevel(context, listToClone) > 0) {
          var listParent = listToClone.parentNode;
          for (m = listIndex + 1; m < listParent.childNodes.length; m++) {
            elementsToMove.push(listParent.childNodes[m]);
          }
        }
        // split list if necessary
        if (!isLastItemOfList && !isFirstItemOfList) {
          var deepestItem = null;
          var isEmptyDeepestItem = false;
          while (listToClone) {
            var clonedList = listToClone.cloneNode(false);
            var clonedItem = context.createElement('li');
            com.setAttribute(clonedItem, lut.CLONED_MARKER, 'true');
            if (deepestItem === null || deepestItem === undefined) {
              deepestItem = clonedItem;
              if (lastItem.childNodes.length === 0) {
                isEmptyDeepestItem = true;
              } else {
                lut.moveItemContent(lastItem, deepestItem);
              }
            }
            clonedList.appendChild(clonedItem);
            if (splitList) {
              clonedItem.appendChild(splitList);
            }
            splitList = clonedList;
            listToClone = com.getParentNode(context, listToClone);
            if (com.isTag(listToClone, 'li')) {
              listToClone = listToClone.parentNode;
            } else {
              listToClone = null;
            }
          }
          // move content detected beforehand to split list
          var moveTarget = deepestItem.parentNode;
          for (m = 0; m < elementsToMove.length; m++) {
            var domToMove = elementsToMove[m];
            domToMove.parentNode.removeChild(domToMove);
            com.insertBefore(moveTarget.parentNode, domToMove,
              moveTarget.nextSibling);
            moveTarget = domToMove;
          }
          // insert the split list
          com.insertBefore(para.parentNode, splitList, para.nextSibling);
          var copyItem = lastItem;
          var copyDest = deepestItem;
          while (copyItem) {
            var childIndex = com.getChildIndex(copyItem);
            var copyList = copyItem.parentNode;
            var destList = copyDest.parentNode;
            for (c = copyList.childNodes.length - 1; c > childIndex; c--) {
              var itemToMove = copyList.childNodes[c];
              copyList.removeChild(itemToMove);
              insertRef = (destList.childNodes.length > 1 ?
                destList.childNodes[1] : null);
              com.insertBefore(destList, itemToMove, insertRef);
            }
            if ((copyDest === deepestItem) && isEmptyDeepestItem) {
              destList.removeChild(copyDest);
            }
            copyItem = com.getParentNode(context, copyList);
            if (!com.isTag(copyItem, 'li')) {
              copyItem = null;
            }
            copyDest = com.getParentNode(context, destList);
          }
        }
        // remove item & now-empty (nested) lists
        lut.cleanUpList(context, tll, false);
        if ((splitList !== null && splitList !== undefined) && (splitList !== tll)) {
          lut.cleanUpList(context, splitList, false);
        }
        if (!isLastItemOfList && (splitList !== null && splitList !== undefined)) {
          // post-process structure to get a valid list again
          var itemToProcess = com.getFirstChild(splitList);
          itemToProcess = com.getTagInPath(context, itemToProcess, 'li');
          if (itemToProcess) {
            if (lut.isTopLevelList(context, itemToProcess) &&
              lut.isItemEmpty(context, itemToProcess) &&
              com.isAttribDefined(itemToProcess, lut.CLONED_MARKER)) {
              // simply remove empty item if top-level (& clean up afterwards)
              itemToProcess.parentNode.removeChild(itemToProcess);
              lut.cleanUpList(context, splitList, true);
            } else if (keepStructure) {
              // keeping the list's structure intact: insert &nbsp; for all
              // in-between hierarchical levels
              while (itemToProcess) {
                if (!lut.hasItemContent(itemToProcess)) {
                  com.insertBefore(itemToProcess,
                    context.createTextNode(dpr.NBSP),
                    itemToProcess.firstChild);
                }
                itemToProcess = com.getParentNode(context, itemToProcess);
                while (itemToProcess && !com.isTag(itemToProcess, 'li')) {
                  itemToProcess = com.getParentNode(context,
                    itemToProcess);
                }
                lut.cleanUpList(context, splitList, true);
              }
            } else {
              // adjusting the split list's structure - the algorithm used here
              // works as follows:
              // 1. start with the list that contains the first "real" list item
              //    (may be nested deep in the hierarchy) -> source list.
              // 2. insert the items of that list at the beginning of the
              //    top-level list -> dest list
              // 3. process the parent list of the previous source list
              // 4. a) insert that parent list to the last item (shallow) of the
              //       previous source list (that is now a top-level item, if
              //       source and destination list are on different nesting levels
              //    b) Merge source and destination list items otherwise
              // 5. repeat 3 and 4 until the source list has reached nesting level
              //    0 or both source and destination have reached the same
              //    nesting level (which is step 4b)
              // 6. clean up leftovers
              var listsToClean = [splitList];
              insertRef = splitList;
              var deepestItemList = lut.getListForItem(context, itemToProcess);
              var deepestListParent = lut.getItemForDom(context, deepestItemList);
              if (deepestListParent === null || deepestListParent === undefined) {
                return;
              }
              var listToMove, l, moveDestList, mustMove;
              var listsToMove = lut.getNestedLists(deepestListParent);
              while (insertRef) {
                var listCnt = listsToMove.length;
                var baseListToMove = listsToMove[0];
                var srcLevel = lut.getNestingLevel(context, baseListToMove);
                // #5
                if (srcLevel === 0) {
                  break;
                }
                var destLevel = lut.getNestingLevel(context, insertRef);
                var parentList = lut.getListForItem(context, baseListToMove);
                if (srcLevel === destLevel) {
                  // #4b/#5
                  moveDestList = (com.isTag(insertRef, 'li') ?
                    insertRef.parentNode : insertRef);
                  for (l = 0; l < listCnt; l++) {
                    listToMove = listsToMove[l];
                    mustMove = false;
                    if (l === (listCnt - 1)) {
                      if (lut.isSameType(listToMove, moveDestList)) {
                        mustMove = true;
                      }
                    }
                    if (mustMove) {
                      com.moveChildren(listToMove, moveDestList, 0, true);
                    } else {
                      listToMove.parentNode.removeChild(listToMove);
                      com.insertBefore(moveDestList.parentNode,
                        listToMove, moveDestList.nextSibling);
                      moveDestList = listToMove;
                    }
                  }
                  break;
                } else {
                  var lastList = listsToMove[listCnt - 1];
                  lastItem = lastList.childNodes[
                  lastList.childNodes.length - 1];
                  if (com.isTag(insertRef, 'li')) {
                    // #4a
                    for (l = 0; l < listCnt; l++) {
                      listToMove = listsToMove[l];
                      listToMove.parentNode.removeChild(listToMove);
                      insertRef.appendChild(listToMove);
                    }
                  } else {
                    // #2
                    moveDestList = insertRef;
                    for (l = 0; l < listCnt; l++) {
                      listToMove = listsToMove[l];
                      mustMove = false;
                      if (l === (listCnt - 1)) {
                        if (lut.isSameType(listToMove, moveDestList)) {
                          mustMove = true;
                        }
                      }
                      if (mustMove) {
                        com.moveChildren(listToMove, moveDestList);
                      } else {
                        listToMove.parentNode.removeChild(listToMove);
                        com.insertBefore(moveDestList.parentNode,
                          listToMove, moveDestList);
                        listsToClean.push(listToMove);
                      }
                    }
                  }
                  // set insert ref to the last shallow item
                  insertRef = lastItem;
                }
                // #3 (use parent list(s))
                if (lut.getNestingLevel(context, parentList) === 0) {
                  listsToMove = [parentList];
                } else {
                  listsToMove = lut.getNestedLists(lut.getItemForDom(context,
                    parentList));
                }
              }
              // #6
              for (l = 0; l < listsToClean.length; l++) {
                lut.cleanUpList(context, listsToClean[l], true);
              }
            }
          }
        }
      },

      /**
       * Checks if the specified node/offset (as provided by a processing selection)
       * determines the position before a nested list.
       * @param {CUI.rte.EditContext} context The edit context
       * @param {HTMLElement} node The node
       * @param {Number} offset The offset
       * @return {Boolean} True if the specified node/offset determines the position
       *         before a nested list
       */
      isPositionBeforeNestedList: function (context, node, offset) {
        var editBlock = dpr.getEditBlock(context, node);
        if (!com.isTag(editBlock, 'li')) {
          return false;
        }
        if (node.nodeType === 3) {
          var charCnt = com.getNodeCharacterCnt(node);
          if (charCnt > 0) {
            if (offset < charCnt) {
              return false;
            }
          }
        } else if (com.isOneCharacterNode(node)) {
          if (offset !== 0) {
            return false;
          }
        }
        var nextChild = com.getNextNode(context, node);
        return com.isTag(nextChild, com.LIST_TAGS) &&
          (dpr.getEditBlock(context, nextChild) === editBlock);
      },

      /**
       * Marker attribute for empty list items that might be removed on clean up after
       * unlisting
       * @private
       * @type String
       */
      REMOVAL_MARKER: CUI.rte.Common.RTE_ATTRIB_PREFIX + '_invalid',

      /**
       * Marker attribute for list items that were cloned when an original list has been
       * split during unlisting (an) item(s)
       * @private
       * @type String
       */
      CLONED_MARKER: CUI.rte.Common.RTE_ATTRIB_PREFIX + '_cloned'

    };

  }());
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

// todo synchronize DOM & data model
// ListRepresentation and ListRepresenation.Item should get suitable processing methods
// that handle both data model and DOM manipulation, which would make the code much more
// readable as currently is (and could improve performance, as there was no more need
// to recreate the representation from DOM after processing it)

/**
 * @class CUI.rte.ListRepresentation
 * @private
 * <p>This class implements an abstract representation of a list for easier processing
 * &amp; editing (especially hierarchical management, such as indenting and outdenting
 * multiple list items and ensuring correct nesting of multi-level lists).</p>
 * <p>Note that most processing methods of this class do not adjust the data model (but only
 * the DOM), hence the list representation has to be recreated before another processing is
 * executed on the represented list.</p>
 * @constructor
 * Creates a new ListRepresentation.
 * @param {CUI.rte.ListRepresentation} parentList The parent list (if any)
 * @param {Boolean} isCorrectHierarchy (optional) True if the list is correctly nested
 *        (defaults to true)
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.ListRepresentation = new Class({

    toString: 'ListRepresentation',

    /**
     * Parent list (if available)
     * @type CUI.rte.ListRepresentation
     * @private
     */
    parentList: null,

    /**
     * The DOM node representing the list.
     * @type HTMLElement
     * @private
     */
    listDom: null,

    /**
     * Array containing the items of the list.
     * @type CUI.rte.ListRepresentation.Item[]
     * @private
     */
    items: null,

    /**
     * Flag if the list is correctly included in the list hierarchy (correctly nested)
     * @type Boolean
     * @private
     */
    isCorrectHierarchy: false,

    construct: function (parentList, isCorrectHierarchy) {
      this.parentList = parentList;
      this.items = [];
      this.isCorrectHierarchy = isCorrectHierarchy !== false;
    },

    /**
     * Creates a list representation from the specified list DOM object.
     * @param {HTMLElement} listDom The DOM element of the list from which the list
     *        representation is to be build; must be of type "ul" or "ol"
     */
    fromList: function (listDom) {
      var com = CUI.rte.Common;
      this.items.length = 0;
      this.listDom = listDom;
      var children = listDom.childNodes;
      var childCnt = children.length;
      var validItem = null;
      for (var c = 0; c < childCnt; c++) {
        var childToProcess = children[c];
        if (com.isTag(childToProcess, com.LIST_TAGS)) {
          // detected an invalidly nested list
          if (validItem === null || validItem === undefined) {
            validItem = new CUI.rte.ListRepresentation.Item(this, this.listDom);
            this.items.push(validItem);
          }
          var subList = new CUI.rte.ListRepresentation(this, false);
          subList.fromList(childToProcess);
          validItem.addSubList(subList);
        } else if (com.isTag(childToProcess, 'li')) {
          var item = new CUI.rte.ListRepresentation.Item(this, childToProcess);
          this.items.push(item);
          item.detectSubLists();
          validItem = item;
        }
      }
    },

    /**
     * <p>Creates a list representation of the top-level list the specified item is part of.
     * </p>
     * <p>Note that actually the top-level list is used - not the list that actually
     * contains the list item if the item is part of a nested list.</p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} itemDom The DOM element representing the list item (must be of
     *        type "li")
     */
    fromItem: function (context, itemDom) {
      var listDom = CUI.rte.ListUtils.getTopListForItem(context, itemDom);
      if (listDom === null || listDom === undefined) {
        throw new Error('Could not detect list node.');
      }
      this.fromList(listDom);
    },

    /**
     * <p>Gets the {@link CUI.rte.ListRepresentation.Item Item} that represents the
     * specified (DOM) list item.</p>
     * <p>The item is looked up recursively - you can always use the top-most list
     * representation to get a list item that is contained in a nested list.</p>
     * @param {HTMLElement} dom The DOM list item (must be of type "li")
     * @return {CUI.rte.ListRepresentation.Item} The Item representation; null if there
     *         is no suitable
     */
    getItemByDom: function (dom) {
      var itemCnt = this.items.length;
      for (var i = 0; i < itemCnt; i++) {
        var theItem = this.items[i].getItemByDom(dom);
        if (theItem !== null && theItem !== undefined) {
          return theItem;
        }
      }
      return null;
    },

    /**
     * <p>Gets the index (position in this list) of the specified
     * {@link CUI.rte.ListRepresentation.Item Item} in the represented list.</p>
     * <p>Note that this method does not work resursively, i.e. you must call it on the
     *{@link CUI.rte.ListRepresentation ListRepresentation} that actually contains the
     * specified {@link CUI.rte.ListRepresentation.Item Item}.</p>
     * @param {CUI.rte.ListRepresentation.Item} item The item
     * @return {Number} The index (list position) of the specified list item
     */
    getItemIndex: function (item) {
      return CUI.rte.Common.arrayIndex(this.items, item);
    },

    /**
     * <p>Removes the specified {@link CUI.rte.ListRepresentation.Item Item} from this
     * list.</p>
     * <p>Note that this method removes the item from the list representation only, keeping
     * the DOM as it is.</p>
     * @param {CUI.rte.ListRepresentation.Item} itemToRemove The item to remove
     */
    removeItem: function (itemToRemove) {
      var com = CUI.rte.Common;
      var removeIndex = com.arrayIndex(this.items, itemToRemove);
      if (removeIndex >= 0) {
        this.items.splice(removeIndex, 1);
      }
    },

    /**
     * Inserts the specified item after the specified reference item.
     * @param {CUI.rte.ListRepresentation.Item} itemToInsert The item to be inserted
     * @param {CUI.rte.ListRepresentation.Item} refItem The reference item; if null,
     *        the item is inserted at the beginning of the item list
     */
    insertItemAfter: function (itemToInsert, refItem) {
      if (refItem === null || refItem === undefined) {
        this.items.splice(0, 0, itemToInsert);
        return;
      }
      var refIndex = this.getItemIndex(refItem);
      if (refIndex < 0) {
        throw new Error('Invalid insert item; reference must be in \'this\' list.');
      }
      this.items.splice(refIndex + 1, 0, itemToInsert);
    },

    /**
     * <p>Removes the specified {@link CUI.rte.ListRepresentation nested list} from this
     * list.</p>
     * <p>Note that this method removes the nested list from the list representation only,
     * keeping the DOM as it is.</p>
     * @param {CUI.rte.ListRepresentation} subList The nested list to remove
     */
    removeSubList: function (subList) {
      var itemCnt = this.items.length;
      var isRemoved = false;
      for (var i = 0; (i < itemCnt) && !isRemoved; i++) {
        var listsToCheck = this.items[i].subLists;
        var listCnt = listsToCheck.length;
        for (var l = 0; l < listCnt; l++) {
          if (listsToCheck[l] === subList) {
            listsToCheck.splice(l, 1);
            isRemoved = true;
            break;
          } else {
            isRemoved = listsToCheck[l].removeSubList(subList);
            if (isRemoved) {
              break;
            }
          }
        }
      }
      return isRemoved;
    },

    /**
     * Indents the specified DOM list item.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} itemDom The list item to indent (must be of type "li")
     */
    indent: function (context, itemDom) {
      var item = this.getItemByDom(itemDom);
      if (item === null || item === undefined) {
        throw new Error('Could not determine item to indent.');
      }
      item.indent(context);
    },

    /**
     * Outdents the specified DOM list items.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement[]} items The list items to outdent (must be of type "li")
     */
    outdent: function (context, items) {
      var com = CUI.rte.Common;
      // outdent each item
      var itemCnt = items.length;
      for (var i = 0; i < itemCnt; i++) {
        var item = this.getItemByDom(items[i]);
        if (item === null || item === undefined) {
          throw new Error('Could not determine item to outdent.');
        }
        var itemsToExclude = item.outdent(context);
        for (var e = 0; e < itemsToExclude.length; e++) {
          var itemDom = itemsToExclude[e].itemDom;
          var itemIndex = com.arrayIndex(items, itemDom);
          if (itemIndex > i) {
            items.splice(itemIndex, 1);
            itemCnt--;
          }
        }
      }
    },

    /**
     * <p>Ensures the correct hierarchical nesting.</p>
     * <p>This method may be used to convert lists that handle nested lists similar to
     * list items (&lt;li&gt;...&lt;/li&gt;&lt;ul&gt;...&lt;/ul&gt;) instead of appending
     * them to an existing list item (&lt;li&gt;...&lt;ul&gt;...&lt;/ul&gt;&lt;/li&gt;).
     * </p>
     * @param {CUI.rte.EditContext} context The edit context
     */
    ensureHierarchy: function (context) {
      var itemCnt = this.items.length;
      for (var i = 0; i < itemCnt; i++) {
        var itemToProcess = this.items[i];
        itemToProcess.ensureHierarchy(context);
      }
    },

    /**
     * Flattens the represented list to a series of paragraphs.
     * @param {CUI.rte.EditContext} context The edit context
     */
    flatten: function (context, topLevelList) {
      if (topLevelList === null || topLevelList === undefined) {
        topLevelList = CUI.rte.ListUtils.getTopListForItem(context, this.listDom);
      }
      var itemCnt = this.items.length;
      for (var i = 0; i < itemCnt; i++) {
        var itemToProcess = this.items[i];
        itemToProcess.flatten(context, topLevelList);
      }
      this.listDom.parentNode.removeChild(this.listDom);
    },

    /**
     * Creates a "plain text" version of the current state of the list representation.
     * @param {Number} indent (optional) Indentation level
     */
    createDump: function (indent) {
      if (indent === null || indent === undefined) {
        indent = 0;
      }
      var i;
      var indentStr = '';
      for (i = 0; i < indent; i++) {
        indentStr += '   ';
      }
      var dump = indentStr + 'List, type ' + this.listDom.tagName + '; ' +
        (this.isCorrectHierarchy ? 'correct hierarchy' : 'invalid hierarchy') +
        '\n';
      dump += indentStr + ' parent: ' + (this.parentList ? 'yes' : 'no') + '\n';
      for (i = 0; i < this.items.length; i++) {
        dump += indentStr + ' Item #' + (i + 1) + ':\n';
        dump += this.items[i].createDump(indent + 1);
      }
      return dump;
    }

  });

  /**
   * @class CUI.rte.ListRepresentation.Item
   * @private
   * <p>This class represents a single list item as part of a
   * {@link CUI.rte.ListRepresentation ListRepresentation}.</p>
   * <p>Note that most processing methods of this class do not adjust the data model (but only
   * the DOM), hence the list representation has to be recreated before another processing is
   * executed on the represented list.</p>
   * @constructor
   * Creates a new ListRepresentation.Item.
   * @param {CUI.rte.ListRepresentation} list The list the item is contained
   * @param {HTMLElement} itemDom DOM representation of the list item (must be of type "li")
   */
  CUI.rte.ListRepresentation.Item = new Class({

    toString: 'ListRepresentation.Item',

    /**
     * Back reference to the list the item is contained
     * @type CUI.rte.ListRepresentation
     * @private
     */
    list: null,

    /**
     * DOM element that contains the list item
     * @type HTMLElement
     * @private
     */
    itemDom: null,

    /**
     * Subordinate list (if any)
     * @type CUI.rte.ListRepresentation[]
     * @private
     */
    subLists: null,

    construct: function (list, itemDom) {
      this.list = list;
      this.itemDom = itemDom;
      this.subLists = [];
    },

    /**
     * <p>Adds the specified nested list explicitly.</p>
     * <p>Note that the specified list is not inspected for further nested lists. Use
     * {@link #detectSubLists} explicitly on the specified list.</P>
     * @param {CUI.rte.ListRepresentation} subList The list representation to add
     */
    addSubList: function (subList) {
      this.subLists.push(subList);
    },

    /**
     * Inspects the list item for nested lists recursively and adjusts the item
     * representation accordingly.
     * @param {HTMLElement} subItem (optional) The DOM element to check; defaults to the
     *        DOM element representing the list item
     */
    detectSubLists: function (subItem) {
      var com = CUI.rte.Common;
      if (!subItem) {
        subItem = this.itemDom;
      }
      if (com.isTag(subItem, com.LIST_TAGS)) {
        var subList = new CUI.rte.ListRepresentation(this.list, true);
        subList.fromList(subItem);
        this.subLists.push(subList);
      } else if (subItem.nodeType === 1) {
        var childCnt = subItem.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
          this.detectSubLists(subItem.childNodes[c]);
        }
      }
    },

    /**
     * <p>Gets the item representation of the specified DOM list item.</p>
     * <p>Note that this method works recursively, considering nested lists.</p>
     * @param {HTMLElement} dom DOM list item (must be of type "li")
     */
    getItemByDom: function (dom) {
      if (this.itemDom === dom) {
        return this;
      }
      var slCnt = this.subLists.length;
      for (var l = 0; l < slCnt; l++) {
        var item = this.subLists[l].getItemByDom(dom);
        if (item !== null && item !== undefined) {
          return item;
        }
      }
      return null;
    },

    /**
     * Gets the item that is located before "this" on the same hierarchical list level.
     * @return {CUI.rte.ListRepresentation.Item} The preceding list item; null if "this"
     *         is the first item of the list
     */
    getPreviousItem: function () {
      var subItems = this.list.items;
      var itemCnt = subItems.length;
      for (var i = 0; i < itemCnt; i++) {
        var item = subItems[i];
        if (item === this) {
          if (i > 0) {
            return subItems[i - 1];
          }
          return null;
        }
      }
      return null;
    },

    /**
     * "Flattens" the child nodes of the item by moving them on the same hierarchical
     * level, directly following the item.
     * @private
     */
    flattenChildNodes: function () {
      var slCnt = this.subLists.length;
      var pNode = this.itemDom.parentNode;
      var refNode = this.itemDom.nextSibling;
      for (var l = 0; l < slCnt; l++) {
        var subList = this.subLists[l];
        var subItems = subList.items;
        for (var i = 0; i < subItems.length; i++) {
          var item = subItems[i];
          this.list.insertItemAfter(item, this);
          item.list = this.list;
          var itemPNode = item.itemDom.parentNode;
          itemPNode.removeChild(item.itemDom);
          if (itemPNode.childNodes.length === 0) {
            itemPNode.parentNode.removeChild(itemPNode);
          }
          if (refNode) {
            pNode.insertBefore(item.itemDom, refNode);
          } else {
            pNode.appendChild(item.itemDom);
          }
        }
      }
      this.subLists.length = 0;
    },

    /**
     * Indents the item.
     * @param {CUI.rte.EditContext} context The edit context
     */
    indent: function (context) {
      var prevItem = this.getPreviousItem();
      if (prevItem === null || prevItem === undefined) {
        return;
      }
      // if the previous item has a sub list, we will have to append the indented item
      // to it
      var slCnt = prevItem.subLists.length;
      var itemIndex = this.list.getItemIndex(this);
      this.list.items.splice(itemIndex, 1);
      if (slCnt > 0) {
        var subList = prevItem.subLists[slCnt - 1];
        this.itemDom.parentNode.removeChild(this.itemDom);
        subList.listDom.appendChild(this.itemDom);
        subList.items.push(this);
        this.list = subList;
        this.flattenChildNodes();
        return;
      }
      // we cannot use a previousSibling's sub list, so we'll have to create a new
      // list
      var newList = context.createElement(this.list.listDom.tagName);
      prevItem.itemDom.appendChild(newList);
      this.itemDom.parentNode.removeChild(this.itemDom);
      newList.appendChild(this.itemDom);
      var newSubList = new CUI.rte.ListRepresentation(prevItem.list, true);
      prevItem.addSubList(newSubList);
      newSubList.listDom = newList;
      newSubList.items.push(this);
      this.list = newSubList;
      this.flattenChildNodes();
    },

    /**
     * Outdents the item.
     * @param {CUI.rte.EditContext} context The edit context
     */
    outdent: function (context) {
      var com = CUI.rte.Common;
      var lut = CUI.rte.ListUtils;
      var slCnt, s, slItemCnt, itemToMove, listDom;
      var outdentedChildren = [];
      var listLevel = com.getListLevel(context, this.itemDom);
      if (listLevel === 1) {
        // first level items must be converted to paragraphs; sub-lists must be moved
        // out of the newly created paragraph
        slCnt = this.subLists.length;
        if (slCnt > 0) {
          var nextSib = this.itemDom.nextSibling;
          var newList;
          var insertRef;
          if (nextSib) {
            newList = nextSib.parentNode;
            insertRef = nextSib;
          } else {
            listDom = this.list.listDom;
            newList = context.createElement(listDom.tagName);
            com.insertBefore(listDom.parentNode, newList, listDom.nextSibling);
            insertRef = null;
          }
          for (s = 0; s < slCnt; s++) {
            var slItems = this.subLists[s].items;
            slItemCnt = slItems.length;
            if (slItemCnt > 0) {
              itemToMove = slItems[0].itemDom;
              outdentedChildren.push(slItems[0]);
              com.insertBefore(newList, itemToMove, insertRef);
              var subListDom = slItems[0].list.listDom;
              if (slItemCnt === 1) {
                subListDom.parentNode.removeChild(subListDom);
              } else {
                itemToMove.appendChild(subListDom);
              }
            }
          }
        }
        var changedDom = lut.convertListItem(context, this.itemDom, 'p');
        listDom = this.list.listDom;
        if (listDom.childNodes.length === 0) {
          listDom.parentNode.removeChild(listDom);
        }
        if (changedDom.nextSibling &&
          com.isTag(changedDom.nextSibling, com.LIST_TAGS)) {
          this.list.fromList(changedDom.nextSibling);
        }
      } else {
        // items on other levels have to be inserted behind the item of the sub list
        // they are currently contained; the sub list has to be removed if no more
        // items are contained after executing the outdent
        listDom = this.list.listDom;
        var parentItemDom = listDom.parentNode;
        var insertItem = this.list.parentList.getItemByDom(parentItemDom);
        var insertItemIndex = insertItem.list.getItemIndex(insertItem) + 1;
        var insertRefDom = parentItemDom.nextSibling;
        var pNode = parentItemDom.parentNode;
        this.itemDom.parentNode.removeChild(this.itemDom);
        if (insertRefDom) {
          pNode.insertBefore(this.itemDom, insertRefDom);
        } else {
          pNode.appendChild(this.itemDom);
        }
        var itemIndex = this.list.getItemIndex(this);
        var itemsToMove = [];
        for (var m = itemIndex + 1; m < this.list.items.length; m++) {
          itemsToMove.push(this.list.items[m]);
        }
        this.list.removeItem(this);
        if (this.list.items.length === 0) {
          listDom.parentNode.removeChild(listDom);
          this.list.parentList.removeSubList(this.list);
        }
        this.list = this.list.parentList;
        if (insertItemIndex < this.list.items.length) {
          this.list.items.splice(insertItemIndex, 0, this);
        } else {
          this.list.items.push(this);
        }
        // if the list item has a nested list with more than one item, indent all
        // but the first item to get the closest possible result
        slCnt = this.subLists.length;
        if (slCnt > 0) {
          for (s = 0; s < slCnt; s++) {
            var subList = this.subLists[s];
            slItemCnt = subList.items.length;
            if (slItemCnt > 0) {
              outdentedChildren.push(subList.items[0]);
            }
            if (slItemCnt > 1) {
              var itemsToIndent = [];
              for (var i = 1; i < slItemCnt; i++) {
                itemsToIndent.push(subList.items[i]);
              }
              for (i = 0; i < (slItemCnt - 1); i++) {
                itemsToIndent[i].indent(context);
              }
            }
          }
        }
        // if the new previousSibling has child lists, we'll have to insert them
        // as child lists of ourself.
        if (itemsToMove.length > 0) {
          var insertListDom = null;
          var insertSubList = null;
          if (this.subLists.length === 0) {
            insertListDom = context.createElement(this.list.listDom.tagName);
            this.itemDom.appendChild(insertListDom);
            insertSubList = new CUI.rte.ListRepresentation(this.list, true);
            insertSubList.listDom = insertListDom;
            this.subLists.push(insertSubList);
          } else {
            insertSubList = this.subLists[this.subLists.length - 1];
            insertListDom = insertSubList.listDom;
          }
          for (m = 0; m < itemsToMove.length; m++) {
            itemToMove = itemsToMove[m];
            var moveDom = itemToMove.itemDom;
            pNode = moveDom.parentNode;
            pNode.removeChild(moveDom);
            itemToMove.list.removeItem(itemToMove);
            if (pNode.childNodes.length === 0) {
              pNode.parentNode.removeChild(pNode);
              itemToMove.list.parentList.removeSubList(itemToMove.list);
            }
            itemToMove.list = insertSubList;
            insertListDom.appendChild(moveDom);
            insertSubList.items.push(itemToMove);
          }
        }
      }
      return outdentedChildren;
    },

    /**
     * Ensures the correct nesting of lists that are subordinate to this list.
     * @param {CUI.rte.EditContext} context The edit context
     */
    ensureHierarchy: function (context) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var listCnt = this.subLists.length;
      for (var l = 0; l < listCnt; l++) {
        var subListToProcess = this.subLists[l];
        if (!subListToProcess.isCorrectHierarchy) {
          var listItem = this.itemDom;
          if (com.isTag(listItem, com.LIST_TAGS)) {
            listItem = context.createElement('li');
            listItem.appendChild(context.createTextNode(dpr.NBSP));
            this.itemDom.appendChild(listItem);
            this.itemDom = listItem;
          }
          var listToMove = subListToProcess.listDom;
          listToMove.parentNode.removeChild(listToMove);
          listItem.appendChild(listToMove);
          subListToProcess.isCorrectHierarchy = true;
        }
        subListToProcess.ensureHierarchy(context);
      }
    },

    /**
     * Flattens the represented item to a paragraph. The paragraph is inserted before the
     * specified top-level list.
     * @param {CUI.rte.EditContext} context The edit context
     */
    flatten: function (context, topLevelList) {
      var com = CUI.rte.Common;
      // flatten item
      var paraNode = context.createElement('p');
      topLevelList.parentNode.insertBefore(paraNode, topLevelList);
      var childCnt = this.itemDom.childNodes.length;
      for (var c = childCnt - 1; c >= 0; c--) {
        var itemToMove = this.itemDom.childNodes[c];
        if (!com.isTag(itemToMove, ['ol', 'ul'])) {
          itemToMove.parentNode.removeChild(itemToMove);
          paraNode.insertBefore(itemToMove, paraNode.firstChild);
        }
      }
      // flatten sub lists
      var listCnt = this.subLists.length;
      for (var l = 0; l < listCnt; l++) {
        this.subLists[l].flatten(context, topLevelList);
      }
      this.subLists.length = 0;
      // remove item from DOM
      this.itemDom.parentNode.removeChild(this.itemDom);
    },

    /**
     * Flattens a single list item by adding its content to the prevoius sibling or parent
     * list item as a new line.
     * @param {CUI.rte.EditContext} context The edit context
     */
    flattenToParent: function (context) {
      var com = CUI.rte.Common;
      var listDom = this.list.listDom;
      var auxRoot = CUI.rte.DomProcessor.getAuxRootNode(context, listDom);
      if (auxRoot === listDom.parentNode) {
        // use outdent if we are "unlisting" a first-level list item
        this.outdent(context);
        return;
      }
      this.flattenChildNodes();
      var childCnt;
      var itemDomRef = null;
      var insertRef = null;
      if (this.itemDom.previousSibling) {
        // prefer previous sibling - but will have to search for a suitable insert
        // point (which is the last item in the last nested list, or a non-list node)
        itemDomRef = this.itemDom.previousSibling;
        while (true) {
          childCnt = itemDomRef.childNodes.length;
          if (childCnt === 0) {
            break;
          }
          if (!com.isTag(itemDomRef.childNodes[childCnt - 1], com.LIST_TAGS)) {
            break;
          }
          // get last item of list
          itemDomRef = itemDomRef.childNodes[childCnt - 1].lastChild;
        }
      } else {
        // use parent item if no suitable previous sibling exists
        itemDomRef = com.getParentNode(context, listDom);
        insertRef = listDom;
      }
      // move
      itemDomRef.insertBefore(context.createElement('br'), insertRef);
      var children = this.itemDom.childNodes;
      childCnt = children.length;
      for (var c = childCnt - 1; c >= 0; c--) {
        var childToMove = children[c];
        childToMove.parentNode.removeChild(childToMove);
        itemDomRef.insertBefore(childToMove, insertRef);
        insertRef = childToMove;
      }
      // remove self from DOM & data model
      listDom.removeChild(this.itemDom);
      if (listDom.childNodes.length === 0) {
        this.list.parentList.removeSubList(this.list);
        listDom.parentNode.removeChild(listDom);
      }
      this.list.removeItem(this);
      this.list = null;
    },

    /**
     * Creates a "plain text" version of the current state of the list item representation.
     * @param {Number} indent (optional) Indentation level
     */
    createDump: function (indent) {
      var com = CUI.rte.Common;
      if (indent === null || indent === undefined) {
        indent = 0;
      }
      var i;
      var indentStr = '';
      for (i = 0; i < indent; i++) {
        indentStr += '   ';
      }
      var dump = com.dumpNodeRecursively(this.itemDom, indent);
      for (var l = 0; l < this.subLists.length; l++) {
        dump += indentStr + ' Sub list #' + (l + 1) + ':\n';
        dump += this.subLists[l].createDump(indent + 1);
      }
      return dump;
    }

  });

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.CellSelection
 * @private
 * This class represents a cell-based table selection as used internally by the table
 * plugin.
 * @constructor
 * @param {CUI.rte.TableMatrix} tableMatrix Table matrix that underlies the
 *        selection
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.CellSelection = new Class({

    toString: 'CellSelection',

    /**
     * The table matrix the selection has been created from
     * @private
     * @type CUI.rte.TableMatrix
     */
    tableMatrix: null,

    /**
     * Array of cell definitions that represent the currently selected cells
     * @private
     * @type Array
     */
    cells: null,

    /**
     * Object that holds comprehensive information about the current selection; properties
     * are: minRow, minCol, maxRowExcl, maxColExcl, cols, rows, isRect, anchorCell;
     * isRect defines if the selection forms a rectangle; anchorCell specifies the cell at
     * the top/left corner of the selection
     * @property selectionProps
     * @type Object
     */
    selectionProps: null,

    construct: function (tableMatrix) {
      this.cells = [];
      this.tableMatrix = tableMatrix;
    },

    /**
     * Adds the cell specified by its cell definition to the current selection.
     * @param {Object} cellDef cell definition (as used/created by various mathods of
     *        {@link CUI.rte.TableMatrix})
     */
    addCell: function (cellDef) {
      this.cells.push(cellDef);
    },

    /**
     * <p>Expand the current selection by the specified number of columns to the
     * bottom/right.</p>
     * <p>The method ensures that the selection is rectangular again after expanding it by
     * adding additional cells as required. It also reprocesses the {@link #selectionProps}
     * property to fit the expanded selection.</p>
     * @param {Number} cols Number of columns to expand the selection by
     * @param {Number} rows Number of rows to expand the selection by
     */
    expand: function (cols, rows) {
      if (this.selectionProps === null || this.selectionProps === undefined) {
        this.process();
      }
      if (this.selectionProps === null || this.selectionProps === undefined) {
        return;
      }
      if (this.tableMatrix.fullMatrix === null || this.tableMatrix.fullMatrix === undefined) {
        this.tableMatrix.createFullMatrix();
      }
      var com = CUI.rte.Common;
      // first, add all cells that are really required to expand the selection
      var cellsToAdd = [];
      var baseCol = this.selectionProps.minCol;
      var baseRow = this.selectionProps.minRow;
      var expandCol = this.selectionProps.maxColExcl;
      var expandRow = this.selectionProps.maxRowExcl;
      var r, c, expR, expC, cellToAdd;
      if (cols > 0) {
        for (r = 0; r < this.selectionProps.rows; r++) {
          for (expC = 0; expC < cols; expC++) {
            cellToAdd = this.tableMatrix.fullMatrix[baseRow + r][expandCol + expC];
            if (cellToAdd) {
              cellToAdd = cellToAdd.cellRef;
              if (!com.arrayContains(cellsToAdd, cellToAdd)) {
                cellsToAdd.push(cellToAdd);
              }
            }
          }
        }
      }
      if (rows > 0) {
        for (c = 0; c < this.selectionProps.cols; c++) {
          for (expR = 0; expR < rows; expR++) {
            cellToAdd = this.tableMatrix.fullMatrix[expandRow + expR][baseCol + c];
            if (cellToAdd) {
              cellToAdd = cellToAdd.cellRef;
              if (!com.arrayContains(cellsToAdd, cellToAdd)) {
                cellsToAdd.push(cellToAdd);
              }
            }
          }
        }
      }
      // second, add additional cells that are required to make the selection rectangular
      // again
      var minCol = baseCol;
      var minRow = baseRow;
      var maxCol = expandCol + cols;
      var maxRow = expandRow + rows;
      var itMinCol = minCol;
      var itMinRow = minRow;
      var itMaxCol = maxCol;
      var itMaxRow = maxRow;
      var isProcessed = false;
      while (!isProcessed) {
        var cellCnt = cellsToAdd.length;
        for (c = 0; c < cellCnt; c++) {
          var cell = cellsToAdd[c];
          var cellMaxCol = cell.col + cell.colSpan;
          var cellMaxRow = cell.row + cell.rowSpan;
          if (cell.col < itMinCol) {
            itMinCol = cell.col;
          }
          if (cellMaxCol > itMaxCol) {
            itMaxCol = cellMaxCol;
          }
          if (cell.row < itMinRow) {
            itMinRow = cell.row;
          }
          if (cellMaxRow > itMaxRow) {
            itMaxRow = cellMaxRow;
          }
        }
        if ((itMinCol !== minCol) || (itMinRow !== minRow) ||
          (itMaxCol !== maxCol) || (itMaxRow !== maxRow)) {
          for (r = itMinRow; r < itMaxRow; r++) {
            for (c = itMinCol; c < itMaxCol; c++) {
              var cellToCheck = this.tableMatrix.matrix[r][c];
              if (cellToCheck) {
                if (!com.arrayContains(cellsToAdd, cellToCheck)) {
                  cellsToAdd.push(cellToCheck);
                }
              }
            }
          }
          minRow = itMinRow;
          minCol = itMinCol;
          maxRow = itMaxRow;
          maxCol = itMaxCol;
        } else {
          isProcessed = true;
        }
      }
      for (c = 0; c < cellsToAdd.length; c++) {
        this.cells.push(cellsToAdd[c]);
      }
      this.process();
    },

    /**
     * <p>Processes the current selection to provide comprehensive selection information
     * through the {@link #selectionProps} property.</p>
     * @private
     */
    process: function () {
      if (!this.cells || (this.cells.length === 0)) {
        return;
      }
      var min = {
        'row': -1,
        'col': -1
      };
      var max = {
        'row': -1,
        'col': -1
      };
      var anchorCell = null;
      var cellArea = 0, spansThead = false, spansTbody = false, spansTfoot = false;
      var com = CUI.rte.Common;
      for (var c = 0; c < this.cells.length; c++) {
        var cellToProcess = this.cells[c];
        if (!spansThead && com.isTag(cellToProcess.cellDom.parentNode.parentNode, 'thead')) {
          spansThead = true;
        } else if (!spansTbody && com.isTag(cellToProcess.cellDom.parentNode.parentNode, 'tbody')) {
          spansTbody = true;
        } else if (!spansTfoot && com.isTag(cellToProcess.cellDom.parentNode.parentNode, 'tfoot')) {
          spansTfoot = true;
        }
        if ((cellToProcess.col < min.col) || (min.col < 0)) {
          min.col = cellToProcess.col;
        }
        if ((cellToProcess.row < min.row) || (min.row < 0)) {
          min.row = cellToProcess.row;
        }
        var lastColExcl = cellToProcess.col + cellToProcess.colSpan;
        var lastRowExcl = cellToProcess.row + cellToProcess.rowSpan;
        if (lastColExcl > max.col) {
          max.col = lastColExcl;
        }
        if (lastRowExcl > max.row) {
          max.row = lastRowExcl;
        }
        if ((cellToProcess.col === min.col) && (cellToProcess.row === min.row)) {
          anchorCell = cellToProcess;
        }
        cellArea += cellToProcess.colSpan * cellToProcess.rowSpan;
      }
      var cols = max.col - min.col;
      var rows = max.row - min.row;
      var selectionArea = cols * rows;
      this.selectionProps = {
        'minRow': min.row,
        'minCol': min.col,
        'maxRowExcl': max.row,
        'maxColExcl': max.col,
        'cols': cols,
        'rows': rows,
        'isRect': (selectionArea === cellArea),
        'anchorCell': anchorCell,
        'spansThead': spansThead,
        'spansTbody': spansTbody,
        'spansTfoot': spansTfoot
      };
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.SearchableDocument
 * @private
 * The RichText.SearchableDocument provides means to execute
 * a plaintext search on a HTML document or fragment.
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.SearchableDocument = new Class({

    toString: 'SearchableDocument',

    plainText: null,

    plainTextLC: null,

    refs: null,

    findPos: 0,

    currentSearch: 0,

    config: null,

    /**
     * @private
     */
    createInternally: function (dom) {
      var com = CUI.rte.Common;
      if (dom.nodeType === 3) {
        var text = com.getNodeText(dom);
        if (text) {
          this.refs.push({
            'textPos': this.plainText.length,
            'charCnt': text.length,
            'nodeRef': dom
          });
          this.plainText += text;
        }
      } else if (dom.nodeType === 1) {
        var addWhitespace =
          (com.isTag(dom, CUI.rte.SearchableDocument.WHITESPACE_TAGS) ||
          com.isTag(dom, com.EDITBLOCK_TAGS)) &&
          (!com.strEndsWith(this.plainText, ' '));
        if ((this.plainText.length > 0) && addWhitespace) {
          this.refs.push({
            'textPos': this.plainText.length,
            'charCnt': 1,
            'nodeRef': dom
          });
          this.plainText += ' ';
        }
        var children = dom.childNodes;
        for (var i = 0; i < children.length; i++) {
          this.createInternally(children[i]);
        }
      }
    },

    create: function (dom) {
      this.plainText = '';
      this.refs = [];
      this.createInternally(dom);
      this.plainTextLC = this.plainText.toLowerCase();
    },

    getRefForPosition: function (textPos) {
      for (var i = 0; i < this.refs.length; i++) {
        var refToCheck = this.refs[i];
        if ((refToCheck.textPos >= textPos) &&
          ((refToCheck.textPos + refToCheck.charCnt) < textPos)) {
          return refToCheck;
        }
      }
      return null;
    },

    createMatch: function (textPos, charCnt) {
      var result = [];
      var endPosIncl = textPos + charCnt - 1;
      var refCnt = this.refs.length;
      for (var i = 0; i < refCnt; i++) {
        var ref = this.refs[i];
        var refEndPosIncl = ref.textPos + ref.charCnt - 1;
        if (((ref.textPos >= textPos) && (ref.textPos <= endPosIncl)) ||
          ((refEndPosIncl >= textPos) && (refEndPosIncl <= endPosIncl)) ||
          ((ref.textPos >= textPos) && (refEndPosIncl <= endPosIncl)) ||
          ((ref.textPos <= textPos) && (refEndPosIncl >= endPosIncl))) {
          result.push({
            matchPos: textPos,
            matchChars: charCnt,
            nodePos: ref.textPos,
            nodeCharCnt: ref.charCnt,
            node: ref.nodeRef
          });
        } else {
          // as the array is sorted ascendingly, we are finished if we have already
          // found something and the current reference is not part of the result
          // (anymore)
          if (result.length > 0) {
            return result;
          }
        }
      }
      return result;
    },

    getRefForNode: function (node) {
      for (var i = 0; i < this.refs.length; i++) {
        if (this.refs[i].nodeRef === node) {
          return this.refs[i];
        }
      }
      return null;
    },

    find: function (text, config) {
      this.config = config;
      this.currentSearch = text;
      this.findPos = config.startPos || 0;
      return this.findNext();
    },

    findNext: function () {
      var baseText = (this.config.ignoreCase ? this.plainTextLC : this.plainText);
      var pattern = (this.config.ignoreCase ? this.currentSearch.toLowerCase()
        : this.currentSearch);
      var textPos = baseText.indexOf(pattern, this.findPos);
      if (textPos < 0) {
        this.findPos = 0;
        return null;
      }
      this.findPos = textPos + pattern.length;
      return this.createMatch(textPos, pattern.length);
    },

    adjustToReplace: function (replaceText) {
      this.findPos += replaceText.length - this.currentSearch.length;
    },

    createDump: function () {
      var dump = 'Searchable text:\n' + this.plainText + '\n\n';
      dump += 'References:\n' + CUI.rte.Common.dumpObject(this.refs);
      return dump;
    }

  });

  /**
   * Array that defines tags that should be handled as whitespace when searching an HTML
   * text
   * @static
   * @final
   * @type String[]
   * @private
   */
  CUI.rte.SearchableDocument.WHITESPACE_TAGS = ['br', 'img'];

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.Compatibility
 * @private
 * @since 5.3
 */
(function (CUI) {
  'use strict';
  CUI.rte.Compatibility = (function () {

    var com = CUI.rte.Common;

    return {

      moveDeprecatedPluginConfig: function (config) {
        var compat = CUI.rte.Compatibility;
        compat.correctConfigOption(config, 'defaultPasteMode',
          'rtePlugins.edit.defaultPasteMode');
        compat.correctConfigOption(config, 'stripHtmlTags',
          'rtePlugins.edit.stripHtmlTags');
        compat.correctConfigOption(config, 'tabSize',
          'rtePlugins.keys.tabSize');
        compat.correctConfigOption(config, 'trimLinkSelection',
          'rtePlugins.links.trimLinkSelection');
        compat.correctConfigOption(config, 'anchordialogConfig',
          'rtePlugins.links.anchorDialogConfig');
        compat.correctConfigOption(config, 'indentSize',
          'rtePlugins.lists.indentSize');
        compat.correctConfigOption(config, 'specialCharsConfig',
          'rtePlugins.misctools.specialCharsConfig');
        compat.correctConfigOption(config, 'formats',
          'rtePlugins.paraformat.formats');
        compat.correctConfigOption(config, 'cssStyles',
          'rtePlugins.styles.styles');
        compat.correctConfigOption(config, 'editMode',
          'rtePlugins.table.editMode');
        compat.correctConfigOption(config,
          'rtePlugins.table.tablePropConfig.tableStyles',
          'rtePlugins.table.tableStyles');
        var tableStyles = compat.getConfigValue(config, 'rtePlugins.table.tableStyles');
        if (tableStyles) {
          tableStyles = compat.convertToArray(tableStyles, 'cssName', 'text');
          compat.changeDeprecatedPropertyName(tableStyles, 'className', 'cssName');
          compat.setConfigValue(config, 'rtePlugins.table.tableStyles', tableStyles);
        }
        compat.correctConfigOption(config,
          'rtePlugins.table.tablePropConfig.defaultValues',
          'rtePlugins.table.defaultValues');
        compat.correctConfigOption(config,
          'rtePlugins.table.cellPropConfig.cellStyles',
          'rtePlugins.table.cellStyles');
        var cellStyles = compat.getConfigValue(config, 'rtePlugins.table.cellStyles');
        if (cellStyles) {
          cellStyles = compat.convertToArray(cellStyles, 'cssName', 'text');
          compat.changeDeprecatedPropertyName(cellStyles, 'className', 'cssName');
          compat.setConfigValue(config, 'rtePlugins.table.cellStyles', cellStyles);
        }
      },

      moveDeprecatedHtmlRules: function (config) {
        var compat = CUI.rte.Compatibility;
        var filteredConfig = compat.createFilteredConfig(config, 'linkbrowseConfig', [
          'cssInternal',
          'cssExternal',
          'protocols',
          'defaultProtocol',
          'targetConfig'
        ], true);
        var ruleConfig = filteredConfig[0];
        if (ruleConfig !== null && ruleConfig !== undefined) {
          compat.setConfigValue(config, 'htmlRules.links',
            new CUI.rte.HtmlRules.Links(ruleConfig));
        }
        var dialogConfig = filteredConfig[1];
        if (dialogConfig !== null && dialogConfig !== undefined) {
          compat.setConfigValue(config, 'rtePlugins.links.linkDialogConfig',
            dialogConfig);
        }
        compat.correctConfigOption(config, 'removeSingleParagraphContainer',
          'htmlRules.blockHandling.removeSingleParagraphContainer');
        compat.correctConfigOption(config, 'singleParagraphContainerReplacement',
          'htmlRules.blockHandling.singleParagraphContainerReplacement');
      },

      createFilteredConfig: function (config, path, filterIncl, removeJcrLeftovers) {
        var compat = CUI.rte.Compatibility;
        var configObj = compat.getConfigValue(config, path);
        if ((configObj === null) || (configObj === undefined)) {
          return [null, null];
        }
        if ((filterIncl === null) || (filterIncl === undefined)) {
          return [configObj, null];
        }
        if (removeJcrLeftovers) {
          compat.filterJcrLeftovers(configObj);
        }
        var filteredConfig = {};
        var leftoverConfig = null;
        for (var propName in configObj) {
          if (com.arrayContains(filterIncl, propName)) {
            filteredConfig[propName] = configObj[propName];
          } else {
            if ((leftoverConfig === null) || (leftoverConfig === undefined)) {
              leftoverConfig = {};
            }
            leftoverConfig[propName] = configObj[propName];
          }
        }
        return [filteredConfig, leftoverConfig];
      },

      filterJcrLeftovers: function (obj) {
        if (obj['jcr:primaryType']) {
          delete obj['jcr:primaryType'];
        }
        if (obj['xtype'] && (obj['xtype'] === 'nt:unstructured')) {
          delete obj['xtype'];
        }
      },

      correctConfigOption: function (config, deprecatedPath, currentPath) {
        var compat = CUI.rte.Compatibility;
        var deprecatedValue = compat.getConfigValue(config, deprecatedPath);
        if (deprecatedValue !== null && deprecatedValue !== undefined) {
          compat.setConfigValue(config, currentPath, deprecatedValue);
          compat.removeConfigValue(config, deprecatedPath);
        }
      },

      getConfigValue: function (config, path) {
        var configObj = config;
        var parts = path.split('.');
        for (var p = 0; p < parts.length; p++) {
          configObj = configObj[parts[p]];
          if (configObj === null || configObj === undefined) {
            return null;
          }
        }
        return configObj;
      },

      setConfigValue: function (config, path, value) {
        var configObj = config;
        var parts = path.split('.');
        var partCnt = parts.length;
        if (partCnt === 0) {
          return;
        }
        for (var p = 0; p < (partCnt - 1); p++) {
          var configParent = configObj;
          configObj = configObj[parts[p]];
          if (configObj === null || configObj === undefined) {
            configObj = {};
            configParent[parts[p]] = configObj;
          }
        }
        configObj[parts[partCnt - 1]] = value;
      },

      removeConfigValue: function (config, path) {
        var configObj = config;
        var parts = path.split('.');
        var partCnt = parts.length;
        if (partCnt === 0) {
          return;
        }
        for (var p = 0; p < (partCnt - 1); p++) {
          configObj = configObj[parts[p]];
          if (configObj === null || configObj === undefined) {
            return;
          }
        }
        delete configObj[parts[partCnt - 1]];
      },

      /**
       * This method provides backwards-compatibility for the "enableXXX"-style
       * configuration that is now deprecated in favor of
       * {@link CUI.rte.RichText#rtePlugins}.
       * @param {Object} config The config object to be used for configuration
       * @param {CUI.rte.EditorKernel} editorKernel The editor kernel
       * @param {Function} defaultPluginConfigFn (optional) A function that checks
       *        for default plugin configuration
       * @private
       */
      configurePlugins: function (config, editorKernel, defaultPluginConfigFn) {
        var isButtonEnabled = function (group, buttonId) {
          var isGroupEnabled = false;
          var groupConfig = null;
          if (group === 'format') {
            isGroupEnabled = config.enableFormat;
            groupConfig = config.formatButtons;
          } else if (group === 'alignments') {
            isGroupEnabled = config.enableAlignments;
            groupConfig = config.alignmentButtons;
          } else if (group === 'lists') {
            isGroupEnabled = config.enableLists;
            groupConfig = config.listButtons;
          } else if (group === 'links') {
            isGroupEnabled = config.enableLinks;
            groupConfig = config.linkButtons;
          } else if (group === 'edit') {
            isGroupEnabled = config.enableEditTools;
            groupConfig = config.editToolButtons;
          }
          var isEnabled = (isGroupEnabled === undefined ? undefined : false);
          if (isGroupEnabled) {
            if (groupConfig) {
              isEnabled = !!groupConfig[buttonId];
            } else {
              isEnabled = true;
            }
          }
          return isEnabled;
        };
        var checkPluginConfig = function (pluginId, feature) {
          var groupId = pluginId;
          switch (pluginId) {
          case 'format':
            break;
          case 'justify':
            groupId = 'alignments';
            feature = feature.substring(7, feature.length);
            break;
          case 'lists':
            break;
          case 'subsuperscript':
            return config.enableSubSuperScript;
          case 'links':
            if (feature === 'modifylink') {
              feature = 'createlink';
            }
            break;
          case 'paraformat':
            return config.enableParagraphFormat;
          case 'styles':
            return config.enableStyle;
          case 'misctools':
            if (feature === 'sourceedit') {
              return config.enableSourceEdit;
            }
            if (feature === 'specialchars') {
              return config.enableSpecialChars;
            }
            break;
          }
          return isButtonEnabled(groupId, feature);
        };
        var pluginConfig = config.rtePlugins;
        for (var pluginId in editorKernel.registeredPlugins) {
          if (editorKernel.registeredPlugins.hasOwnProperty(pluginId)) {
            var plugin = editorKernel.registeredPlugins[pluginId];
            var plgConfig = {};
            var features = plugin.getFeatures();
            var featCnt = features.length;
            for (var f = 0; f < featCnt; f++) {
              var isEnabled = undefined;
              if (defaultPluginConfigFn) {
                isEnabled = defaultPluginConfigFn(pluginId, features[f]);
              }
              if (isEnabled === undefined) {
                isEnabled = checkPluginConfig(pluginId, features[f]);
              }
              if (isEnabled !== undefined) {
                if (!plgConfig.features) {
                  plgConfig.features = [];
                }
                if (isEnabled) {
                  plgConfig.features.push(features[f]);
                }
              }
            }
            if (pluginConfig && pluginConfig[pluginId]) {
              CUI.rte.Utils.apply(plgConfig, pluginConfig[pluginId]);
            }
            if (config.externalStyleSheets && plugin.pluginId === 'fullscreen') {
              plgConfig.externalStyleSheets = config.externalStyleSheets;
            }
            plugin.notifyPluginConfig(plgConfig);
          }
        }
      },

      /**
       * Ensures that the specified config object is an array. If it is not an array,
       * an array is created from the properties of the specified object: Each
       * property is converted to an array element that has two properties: one named
       * as specified by keyProp, containing the original property's name; another named
       * as specified by valueProp, containing the original property's value.
       * @param {Object} obj The object to ensure that it is an array.
       * @param {String} keyProp Name of the property containing converted property's name
       * @param {String} valueProp Name of the property containing converted property's
       *        value
       */
      convertToArray: function (obj, keyProp, valueProp) {
        if (!obj) {
          return null;
        }
        com.removeJcrData(obj);
        if (CUI.rte.Utils.isArray(obj)) {
          return obj;
        }
        var array = [];
        var item;
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            var value = obj[key];
            if (typeof(value) === 'object') {
              if (value[keyProp] && value[valueProp]) {
                array.push(value);
              } else {
                item = {};
                item[keyProp] = key;
                item[valueProp] = value;
                array.push(item);
              }
            } else {
              item = {};
              item[keyProp] = key;
              item[valueProp] = value;
              array.push(item);
            }
          }
        }
        return array;
      },

      /**
       * <p>Changes a deprecated property name (in an array of objects) to the current
       * name.</p>
       * <p>For example: [ { deprecated: "A" }, "deprecated": "B" } ] is converted to
       * [ { "current": "A" }, { "current": "B" } ] (if called with "deprecated" as
       * parameter deprecatedName and "current" as parameter currentName).</p>
       * @param {Object[]} array The array to be converted
       * @param {String} deprecatedName Deprecated property name
       * @param {String} currentName Current property name
       */
      changeDeprecatedPropertyName: function (array, deprecatedName, currentName) {
        if (array === null || array === undefined) {
          return;
        }
        var itemCnt = array.length;
        for (var i = 0; i < itemCnt; i++) {
          var itemToCheck = array[i];
          if (itemToCheck.hasOwnProperty(deprecatedName)) {
            if (!itemToCheck.hasOwnProperty(currentName)) {
              itemToCheck[currentName] = itemToCheck[deprecatedName];
              delete itemToCheck[deprecatedName];
            }
          }
        }
      },

      /**
       * <p>Ensures that the specified property of the specified object is actually a
       * regular expression and handles default values.</p>
       * <p>This is a workaround for several issues around RegExp handling with CRX.</p>
       * <p>If the specified property does not exist or is undefined/null, the default
       * value is set. If the property value is a String, either a RegExp with the string
       * is created or the value is set to null if an empty string is found. Otherwise,
       * the property is kept "as is".</p>
       * @param {Object} obj The object
       * @param {String} prop The property name
       * @param {RegExp} defaultValue The default value
       * @since 5.5
       */
      adjustRegExp: function (obj, prop, defaultValue) {
        if (obj[prop] === null || obj[prop] === undefined) {
          obj[prop] = defaultValue;
        } else if (CUI.rte.Utils.isString(obj[prop])) {
          var propValue = obj[prop];
          var opts;
          if (com.strStartsWith(propValue, '/')) {
            var finalSlash = propValue.lastIndexOf('/');
            if (finalSlash > 0) {
              if (finalSlash < (propValue.length - 1)) {
                opts = propValue.substring(finalSlash + 1, propValue.length);
              }
              propValue = propValue.substring(1, finalSlash);
            }
          }
          obj[prop] = (propValue.length === 0 ? null : new RegExp(propValue, opts));
        }
      }

    };

  }());
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.HtmlRules
 * This class and its sublasses represents the rules to be applied on HTML processing
 * from inside the {@link CQ.form.RichText RichText} component.
 * @since 5.3
 * @constructor
 * Creates a HtmlRules object.
 * @param {Object} config The configuration
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.HtmlRules = new Class({

    toString: 'HtmlRules',

    /**
     * @cfg {Object} links
     * Defines how links are created/handled.
     */
    /**
     * @property links
     * Defines how links are created/handled.
     * @type CUI.rte.HtmlRules.Links
     */
    links: null,

    /**
     * @cfg {Object} serializer
     * Defines HTML serialization
     */
    /**
     * @property serializer
     * Defines HTML serialization
     * @type CUI.rte.HtmlRules.Serializer
     */
    serializer: null,

    /**
     * @cfg {Object} docType
     * Defines the doctype
     */
    /**
     * @property docType
     * Defines the doctype
     * @type CUI.rte.HtmlRules.DocType
     */
    docType: null,

    /**
     * @cfg {Object} blockHandling
     * Defines the rules for handling blocks (edit blocks, aux roots, and so on).
     */
    /**
     * @property blockHandling
     * Defines the rules for handling blocks (edit blocks, aux roots, and so on).
     * @type CUI.rte.HtmlRules.BlockHandling
     */
    blockHandling: null,

    /**
     * @property tableHandling
     * Defines the rules for handling tables (thead, tfoot merging configs).
     * @type CUI.rte.HtmlRules.TableHandling
     */
    tableHandling: null,

    /**
     * @cfg {Object} genericHtml
     * Defines the rules for handling generic HTML (i.e. HTML that can't directly be
     * edited by RTE)
     */
    /**
     * @property genericHtml
     * Defines the rules for handling generic HTML (i.e. HTML that can't directly be
     * edited by RTE)
     * @type CUI.rte.genhtml.GenericHtmlRules
     */
    genericHtml: null,


    construct: function (config) {
      config = config || {};
      var hrls = CUI.rte.HtmlRules;
      this.links = new hrls.Links(config.links);
      this.serializer = new hrls.Serializer(config.serializer);
      this.docType = new hrls.DocType(config.docType);
      this.blockHandling = new hrls.BlockHandling(config.blockHandling);
      this.tableHandling = new hrls.TableHandling(config.tableHandling);
      this.genericHtml = new CUI.rte.genhtml.GenericHtmlRules(config.genericHtml);
      delete config.links;
      delete config.serializer;
      delete config.docType;
      delete config.blockHandling;
      delete config.tableHandling;
      delete config.genericHtml;
      /*
       CUI.rte.Utils.applyDefaults(config, {
       "defaultEditBlockType": "p"
       });
       */
      CUI.rte.Utils.apply(this, config);
    }

  });

  /**
   * Removes the server prefix (http://hostname:port/context; deliberately inserted by the
   * browser) from an internal link.
   * @param {String} href URL where the server prefix should be removed
   * @param {String} type The type of the href (for example, image or hyperlink; use
   *        constants defined in class {@link CUI.rte.Utils})
   * @return {String} adjusted URL ("/content/foo/bar" for internal links;
   *         "http://hostname[:port]/foo/bar" for external links
   */
  CUI.rte.HtmlRules.removePrefixForInternalLinks = function (href, type) {
    var currentUrl = location.href;
    var currentServerPrefix = CUI.rte.Utils.getServerPrefix(currentUrl) + '/';
    var prefixLen = currentServerPrefix.length;
    if (href.length > prefixLen) {
      if (href.substring(0, prefixLen) === currentServerPrefix) {
        var isSamePage = false;
        var hasQueryString = false;
        if (href.length > currentUrl.length) {
          if (href.substring(0, currentUrl.length) === currentUrl) {
            var sepChar = href.charAt(currentUrl.length);
            switch (sepChar) {
            case '?':
              hasQueryString = true;
              isSamePage = true;
              break;
            case '#':
              isSamePage = true;
              break;
            }
          }
        }
        if (isSamePage && !hasQueryString) {
          // anchor-only link: remove protocol, host, path
          href = href.substring(currentUrl.length, href.length);
        } else {
          href = href.substring(prefixLen - 1, href.length);
        }
      }
    }
    return href;
  };


  /**
   * @class CUI.rte.HtmlRules.Links
   * The HtmlRules.Links class represents the HTML rules used for creating links.
   * @since 5.3
   * @constructor
   * Creates a HtmlRules.Links object.
   * @param {Object} config The configuration
   */
  CUI.rte.HtmlRules.Links = new Class({

    toString: 'HtmlRules.Links',

    /**
     * @cfg {String} cssMode
     * <p>Defines the CSS mode for links. Possible values are:</p>
     * <ul>
     *   <li>"remove" - removes class elements on links</li>
     *   <li>"keep" - keeps manually added classes "as is"</li>
     *   <li>"replace" - replaces manually added classes by using the classes defined by
     *     {@link #cssInternal} and {@link #cssExternal}.</li>
     *   <li>"auto" - (default) determines the cssMode through the settings of
     *     {@link #cssInternal} and {@link #cssExternal}. If at least one of these
     *     properties is set, mode "replace" is used. If none is set, mode "keep" is
     *     used instead.</li>
     * </ul>
     * @since 5.3
     */
    cssMode: null,

    /**
     * @cfg {String} cssInternal
     * CSS class to use for internal links
     */
    cssInternal: null,

    /**
     * @cfg {String} cssExternal
     * CSS class to use for external links
     */
    cssExternal: null,

    /**
     * @cfg {String[]} protocols
     * A list of available prototcols; use the entire protocol prefix (e.g. "http://",
     * "ftp://"). Note that internal links are always available.
     */
    protocols: null,

    /**
     * @cfg {String} defaultProtocol
     * The default protocol value; must be one of the values in {@link #protocols}
     */
    defaultProtocol: null,

    /**
     * @cfg {Object} targetConfig
     * <p>Defines how to handle the "target" attribute of the link being edited. Properties:
     * </p>
     * <ul>
     *   <li><code>mode</code> : String<br>
     *     Specifies the target mode; valid values are: "auto" - means that an automatic
     *     target is chosen (specified by the "targetExternal" property for external
     *     links and "targetInternal" for internal links). "manual" - means that the
     *     user can specify a target through an input field. "blank" - means that there
     *     is a checkbox to select if a link should be opened in a new window. "none" if no
     *     target attribute may be provided.</li>
     *   <li><code>targetInternal</code> : String<br>
     *     The target for internal links (only if mode == "auto")</li>
     *   <li><code>targetExternal</code> : String<br>
     *     The target for external links (only if mode == "auto")</li>
     * </ul>
     */
    targetConfig: null,

    /**
     * @cfg {Boolean} ensureInternalLinkExt
     * True if a proper extension (.html) should be ensured for internal links. False
     * if it's the user's responsibility to enter internal links correctly. Defaults to
     * true.
     * @since 5.4
     */
    ensureInternalLinkExt: false,

    /**
     * @cfg {RegExp} relativeLinkRegExp
     * A regular expression that is used to detect relative links. Relative links are
     * not prepended with an http:// link.
     * @since 5.5
     */
    relativeLinkRegExp: null,


    construct: function (config) {
      config = config || {};
      var defaults = {
        'cssMode': 'auto',
        'protocols': [
          'http://',
          'https://',
          'ftp://',
          'mailto:'
        ],
        'targetConfig': {
          'mode': 'blank'
        },
        'ensureInternalLinkExt': true
      };
      CUI.rte.Utils.applyDefaults(config, defaults);
      CUI.rte.Utils.apply(this, config);
      // adjust regexp
      CUI.rte.Compatibility.adjustRegExp(this, 'relativeLinkRegExp',
        CUI.rte.HtmlRules.Links.REL_LINK_DEFAULT_REGEXP);
    },

    /**
     * Get the protocol (if containes in the protocol array) of the specified HREF.
     * @param {String} href The HREF (i.e. "http://host.domain.tld/path/to/file.ext")
     * @return {String} The protocol; null if no or no valid/allowed protocol is available
     */
    getProtocol: function (href) {
      if (this.protocols) {
        var pCnt = this.protocols.length;
        for (var p = 0; p < pCnt; p++) {
          var protocol = this.protocols[p];
          if (CUI.rte.Common.strStartsWith(href, protocol)) {
            return protocol;
          }
        }
      }
      return null;
    },

    /**
     * <p>Checks if the specified HREF generally has (most probably) a protocol prefix.</p>
     * <p>The protocol is not checked against the protocols array.</p>
     * @param {String} href The HREF (i.e. "http://host.domain.tld/path/to/file.ext")
     * @return {Boolean} True, if a protocol has been detected for the specified HREF
     */
    hasProtocol: function (href) {
      return CUI.rte.HtmlRules.Links.hasProtocol(href);
    },

    /**
     * Checks if the specified HREF represents an internal link.
     * @param {String} href The HREF (i.e. "http://host.domain.tld/path/to/file.ext")
     * @return {Boolean} True, if the specified HREF represents an internal link
     */
    isInternalLink: function (href) {
      return CUI.rte.HtmlRules.Links.isInternalLink(href);
    },

    /**
     * Checks if the specified HREF represents a relative link.
     * @param {String} href the HREF (i.e. "http://host.domain.tld/path/to/file.ext")
     */
    isRelativeLink: function (href) {
      return CUI.rte.HtmlRules.Links.isRelativeLink(href, this.relativeLinkRegExp);
    },

    /**
     * <p>Validates the specified HREF.</p>
     * <p>The HREF is considered valid if:</p>
     * <ul>
     *   <li>It has a valid protocol.</li>
     *   <li>Or represents an internal link (note that the internal link is not verified
     *     to point to a valid node).</li>
     *   <li>Or is recognized as a link without protocol (i.e. "www.day.com",
     *     "localhost:80")</li>
     * </ul>
     * @param {String} href The HREF to validate
     * @return {Boolean} True if the HREF could be validated
     */
    validateHref: function (href) {
      var protocol = this.getProtocol(href);
      if (protocol) {
        // valid protocol prepended
        return true;
      }
      // internal & relative links
      if (this.isInternalLink(href)) {
        return true;
      }
      if (this.isRelativeLink(href)) {
        return true;
      }
      // invalid protocol?
      if (this.hasProtocol(href)) {
        return false;
      }
      // link without protocol (i.e. www.day.com) or empty link
      return !!(href && (href.length > 0));
    },

    /**
     * Applies the link rules to the specified DOM object.
     * @param {HTMLElement|Object} obj DOM object or JavaScript stub object to apply rules
     *        to
     */
    applyToObject: function (obj) {
      var com = CUI.rte.Common;
      var isDomObject = (obj.nodeType && (obj.nodeType === 1));
      var href;
      if (isDomObject) {
        href = CUI.rte.HtmlRules.Links.getLinkHref(obj);
      } else {
        href = obj.href || '';
      }
      var cssMode = this.cssMode;
      if (cssMode === 'auto') {
        if ((this.cssInternal !== null && this.cssInternal !== undefined) || (this.cssExternal !== null && this.cssExternal !== undefined)) {
          cssMode = 'replace';
        } else {
          cssMode = 'keep';
        }
      }
      if (cssMode === 'remove') {
        if (isDomObject) {
          com.removeAttribute(obj, 'class');
        } else {
          obj.cssClass = null;
        }
      } else if (cssMode === 'replace') {
        var cssClass = null;
        if (this.cssInternal && this.isInternalLink(href)) {
          cssClass = this.cssInternal;
        }
        if (this.cssExternal && !this.isInternalLink(href)) {
          cssClass = this.cssExternal;
        }
        if (isDomObject) {
          if (cssClass !== null && cssClass !== undefined) {
            com.setAttribute(obj, 'class', cssClass);
          } else {
            com.removeAttribute(obj, 'class');
          }
        } else {
          obj.cssClass = cssClass;
        }
      }
      if (this.targetConfig) {
        switch (this.targetConfig.mode) {
        case 'none':
          if (isDomObject) {
            com.removeAttribute(obj, 'target');
          } else {
            obj.target = null;
          }
          break;
        case 'auto':
          var target = (this.isInternalLink(href) ?
            this.targetConfig.targetInternal
            : this.targetConfig.targetExternal);
          if (isDomObject) {
            if (target !== null && target !== undefined) {
              com.setAttribute(obj, 'target', target);
            } else {
              com.removeAttribute(obj, 'target');
            }
          } else {
            obj.target = target;
          }
          break;
        }
      }
      if (this.isInternalLink(href) || this.isRelativeLink(href)) {
        var anchorPos = href.indexOf('#');
        if (anchorPos === 0) {
          // change nothing if we have an "anchor only"-HREF
          return;
        }
        // add extension to internal links if necessary (relative links are considered
        // internal links as well)
        if (this.ensureInternalLinkExt && this.isPage(href)) {
          var anchor = '';
          if (anchorPos > 0) {
            anchor = href.substring(anchorPos, href.length);
            href = href.substring(0, anchorPos);
          }
          var query = '';
          var queryPos = href.indexOf('?');
          if (queryPos > 0) {
            query = href.substring(queryPos, href.length);
            href = href.substring(0, queryPos);
          }
          // add extension to href if necessary
          var extSepPos = href.lastIndexOf('.');
          var slashPos = href.lastIndexOf('/');
          var hasClosingSlash = (slashPos === (href.length - 1));
          if (((extSepPos <= 0) || (extSepPos < slashPos)) && !hasClosingSlash) {
            obj.href = href + CUI.rte.Constants.EXTENSION_HTML + query + anchor;
          }
        }
      } else if ((this.getProtocol(href) === null || this.getProtocol(href) === undefined) && !this.hasProtocol(href)) {
        // Two cases will end up here: either we have a relative link:
        //    relative/path/to/resource.html
        // or we have an absolute link where the user failed to specify the protocol:
        //    www.adobe.com/somePage.html
        // Trouble is, there's no definitive way to tell which we have.  So we apply
        // a few heuristics:
        if (!this.isPage(href)) {
          var slash = href.indexOf('/');
          var hostname = (slash > 0 ? href.substring(0, slash) : href);
          if (CUI.rte.HtmlRules.Links.PROBABLE_HOST_REGEXP.test(hostname)) {
            // user forgot to type a protocol; give them a default one:
            var protocol = this.defaultProtocol || 'http://';
            obj.href = protocol + href;
          }
          //else {
          // still might be a host which failed our PROBABLE_HOST_REGEXP test, but
          // better to have a false-negative and do nothing than to wreck a user's
          // valid relative URL.  (See bugs CQ5-10876 and CQ5-13109.)
          // }
        }
      }
    },

    /**
     * Returns true if the href points to a page.
     * @param {String} href A relative or absolute path
     */
    isPage: function (href) {
      var path;
      if (this.isRelativeLink(href)) {
        path = CUI.rte.Utils.resolveRelativePath(href);
      } else if (this.isInternalLink(href)) {
        path = href;
      }

      if (!path) {
        return false;
      } else if (path.indexOf('?') >= 0) {
        path = path.substring(0, path.indexOf('?'));    // trim query parameter
      } else if (path.indexOf('#') >= 0) {
        path = path.substring(0, path.indexOf('#'));    // trim fragment identifier
      }

      // links are already considered URL encoded, so we'll have to decode them
      // before passing the path to #getPageInfo()
      return CUI.rte.Utils.isExistingPage(path);
    }

  });

  /**
   * The default regular expression used for detecting hostnames
   */
  CUI.rte.HtmlRules.Links.PROBABLE_HOST_REGEXP = /^(localhost)|([\w\d\-\u0081-\uffff]+\.[\w\d\-\u0081-\uffff]+\.[\w\d\-\u0081-\uffff]+)$/;

  /**
   * Checks if the specified HREF has a protocol prefix (http://, mailto:, etc.).
   * @param {String} href HREF to check
   * @return {Boolean} <i>true</i> if the specified HREF has a protocol prefix
   */
  CUI.rte.HtmlRules.Links.hasProtocol = function (href) {
    return (/^[A-Za-z][A-Za-z\d+\-.]*:(\/\/)?([^\d]|[\d]+@|$)/).test(href);
  };

  /**
   * Checks if the specified HREF defines an internal link.
   * @param {String} href HREF to check
   */
  CUI.rte.HtmlRules.Links.isInternalLink = function (href) {
    return href && (href.length > 0) &&
      ((href.charAt(0) === '/') || (href.charAt(0) === '#'));
  };

  /**
   * Checks if the specified HREF represents a relative link.
   * @param {String} href the HREF (i.e. "http://host.domain.tld/path/to/file.ext")
   * @param {RegExp} regEx The regular expression to be used for detecting the relative link;
   *        if null, no relative link detection is applied on the HREF.
   */
  CUI.rte.HtmlRules.Links.isRelativeLink = function (href, regEx) {
    if (!regEx) {
      return false;
    }
    // console.log(regEx.test(href));
    return regEx.test(href);
  };

  /**
   * The default regular expression used for detecting relative links
   */
  CUI.rte.HtmlRules.Links.REL_LINK_DEFAULT_REGEXP = /^\.{1,2}\/(.*)/;

  /**
   * <p>Returns the HREF of the specified DOM element.</p>
   * <p>This method uses the proprietary RTE attribute if available. Otherwise, the
   * HREF attribute is taken and a guess is made if the HREF represents an internal link.
   * If so, the HREF is adjusted accordingly.</p>
   * @param {HTMLElement} dom The link element to check
   * @return {String} The link element's HREF attribute
   */
  CUI.rte.HtmlRules.Links.getLinkHref = function (dom) {
    var com = CUI.rte.Common;
    var href;
    if (com.isAttribDefined(dom, com.HREF_ATTRIB)) {
      href = com.getAttribute(dom, com.HREF_ATTRIB);
    } else {
      href = com.getAttribute(dom, 'href');
      if (href) {
        href = CUI.rte.HtmlRules.removePrefixForInternalLinks(href,
          CUI.rte.Utils.URL_LINK);
      }
    }
    return href;
  };

  /**
   * Removes the server prefix (http://hostname:port/context; deliberately inserted by the
   * browser) from an internal link.
   * @param {String} href URL where the server prefix should be removed
   * @return {String} adjusted URL ("/content/foo/bar" for internal links;
   *         "http://hostname[:port]/foo/bar" for external links
   * @deprecated use {@link CUI.rte.HtmlRules#removePrefixForInternalLinks instead
 */
  CUI.rte.HtmlRules.Links.removePrefixForInternalLinks = function (href) {
    return CUI.rte.HtmlRules.removePrefixForInternalLinks(href, CUI.rte.Utils.URL_LINK);
  };


  /**
   * @class CUI.rte.HtmlRules.Serializer
   * The HtmlRules.Serializer class represents the rules used for serializing and
   * deserializing HTML from/to DOM objects.
   * @since 5.3
   * @constructor
   * Creates a HtmlRules.Serializer object.
   * @param {Object} config The configuration
   */
  CUI.rte.HtmlRules.Serializer = new Class({

    toString: 'HtmlRules.Serializer',

    /**
     * @cfg {String} mode
     * <p>Serializer mode. Valid settings are:</p>
     * <ul>
     *   <li>"auto" - uses the a suitable default serializer.</li>
     *   <li>"customized" - uses customized serializer and deserializer; must be provided
     *     through the {@link #serializer} and {@link #deserializer} config options.</li>
     * </ul>
     * <p>Defaults to "auto".</p>
     */
    mode: null,

    /**
     * @cfg {Object} config
     * Configuration if a standard serializer ({@link CUI.rte.HtmlSerializer},
     * {@link CUI.rte.XhtmlSerializer} is used. See the corresponding class for
     * respective config options. Ignored if mode == "customized". Defaults to null to use
     * the serializer's default configuration.
     */
    config: null,

    /**
     * @cfg {CUI.rte.Serializer} serializer
     * Provides a customized serializer. Ignored if mode != "customized". Defaults to null.
     */
    serializer: null,

    /**
     * @cfg {CUI.rte.Serializer} deserializer
     * Provides a customized deserializer. Ignored if mode != "customized". Defaults to
     * null.
     */
    deserializer: null,


    construct: function (config) {
      config = config || {};
      CUI.rte.Utils.applyDefaults(config, {
        'mode': 'auto',
        'config': null,
        'serializer': null,
        'deserializer': null
      });
      CUI.rte.Utils.apply(this, config);
    },

    /**
     * Serializes the specified DOM tree.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} dom The root node of the DOM tree to be serialized; the root
     *        node itself is not serialized
     * @param {CUI.rte.HtmlRules.DocType} docType The doc type
     * @return {String} The serialized representation of the DOM tree
     */
    serialize: function (context, dom, docType) {
      // create serializer if necessary
      if (this.serializer === null || this.serializer === undefined) {
        switch (this.mode) {
        case 'auto':
          if (docType.baseType === 'html') {
            this.serializer = new CUI.rte.HtmlSerializer(this.config);
          } else if (docType.baseType === 'xhtml') {
            this.serializer = new CUI.rte.XhtmlSerializer(this.config);
          }
          break;
        case 'customized':
          throw new Error('Using \'customized\' serialization, but no custonized ' +
          'serializing object configured (use \'serializer\' config option)');
        default:
          throw new Error('Invalid serialization mode: \'' + this.mode + '\'');
        }
      }
      return this.serializer.serialize(context, dom);
    },

    /**
     * Deserializes the specified HTML fragment to the specified root DOM element.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {String} html The HTML code to deserialize
     * @param {HTMLElement} dom The root node of the DOM tree the HTML is deserialized to
     * @param {CUI.rte.HtmlRules.DocType} docType The doc type
     */
    deserialize: function (context, html, dom, docType) {
      // create deserializer if necessary
      if (this.deserializer === null || this.deserializer === undefined) {
        switch (this.mode) {
        case 'auto':
          if (docType.baseType === 'html') {
            this.deserializer = new CUI.rte.HtmlDeserializer(this.config);
          } else if (docType.baseType === 'xhtml') {
            this.deserializer = new CUI.rte.XhtmlDeserializer(this.config);
          }
          break;
        case 'customized':
          throw new Error('Using \'customized\' serialization, but no custonized ' +
          'deserializing object configured (use \'deserializer\' config ' +
          'option)');
        default:
          throw new Error('Invalid serialization mode: \'' + this.mode + '\'');
        }
      }
      return this.deserializer.deserialize(context, html, dom);
    }

  });


  /**
   * @class CUI.rte.HtmlRules.DocType
   * <p>The HtmlRules.DocType class represents some rules regarding document types.</p>
   * <p>It mostly influences the way HTML code is generated from the DOM (using some of the
   * {@link CUI.rte.HtmlProcessor} modules, especially the Postprocessor that is
   * responsible for the final HTML result.</p>
   * @constructor
   * Creates a new HtmlRules.DocType object.
   * @param {Object} config The configuration object
   */
  CUI.rte.HtmlRules.DocType = new Class({

    toString: 'HtmlRules.DocType',

    /**
     * @cfg {String} baseType
     * Basic document type; allowed values: "html", "xhtml"; defaults to "html"
     */
    baseType: null,

    /**
     * @cfg {String} version
     * Doctype version; only valid values: "4.0" for baseType == "html"; "1.0" for
     * baseType == "xhtml". Note that you'll have to provide the version as a String
     * object, not as a Number.
     */
    version: null,

    /**
     * @cfg {Object} typeConfig
     * Type-specific configuration. Currently supported config options:
     * <ul>
     *   <li><code>useSemanticMarkup</code> : Boolean<br>
     *     True if semantic markup should be used in favour of "physical style" markup
     *     (for example, use "strong" instead of "b" tags). The mapping of semantic to
     *     physical style tags is defined by semanticMarkupMap.</li>
     *   <li><code>semanticMarkupMap</code> : Object<br>
     *     Defines the mapping between physical style tags (key) and semantic markup tags
     *     (value). Note that you must specify a valid map, even if useSemanticMarkup is
     *     set to false.</li>
     *   <li><code>isXhtmlStrict</code> : Boolean<br>
     *     Defines if strict XHTML 1.0 has to be used (only if {@link #baseType} ==
     *     "xhtml"). Note that XHTML 1.0 strict has some limitations; for example the
     *     "u" tag is no longer supported.</li>
     * </ul>
     */
    typeConfig: null,

    /**
     * "Blacklist" of (RTE supported) tags that are not allowed by the current doc type
     * @private
     * @type String[]
     */
    tagBlacklist: null,

    construct: function (config) {
      config = config || {};
      CUI.rte.Utils.applyDefaults(config, {
        'baseType': 'html',
        'version': '4.0',
        'typeConfig': {
          'useSemanticMarkup': false,
          'semanticMarkupMap': {
            'b': 'strong',
            'i': 'em'
          }
        }
      });
      CUI.rte.Utils.apply(this, config);
      if ((this.baseType !== 'html') && (this.baseType !== 'xhtml')) {
        throw new Error('Invalid doctype; must be \'html\' or \'xhtml\'');
      }
      this.tagBlackList = [];
      if (this.baseType === 'html') {
        if (this.version !== '4.0') {
          throw new Error('Invalid version; must be \'4.0\' for doctype \'html\'.');
        }
      }
      if (this.baseType === 'xhtml') {
        if (this.version !== '1.0') {
          throw new Error('Invalid version; must be \'1.0\' for doctype \'xhtml\'.');
        }
        if (this.typeConfig.isXhtmlStrict) {
          this.tagBlackList.push('u');
        }
      }
    },

    /**
     * <p>Checks if the specified tag is allowed by the current document type.</p>
     * <p>Note that this method currently does not use the DTD to detect invalid tags,
     * but a blacklist is used.</p>
     * @param {String} tagName The tag name to be checked
     * @return {Boolean} True if the specified tag name is allowed for the doctype
     */
    isAllowed: function (tagName) {
      return !CUI.rte.Common.arrayContains(this.tagBlackList, tagName.toLowerCase());
    },

    /**
     * Checks if the specified tag is listed as semantic markup and returns the
     * corresponding physical style markup.
     * @param {String} tagName The tag name to be checked
     * @return {String} The corresponding physical style tag; null, if the specified tag
     *         name is not registered as semantic markup
     */
    convertToPhysicalStyle: function (tagName) {
      var markupMap = this.typeConfig.semanticMarkupMap;
      if (!markupMap) {
        return null;
      }
      tagName = tagName.toLowerCase();
      for (var physStyle in markupMap) {
        if (markupMap.hasOwnProperty(physStyle)) {
          if (markupMap[physStyle] === tagName) {
            return physStyle;
          }
        }
      }
      return null;
    },

    /**
     * Checks if the specified tag is listed as a physical style and returns the
     * corresponding semantic markup.
     * @param {String} tagName The tag name to be checked
     * @return {String} The corresponding semantic tag; null, if the specified tag
     *         name is not registered as a physical style
     */
    convertToSemanticMarkup: function (tagName) {
      if (!this.typeConfig.semanticMarkupMap) {
        return null;
      }
      tagName = tagName.toLowerCase();
      if (this.typeConfig.semanticMarkupMap.hasOwnProperty(tagName)) {
        return this.typeConfig.semanticMarkupMap[tagName];
      }
      return null;
    },

    /**
     * Adjusts the specified tag to the document type's requirements.
     * @param {String} tagName The name of the tag to adjust
     * @return {String} Adjusted tag name; null if nothing has to be adjusted; "" if the
     *         tag has to be ignored as it is not supported by the doctype
     */
    adjustToDocType: function (tagName) {
      if (this.typeConfig.useSemanticMarkup) {
        var convertedTag = this.convertToSemanticMarkup(tagName);
        if (convertedTag !== null && convertedTag !== undefined) {
          return (this.isAllowed(convertedTag) ? convertedTag : '');
        }
      }
      if (!this.isAllowed(tagName)) {
        return '';
      }
      return null;
    },

    /**
     * Adjusts the specified tag to the requirements of RTE.
     * @param {String} tagName The name of the tag to adjust
     * @return {String} Adjusted tag name; null if nothing has to be adjusted
     */
    adjustToRaw: function (tagName) {
      return this.convertToPhysicalStyle(tagName);
    }

  });

  CUI.rte.HtmlRules.BlockHandling = new Class({

    toString: 'HtmlRules.BlockHandling',

    /**
     * @cfg {String} defaultEditBlock
     * The default edit block type to use; defaults to "p"
     * @since 5.4
     */
    /**
     * @property defaultEditBlockType
     * The default edit block type to use
     * @type String
     * @since 5.4
     */
    defaultEditBlockType: null,

    /**
     * @cfg {Boolean} removeSingleParagraphContainer
     * True if the paragraph element of texts that consist only of a single paragraph
     * should be removed on postprocessing (defaults to false).
     * For example, if a text is &lt;p&gt;Single paragraph text&lt;/p&gt;, the surrounding
     * "p" tag would get removed if this option was set to true. This option is mainly for
     * backward compatibility with CQ 5.1, where container tags had not yet been available.
     * Hence texts that were created by a CQ 5.1 instance will be surrounded by a single "p"
     * element before they are edited in a CQ 5.2+ instance. By setting this option to true,
     * this automatically added "p" tag will get removed before the text is saved, at least
     * if no other paragraphs or containers were added.
     */
    removeSingleParagraphContainer: false,

    /**
     * @cfg {String} singleParagraphContainerReplacement
     * Specifies the name of the tag that has to be used if a paragraph container cannot
     * be simply removed because it carries additional info (for example, alignment and/or
     * CSS classes; defaults to "div"). Note that this setting only takes effect if
     * {@link #removeSingleParagraphContainer} is set to true.
     */
    singleParagraphContainerReplacement: null,

    construct: function (config) {
      config = config || {};
      CUI.rte.Utils.applyDefaults(config, {
        'defaultEditBlockType': 'p',
        'removeSingleParagraphContainer': false,
        'singleParagraphContainerReplacement': 'div'
      });
      CUI.rte.Utils.apply(this, config);
    }

  });

  CUI.rte.HtmlRules.TableHandling = new Class({

    toString: 'HtmlRules.TableHandling',

    /**
     * @cfg {Boolean} mergeTheadToTbody
     * True to merge the rows in thead into tbody.
     */
    mergeTheadToTbody: false,

    /**
     * @cfg {Boolean} mergeTfootToTbody
     * True to merge the rows in tfoot into tbody.
     */
    mergeTfootToTbody: false,

    construct: function(config) {
      config = config || { };
      CUI.rte.Utils.applyDefaults(config, {
        'mergeTheadToTbody': false,
        'mergeTfootToTbody': false
      });
      CUI.rte.Utils.apply(this, config);
    }

  });

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.Serializer
 * <p>The Serializer class works as an "interface" for providing fully customized HTML
 * serializers.</p>
 * <p>Serializers are used to convert the DOM of the edited document (resp. its "body" part)
 * into a suitable HTML representation that is used for storing the document in the
 * repository or editing using HTML source view.</p>
 * <p>You should only consider implementing this interface directly if you have very special
 * requirements. Usually, it should make more sense to extend one of the default
 * serializers, {@link CUI.rte.HtmlSerializer} or {@link CUI.rte.XhtmlSerializer}.
 * </p>
 * <p>Serializers should usually do the following cleanup/adjustments:</p>
 * <ul>
 *   <li>Provide correct tag/attribute case (i.e., in XHTML output, tag and attribute names
 *     should be lowercase)</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.Serializer = new Class({

    toString: 'Serializer',

    /**
     * <p>Serializes the specified DOM (sub-) tree.</p>
     * <p>Note that the specified DOM element itself must not get serialized.</p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} dom The DOM (sub-) tree to serialize
     * @return {String} The serialized representation of the DOM (sub-) tree
     */
    serialize: function (context, dom) {
      // must be overridden by the implementing class
      return '';
    }

  });

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.HtmlSerializer
 * @extends CUI.rte.Serializer
 * The HtmlSerializer is used to serialize a DOM (sub-) tree to its HTML (String)
 * equivalent.
 * @constructor
 * Creates a new HtmlSerializer.
 * @param {Object} config The configuration object
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.HtmlSerializer = new Class({

    toString: 'HtmlSerializer',

    extend: CUI.rte.Serializer,

    /**
     * The edit context
     * @private
     * @type CUI.rte.EditContext
     */
    context: null,

    /**
     * HTML code that should be added to the next structural node that has no more child
     * nodes
     * @private
     * @type String
     */
    deepestChildAddHtml: null,

    /**
     * @cfg {String[]} nonClosingTags
     * Array that contains tags that must not be closed. Defaults to: [ "br", "hr", "img",
     * "area", "input", "col" ]
     */
    nonClosingTags: null,

    /**
     * @cfg {String} tagCase
     * Defines the case of tags; valid values are: "upper" (for uppercase tags), "lower"
     * (for lowercase tags), "keep" (to keep tag names as they are according to DOM).
     * Defaults to "lower".
     */
    tagCase: null,

    /**
     * @cfg {String} attribNameCase
     * Defines the case of attribute names; valid values are: "upper" (for uppercase tags),
     * "lower" (for lowercase tags), "keep" (to keep tag names as they are according to
     * DOM). Defaults to "lower".
     */
    attribNameCase: null,

    /**
     * @cfg {String} styleAttribNameCase
     * Defines the case of style attribute names; valid values are: "upper" (for uppercase
     * tags), "lower" for (lowercase tags), "keep" (to keep tag names as they are according
     * to DOM). Defaults to "lower"
     */
    styleAttribNameCase: null,

    /**
     * @cfg {String} idAttribMode
     * Defines how to handle the ID attribute; valid values are: "remove" (for removing
     * ID attributes), "keep" (to keep them). Defaults to "keep"
     */
    idAttribMode: null,

    /**
     * @cfg {Function} beautifier
     * A function that is called on every node. This function may add whitespace to
     * "beautify" the generated HTML. The function gets the edit context, the DOM object and
     * a flag that determines if the function is called before (true) or after (false)
     * processing the DOM object. The function may return "null" (= do nothing) or some
     * text to be added. The text to be added must be specified as an Object with
     * properties "before" and "after", defining the text to be inserted before/after
     * the opening resp. closing tag.
     */
    beautifier: null,

    /**
     * @cfg {Boolean} convertToHTMLEntities
     * If set to true, this will trigger encoding of special characters into html entities
     * as provided in htmlEntitiesConversionMap.
     */
    convertToHTMLEntities: false,

    /**
     * Map containing mapping from special character's unicode value to the corresponding html
     * entities. Eg. For registered trademark character the map could be like:
     * {
     *     '\u00ae' : '&reg;'
     * }
     */
    htmlEntitiesConversionMap: null,

    construct: function (config) {
      this._init(config);
    },

    _init: function (config) {
      config = config || {};
      CUI.rte.Utils.applyDefaults(config, {
        'nonClosingTags': CUI.rte.HtmlSerializer.NON_CLOSING_TAGS,
        'tagCase': 'lower',
        'attribNameCase': 'lower',
        'styleAttribNameCase': 'lower',
        'idAttribMode': 'keep',
        'beautifier': CUI.rte.HtmlSerializer.defaultBeautifier,
        'convertToHTMLEntities' : false,
        'htmlEntitiesConversionMap' : CUI.rte.HtmlSerializer.HTML_ENTITIES_MAP
      });
      CUI.rte.Utils.apply(this, config);
    },

    /**
     * <p>Browser-independent way to get attribute values.</p>
     * <p>Contrary to {@link CUI.rte.Common#getAttribute}, this method does not do
     * any attribute-name translations, but works around an IE bug with cloned nodes (some
     * attributes are returned as 0 if accessed regularily) that the former method doesn't
     * work around.</p>
     * @param {HTMLElement} dom The DOM element to get the attribute value from
     * @param {String} attribName The attribute's name
     * @return {String} The attribute's value
     */
    getAttribValue: function (dom, attribName) {
      var com = CUI.rte.Common;
      // IE <= 7 handles named anchors differently; see bug #36231
      if (com.ua.isIE6 || com.ua.isIE7) {
        var nameLC = attribName.toLowerCase();
        if (CUI.rte.Common.isTag(dom, 'a') && (nameLC === 'name')) {
          return dom.attributes['name'].nodeValue;
        }
      }
      return com.ua.isOldIE ? dom.getAttribute(attribName, 2) : dom.getAttribute(attribName);
    },

    /**
     * Helper that determines if an attribute has actually to be serialized according to
     * the serializer's settings.
     * @param {Attr} attrib The attribute to check
     * @return {Boolean} True if the attribute must not be serialized
     */
    ignoreAttribute: function (attrib) {
      var com = CUI.rte.Common;
      var attrName = attrib.nodeName.toLowerCase();
      if ((attrName === 'id') && (this.idAttribMode === 'remove')) {
        return true;
      }
      return com.arrayContains(CUI.rte.HtmlSerializer.HELPER_ATTRIBUTES, attrName);
    },

    /**
     * Adjusts the case of the specified string.
     * @private
     */
    adjustCase: function (str, strCase) {
      switch (strCase) {
      case 'upper':
        str = str.toUpperCase();
        break;
      case 'lower':
        str = str.toLowerCase();
        break;
      }
      return str;
    },

    /**
     * Creates the tag name string for the specified DOM element.
     * @param {HTMLElement} dom The DOM element to create the tag name for
     * @return {String} The tag name ("img", "IMG", "a", "table", ...)
     */
    createTagStr: function (dom) {
      return this.adjustCase(dom.tagName, this.tagCase);
    },

    /**
     * Serializes the specified attribute of the specified DOM element.
     * @param {String} name The name of the attribute to serialize
     * @param {String} value The value of the attribute to serialize
     */
    serializeAttribute: function (name, value) {
      name = this.adjustCase(name, this.attribNameCase);
      var nameLC = name.toLowerCase();
      if ((nameLC === 'style') && (this.styleAttribNameCase !== 'keep')) {
        var styleDef = CUI.rte.HtmlProcessor.parseStyleDef(value);
        value = '';
        for (var styleName in styleDef) {
          if (styleDef.hasOwnProperty(styleName)) {
            var styleValue = styleDef[styleName];
            // IE 9 may report empty style parts; ignore them
            if (styleValue && (styleValue.length > 0)) {
              if (value.length > 0) {
                value += ' ';
              }
              styleName = this.adjustCase(styleName, this.styleAttribNameCase);
              value += styleName + ': ' + styleValue + ';';
            }
          }
        }
      }
      // don't write empty attributes, they don't make sense at all ...
      if ((value === null || value === undefined) || (value.length === 0)) {
        return '';
      }
      // ignore colspan/rowspan of "1"
      if ((nameLC === 'colspan') || (nameLC === 'rowspan')) {
        if (parseInt(value, 10) === 1) {
          return '';
        }
      }
      return name + '=\"' + CUI.rte.Utils.htmlEncode(value) + '\"';
    },

    /**
     * Serializes the attributes of the specified DOM element.
     * @param {HTMLElement} dom The DOM element
     */
    serializeAttributes: function (dom) {
      var com = CUI.rte.Common;
      var attribFilter = (com.ua.isGecko ? com.FILTER_GECKO_TEMPORARY_ATTRIBS : null);
      var attributeNames = com.getAttributeNames(dom, true, attribFilter);
      var attribCnt = attributeNames.length;
      var attribsStr = '';
      var isFirstAttrib = true;
      for (var a = 0; a < attribCnt; a++) {
        var attrib = dom.attributes.getNamedItem(attributeNames[a]);
        if (!this.ignoreAttribute(attrib)) {
          var attrName = attrib.nodeName;
          var attrNameLC = attrName.toLowerCase();
          // IE bugs around, at least if DOM is cloned, so again use a special
          // treatment
          var attrValue = this.getAttribValue(dom, attrName);
          if (!attrValue) {
            if (attrNameLC === 'style') {
              attrValue = dom.style.cssText;
            } else if (attrNameLC === 'class') {
              attrValue = dom.className;
            }
          }
          // handle helper attributes
          var tagNameLC = dom.tagName.toLowerCase();
          var attribMapping = CUI.rte.HtmlSerializer.HELPER_ATTRIB_MAPPINGS[
            tagNameLC];
          if (attribMapping) {
            for (var m = 0; m < attribMapping.length; m += 2) {
              var srcAttrib = attribMapping[m];
              if (attrNameLC === srcAttrib) {
                attrValue = this.getAttribValue(dom, attribMapping[m + 1]);
                break;
              }
            }
          }
          // at last, do the actual serializing
          var serializedAttrib = this.serializeAttribute(attrName, attrValue);
          if (serializedAttrib.length > 0) {
            if (!isFirstAttrib) {
              attribsStr += ' ';
            } else {
              isFirstAttrib = false;
            }
            attribsStr += serializedAttrib;
          }
        }
      }
      return attribsStr;
    },

    /**
     * Serializes the specified text node.
     * @param {HTMLElement} dom The text node to be serialized (must be a text node!)
     * @return {String} The serialized representation of the text node
     */
    serializeTextNode: function (dom) {
      var markup = CUI.rte.Utils.htmlEncode(dom.nodeValue);
      var conversionMap = this.htmlEntitiesConversionMap;
      if (this.convertToHTMLEntities) {
        for (var key in conversionMap) {
          if (conversionMap.hasOwnProperty(key)) {
            var reg = new RegExp(key, 'g');
            markup = markup.replace(reg, conversionMap[key]);
          }
        }
      }
      return markup.replace(/\u00A0/g, '&nbsp;');
    },

    /**
     * Serializes the specified comment node.
     * @param {HTMLElement} dom The comment node to be serialized (must be a comment node!)
     * @return {String} The serialized representation of the comment node
     */
    serializeCommentNode: function(dom) {
      // comments need not to be escaped, see:
      // https://www.w3.org/TR/html-markup/syntax.html#syntax-text
      return '<!--' + dom.nodeValue + '-->';
    },

    /**
     * Serializes the specified DOM node on "entering" the node (= before
     * processing/serializing child nodes).
     * @param {HTMLElement} dom DOM node to serialize
     * @return {String} The serialized representation of the DOM node
     */
    serializeNodeEnter: function (dom) {
      var com = CUI.rte.Common;
      if (dom.nodeType === 3) {
        return this.serializeTextNode(dom);
      }
      if (dom.nodeType === 8) {
        return this.serializeCommentNode(dom);
      }
      var html = '<' + this.createTagStr(dom);
      var attribsStr = this.serializeAttributes(dom);
      if (attribsStr.length > 0) {
        html += ' ' + attribsStr;
      }
      html += '>';
      // insert an additional linebreak after opening "pre" tags
      if (com.isTag(dom, 'pre')) {
        html += '\n';
      }
      // add &nbsp; to empty editing blocks
      if (com.isEmptyEditingBlock(dom, true)) {
        this.deepestChildAddHtml = '&nbsp;';
      }
      if (this.deepestChildAddHtml !== null && this.deepestChildAddHtml !== undefined) {
        if (dom.childNodes.length === 0) {
          html += this.deepestChildAddHtml;
          this.deepestChildAddHtml = null;
        }
      }
      return html;
    },

    /**
     * Serializes the specified DOM node on "leaving" the node (= after
     * processing/serializing child nodes).
     * @param {HTMLElement} dom DOM node to serialize
     * @return {String} The serialized representation of the DOM node
     */
    serializeNodeLeave: function (dom) {
      if (dom.nodeType === 3 || (dom.nodeType === 8)) {
        return '';
      }
      var com = CUI.rte.Common;
      var html = '';
      if (!com.isTag(dom, this.nonClosingTags)) {
        html = '</' + this.createTagStr(dom) + '>';
        if (com.isTag(dom, 'pre')) {
          html = '\n' + html;
        }
      }
      return html;
    },

    /**
     * Serializes the specified subtree, including the specified subtree root.
     * @param {HTMLElement} dom The subtree root
     * @return {String} The serialized representation of the specified subtree
     */
    serializeSubTree: function (dom) {
      var preHtml = this.beautifier(this.context, dom, true);
      var html = '';
      var nodeHtml = this.serializeNodeEnter(dom);
      if (preHtml) {
        if (preHtml.before) {
          html = preHtml.before;
        }
        html += nodeHtml;
        if (preHtml.after) {
          html += preHtml.after;
        }
      }
      else {
        html = nodeHtml;
      }
      var childCnt = dom.childNodes.length;
      for (var c = 0; c < childCnt; c++) {
        html += this.serializeSubTree(dom.childNodes[c]);
      }
      nodeHtml = this.serializeNodeLeave(dom);
      var postHtml = this.beautifier(this.context, dom, false);
      if (postHtml) {
        if (postHtml.before) {
          html += postHtml.before;
        }
        html += nodeHtml;
        if (postHtml.after) {
          html += postHtml.after;
        }
      } else {
        html += nodeHtml;
      }
      return html;
    },

    /**
     * <p>Serializes the specified DOM (sub-) tree.</p>
     * <p>Note that the specified DOM element itself doesn't get serialized.</p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} dom The DOM (sub-) tree to serialize
     * @return {String} The serialized representation of the DOM (sub-) tree
     */
    serialize: function (context, dom) {
      this.context = context;
      this.deepestChildAddHtml = null;
      var html = '';
      var childCnt = dom.childNodes.length;
      for (var c = 0; c < childCnt; c++) {
        html += this.serializeSubTree(dom.childNodes[c]);
      }
      return html;
    }

  });

  /**
   * Array containing (default) tags that should not have a closing tag in HTML
   * @type String[]
   * @private
   */
  CUI.rte.HtmlSerializer.NON_CLOSING_TAGS = ['br', 'hr', 'img', 'area', 'input', 'col'];

  /**
   * Array that defines helper attributes that will not be serialized
   * @type String[]
   * @private
   */
  CUI.rte.HtmlSerializer.HELPER_ATTRIBUTES = [
    CUI.rte.Common.HREF_ATTRIB,
    CUI.rte.Common.SRC_ATTRIB
  ];

  /**
   * Object that defines the mapping of helper attributes
   * @type Object
   * @private
   */
  CUI.rte.HtmlSerializer.HELPER_ATTRIB_MAPPINGS = {
    'a': ['href', CUI.rte.Common.HREF_ATTRIB],
    'img': ['src', CUI.rte.Common.SRC_ATTRIB]
  };

  CUI.rte.HtmlSerializer.defaultBeautifier = function (context, dom, isNodeEnter) {
    var com = CUI.rte.Common;
    if (com.isTag(dom, com.BLOCK_TAGS)) {
      if (isNodeEnter) {
        if (!com.isTag(dom, com.EDITBLOCK_TAGS)) {
          return {
            'before': null,
            'after': '\n'
          };
        }
      } else {
        return {
          'before': null,
          'after': '\n'
        };
      }
      return null;
    }
    if (com.isTag(dom, com.EDITBLOCK_TAGS)) {
      if (!isNodeEnter) {
        return {
          'before': null,
          'after': '\n'
        };
      }
      return null;
    }
    if (com.isTag(dom, 'br')) {
      if (!isNodeEnter) {
        // don't add \n if we have a Gecko/WebKit empty line placeholder
        if (!com.ua.isIE) {
          var editBlock = com.getTagInPath(context, dom, com.EDITBLOCK_TAGS);
          if (editBlock) {
            var contentNodes = com.getCharacterNodes(editBlock);
            if (contentNodes.length === 1) {
              return null;
            }
          }
        }
        return {
          'before': null,
          'after': '\n'
        };
      }
    }
    return null;
  };

  CUI.rte.HtmlSerializer.HTML_ENTITIES_MAP = {
    '\u00ad': '&shy;',
    '\u00a1': '&iexcl;',
    '\u00a2': '&cent;',
    '\u00a3': '&pound;',
    '\u00a4': '&curren;',
    '\u00a5': '&yen;',
    '\u00a6': '&brvbar;',
    '\u00a7': '&sect;',
    '\u00a8': '&uml;',
    '\u00a9': '&copy;',
    '\u00aa': '&ordf;',
    '\u00ab': '&laquo;',
    '\u00ac': '&not;',
    '\u00ae': '&reg;',
    '\u00af': '&macr;',
    '\u00b0': '&deg;',
    '\u00b1': '&plusmn;',
    '\u00b2': '&sup2;',
    '\u00b3': '&sup3;',
    '\u00b4': '&acute;',
    '\u00b5': '&micro;',
    '\u00b6': '&para;',
    '\u00b7': '&middot;',
    '\u00b8': '&cedil;',
    '\u00b9': '&sup1;',
    '\u00ba': '&ordm;',
    '\u00bb': '&raquo;',
    '\u00bc': '&frac14;',
    '\u00bd': '&frac12;',
    '\u00be': '&frac34;',
    '\u00bf': '&iquest;',
    '\u00d7': '&times;',
    '\u00f7': '&divide;',
    '\u0192': '&fnof;',
    '\u2022': '&bull;',
    '\u2026': '&hellip;',
    '\u2032': '&prime;',
    '\u2033': '&Prime;',
    '\u203e': '&oline;',
    '\u2044': '&frasl;',
    '\u2118': '&weierp;',
    '\u2111': '&image;',
    '\u211c': '&real;',
    '\u2122': '&trade;',
    '\u2135': '&alefsym;',
    '\u2190': '&larr;',
    '\u2191': '&uarr;',
    '\u2192': '&rarr;',
    '\u2193': '&darr;',
    '\u2194': '&harr;',
    '\u21b5': '&crarr;',
    '\u21d0': '&lArr;',
    '\u21d1': '&uArr;',
    '\u21d2': '&rArr;',
    '\u21d3': '&dArr;',
    '\u21d4': '&hArr;',
    '\u2200': '&forall;',
    '\u2202': '&part;',
    '\u2203': '&exist;',
    '\u2205': '&empty;',
    '\u2207': '&nabla;',
    '\u2208': '&isin;',
    '\u2209': '&notin;',
    '\u220b': '&ni;',
    '\u220f': '&prod;',
    '\u2211': '&sum;',
    '\u2212': '&minus;',
    '\u2217': '&lowast;',
    '\u221a': '&radic;',
    '\u221d': '&prop;',
    '\u221e': '&infin;',
    '\u2220': '&ang;',
    '\u2227': '&and;',
    '\u2228': '&or;',
    '\u2229': '&cap;',
    '\u222a': '&cup;',
    '\u222b': '&int;',
    '\u2234': '&there4;',
    '\u223c': '&sim;',
    '\u2245': '&cong;',
    '\u2248': '&asymp;',
    '\u2260': '&ne;',
    '\u2261': '&equiv;',
    '\u2264': '&le;',
    '\u2265': '&ge;',
    '\u2282': '&sub;',
    '\u2283': '&sup;',
    '\u2284': '&nsub;',
    '\u2286': '&sube;',
    '\u2287': '&supe;',
    '\u2295': '&oplus;',
    '\u2297': '&otimes;',
    '\u22a5': '&perp;',
    '\u22c5': '&sdot;',
    '\u2308': '&lceil;',
    '\u2309': '&rceil;',
    '\u230a': '&lfloor;',
    '\u230b': '&rfloor;',
    '\u27e8': '&lang;',
    '\u27e9': '&rang;',
    '\u25ca': '&loz;',
    '\u2660': '&spades;',
    '\u2663': '&clubs;',
    '\u2665': '&hearts;',
    '\u2666': '&diams;',
    '\u02c6': '&circ;',
    '\u02dc': '&tilde;',
    '\u2002': '&ensp;',
    '\u2003': '&emsp;',
    '\u2009': '&thinsp;',
    '\u200c': '&zwnj;',
    '\u200d': '&zwj;',
    '\u200e': '&lrm;',
    '\u200f': '&rlm;',
    '\u2013': '&ndash;',
    '\u2014': '&mdash;',
    '\u2018': '&lsquo;',
    '\u2019': '&rsquo;',
    '\u201a': '&sbquo;',
    '\u201c': '&ldquo;',
    '\u201d': '&rdquo;',
    '\u201e': '&bdquo;',
    '\u2020': '&dagger;',
    '\u2021': '&Dagger;',
    '\u2030': '&permil;',
    '\u2039': '&lsaquo;',
    '\u203a': '&rsaquo;',
    '\u20ac': '&euro;',
    '\u00c0': '&Agrave;',
    '\u00c1': '&Aacute;',
    '\u00c2': '&Acirc;',
    '\u00c3': '&Atilde;',
    '\u00c4': '&Auml;',
    '\u00c5': '&Aring;',
    '\u00c6': '&AElig;',
    '\u00c7': '&Ccedil;',
    '\u00c8': '&Egrave;',
    '\u00c9': '&Eacute;',
    '\u00ca': '&Ecirc;',
    '\u00cb': '&Euml;',
    '\u00cc': '&Igrave;',
    '\u00cd': '&Iacute;',
    '\u00ce': '&Icirc;',
    '\u00cf': '&Iuml;',
    '\u00d0': '&ETH;',
    '\u00d1': '&Ntilde;',
    '\u00d2': '&Ograve;',
    '\u00d3': '&Oacute;',
    '\u00d4': '&Ocirc;',
    '\u00d5': '&Otilde;',
    '\u00d6': '&Ouml;',
    '\u00d8': '&Oslash;',
    '\u00d9': '&Ugrave;',
    '\u00da': '&Uacute;',
    '\u00db': '&Ucirc;',
    '\u00dc': '&Uuml;',
    '\u00dd': '&Yacute;',
    '\u00de': '&THORN;',
    '\u00df': '&szlig;',
    '\u00e0': '&agrave;',
    '\u00e1': '&aacute;',
    '\u00e2': '&acirc;',
    '\u00e3': '&atilde;',
    '\u00e4': '&auml;',
    '\u00e5': '&aring;',
    '\u00e6': '&aelig;',
    '\u00e7': '&ccedil;',
    '\u00e8': '&egrave;',
    '\u00e9': '&eacute;',
    '\u00ea': '&ecirc;',
    '\u00eb': '&euml;',
    '\u00ec': '&igrave;',
    '\u00ed': '&iacute;',
    '\u00ee': '&icirc;',
    '\u00ef': '&iuml;',
    '\u00f0': '&eth;',
    '\u00f1': '&ntilde;',
    '\u00f2': '&ograve;',
    '\u00f3': '&oacute;',
    '\u00f4': '&ocirc;',
    '\u00f5': '&otilde;',
    '\u00f6': '&ouml;',
    '\u00f8': '&oslash;',
    '\u00f9': '&ugrave;',
    '\u00fa': '&uacute;',
    '\u00fb': '&ucirc;',
    '\u00fc': '&uuml;',
    '\u00fd': '&yacute;',
    '\u00fe': '&thorn;',
    '\u00ff': '&yuml;',
    '\u0152': '&OElig;',
    '\u0153': '&oelig;',
    '\u0160': '&Scaron;',
    '\u0161': '&scaron;',
    '\u0178': '&Yuml;',
    '\u0391': '&Alpha;',
    '\u0392': '&Beta;',
    '\u0393': '&Gamma;',
    '\u0394': '&Delta;',
    '\u0395': '&Epsilon;',
    '\u0396': '&Zeta;',
    '\u0397': '&Eta;',
    '\u0398': '&Theta;',
    '\u0399': '&Iota;',
    '\u039a': '&Kappa;',
    '\u039b': '&Lambda;',
    '\u039c': '&Mu;',
    '\u039d': '&Nu;',
    '\u039e': '&Xi;',
    '\u039f': '&Omicron;',
    '\u03a0': '&Pi;',
    '\u03a1': '&Rho;',
    '\u03a3': '&Sigma;',
    '\u03a4': '&Tau;',
    '\u03a5': '&Upsilon;',
    '\u03a6': '&Phi;',
    '\u03a7': '&Chi;',
    '\u03a8': '&Psi;',
    '\u03a9': '&Omega;',
    '\u03b1': '&alpha;',
    '\u03b2': '&beta;',
    '\u03b3': '&gamma;',
    '\u03b4': '&delta;',
    '\u03b5': '&epsilon;',
    '\u03b6': '&zeta;',
    '\u03b7': '&eta;',
    '\u03b8': '&theta;',
    '\u03b9': '&iota;',
    '\u03ba': '&kappa;',
    '\u03bb': '&lambda;',
    '\u03bc': '&mu;',
    '\u03bd': '&nu;',
    '\u03be': '&xi;',
    '\u03bf': '&omicron;',
    '\u03c0': '&pi;',
    '\u03c1': '&rho;',
    '\u03c2': '&sigmaf;',
    '\u03c3': '&sigma;',
    '\u03c4': '&tau;',
    '\u03c5': '&upsilon;',
    '\u03c6': '&phi;',
    '\u03c7': '&chi;',
    '\u03c8': '&psi;',
    '\u03c9': '&omega;',
    '\u03d1': '&thetasym;',
    '\u03d2': '&upsih;',
    '\u03d6': '&piv;',
    '\u0027': '&#39;'
  };

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.XhtmlSerializer
 * @extends CUI.rte.HtmlSerializer
 * The XhtmlSerializer is used to serialize a DOM (sub-) tree to its XHTML (String)
 * equivalent.
 * @constructor
 * Creates a new XHtmlSerializer.
 * @param {Object} config The configuration object
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.XhtmlSerializer = new Class({

    toString: 'XhtmlSerializer',

    extend: CUI.rte.HtmlSerializer,

    /**
     * @cfg {String[]} nonClosingTags
     * @hide
     * Must be set to [ ] for XHTML conformity
     */

    /**
     * @cfg {String} tagCase
     * @hide
     * Must be set to "lower" for XHTML conformity
     */

    /**
     * @cfg {String} attribNameCase
     * @hide
     * Must be set to "lower" for XHTML conformity
     */

    /**
     * @cfg {Boolean} useShortTags
     * Determines if "short tags" (i.e. &lt;br /&gt; should be used for empty elements;
     * defaults to false
     */
    useShortTags: false,


    _init: function (config) {
      config = config || {};
      delete config.tagCase;
      delete config.attribNameCase;
      delete config.nonClosingTags;
      CUI.rte.Utils.applyDefaults(config, {
        'tagCase': 'lower',
        'attribNameCase': 'lower',
        'useShortTags': false,
        'nonClosingTags': []
      });
      this.inherited(arguments);
    },

    isShortTag: function (dom) {
      var com = CUI.rte.Common;
      if (com.isTag(dom, 'a') && com.isAttribDefined(dom, 'name')) {
        return false;
      }
      return (dom.childNodes.length === 0);
    },

    serializeNodeEnter: function (dom) {
      var com = CUI.rte.Common;
      if (dom.nodeType === 1) {
        if (this.useShortTags && this.isShortTag(dom)) {
          // Handle short tags that are either void or foreign elements here. If the empty
          // node is none of those, the superclass will convert it to (for example)
          // <p>&nbsp;</p> instead of the (invalid) <p />.
          var domNamespace = com.getNamespace(dom);
          if (com.isTag(dom, com.VOID_TAGS) || domNamespace === 'math' || domNamespace === 'svg') {
            var html = '<' + this.createTagStr(dom);
            var attribsStr = this.serializeAttributes(dom);
            if (attribsStr.length > 0) {
              html += ' ' + attribsStr;
            }
            if (this.deepestChildAddHtml !== null && this.deepestChildAddHtml !== undefined) {
              html += '>' + this.deepestChildAddHtml;
              html += '</' + this.createTagStr(dom) + '>';
            } else {
              html += ' />';
            }
            return html;
          }
        }
      }
      return this.inherited(arguments);
    },

    serializeNodeLeave: function (dom) {
      var com = CUI.rte.Common;
      if (dom.nodeType === 1) {
        var domNamespace = com.getNamespace(dom);
        if (com.isTag(dom, com.VOID_TAGS) || domNamespace === 'math' || domNamespace === 'svg') {
          if (this.useShortTags && this.isShortTag(dom)) {
            return '';
          }
        }
      }
      return this.inherited(arguments);
    }

  });

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.Deserializer
 * <p>The Serializer class works as an "interface" for providing fully customized HTML
 * deserializers.</p>
 * <p>Deserializers are used to convert persisted HTML into a suitable DOM tree before
 * they are being edited.</p>
 * <p>You should only consider implementing this interface directly if you have very special
 * requirements. Usually, it should make more sense to extend one of the default
 * serializers, {@link CUI.rte.HtmlDeserializer} or
 * {@link CUI.rte.XhtmlDeserializer}.</p>
 * <p>Deserializers should usually do the following cleanup/adjustments:</p>
 * <ul>
 *   <li>Correct the incoming (X)HTML to be browser-compatible. For example, IE chokes if
 *     XHTML is directly set to the DOM.</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.Deserializer = new Class({

    toString: 'Deserializer',

    /**
     * <p>Deserializes the specified HTML to the sppecified DOM root element.</p>
     * <p>Note that the specified DOM element itself is kept as is.</p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {String} html The HTML to be deserialized
     * @param {HTMLElement} rootDom The DOM (sub-) tree to deserialize the HTML to
     */
    deserialize: function (context, html, rootDom) {
      // must be overridden by the implementing class
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.HtmlDeserializer
 * @extends CUI.rte.Deserializer
 * The HtmlDeserializer is used to deserialize HTML code to a suitable DOM tree.
 * @constructor
 * Creates a new HtmlDeserializer.
 * @param {Object} config The configuration object
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.HtmlDeserializer = new Class({

    toString: 'HtmlDeserializer',

    extend: CUI.rte.Deserializer,

    construct: function (config) {
      this._init(config);
    },

    _init: function () {
      // may be overridden
    },

    /**
     * <p>Duplicates references to temporary attributes that are safe from being
     * changed deliberately by the browser.</p>
     * <p>For example, &lt;a href="/content/bla/en/blubb.html"&gt; is changed into
     * &lt;a href="/content/bla/en/blubb.html" _rte_href="/content/bla/en/blubb.html"&gt;.
     * </p>
     * @param {String} html The HTML code to process
     * @return {String} The processed HTML code
     */
    duplicateReferences: function (html) {
      var rules = CUI.rte.HtmlDeserializer.DUPLICATE_RULES;
      var ruleCnt = rules.length;
      for (var r = 0; r < ruleCnt; r++) {
        var rule = rules[r];
        html = html.replace(rule[0], rule[1]);
      }
      return html;
    },

    /**
     * Deserializes the specified HTML code to the specified DOM element.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {String} html The HTML to be deserialized
     * @param {HTMLElement} rootDom The DOM (sub-) tree to deserialize the HTML to
     */
    deserialize: function (context, html, rootDom) {
      html = this.duplicateReferences(html);
      rootDom.innerHTML = html;
    }

  });

  /**
   * Array that defines the rules required for duplicating references to temporary attributes
   * that are safe from being changed deliberately by the browser. Each element consists of
   * two sub-elements. The first contains the regular expression used to match tags that
   * require attribute duplication; the second element contains the replacement string that
   * does the actual duplication .
   * @type Object[][]
   * @private
   */
  CUI.rte.HtmlDeserializer.DUPLICATE_RULES = [[
    /(<a[^>]*?href=")([^"]*?)(")((.|\n|\r)*?>)/gi,
    '$1$2$3 ' + CUI.rte.Common.HREF_ATTRIB + '=\"$2\"$4'
  ], [
    /(<a[^>]*?href=')([^']*?)(')((.|\n|\r)*?>)/gi,
    '$1$2$3 ' + CUI.rte.Common.HREF_ATTRIB + '=\"$2\"$4'
  ], [
    /(<img[^>]*?src=")([^"]*?)(")((.|\n|\r)*?>)/gi,
    '$1$2$3 ' + CUI.rte.Common.SRC_ATTRIB + '=\"$2\"$4'
  ]
  ];

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.XhtmlDeserializer
 * @extends CUI.rte.HtmlDeserializer
 * The HtmlDeserializer is used to deserialize XHTML code to a suitable DOM tree.
 * @constructor
 * Creates a new XhtmlDeserializer.
 * @param {Object} config The configuration object
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.XhtmlDeserializer = new Class({

    toString: 'XhtmlDeserializer',

    extend: CUI.rte.HtmlDeserializer,

    _init: function () {
      this.inherited(arguments);
      // build Regex to remove unnecessary/harmful closing tags
      var nct = CUI.rte.HtmlSerializer.NON_CLOSING_TAGS;
      var regExpStr = '<\\/(';
      for (var n = 0; n < nct.length; n++) {
        if (n > 0) {
          regExpStr += '|';
        }
        regExpStr += nct[n];
      }
      regExpStr += ')>';
      this.regExp = new RegExp(regExpStr, 'gi');
    },

    /**
     * Expands XHTML "short tags", as they confuse Internet Explorer.
     * @param {String} xhtml The XHTML to expand
     * @return {String} The expanded XHTML
     */
    expandShortTags: function (xhtml) {
      var xds = CUI.rte.XhtmlDeserializer;
      var expanded = xhtml.replace(xds.EXPAND_SHORT_XHTML,
        xds.XHTML_EXPANSION_REPLACEMENT);
      return expanded.replace(this.regExp, '');
    },

    /**
     * Deserializes the specified XHTML-compliant HTML code to the specified DOM element.
     * </p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {String} xhtml The HTML to be deserialized
     * @param {HTMLElement} rootDom The DOM (sub-) tree to deserialize the HTML to
     */
    deserialize: function (context, xhtml, rootDom) {
      // preprocess short tags
      xhtml = this.expandShortTags(xhtml);
      xhtml = this.duplicateReferences(xhtml);
      rootDom.innerHTML = xhtml;
    }

  });

  /**
   * Regular expression that is used to expand XHTML short tags
   * (&lt;a name="xyz"/&gt; -&gt; &lt;a name="xyz&gt;&lt;/a&gt;
   */
  CUI.rte.XhtmlDeserializer.EXPAND_SHORT_XHTML = /<([^\/][^\n\r\t >]*)([^>]*)(\/>)/gi;

  /**
   * Replacement pattern that is used to expand XHTML short tags
   */
  CUI.rte.XhtmlDeserializer.XHTML_EXPANSION_REPLACEMENT = '<$1$2></$1>';

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.DomCleanup
 * This class implements a DOM-based cleanup module to ensure that the input can be
 * processed and the output is suitable for persisting it (the actual HTML is generated by
 * the component's {@link CUI.rte.HtmlSerializer}, which applies additional rules to
 * cleanup the generated HTML).
 * @constructor
 * Creates a new DomCleanup.
 * @param {Object} config The kernel's configuration
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.DomCleanup = new Class({

    toString: 'DomCleanup',

    /**
     * @cfg {String[]} tagsToRemove
     * List of tags to be removed
     */
    tagsToRemove: null,

    /**
     * Rules for preprocessing pasted content. Only valid if {@link #prepareHtmlPaste} is
     * used. Format is defined at {@link CUI.rte.plugins.EditToolsPlugin#htmlPasteRules}
     * @private
     * @type Object
     */
    pasteRules: null,

    /**
     * The editor kernel we're working on
     * @private
     * @type CUI.rte.EditorKernel
     */
    editorKernel: null,

    /**
     * The edit context we're working in
     * @private
     * @type CUI.rte.EditContext
     */
    context: null,

    /**
     * The current HTML rules
     * @private
     * @type CUI.rte.HtmlRules
     */
    htmlRules: null,

    /**
     * Processing mode; as defined by the constants of this class.
     * @private
     * @type Number
     */
    processingMode: null,

    /**
     * Array of DOM elements to be removed after traversing the DOM tree
     * @private
     * @type HTMLElement[]
     */
    elementsToRemove: null,

    /**
     * Array of sub tree roots to be removed
     * @private
     * @type HTMLElement[]
     */
    subTreesToRemove: null,

    /**
     * Array of DOM elements to be changed after traversing the DOM tree. Each array
     * element has a domToChange property that determines the element to be changed, and
     * a changedDom property that defines the changed element.
     * @private
     * @type Object[]
     */
    elementsToChange: null,

    /**
     * Array of DOM elements to be inserted after traversing the DOM tree. Each array
     * element has a domToInsert property that determines the element to be inserted, a
     * parentDom property that defines the parent element it gets appended to, and an
     * (optional) refDom property that determines the sibling element the new element gets
     * inserted before
     */
    elementsToInsert: null,

    /**
     * Array of empty editing blocks that have to be "fixed for editing" on IE
     */
    emptyBlocksIE: null,


    construct: function (config) {
      CUI.rte.Utils.apply(this, config);
    },


    // -- Helpers --------------------------------------------------------------------------

    /**
     * <p>Marks the specified DOM element for being removed.</p>
     * <p>Using this method prevents that the same DOM element is added multiple times
     * to the list of elements to be removed.</p>
     * @param {HTMLElement} dom The DOM element to be removed
     */
    markForRemoval: function (dom) {
      if (!CUI.rte.Common.arrayContains(this.elementsToRemove, dom)) {
        this.elementsToRemove.push(dom);
      }
    },

    /**
     * Marks the sub tree that starts at the specified DOM element for being deleted. The
     * specified element will get deleted as well.
     * @param {HTMLElement} root The root element of the sub tree to be marked for removal
     */
    markSubTreeForRemoval: function (root) {
      this.subTreesToRemove.push(root);
    },

    /**
     * Marks the specified DOM element for be inserted according the specified rules.
     * @param {HTMLElement} dom The element to be inserted
     * @param {HTMLElement} parentDom The parent element
     * @param {HTMLElement} siblingRef (optional) The element the new element is inserted
     *        before; if not specified, the DOM element will be appended
     */
    markForInsertion: function (dom, parentDom, siblingRef) {
      this.elementsToInsert.push({
        'domToInsert': dom,
        'parentDom': parentDom,
        'refDom': siblingRef
      });
    },

    /**
     * <p>Checks if we are doing any preprocessing.</p>
     * <p>This method returns true for "default" preprocessing, but also for paste
     * preprocessing.</p>
     * @return {Boolean} True if any kind of preprocessing is currently executed
     */
    isPreProcessing: function () {
      var dcu = CUI.rte.DomCleanup;
      return (this.processingMode === dcu.PASTE_PREPARE) || (this.processingMode === dcu.PRE);
    },

    /**
     * Flattens the specified DOM element by creating paragraphs from the specified
     * container structures and removing nested structures of the specified type.
     * @param {HTMLElement} dom The DOM element to be flattened
     * @param {String|String[]} tagsToFlatten Defines the tag or tags that contain content
     *        to be flattened; for example: "li" for list items
     * @param {String|String[]} nestingTags Defines the tag or tags that mark nested
     *        striucture; for example: "table" for nested tables
     * @return {HTMLElement} The first flattened element (changed container element)
     */
    flattenNestedStructure: function (dom, tagsToFlatten, nestingTags) {
      var com = CUI.rte.Common;
      var continueDom = null;
      var parentRef = dom.parentNode;
      var insertRef = dom.nextSibling;
      var replacementTag = this.pasteRules.fallbackBlockTag || 'p';
      var nodesToFlatten = com.getTags(dom, tagsToFlatten);
      var nodeCnt = nodesToFlatten.length;
      for (var n = 0; n < nodeCnt; n++) {
        var domToFlatten = nodesToFlatten[n];
        var flattenedDom = this.context.createElement(replacementTag);
        if (continueDom === null || continueDom === undefined) {
          continueDom = flattenedDom;
        }
        com.insertBefore(parentRef, flattenedDom, insertRef);
        // move children - skip nested containers (nested content elements are already
        // included in nodesToFlatten)
        var children = domToFlatten.childNodes;
        while (children.length > 0) {
          var childToMove = children[0];
          if (!com.isTag(childToMove, nestingTags)) {
            flattenedDom.appendChild(childToMove);
          }
        }
      }
      dom.parentNode.removeChild(dom);
      return continueDom;
    },


    // -- Processing methods ---------------------------------------------------------------

    /**
     * <p>Checks if the specified DOM element marks the root of a valid sub tree in the DOM.
     * </p>
     * <p>If the method returns false, the entire sub tree gets removed, including the
     * specified DOM element.</p>
     * <p>If the method returns false, ancestor elements or sub trees can still be
     * declared invalid.</p>
     * @param {HTMLElement} dom The DOM element to check
     * @return {Boolean} True if the sub tree starting at the specified element is
     *         considered valid
     */
    isValidSubTree: function (dom) {
      var com = CUI.rte.Common;
      var isValid = true;
      // handle temporary elements first
      var tempAttrib = com.getAttribute(dom, com.TEMP_EL_ATTRIB, true);
      if (tempAttrib) {
        var splitAttrib = tempAttrib.split(':');
        var keepChildren = com.arrayContains(splitAttrib, 'keepChildren');
        var emptyOnly = com.arrayContains(splitAttrib, 'emptyOnly');
        if (!keepChildren) {
          if (emptyOnly) {
            // check for emptiness has to be executed recursively
            var checkEmpty = function (dom) {
              if (dom.nodeType === 3) {
                return false;
              }
              var childCnt = dom.childNodes.length;
              if (childCnt === 0) {
                return true;
              }
              for (var c = 0; c < childCnt; c++) {
                var child = dom.childNodes[c];
                var tempAttrib = com.getAttribute(dom, com.TEMP_EL_ATTRIB,
                  true);
                if (!tempAttrib) {
                  return false;
                }
                var splitAttrib = tempAttrib.split(':');
                if (com.arrayContains(splitAttrib, 'emptyOnly')) {
                  if (!checkEmpty(child)) {
                    return false;
                  }
                } else {
                  return false;
                }
              }
              return true;
            };
            if (checkEmpty(dom)) {
              isValid = false;
            } else {
              com.removeAttribute(dom, com.TEMP_EL_ATTRIB);
            }
          } else {
            isValid = false;
          }
        }
      }
      return isValid;
    },

    /**
     * <p>Checks if the specified DOM element is valid according to current rules.</p>
     * <p>Note that - contrary to {@link #isValidSubTree} - this method only removes
     * the specified element (if false is returned) and leaves the ancestor elements intact.
     * </p>
     * @param {HTMLElement} dom The DOM element to check
     * @return {Boolean} True if the DOM element is considered valid
     */
    isValidElement: function (dom) {
      var com = CUI.rte.Common;
      var tagName = dom.tagName.toLowerCase();
      // ignore namespaced tags
      var namespace = com.getNamespace(dom);
      if (namespace !== null && namespace !== undefined) {
        return false;
      }
      // IE issue: orphaned empty tags are not ignored, instead IE creates invalid DOM
      // elements from them, so we need to remove them
      if ((dom.nodeType === 1) && com.strStartsWith(dom.tagName, '/')) {
        return false;
      }
      // ignore blacklisted tags
      if (this.tagsToRemove) {
        if (com.arrayContains(this.tagsToRemove, tagName)) {
          return false;
        }
      }
      // ignore elements with "_rtetemp" attribute
      if (com.isTag(dom, 'span') && com.isAttribDefined(dom, '_rtetemp')) {
        return false;
      }
      // ignore temporary elements that keep child nodes
      var tempAttrib = com.getAttribute(dom, com.TEMP_EL_ATTRIB, true);
      if (tempAttrib) {
        var splitAttrib = tempAttrib.split(':');
        var keepChildren = com.arrayContains(splitAttrib, 'keepChildren');
        if (keepChildren) {
          return false;
        }
      }
      return true;
    },

    /**
     * <p>Change linefeeds in preformatted sections into "br" tags - although this is
     * no correct HTML, browsers tend to be more stable with br tags (and selection handling
     * is much easier) while editing.</p>
     */
    handlePreformattedSection: function (dom) {
      var context = this.context;
      var com = CUI.rte.Common;
      if (this.isPreProcessing()) {
        if (com.isTag(dom, 'pre')) {
          var recurse = function (toProcess) {
            var parentNode = toProcess.parentNode;
            if (toProcess.nodeType === 3) {
              var nodeText = toProcess.nodeValue;
              nodeText = nodeText.replace(/\r\n/g, '\n');
              nodeText = nodeText.replace(/\r/g, '\n');
              var pos;
              do {
                pos = nodeText.indexOf('\n');
                if (pos >= 0) {
                  if (pos > 0) {
                    parentNode.insertBefore(context.createTextNode(
                      nodeText.substring(0, pos)), toProcess);
                  }
                  parentNode.insertBefore(context.createElement('br'),
                    toProcess);
                  nodeText = nodeText.substring(pos + 1, nodeText.length);
                }
              } while (pos >= 0);
              if (nodeText.length === 0) {
                parentNode.removeChild(toProcess);
              } else {
                toProcess.nodeValue = nodeText;
              }
            } else if (toProcess.nodeType === 1) {
              var childCnt = toProcess.childNodes.length;
              for (var c = childCnt - 1; c >= 0; c--) {
                recurse(toProcess.childNodes[c]);
              }
            }
          };
          recurse(dom);
          // remove trailing br (if there is one), as it is implied by the closing
          // pre tag
          var lastTextChild = com.getLastTextChild(dom, true, false);
          if (com.isTag(lastTextChild, 'br')) {
            var predesc = com.getPreviousCharacterNode(context, lastTextChild,
              com.EDITBLOCK_TAGS);
            if (com.isTag(predesc, 'br')) {
              if (com.ua.isGecko || com.ua.isWebKit || com.ua.isIEBRPlaceholder) {
                com.setAttribute(lastTextChild, com.BR_TEMP_ATTRIB, 'brEOB');
              } else if (com.ua.isIE) {
                lastTextChild.parentNode.removeChild(lastTextChild);
                CUI.rte.DomProcessor.fixEmptyLinefeedIE(context, predesc);
              }
            } else {
              lastTextChild.parentNode.removeChild(lastTextChild);
            }
          }
        }
      } else {
        // change "\n"'s into "br"s inside "pre" blocks, as browsers tend to be more
        // stable when linefeeds are still represented as "br" while editing
        // (counterpart is in handlePreformattedSection)
        if (com.isTag(dom, 'br') && com.getTagInPath(this.context, dom, 'pre')) {
          this.elementsToChange.push({
            'domToChange': dom,
            'changedDom': this.context.createTextNode('\n')
          });
        }
      }
    },

    /**
     * <p>Handles empty lines at the end of blocks for the browsers that require it
     * (currently WebKit and Gecko).</p>
     * <p>Additional "br" tags get removed on reverse cleanup again (see isValidElement).
     * </p>
     * @param {HTMLElement} dom The
     */
    handleEmptyLinesAtEOB: function (dom) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var brReplacement;
      if (this.isPreProcessing()) {
        var text = com.getNodeText(dom);
        if ((text === dpr.NBSP) && dpr.isBlockEnd(this.context, dom)) {
          if (com.ua.isWebKit || com.ua.isGecko || com.ua.isIEBRPlaceholder) {
            // Gecko/WebKit: replace &nbsp;s that are placeholders for empty lines
            // at the end of a block by appropriately marked additional <br>s
            brReplacement = this.context.createElement('br');
            com.setAttribute(brReplacement, com.BR_TEMP_ATTRIB, 'brEOB');
            this.elementsToChange.push({
              'domToChange': dom,
              'changedDom': brReplacement
            });
          } else if (com.ua.isIE) {
            // IE: remove &nbsp;s that are placeholders for empty blocks
            var prevNode = com.getPreviousCharacterNode(this.context, dom,
              com.EDITBLOCK_TAGS);
            if (com.isTag(prevNode, 'br')) {
              // placeholder for empty line at the end of an empty block
              this.markForRemoval(dom);
              dpr.fixEmptyLinefeedIE(this.context, prevNode);
            } else if (!prevNode) {
              this.markForRemoval(dom);
              var block = dpr.getEditBlock(this.context, dom);
              this.emptyBlocksIE.push(block);
            }
          }
        }
      } else {
        if (com.ua.isGecko || com.ua.isWebKit || com.ua.isIEBRPlaceholder) {
          // Gecko/Webkit: Remove unnecessary <br> nodes; replace them by &nbsp;s
          // if they are placeholders for empty lines at the end of a block;
          // "br"s in "pre" areas are handled in handlePreformattedSection()
          if (com.isTag(dom, 'br') && !com.getTagInPath(this.context, dom, 'pre')) {
            var editBlock = com.getTagInPath(this.context, dom, com.EDITBLOCK_TAGS);
            var isEmptyBlock =
              editBlock && (com.getCharacterNodes(editBlock).length === 1);
            if (isEmptyBlock) {
              this.markForRemoval(dom);
            } else {
              var isMarkedDirty = com.isAttribDefined(dom, com.BR_TEMP_ATTRIB) ||
                com.hasAttributes(dom, {'type': '_moz'});
              if (isMarkedDirty && dpr.isBlockEnd(this.context, dom)) {
                this.elementsToChange.push({
                  'domToChange': dom,
                  'changedDom': this.context.createTextNode(dpr.NBSP)
                });
              }
            }
          }
        } else if (com.ua.isIE) {
          // IE: Add &nbsp; if required
          if (com.isTag(dom, 'br') && dpr.isBlockEnd(this.context, dom)) {
            var nbsp = this.context.createTextNode(dpr.NBSP);
            this.markForInsertion(nbsp, dom.parentNode);
          }
        }
      }
    },

    /**
     * Enforces HTML rules on the specified DOM element.
     * @param {HTMLElement} dom The DOM element to apply rules to
     * @return {Boolean} True if the DOM element was marked for removal
     */
    applyHtmlRules: function (dom) {
      // todo maybe we should move an extended version of this method to HtmlRules for common use?
      var com = CUI.rte.Common;
      // adjust tag names to more appropriate (regarding editing) tag names if
      // necessary
      var tagName = dom.tagName.toLowerCase();
      var changedTagName = (this.isPreProcessing() ?
        this.htmlRules.docType.adjustToRaw(tagName)
        : this.htmlRules.docType.adjustToDocType(tagName));
      var changedDom;
      if (changedTagName !== null && changedTagName !== undefined) {
        if (changedTagName.length > 0) {
          changedDom = this.context.createElement(changedTagName);
          this.elementsToChange.push({
            'domToChange': dom,
            'changedDom': changedDom
          });
        } else { //#37049 - remove blacklisted tags
          this.elementsToRemove.push(dom);
          return true;
        }
        return false;
      }
      if (this.isPreProcessing()) {
        // handle links (add attributes as specified by rules, remove links with invalid
        // HREFs)
        if (com.isTag(dom, 'a')) {
          var href = com.getAttribute(dom, 'href');
          if (href) {
            if (this.htmlRules.links.validateHref(href)) {
              this.htmlRules.links.applyToObject(dom);
              return false;
            } else {
              this.markForRemoval(dom);
              return true;
            }
          }
        }
      }
      return false;
    },

    /**
     * <p>Handles alignment for the specified DOM element.</p>
     * <p>It is ensured that for several block tags the "style" attribute is used rather
     * than the "align" attribute (due to editing restrictions of several browsers).</p>
     * @param {HTMLElement} dom The DOM element to process
     */
    handleAlignment: function (dom) {
      var com = CUI.rte.Common;
      // currently, we only do this for div/p tags
      var tagsToHandle = ['p', 'div'];
      if (com.isTag(dom, tagsToHandle)) {
        if (this.isPreProcessing()) {
          var alignAttrib = com.getAttribute(dom, 'align', true);
          if (alignAttrib) {
            com.removeAttribute(dom, 'align');
            dom.style.textAlign = alignAttrib;
          }
        }
      }
    },

    /**
     * <p>Handles "a" elements.</p>
     * <p>For named anchors, this means that a suitable CSS class is applied or removed.
     * Additionally, the DOM will be changed to meet editing requirements if necessary.</p>
     * <p>For links, a RTE-specific property is added that holds the original HREF. On
     * postprocessing, this RTE-specific property is moved to the HREF attribute again.</p>
     * <p>You can specify any DOM element, as the element is checked before it is
     * actually processed.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleAnchor: function (dom) {
      var com = CUI.rte.Common;
      var dcu = CUI.rte.DomCleanup;
      var idAttrib, nameAttrib;
      if (com.isTag(dom, 'a')) {
        // using id attribute since html5 dosen't supports name attribute anymore
        idAttrib = com.getAttribute(dom, 'id', true);
        nameAttrib = com.getAttribute(dom, 'name', true);
        var hrefAttrib = CUI.rte.HtmlRules.Links.getLinkHref(dom);
        var linkPlugin = this.editorKernel.registeredPlugins.links;
        var anchorEditingStyle;
        if (linkPlugin) {
          anchorEditingStyle = linkPlugin.getConfig().anchorEditingStyle;
        }
        if (idAttrib || nameAttrib) {
          if (this.isPreProcessing()) {
            // change <a id="bla">text</a> to <a id="bla"></a>text
            var children = dom.childNodes;
            var parentDom = dom.parentNode;
            var insertRef = dom.nextSibling;
            while (children.length > 0) {
              com.insertBefore(parentDom, children[0], insertRef);
            }
            var imgReplacement = this.context.createElement('img');
            com.setAttribute(imgReplacement, 'src',
              CUI.rte.Utils.getBlankImageUrl());
            if (nameAttrib) {
              // see https://www.w3.org/TR/html5/obsolete.html#obsolete-but-conforming-features
              com.setAttribute(imgReplacement, com.A_ID_REPLACEMENT_ATTRIB,
                nameAttrib);
              com.setAttribute(imgReplacement, com.A_NAME_REPLACEMENT_ATTRIB,
                nameAttrib);
            } else {
              com.setAttribute(imgReplacement, com.A_ID_REPLACEMENT_ATTRIB,
                idAttrib);
            }
            if (anchorEditingStyle) {
              com.setAttribute(imgReplacement, 'style', anchorEditingStyle);
            } else {
              com.addClass(imgReplacement, CUI.rte.Theme.ANCHOR_CLASS);
            }
            this.elementsToChange.push({
              'domToChange': dom,
              'changedDom': imgReplacement
            });
          } else if (this.processingMode === dcu.POST) {
            if (anchorEditingStyle) {
              com.removeAttribute(dom, 'style');
            } else {
              com.removeClass(dom, CUI.rte.Theme.ANCHOR_CLASS);
            }
          }
        }
        if (hrefAttrib) {
          if (this.processingMode === dcu.PASTE_PREPARE) {
            var helperAttrib = com.getAttribute(dom, com.HREF_ATTRIB);
            if (!helperAttrib) {
              com.setAttribute(dom, com.HREF_ATTRIB, hrefAttrib);
            }
          }
        }
      } else if (com.isTag(dom, 'img') &&
        com.isAttribDefined(dom, com.A_ID_REPLACEMENT_ATTRIB)) {
        if (!this.isPreProcessing()) {
          var anchorDom = this.context.createElement('a');
          idAttrib = com.getAttribute(dom, com.A_ID_REPLACEMENT_ATTRIB);
          nameAttrib = com.getAttribute(dom, com.A_NAME_REPLACEMENT_ATTRIB);
          if (nameAttrib){
            com.setAttribute(anchorDom, 'name', nameAttrib);
          }
    		  com.setAttribute(anchorDom, 'id', idAttrib);
          this.elementsToChange.push({
            'domToChange': dom,
            'changedDom': anchorDom
          });
        }
      }
    },

    /**
     * <p>Handles images.</p>
     * <p>Here, the SRC-attribute is doubled for editing, as browser do nasty things with
     * it.</p>
     * <p>You can specify any DOM element, as the element is checked before it is
     * actually processed.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleImage: function (dom) {
      var com = CUI.rte.Common;
      var dcu = CUI.rte.DomCleanup;
      var hr = CUI.rte.HtmlRules;
      var hpr = CUI.rte.HtmlProcessor;
      if (com.isTag(dom, 'img')) {
        var urlType = CUI.rte.Utils.URL_IMAGE;
        var srcAttrib;
        if (this.processingMode === dcu.PRE) {
          srcAttrib = com.getAttribute(dom, com.SRC_ATTRIB, true);
          srcAttrib = (srcAttrib ? srcAttrib : com.getAttribute(dom, 'src', true));
          com.setAttribute(dom, 'src', CUI.rte.Utils.processUrl(srcAttrib, urlType));
        }
        if (this.processingMode === dcu.PASTE_PREPARE) {
          srcAttrib = com.getAttribute(dom, 'src', true);
          if (srcAttrib) {
            var helperAttrib = com.getAttribute(dom, com.SRC_ATTRIB, true);
            if (!helperAttrib) {
              com.setAttribute(dom, com.SRC_ATTRIB,
                hr.removePrefixForInternalLinks(srcAttrib, urlType));
            }
          }
        }
        if (this.processingMode === dcu.POST) {
          // image width/height might be provided as style attribute (IE!), so
          // we need to normalize this before serializing
          var style = com.getAttribute(dom, 'style');
          if (style) {
            var styleDef = hpr.parseStyleDef(style);
            if (styleDef.width) {
              com.setAttribute(dom, 'width', parseInt(styleDef.width, 10));
              delete styleDef.width;
            }
            if (styleDef.height) {
              com.setAttribute(dom, 'height', parseInt(styleDef.height, 10));
              delete styleDef.height;
            }
            var styleAttr = hpr.createStyleAttrib(styleDef);
            if (styleAttr) {
              com.setAttribute(dom, 'style', styleAttr);
            } else {
              com.removeAttribute(dom, 'style');
            }
          }
        }
      }
    },

    /**
     * <p>Handles tables.</p>
     * <p>In this case, table without a border get a class added that makes the border
     * temporarily visible for editing.</p>
     * <p>You can specify any DOM element, as the element is checked before it is
     * actually processed.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleTable: function (dom) {
      var com = CUI.rte.Common;
      var dcu = CUI.rte.DomCleanup;
      if (com.isTag(dom, 'table')) {
        var borderAttrib = com.getAttribute(dom, 'border', true);
        var hasBorder = false;
        if (borderAttrib) {
          try {
            hasBorder = (parseInt(borderAttrib, 10) > 0);
          } catch (e) {
            // ignore, as we can't do anything about it
          }
        }
        if (!hasBorder) {
          if (this.isPreProcessing()) {
            com.addClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
          } else if (this.processingMode === dcu.POST) {
            com.removeClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
          }
        }
        this.handleCellSpacingAttribute(dom);
      } else if (com.isTag(dom, ['td', 'th'])) {
        if (this.processingMode === dcu.POST) {
          com.removeClass(dom, CUI.rte.Theme.TABLESELECTION_CLASS);
          if (com.isTag(dom, 'th') && com.getAttribute(dom, 'hiddenheader')) {
            var divToAdd = this.context.createElement('div');
            com.setAttribute(divToAdd, 'hiddenheader', 'true');
            com.removeAttribute(dom, 'hiddenheader');
            var tablePlugin = this.editorKernel.registeredPlugins.table;
            if (tablePlugin) {
              var hiddenHeaderConfig = tablePlugin.getHiddenHeaderConfig();
              if (hiddenHeaderConfig.hiddenHeaderClassName) {
                com.addClass(divToAdd, hiddenHeaderConfig.hiddenHeaderClassName);
              } else if (hiddenHeaderConfig.hiddenHeaderStyle) {
                com.setAttribute(divToAdd, 'style', hiddenHeaderConfig.hiddenHeaderStyle);
              }
              if (hiddenHeaderConfig.hiddenHeaderEditingCSS) {
                com.removeClass(dom, hiddenHeaderConfig.hiddenHeaderEditingCSS);
              } else {
                var stylesToRemove = [];
                var editingStyle = hiddenHeaderConfig.hiddenHeaderEditingStyle;
                editingStyle = editingStyle.trim();
                var attributes = editingStyle.split(';');
                for (var i = 0; i < attributes.length; i++) {
                  var propNameValue = attributes[i].split(':');
                  if (propNameValue.length === 2) {
                    var propName = propNameValue[0].trim();
                    if (propName.length) {
                      stylesToRemove.push(propName);
                    }
                  }
                }
                com.removeInlineStyles(dom, stylesToRemove);
              }
            }
            while(dom.firstChild) {
              divToAdd.appendChild(dom.firstChild);
            }
            dom.appendChild((divToAdd));
          }
        }
      }
    },

    /**
     * @private
     */
    handleCellSpacingAttribute: function (dom) {
      return;
    },

    /**
     * <p>Handles lists.</p>
     * <p>It is ensured that nested lists are correctly structured.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleList: function (dom) {
      var com = CUI.rte.Common;
      var lut = CUI.rte.ListUtils;
      if (com.isTag(dom, com.LIST_TAGS)) {
        if (lut.isTopLevelList(this.context, dom)) {
          var listProcessor = new CUI.rte.ListRepresentation();
          listProcessor.fromItem(this.context, dom);
          listProcessor.ensureHierarchy(this.context);
        }
      }
    },

    /**
     * <p>Handles style information in the style attribute of span elements.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleSpanStyles: function (dom) {
      var com = CUI.rte.Common;
      if (this.isPreProcessing()) {
        if (com.isTag(dom, 'span')) {
          var changedDom, changeDef;
          if (dom.style.fontWeight === 'bold') {
            changedDom = this.context.createElement('b');
            changeDef = {
              'domToChange': dom,
              'changedDom': changedDom
            };
          }
          if (dom.style.fontStyle === 'italic') {
            var italicDom = this.context.createElement('i');
            if (changedDom) {
              changedDom.appendChild(italicDom);
              changeDef.childDom = italicDom;
            } else {
              changedDom = italicDom;
              changeDef = {
                'domToChange': dom,
                'changedDom': changedDom
              };
            }
          }
          if (dom.style.textDecoration === 'underline') {
            var underlineDom = this.context.createElement('u');
            if (changedDom) {
              if (changeDef.childDom) {
                changeDef.childDom.appendChild(underlineDom);
              } else {
                changedDom.appendChild(underlineDom);
              }
              changeDef.childDom = underlineDom;
            } else {
              changedDom = underlineDom;
              changeDef = {
                'domToChange': dom,
                'changedDom': changedDom
              };
            }
          }
          if (changeDef) {
            this.elementsToChange.push(changeDef);
          }
        }
      }
    },

    handleDiv: function (dom) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      if (this.isPreProcessing()) {
        if (com.isTag(dom, 'div') && com.getAttribute(dom, 'hiddenheader') === 'true') {
          var tablePlugin = this.editorKernel.registeredPlugins.table;
          if (tablePlugin) {
            var hiddenHeaderConfig = tablePlugin.getHiddenHeaderConfig();
            if (hiddenHeaderConfig.hiddenHeaderEditingCSS) {
              com.addClass(dom.parentNode, hiddenHeaderConfig.hiddenHeaderEditingCSS);
            } else {
              com.addInlineStyles(dom.parentNode, hiddenHeaderConfig.hiddenHeaderEditingStyle);
            }
          }
          com.setAttribute(dom.parentNode, 'hiddenheader', 'true');
          dpr.removeWithoutChildren(dom);
        }
      }

    },

    handleFont: function (dom) {
      var com = CUI.rte.Common;
      if (!this.isPreProcessing()) {
        // remove empty font tags (workaround for Chrome issue with fonts)
        if (com.isTag(dom, 'font')) {
          if (!com.hasTextChild(dom, true)) {
            this.elementsToRemove.push(dom);
          }
        }
      }
    },

    /**
     * This method handles several specific tags.
     * @param {HTMLElement} dom The DOM element
     */
    handleSpecificTags: function (dom) {
      this.handleAlignment(dom);
      this.handleAnchor(dom);
      this.handleImage(dom);
      this.handleTable(dom);
      this.handleSpanStyles(dom);
      this.handleDiv(dom);
      this.handleList(dom);
      this.handlePreformattedSection(dom);
      this.handleFont(dom);

      //executes any pluggued processor
      var processors = CUI.rte.DomCleanup.pluggableDomProcessors;
      if (processors !== null) {
        for (var i = 0; i < processors.length; i++) {
          var processor = processors[i];
          if (processor) {
            processor.call(this, dom);
          }
        }
      }
    },

    /**
     * This method handles empty content.
     * @param {HTMLElement} rootDom The root DOM
     */
    handleEmptyContent: function (rootDom) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var dcu = CUI.rte.DomCleanup;
      if (this.processingMode === dcu.PRE) {
        if (rootDom.childNodes.length === 0) {
          var placeholder = dpr.createEmptyLinePlaceholder(this.context, true,
            this.htmlRules.blockHandling.defaultEditBlockType);
          rootDom.appendChild(placeholder);
        } else if (rootDom.childNodes.length === 1) {
          // newer Firefox versions automatically change an empty string set as
          // innerHTML into a single <br> node (which is corrected into <p><br></p>
          // by handleContainerRules
          var blockNode = rootDom.childNodes[0];
          var textNodes = com.getCharacterNodes(blockNode);
          if ((textNodes.length === 1) && com.isTag(textNodes[0], 'br')) {
            com.setAttribute(textNodes[0], com.BR_TEMP_ATTRIB, 'brEOB');
          }
        }
      } else if (this.processingMode === dcu.POST) {
        if (rootDom.childNodes.length === 1) {
          var singleChild = rootDom.childNodes[0];
          if (com.isTag(singleChild, com.EDITBLOCK_TAGS)) {
            if (dpr.isEmptyLineBlock(singleChild)) {
              rootDom.removeChild(singleChild);
            }
          }
        }
      }
    },


    /**
     * Handles container-related HTML rules, such as removing the block around a single
     * content block if configured accordingly.
     * @param {HTMLElement} rootDom The root DOM
     */
    handleContainerRules: function (rootDom) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var dcu = CUI.rte.DomCleanup;
      var blockRules = this.htmlRules.blockHandling;
      var tableRules = this.htmlRules.tableHandling;
      var defaultEditBlock = blockRules.defaultEditBlockType;
      var blockRepTag = blockRules.singleParagraphContainerReplacement;
      if (this.processingMode === dcu.PRE) {
        dpr.ensureBlockContent(this.context, defaultEditBlock, null, false, false);
        dpr.adjustTables(this.context, tableRules);
        var fixIECnt = this.emptyBlocksIE.length;
        for (var i = 0; i < fixIECnt; i++) {
          dpr.fixEmptyEditingBlockIE(this.context, this.emptyBlocksIE[i]);
        }
      } else if (this.processingMode === dcu.POST) {
        if (blockRules.removeSingleParagraphContainer) {
          var rootElCnt = rootDom.childNodes.length;
          if (rootElCnt === 1) {
            var blockDom = rootDom.childNodes[0];
            if (com.isTag(blockDom, defaultEditBlock)) {
              var bStyle = blockDom.style;
              var blockClass = com.getAttribute(blockDom, 'class', true);
              if (blockClass || bStyle.textAlign || bStyle.marginLeft) {
                // change tag, as there are properties to keep on the single
                // block
                if (defaultEditBlock !== blockRepTag) {
                  var newBlockDom = this.context.createElement(blockRepTag);
                  if (blockClass) {
                    com.setAttribute(newBlockDom, 'class', blockClass);
                  }
                  if (bStyle.textAlign) {
                    newBlockDom.style.textAlign = bStyle.textAlign;
                  }
                  if (bStyle.marginLeft) {
                    newBlockDom.style.marginLeft = bStyle.marginLeft;
                  }
                  com.replaceNode(blockDom, newBlockDom);
                }
              } else {
                // nothing to keep, so we'll simply remove the single block
                dpr.removeWithoutChildren(blockDom);
              }
            }
          }
        }
      }
    },


    // -- Additional paste processing ------------------------------------------------------

    /**
     * Checks if the specified element is allowed for tags and marks it for removal if not.
     * @param {HTMLElement} dom The element to check
     * @return {HTMLElement} The element or null if the element has been marked for removal
     */
    checkAllowedForPaste: function (dom) {
      var com = CUI.rte.Common;
      var markForRemoval = true;
      // tags that are always allowed
      var defaultAllowedTags = ['br'];
      // tags that are considered "basic tags"
      var basicTags = {
        'b': 'bold',
        'i': 'italic',
        'u': 'underline',
        'a': 'anchor',
        'img': 'image',
        'sub': 'subscript',
        'sup': 'superscript'
      };
      var basicTagDef = null;
      if (this.pasteRules.allowBasics) {
        var tagNameLC = dom.tagName.toLowerCase();
        if (basicTags.hasOwnProperty(tagNameLC)) {
          basicTagDef = basicTags[tagNameLC];
        }
      }
      if (this.pasteRules.table) {
        if ((this.pasteRules.table.allow) ||
          (this.pasteRules.table.ignoreMode === 'paragraph')) {
          defaultAllowedTags.push('table');
          defaultAllowedTags.push('tbody');
          defaultAllowedTags.push('tr');
          defaultAllowedTags.push('td');
          defaultAllowedTags.push('th');
        }
      }
      if (this.pasteRules.list) {
        if ((this.pasteRules.list.allow) ||
          (this.pasteRules.list.ignoreMode === 'paragraph')) {
          defaultAllowedTags.push('ul');
          defaultAllowedTags.push('ol');
          defaultAllowedTags.push('li');
        }
      }
      if (basicTagDef !== null && basicTagDef !== undefined) {
        markForRemoval = (this.pasteRules.allowBasics[basicTagDef] !== true);
      } else if (com.isTag(dom, defaultAllowedTags)) {
        markForRemoval = false;
      } else if (com.isTag(dom, com.BLOCK_TAGS)) {
        // block tags are handled differently
        markForRemoval = false;
      } else if (com.isTag(dom, 'span') && (com.parseCSS(dom).length > 0)) { // exception for span if it has css classes assigned
        markForRemoval = false;
      }
      if (markForRemoval) {
        this.elementsToRemove.push(dom);
        return null;
      }
      return dom;
    },

    /**
     * Applies table-specific paste-rules.
     * @param {HTMLElement} dom The table's DOM element
     * @return {HTMLElement} The DOM element to continue processing with
     */
    handleTablesOnPaste: function (dom) {
      var com = CUI.rte.Common;
      var tableRules = this.pasteRules.table;
      if (tableRules.allow) {
        return dom;
      }
      if (tableRules.ignoreMode === 'remove') {
        // delete child nodes directly to avoid unnecessary processing, and mark
        // table itself for removal
        com.removeAllChildren(dom);
        this.markForRemoval(dom);
        return dom;
      }
      return this.flattenNestedStructure(dom, com.TABLE_CELLS, 'table');
    },

    /**
     * Applies list-specific paste-rules.
     * @param {HTMLElement} dom The table's DOM element
     * @return {HTMLElement} The DOM element to continue processing with
     */
    handleListsOnPaste: function (dom) {
      var com = CUI.rte.Common;
      var listRules = this.pasteRules.list;
      if (listRules.allow) {
        return dom;
      }
      if (listRules.ignoreMode === 'remove') {
        // delete child nodes directly to avoid unnecessary processing, and mark
        // list itself for removal
        com.removeAllChildren(dom);
        this.markForRemoval(dom);
        return dom;
      }
      return this.flattenNestedStructure(dom, 'li', com.LIST_TAGS);
    },

    /**
     * Checks if the specified DOM element is a block tag and changes it according to the
     * paste rules if necessary.
     * @param {HTMLElement} dom The DOM element
     */
    handleBlockTagsOnPaste: function (dom) {
      var com = CUI.rte.Common;
      if (com.isTag(dom, com.BLOCK_TAGS)) {
        var tagNameLC = dom.tagName.toLowerCase();
        // tables and lists must be handled specifically if a rule is available
        if (com.isTag(dom, 'table') && this.pasteRules.table) {
          return this.handleTablesOnPaste(dom);
        }
        if (com.isTag(dom, com.LIST_TAGS) && this.pasteRules.list) {
          return this.handleListsOnPaste(dom);
        }
        var mustChange = true;
        if (this.pasteRules.allowBlockTags) {
          mustChange = !com.arrayContains(this.pasteRules.allowBlockTags, tagNameLC);
        }
        if (mustChange) {
          var fallbackTag = this.pasteRules.fallbackBlockTag || 'p';
          var changedDom = this.context.createElement(fallbackTag);
          this.elementsToChange.push({
            'domToChange': dom,
            'changedDom': changedDom
          });
        }
      }
    },

    /**
     * Handles "class" attributes of elements due to the paste rules defined.
     * @param {HTMLElement} dom The DOM element
     */
    handleCssClassesOnPaste: function (dom) {
      var com = CUI.rte.Common;
      var cssMode = (this.pasteRules.cssMode || 'remove');
      var cssClasses = com.parseCSS(dom);
      if (cssClasses && (cssClasses.length > 0)) {
        switch (cssMode) {
        case 'remove':
          com.removeAttribute(dom, 'class');
          break;
        case 'whitelist':
          var allowedClasses = this.pasteRules.allowedCssNames || [];

          // get allowed classes from plugin
          if (this.editorKernel.registeredPlugins.styles) {
            var stylesFromPlugin = this.editorKernel.registeredPlugins.styles.getStyles() || [];

            for (var i = 0; i < stylesFromPlugin.length; i++) {
              allowedClasses.push(stylesFromPlugin[i].cssName);
            }
          }

          var classCnt = cssClasses.length;
          for (var c = 0; c < classCnt; c++) {
            var classToCheck = cssClasses[c];
            if (!com.arrayContains(allowedClasses, classToCheck)) {
              com.removeClass(dom, classToCheck);
            }
          }
          break;
        }
      }
    },

    /**
     * Compiles a RegExp object from the specified parameter if it is a String.
     * @param {String|RegExp} regex The potential regular expression
     */
    manageRegEx: function (regex) {
      var length;
      // do it in a separate method to avoid potential leak
      if (typeof(regex) === 'string') {
        length = regex.length;
        if (regex.charAt('0') === '/' && regex.charAt(length - 1) === '/') {
          regex = new RegExp(regex.substring(0, length - 1));
        }
      }
      return regex;
    },

    /**
     * Executes several security checks on the specified DOM element according to the
     * defined paste rules.
     * @param {HTMLElement} dom The DOM element
     * @return {HTMLElement} The DOM element or null if the element has been marked for
     *         removal
     */
    handleSecurity: function (dom) {
      var com = CUI.rte.Common;
      // execute link verification
      if (com.isTag(dom, 'a')) {
        var hrefAttrib = com.getAttribute(dom, 'href', true);
        if (hrefAttrib && this.pasteRules.linkRemoveRegEx) {
          var regex = this.manageRegEx(this.pasteRules.linkRemoveRegEx);
          if (regex) {
            if (hrefAttrib.search(regex) >= 0) {
              this.markForRemoval(dom);
              return null;
            }
          }
        }
      }
      return dom;
    },

    /**
     * Removes attributes that are not allowed.
     * @param {HTMLElement} dom The DOM element
     */
    handleAttributes: function (dom) {
      var com = CUI.rte.Common;
      var attribs = com.getAttributeNames(dom);
      var globalAllowed = null;
      var tagAllowed = null;
      var tagNameLC = dom.tagName.toLowerCase();
      if (this.pasteRules.allowedAttributes) {
        globalAllowed = this.pasteRules.allowedAttributes['*'];
        tagAllowed = this.pasteRules.allowedAttributes[tagNameLC];
      }
      var attribCnt = attribs.length;
      for (var a = 0; a < attribCnt; a++) {
        var attribName = attribs[a];
        var isAllowed = false;
        if (globalAllowed && com.arrayContains(globalAllowed, attribName)) {
          isAllowed = true;
        }
        if (tagAllowed && com.arrayContains(tagAllowed, attribName)) {
          isAllowed = true;
        }
        if (!isAllowed) {
          com.removeAttribute(dom, attribName);
        }
      }
    },

    /**
     * <p>This method handles the preprocessing for pasted HTML content.</p>
     * <p>It may be called in any processing mode.</p>
     * @param {HTMLElement} dom The DOM element to be processed
     * @return {HTMLElement} The DOM element to continue processing with
     */
    handlePasteProcessing: function (dom) {
      var dcu = CUI.rte.DomCleanup;
      var originalDom = dom;
      if ((this.mode = dcu.PASTE_PREPARE) && (this.pasteRules !== null && this.pasteRules !== undefined)) {
        if (dom) {
          dom = this.handleSecurity(dom);
        }
        if (dom) {
          this.handleBlockTagsOnPaste(dom);
          this.handleCssClassesOnPaste(dom);
          this.handleAttributes(dom);
        }
        dom = this.checkAllowedForPaste(dom);
      }
      // continue with original DOM if element has been marked for removal
      return dom || originalDom;
    },


    // -- Processing -----------------------------------------------------------------------

    /**
     * Optimize the tree (executes operations that can't be efficiently processed
     * in the event-driven manner the DomCleanup else works).
     * @param {HTMLElement} root The root element
     */
    optimizeTree: function (root) {

      var com = CUI.rte.Common;

      function optimizeNode(dom, joinableTags) {
        if (com.isTag(dom, joinableTags)) {
          var isDone = false;
          do {
            var nextDom = dom.nextSibling;
            if (nextDom) {
              if (com.equals(dom, nextDom)) {
                com.moveChildren(nextDom, dom, 0, true);
                nextDom.parentNode.removeChild(nextDom);
              } else {
                isDone = true;
              }
            } else {
              isDone = true;
            }
          } while (!isDone);
        }
        if (dom.nodeType === 1) {
          for (var c = 0; c < dom.childNodes.length; c++) {
            optimizeNode(dom.childNodes[c], joinableTags);
          }
        }
      }

      if (!this.isPreProcessing()) {
        var optimizable = [
          'b', 'i', 'u', 'big', 'small', 'strong', 'em', 'sub', 'sup', 'span'
        ];
        optimizeNode(root, optimizable);
      }
    },

    /**
     * Handles generic HTML for the specified sub-tree recursively.
     * @param {HTMLElement} dom Root element of the sub-tree
     * @param {Boolean} isRoot True if we are at the root node of the entire traversal
     */
    traverse: function (dom, isRoot) {
      var ignoreRecursion = false;
      if (!isRoot) {
        if (dom.nodeType === 1) {
          if (!this.isValidSubTree(dom)) {
            this.markSubTreeForRemoval(dom);
            ignoreRecursion = true;
          } else if (!this.isValidElement(dom)) {
            this.markForRemoval(dom);
          } else {
            // paste processing works as a "pre-filter"
            dom = this.handlePasteProcessing(dom);
            var isRemoved = false;
            if (this.htmlRules) {
              isRemoved = this.applyHtmlRules(dom);
            }
            if (!isRemoved) {
              this.handleSpecificTags(dom);
            }
          }
        }
        this.handleEmptyLinesAtEOB(dom);
      }
      if (!ignoreRecursion) {
        var children = dom.childNodes;
        for (var c = 0; c < children.length; c++) {
          this.traverse(children[c], false);
        }
      }
    },

    /**
     * Removes elements that were marked for removal while traversing the DOM tree.
     */
    removeElements: function () {
      var dpr = CUI.rte.DomProcessor;
      var removeCnt = this.elementsToRemove.length;
      for (var r = 0; r < removeCnt; r++) {
        dpr.removeWithoutChildren(this.elementsToRemove[r]);
      }
      this.elementsToRemove.length = 0;
      removeCnt = this.subTreesToRemove.length;
      for (r = 0; r < removeCnt; r++) {
        var toRemove = this.subTreesToRemove[r];
        if (toRemove.parentNode) {
          toRemove.parentNode.removeChild(toRemove);
        }
      }
      this.subTreesToRemove.length = 0;
    },

    /**
     * Replaces elements that were marked accordingly while traversing the DOM tree.
     */
    replaceElements: function () {
      var com = CUI.rte.Common;
      var replaceCnt = this.elementsToChange.length;
      for (var r = 0; r < replaceCnt; r++) {
        var changeDef = this.elementsToChange[r];
        var toChange = changeDef.domToChange;
        com.replaceNode(toChange, changeDef.changedDom, changeDef.childDom);
        // if element was marked for removal, we'll have to remove it from that list
        // as we'd otherwise provoke an exception
        for (var rm = 0; rm < this.elementsToRemove.length; rm++) {
          if (this.elementsToRemove[rm] === toChange) {
            this.elementsToRemove.splice(rm, 1);
            break;
          }
        }
      }
    },

    /**
     * Inserts the elements that were marked accordingly while traversing the DOM tree.
     */
    insertElements: function () {
      var insertCnt = this.elementsToInsert.length;
      for (var i = 0; i < insertCnt; i++) {
        var changeDef = this.elementsToInsert[i];
        var toInsert = changeDef.domToInsert;
        var parentDom = changeDef.parentDom;
        var siblingRef = changeDef.refDom;
        if (siblingRef) {
          parentDom.insertBefore(toInsert, siblingRef);
        } else {
          parentDom.appendChild(toInsert);
        }
      }
    },


    // -- "Interface"/Implementation -------------------------------------------------------

    /**
     * Executes the DOM cleanup (used by each of the processing methods).
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root element to begin cleanup with
     * @private
     */
    execute: function (editorKernel, rootDom) {
      // init
      this.editorKernel = editorKernel;
      this.context = editorKernel.getEditContext();
      this.htmlRules = editorKernel.getHtmlRules();

      function clear(array) {
        if (array) {
          array.length = 0;
          return array;
        }
        return [];
      }

      this.elementsToRemove = clear(this.elementsToRemove);
      this.subTreesToRemove = clear(this.subTreesToRemove);
      this.elementsToChange = clear(this.elementsToChange);
      this.elementsToInsert = clear(this.elementsToInsert);
      this.emptyBlocksIE = clear(this.emptyBlocksIE);

      // actually execute
      this.traverse(rootDom, true);
      this.insertElements();
      this.replaceElements();
      this.removeElements();
      this.optimizeTree(rootDom);
      this.handleContainerRules(rootDom);
      this.handleEmptyContent(rootDom);
    },

    /**
     * Executes DOM-based preprocessing on the specified root node.
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root node
     */
    preprocess: function (editorKernel, rootDom) {
      this.processingMode = CUI.rte.DomCleanup.PRE;
      this.execute(editorKernel, rootDom);
    },

    /**
     * Executes DOM-based postprocessing on the specified root node.
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root node
     */
    postprocess: function (editorKernel, rootDom) {
      this.processingMode = CUI.rte.DomCleanup.POST;
      this.execute(editorKernel, rootDom);
    },

    /**
     * Executes DOM-based preprocessing of HTML content that was pasted from a potentially
     * unknown source.
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root node
     * @param {Object} pasteRules The rules to be applied for pasted content
     */
    prepareHtmlPaste: function (editorKernel, rootDom, pasteRules) {
      this.processingMode = CUI.rte.DomCleanup.PASTE_PREPARE;
      this.pasteRules = pasteRules;
      this.execute(editorKernel, rootDom);
    }

  });


  /**
   * Mode: Preprocessing (= persisted to editable state)
   */
  CUI.rte.DomCleanup.PRE = 0;

  /**
   * Mode: Postprocessing (= edited to a pesistable state)
   */
  CUI.rte.DomCleanup.POST = 1;

  /**
   * Mode: Preprocessing of HTML content pasted from anywhere
   */
  CUI.rte.DomCleanup.PASTE_PREPARE = 2;

  /**
   * Array of pluggable dom processors, pushed by plugins to manage specific tags.
   * A processor should be of the form function (dom)
   */
  CUI.rte.DomCleanup.pluggableDomProcessors = null;

  /**
   * <p>Adds a dom processor that will be called at dom pre & post processing, allowing
   * plugins to add their own DOM manipulation</p>
   */
  CUI.rte.DomCleanup.addDomProcessor = function (processor) {
    var dcu = CUI.rte.DomCleanup;
    if (dcu.pluggableDomProcessors === null) {
      dcu.pluggableDomProcessors = [];
    }
    dcu.pluggableDomProcessors.push(processor);
  };
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.Command
 * @private
 * The Command should be implemented by all RTE commands that cannot be handled by the
 * browser's implementation itself.
 * <p>
 * Each implementation of this class can provide one or multiple commands. It has to
 * check if it is accountable for a command in the {@link #isCommand} method. If a class
 * is accountable for a single command, it should register on that command in the
 * {@link CUI.rte.CommandRegistry}. If multiple commands are supported, a unique name,
 * starting with "_", may be chosen at your discretion.
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.Command = new Class({

    toString: 'Command',

    isCommand: function (cmdStr) {
      // this method must be overridden
      return false;
    },

    isUndoable: function (cmdStr) {
      // this method can be overridden by commands that are actually not undoable (for
      // example undo/redo commands themselves)
      return true;
    },

    requiresInitializedComponent: function (cmdStr) {
      // this method can be overridden by commands that do not require an initialized
      // RTE component, for example for configuration, setup, etc.
      return true;
    },

    getProcessingOptions: function () {
      return CUI.rte.commands.Command.PO_NONE;
    },

    execute: function (execDef) {
      // this method must be overridden
    },

    // todo use a single parameter
    queryState: function (selectionDef, cmd) {
      return false;
    }

  });

  /**
   * @static
   * @final
   * @type Number
   * @private
   */
  CUI.rte.commands.Command.PO_NONE = 0;

  /**
   * @static
   * @final
   * @type Number
   * @private
   */
  CUI.rte.commands.Command.PO_SELECTION = 1;

  /**
   * @static
   * @final
   * @type Number
   * @private
   */
  CUI.rte.commands.Command.PO_BOOKMARK = 2;

  /**
   * @static
   * @final
   * @type Number
   * @private
   */
  CUI.rte.commands.Command.PO_NODELIST = 4;

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.CommandRegistry
 * This class is used to manage commands used for rich text editing. Each command has a
 * respective identifier by which it can be executed
 * {@link CUI.rte.EditorKernel#execCmd}.
 * @since 5.3
 * @private
 */
(function (CUI) {
  'use strict';
  CUI.rte.commands.CommandRegistry = (function () {

    var cmdRegistry = {};

    return {

      /**
       * Registers the specified class as a rich text editing command.
       * <p>
       * Note that a class that extends {@link CUI.rte.Command} can provide/account for
       * multiple commands. In such cases, it is convention that the {@link #command}
       * parameter of the registring call starts with a "_".
       * @param {String} command The command identifier; must start with a "_" if the
       *        specified command class provides multiple commands
       * @param {Function} cls The command class (must extend
       *        {@link CUI.rte.commands.Command})
       */
      register: function (command, cls) {
        cmdRegistry[command] = cls;
      },

      /**
       * <p>Creates an associative array, containing instances of all currently
       * registered commands.</p>
       * <p>The created object may be used by a single {@link CUI.rte.EditorKernel}
       * instance.</p>
       * @return {Object} Associative array of instantiated commands
       */
      createRegisteredCommands: function () {
        var registeredCommands = {};
        for (var cmd in cmdRegistry) {
          if (cmdRegistry.hasOwnProperty(cmd)) {
            registeredCommands[cmd] = new cmdRegistry[cmd]();
          }
        }
        return registeredCommands;
      }

    };

  }());
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.Delete
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.Delete = new Class({

    toString: 'Delete',

    extend: CUI.rte.commands.Command,

    isCommand: function (cmdStr) {
      var cmdLC = cmdStr.toLowerCase();
      return (cmdLC === 'delete');
    },

    execute: function (execDef) {
      CUI.rte.commands.Delete.executeDelete(execDef.editContext);
    }

  });

  /**
   * <p>Immediately executes the delete command (without using the EditorKernel's selection
   * adjustments).</p>
   * <p>Use this to delete the current (already preprocessed) selection from another command
   * and ensure that the editor is kept in a usable state (at least an empty block will be
   * available afterwards).</p>
   * @param {CUI.rte.EditContext} editContext The edit context
   * @private
   */
  CUI.rte.commands.Delete.executeDelete = function (editContext) {
    editContext.doc.execCommand('delete', false, null);
    CUI.rte.DomProcessor.ensureMinimumContent(editContext);
  };

// register command
  CUI.rte.commands.CommandRegistry.register('delete', CUI.rte.commands.Delete);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.SurroundBase
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.SurroundBase = new Class({

    toString: 'SurroundBase',

    extend: CUI.rte.commands.Command,

    tagName: null,

    attributes: null,

    construct: function (tagName, attributes) {
      this.tagName = tagName;
      this.attributes = attributes;
    },

    /**
     * @private
     */
    containsTag: function (list, tagName) {
      var com = CUI.rte.Common;
      for (var key in list) {
        var dom = list[key];
        if (com.isTag(dom, tagName)) {
          return true;
        }
      }
      return false;
    },

    isCommand: function (cmdStr) {
      return (cmdStr.toLowerCase() === this.tagName.toLowerCase());
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_SELECTION | cmd.PO_BOOKMARK | cmd.PO_NODELIST;
    },

    execute: function (execDef) {
      var com = CUI.rte.Common;
      var nodeList = execDef.nodeList;
      var context = execDef.editContext;
      var isActive = com.containsTagInPath(context, nodeList.commonAncestor,
        this.tagName);
      if (!isActive) {
        nodeList.surround(execDef.editContext, this.tagName, this.attributes);
      } else {
        nodeList.removeNodesByTag(execDef.editContext, this.tagName, null, true);
      }
    },

    queryState: function (selectionDef, cmd) {
      var consistentFormatting = selectionDef.consistentFormatting;
      // todo check attributes
      return this.containsTag(consistentFormatting, this.tagName);
    }

  });

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.DefaultFormatting
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.DefaultFormatting = new Class({

    toString: 'DefaultFormatting',

    extend: CUI.rte.commands.Command,

    /**
     * @private
     */
    containsTag: function (list, tagName) {
      var com = CUI.rte.Common;
      for (var key in list) {
        var dom = list[key];
        if (com.isTag(dom, tagName)) {
          return true;
        }
      }
      return false;
    },

    /**
     * @private
     */
    _getTagNameForCommand: function (cmd) {
      var cmdLC = cmd.toLowerCase();
      var tagName = null;
      switch (cmdLC) {
      case 'bold':
        tagName = 'b';
        break;
      case 'italic':
        tagName = 'i';
        break;
      case 'underline':
        tagName = 'u';
        break;
      case 'subscript':
        tagName = 'sub';
        break;
      case 'superscript':
        tagName = 'sup';
        break;
      }
      return tagName;
    },

    _getParamsFromExecDef: function (execDef) {
      var cmdLC = execDef.command.toLowerCase();
      var isStyle = (cmdLC === 'style');
      var tagName, attributes;
      if (isStyle) {
        tagName = execDef.value.tag;
        attributes = execDef.value.attributes;
      } else {
        tagName = this._getTagNameForCommand(cmdLC);
        attributes = execDef.value;
      }
      return {
        'tag': tagName,
        'attributes': attributes,
        'isStyle': isStyle
      };
    },


    /**
     * @private
     */
    isStrucStart: function (context, node, offset) {
      var parentNode = node.parentNode;
      if (!parentNode) {
        return false;
      }
      if (node !== parentNode.firstChild) {
        return false;
      }
      if (node.nodeType === 3) {
        return (offset === 0);
      }
      if (CUI.rte.Common.isOneCharacterNode(node)) {
        return (offset === undefined) || (offset === null);
      }
      return true;
    },

    /**
     * @private
     */
    isStrucEnd: function (context, node, offset) {
      var com = CUI.rte.Common;
      var parentNode = node.parentNode;
      if (!parentNode) {
        return false;
      }
      if (node !== parentNode.lastChild) {
        return false;
      }
      if (node.nodeType === 3) {
        return (offset === com.getNodeCharacterCnt(node));
      }
      if (com.isOneCharacterNode(node)) {
        return (offset === 0);
      }
      return true;
    },

    /**
     * @private
     */
    _clean: function (dom, stopDom) {
      var dpr = CUI.rte.DomProcessor;
      // ensure that the provided DOM element gets processed as well, even if it is
      // the same as the "stop" element
      var isTraversed = false;
      while (!isTraversed) {
        var parent = dom.parentNode;
        if ((dom.nodeType !== 1) || (dom.childNodes.length !== 0) ||
          (dpr.getTagType(dom) !== dpr.STRUCTURE)) {
          break;
        }
        parent.removeChild(dom);
        isTraversed = (dom === stopDom);
        dom = parent;
      }
    },

    /**
     * @private
     */
    cleanLeft: function (dom) {
      var deepChild = dom;
      while (deepChild.firstChild) {
        deepChild = deepChild.lastChild;
      }
      this._clean(deepChild, dom);
    },

    /**
     * @private
     */
    cleanRight: function (dom) {
      var deepChild = dom;
      while (deepChild.firstChild) {
        deepChild = deepChild.firstChild;
      }
      this._clean(deepChild, dom);
    },

    /**
     * @private
     */
    split: function (splitParent, dom, offset) {
      CUI.rte.DomProcessor.splitToParent(splitParent, dom, offset);
    },

    /**
     * @private
     */
    clean: function (domLeft, domRight) {
      if (domLeft) {
        this.cleanLeft(domLeft);
      }
      if (domRight) {
        this.cleanRight(domRight);
      }
    },

    /**
     * @private
     */
    setCaretTo: function (execDef) {
      var com = CUI.rte.Common;
      var sel = CUI.rte.Selection;
      var dpr = CUI.rte.DomProcessor;
      var startNode;
      var startOffset;
      var placeholderNode;

      function removePlaceholderIfPresent() {
        if (placeholderNode) {
          startNode = placeholderNode.parentNode;
          startOffset = com.getChildIndex(placeholderNode);
          placeholderNode.parentNode.removeChild(placeholderNode);
        }
      }

      var def = this._getParamsFromExecDef(execDef);
      var tag = def.tag;
      var attribs = def.attributes;
      if (tag) {
        var context = execDef.editContext;
        var selection = execDef.selection;
        startNode = selection.startNode;
        startOffset = selection.startOffset;
        var isPlaceholder = dpr.isZeroSizePlaceholder(startNode);
        if (isPlaceholder) {
          placeholderNode = (startNode.nodeType === 3 ? startNode.parentNode :
            startNode);
        }
        var existing = com.getTagInPath(context, startNode, tag, attribs);
        if (!existing) {
          // switch on style
          if (placeholderNode) {
            startNode = placeholderNode.parentNode;
            startOffset = com.getChildIndex(placeholderNode);
          }
          var el = dpr.createNode(context, tag, attribs);
          com.setAttribute(el, com.TEMP_EL_ATTRIB, com.TEMP_EL_REMOVE_ON_SERIALIZE +
          ':emptyOnly');
          dpr.insertElement(context, el, startNode, startOffset);
          sel.selectEmptyNode(context, el);
          if (placeholderNode) {
            placeholderNode.parentNode.removeChild(placeholderNode);
          }
        } else {
          // switch off style
          var path = [];
          var dom = startNode;
          var ref;
          while (dom && (dom !== existing)) {
            if ((dom.nodeType === 1) && !dpr.isZeroSizePlaceholder(dom)) {
              path.push(dom);
            }
            dom = com.getParentNode(context, dom);
          }
          var pathCnt = path.length;
          var parentNode;
          if (pathCnt === 0) {
            // switching off current style
            parentNode = com.getParentNode(context, startNode);
            if (!isPlaceholder &&
              this.isStrucStart(context, startNode, startOffset)) {
              sel.selectBeforeNode(context, parentNode);
            } else if (!isPlaceholder &&
              this.isStrucEnd(context, startNode, startOffset)) {
              sel.selectAfterNode(context, parentNode);
            } else {
              removePlaceholderIfPresent();
              if (com.isCharacterNode(startNode)) {
                // split structure at caret
                this.split(parentNode, startNode, startOffset);
                this.clean(parentNode, parentNode.nextSibling);
                // select behind split point (an empty element will be created
                // automatically)
                sel.selectAfterNode(context, parentNode);
              } else {
                this.split(existing, startNode, startOffset);
                ref = existing.nextSibling;
                var tempSpan = dpr.createTempSpan(context, true, false, true);
                tempSpan.appendChild(context.createTextNode(
                  dpr.ZERO_WIDTH_NBSP));
                existing.parentNode.insertBefore(tempSpan, ref);
                this.clean(existing, ref);
                sel.selectEmptyNode(context, tempSpan);
              }
            }
          } else {
            // switching off a style that's somewhere up in the hierarchy
            var duplicatedNode, cloned;
            // create delta style hierarchy
            for (var p = pathCnt - 1; p >= 0; p--) {
              cloned = path[p].cloneNode(false);
              if (!parentNode) {
                duplicatedNode = cloned;
              } else {
                parentNode.appendChild(cloned);
              }
              parentNode = cloned;
            }
            removePlaceholderIfPresent();
            // split hierarchy and add delta style hierarchy
            this.split(existing, startNode, startOffset);
            ref = existing.nextSibling;
            existing.parentNode.insertBefore(duplicatedNode, ref);
            this.clean(existing, ref);
            // select the deepest (= last cloned) element of the delta styles
            sel.selectEmptyNode(context, cloned);
          }
        }
        return {
          'preventBookmarkRestore': true
        };
      }
      return undefined;
    },

    isCommand: function (cmdStr) {
      var cmdLC = cmdStr.toLowerCase();
      return (cmdLC === 'bold') || (cmdLC === 'italic') || (cmdLC === 'underline') ||
        (cmdLC === 'subscript') || (cmdLC === 'superscript') ||
        (cmdLC === 'style');
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_SELECTION | cmd.PO_BOOKMARK | cmd.PO_NODELIST;
    },

    execute: function (execDef) {
      var com = CUI.rte.Common;
      var nodeList = execDef.nodeList;
      var selection = execDef.selection;
      var context = execDef.editContext;
      var def = this._getParamsFromExecDef(execDef);
      if (def.isStyle && def.attributes.hasOwnProperty('class')) {
        // the "style" command may handle objects differently if a styleable object
        // is the only selection
        var selectedDom = CUI.rte.Selection.getSelectedDom(context, selection);
        var styleableObjects = CUI.rte.plugins.StylesPlugin.STYLEABLE_OBJECTS;
        var styleName = def.attributes['class'];
        if (selectedDom && com.isTag(selectedDom, styleableObjects)) {
          if (com.hasCSS(selectedDom, styleName)) {
            com.removeClass(selectedDom, styleName);
          } else {
            com.addClass(selectedDom, styleName);
          }
          return undefined;
        }
      }
      if (!CUI.rte.Selection.isSelection(selection)) {
        // execDef.editContext.doc.execCommand(execDef.command, false, null);
        return this.setCaretTo(execDef);
      }
      // see queryState()
      var tags = com.getTagInPath(context, selection.startNode, def.tag, def.attributes);
      var isActive = (tags !== null && tags !== undefined);
      if (!isActive) {
        nodeList.surround(execDef.editContext, def.tag, def.attributes);
      } else {
        nodeList.removeNodesByTag(execDef.editContext, def.tag, def.attributes, true);
      }
      return undefined;
    },

    queryState: function (selectionDef, cmd) {
      var com = CUI.rte.Common;
      var tagName = this._getTagNameForCommand(cmd);
      if (!tagName) {
        return undefined;
      }
      var context = selectionDef.editContext;
      var selection = selectionDef.selection;
      var taginPath = com.getTagInPath(context, selection.startNode, tagName);
      return (taginPath !== null && taginPath !== undefined);
    }

  });

// register command
  CUI.rte.commands.CommandRegistry.register('_defaultfmt',
    CUI.rte.commands.DefaultFormatting);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.Anchor
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.Anchor = new Class({

    toString: 'Anchor',

    extend: CUI.rte.commands.Command,

    addAnchorToDom: function (execDef) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var nodeList = execDef.nodeList;
      var id = execDef.value.anchorValue;
      var anchorEditingStyle = execDef.value.pluginConfig.anchorEditingStyle;
      var context = execDef.editContext;
      var anchors = [];
      nodeList.getNamedAnchors(context, anchors, false);
      if (anchors.length > 0) {
        // modify existing anchor(s)
        for (var i = 0; i < anchors.length; i++) {
          this.applyAnchorProperties(anchors[i].dom, id, anchorEditingStyle);
        }
      } else {
        // create new anchor
        var tagName;
        var attributes =  { };
        if (anchorEditingStyle) {
          attributes['style'] = anchorEditingStyle;
        } else {
          attributes['class'] = CUI.rte.Theme.ANCHOR_CLASS;
        }
        // Browsers can't properly edit "a" elements directly, hence substitute to "img" element e.g. CUI-4662
        tagName = 'img';
        attributes[com.A_ID_REPLACEMENT_ATTRIB] = id;
        var selection = execDef.selection;
        var dom = dpr.createNode(context, tagName, attributes);
        dpr.insertElement(context, dom, selection.startNode, selection.startOffset);
      }
    },

    /**
     * Applies anchor properties (name) to the given anchor dom element.
     * @param {HTMLElement} dom DOM element the link properties will be applied
     * @param {String} id id/name Name of the anchor
     * @private
     */
    applyAnchorProperties: function(dom, id, anchorEditingStyle) {
      var com = CUI.rte.Common;
      // some browsers may use a substitute, so we'll have to use a special attribute
      // instead
      if (!com.isTag(dom, 'a')) {
        com.setAttribute(dom, com.A_ID_REPLACEMENT_ATTRIB, id);
      } else {
        com.setAttribute(dom, 'id', id);
      }
      if (anchorEditingStyle) {
        com.setAttribute('style', anchorEditingStyle);
      } else {
        com.setAttribute(dom, 'class', CUI.rte.Theme.ANCHOR_CLASS);
      }
    },

    removeAnchorFromDom: function (execDef) {
      var dpr = CUI.rte.DomProcessor;
      var context = execDef.editContext;
      var nodeList = execDef.nodeList;
      var anchors = [];
      nodeList.getNamedAnchors(context, anchors, true);
      for (var i = 0; i < anchors.length; i++) {
        dpr.removeWithoutChildren(anchors[i].dom);
      }
    },

    isCommand: function (cmdStr) {
      var cmdLC = cmdStr.toLowerCase();
      return (cmdLC === 'anchor');
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_BOOKMARK | cmd.PO_SELECTION | cmd.PO_NODELIST;
    },

    execute: function (execDef) {
      var value = execDef.value;
      var anchorValue = value.anchorValue;
      if (anchorValue) {
        this.addAnchorToDom(execDef);
      } else {
        this.removeAnchorFromDom(execDef);
      }
    },

    queryState: function (selectionDef, cmd) {
      return (selectionDef.namedAnchorCount > 0);
    }

  });

// register command
  CUI.rte.commands.CommandRegistry.register('anchor', CUI.rte.commands.Anchor);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.CutCopy
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.CutCopy = new Class({

    toString: 'CutCopy',

    extend: CUI.rte.commands.Command,

    isCommand: function (cmdStr) {
      var cmdLC = cmdStr.toLowerCase();
      return (cmdLC === 'cut') || (cmdLC === 'copy');
    },

    execute: function (execDef) {

      var command = execDef.command;
      var doc = execDef.editContext.doc;

      var isSuccess = false;
      try {
        // additional IE eventing required to check if the cut/copy succeeded
        var isIESuccess = false;
        var successHandler = function () {
          isIESuccess = true;
        };
        var isIE = CUI.rte.Common.ua.isIE;
        if (isIE) {
          CUI.rte.Eventing.on(this.editContext, doc, command, successHandler);
        }
        isSuccess = doc.execCommand(command, false, null);
        if (isIE) {
          isSuccess = isIESuccess;
          CUI.rte.Eventing.un(this.editContext, doc, command, successHandler);
        }
      } catch (e) {
        // handled via isSuccess
      }
      if (!isSuccess) {
        throw new Error('Cannot ' + command + '.');
      }
    }

  });

// register command
  CUI.rte.commands.CommandRegistry.register('_cutcopy', CUI.rte.commands.CutCopy);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.Format
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.Format = new Class({

    toString: 'Format',

    extend: CUI.rte.commands.Command,

    isCommand: function (cmdStr) {
      return (cmdStr.toLowerCase() === 'format');
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_BOOKMARK | cmd.PO_SELECTION;
    },

    execute: function (execDef) {
      var dpr = CUI.rte.DomProcessor;
      var com = CUI.rte.Common;
      var dom;
      var selection = execDef.selection;
      var context = execDef.editContext;
      var containerList = dpr.createContainerList(context, selection);
      if (containerList.length === 0) {
        var nodeList = execDef.nodeList;
        if (!nodeList) {
          nodeList = dpr.createNodeList(context, selection);
        }
        var auxRoot = com.getTagInPath(context, nodeList.commonAncestor,
          dpr.AUXILIARY_ROOT_TAGS);
        if (auxRoot) {
          dom = dpr.createNode(execDef.editContext, execDef.value.tag);
          com.moveChildren(auxRoot, dom);
          auxRoot.appendChild(dom);
        }
      } else {
        dom = dpr.createNode(execDef.editContext, execDef.value.tag);
        dpr.changeContainerTag(execDef.editContext, containerList, dom, true);
      }
    },

    queryState: function (selectionDef, cmd) {
      // todo find a meaningful implementation -> list of container tags?
      return false;
    }

  });


// register command
  CUI.rte.commands.CommandRegistry.register('format', CUI.rte.commands.Format);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.Indent
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.Indent = new Class({

    toString: 'Indent',

    extend: CUI.rte.commands.Command,

    isCommand: function (cmdStr) {
      return (cmdStr.toLowerCase() === 'indent');
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_SELECTION | cmd.PO_BOOKMARK | cmd.PO_NODELIST;
    },

    execute: function (execDef) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var selection = execDef.selection;
      var nodeList = execDef.nodeList;
      var context = execDef.editContext;
      var tagExcl = CUI.rte.commands.Indent.TAGEXCL;
      var indents = nodeList.getTags(context, [{
        'matcher': function (dom) {
          if (com.isRootNode(context, dom)) {
            return false;
          }
          if (com.isTag(dom, com.BLOCK_TAGS) && !com.isTag(dom, tagExcl)) {
            return true;
          }
          return com.isTag(dom, 'li');
        }
      }], true, true);
      // change auxiliary roots and add them to the indents list
      var auxRoots = dpr.getAuxRoots(context, selection);
      var rootCnt = auxRoots.length;
      for (var r = 0; r < rootCnt; r++) {
        var rootToProcess = auxRoots[r];
        var childCnt = rootToProcess.childNodes.length;
        for (var c = 0 ; c < childCnt ; c++) {
          var child = rootToProcess.childNodes[c];
          if( !((com.isTag(child, com.BLOCK_TAGS) && !com.isTag(child, tagExcl)) || com.isTag(child, 'li')) ) {
            var pNode = context.createElement('p');
            com.insertBefore(rootToProcess,pNode,child.nextSibling);
            pNode.appendChild(child);
            indents.push({
              'dom': pNode
            });
          }
        }
      }
      // change indents of all detected block nodes
      var nodeCnt = indents.length;
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        var nodeToProcess = indents[nodeIndex];
        var dom = nodeToProcess.dom;
        if (com.isTag(dom, com.BLOCK_TAGS)) {
          // block nodes
          var marginLeft = 0;
          if (dom.style.marginLeft) {
            marginLeft = parseInt(dom.style.marginLeft, 10);
          }
          marginLeft += execDef.value ||
          CUI.rte.commands.Indent.DEFAULT_INDENT_SIZE;
          dom.style.marginLeft = marginLeft + 'px';
        } else {
          // list items
          var listProcessor = new CUI.rte.ListRepresentation();
          listProcessor.fromItem(context, dom);
          listProcessor.ensureHierarchy(context);
          listProcessor.indent(context, dom);
        }
      }
    },

    queryState: function (selectionDef, cmd) {
      var com = CUI.rte.Common;
      var context = selectionDef.editContext;
      var tagExcl = CUI.rte.commands.Indent.TAGEXCL;
      var indents = selectionDef.nodeList.getTags(context, [{
        'matcher': function (dom) {
          if (com.isRootNode(context, dom)) {
            return false;
          }
          if (com.isTag(dom, com.BLOCK_TAGS) && !com.isTag(dom, tagExcl)) {
            return !!dom.style.marginLeft;
          }
          return com.isTag(dom, 'li');
        }
      }
      ], true, true);
      return (indents.length > 0);
    }

  });

  /**
   * Block-tags that are excluded from being indented/outdented
   * @static
   * @final
   * @type String[]
   * @private
   */
  CUI.rte.commands.Indent.TAGEXCL = ['ul', 'ol', 'table'];

  /**
   * Default indent size
   * @static
   * @final
   * @type Number
   * @private
   */
  CUI.rte.commands.Indent.DEFAULT_INDENT_SIZE = 40;


// register command
  CUI.rte.commands.CommandRegistry.register('indent', CUI.rte.commands.Indent);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.InsertHtml
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.InsertHtml = new Class({

    toString: 'InsertHtml',

    extend: CUI.rte.commands.Command,

    isCommand: function (cmdStr) {
      return (cmdStr.toLowerCase() === 'inserthtml');
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_SELECTION;
    },

    execute: function (execDef) {
      var com = CUI.rte.Common;
      var htmlToInsert = execDef.value;
      var context = execDef.editContext;
      if (htmlToInsert && (htmlToInsert.length > 0)) {
        if (com.ua.isIE || com.ua.isGecko) {
          // even IE with W3C compliant selection model don't support the
          // "inserthtml" command, so use the old selection model + pasteHTML
          // to insert the HTML
          // Also, for Firefox (<=45) "inserthtml" does not work fine for '&nbsp;'. See CRTE-67
          try {
            var range = com.ua.isIE ? CUI.rte.Selection.saveNativeSelection(context) : CUI.rte.Selection.getLeadRange(context);
            if (range.pasteHTML) {
              range.pasteHTML(htmlToInsert);
            } else {
              var tempDiv = context.doc.createElement('div');
              tempDiv.innerHTML = htmlToInsert;
              var textFrag = context.doc.createDocumentFragment();
              var firstNode, lastNode;
              while ((firstNode = tempDiv.firstChild)) {
                lastNode = textFrag.appendChild(firstNode);
              }
              range.deleteContents();
              range.insertNode(textFrag);
              range.setStartAfter(lastNode);
            }
          } catch (e) {
            throw new Error('Could not insert html due to IE limitations.');
          }
        } else {
          context.doc.execCommand('inserthtml', false, htmlToInsert);
        }
      }
    },

    queryState: function (selectionDef, cmd) {
      return false;
    }

  });


// register command
  CUI.rte.commands.CommandRegistry.register('inserthtml',
    CUI.rte.commands.InsertHtml);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.Justify
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.Justify = new Class({

    toString: 'Justify',

    extend: CUI.rte.commands.Command,

    isCommand: function (cmdStr) {
      var com = CUI.rte.Common;
      return com.strStartsWith(cmdStr.toLowerCase(), 'justify');
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_SELECTION | cmd.PO_BOOKMARK;
    },

    alignTableCells: function (context, cellSelection, alignment) {
      var com = CUI.rte.Common;
      var cells = cellSelection.cells;
      var cellCnt = cells.length;
      for (var c = 0; c < cellCnt; c++) {
        var cellToAlign = cells[c];
        var baseStyle = com.getStyleProp(context, cellToAlign.parentNode, 'textAlign');
        baseStyle = (baseStyle ? baseStyle : 'left');
        if (baseStyle !== alignment) {
          cellToAlign.style.textAlign = alignment;
        } else {
          cellToAlign.style.textAlign = '';
        }
      }
    },

    execute: function (execDef) {
      var dpr = CUI.rte.DomProcessor;
      var com = CUI.rte.Common;
      var selection = execDef.selection;
      var cmd = execDef.command;
      var context = execDef.editContext;
      var textAlign = cmd.substring(7, cmd.length);
      if (selection.cellSelection) {
        this.alignTableCells(context, selection.cellSelection, textAlign);
      } else {
        var containers = dpr.createContainerList(context, selection);
        var containerCnt = containers.length;
        for (var containerIndex = 0; containerIndex < containerCnt; containerIndex++) {
          var containerToChange = containers[containerIndex];
          containerToChange.style.textAlign = textAlign;
        }
        var auxRoots = dpr.getAuxRoots(context, selection);
        var rootCnt = auxRoots.length;
        for (var r = 0; r < rootCnt; r++) {
          var auxRootDom = auxRoots[r];
          if (com.isTag(auxRootDom, [ 'td', 'th', 'caption' ])) {
            auxRootDom.style.textAlign = textAlign;
          }
        }
      }
    },

    queryState: function (selectionDef, cmd) {
      var com = CUI.rte.Common;
      var context = selectionDef.editContext;
      var containerList = com.arrayCopy(selectionDef.containerList);
      var auxRoots = selectionDef.auxRoots;
      var rootCnt = auxRoots.length;
      for (var r = 0; r < rootCnt; r++) {
        var root = auxRoots[r];
        if (com.isTag(root, [ 'td', 'th', 'caption' ])) {
          containerList.push(root);
        }
      }
      var align = cmd.substring(7, cmd.length);
      var selTextAlign = com.getConsistentStyle(context, containerList, 'textAlign',
        'left');
      return (align === selTextAlign);
    }

  });


// register command
  CUI.rte.commands.CommandRegistry.register('_justify', CUI.rte.commands.Justify);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.Link
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.Link = new Class({

    toString: 'Link',

    extend: CUI.rte.commands.Command,

    /**
     * Creates a styled link from the current selection.
     * @private
     */
    addLinkToDom: function (execDef) {
      var context = execDef.editContext;
      var nodeList = execDef.nodeList;
      var url = execDef.value.url;
      var styleName = execDef.value.css;
      var target = execDef.value.target;
      var attributes = execDef.value.attributes || {};
      var links = [];
      nodeList.getAnchors(context, links, true);
      if (links.length > 0) {
        // modify existing link(s)
        for (var i = 0; i < links.length; i++) {
          this.applyLinkProperties(links[i].dom, url, styleName, target, attributes);
        }
      } else {
        // create new link
        var sel = CUI.rte.Selection;
        var dpr = CUI.rte.DomProcessor;
        if (execDef.value.trimLinkSelection === true) {
          var range = sel.getLeadRange(context);
          range = sel.trimRangeWhitespace(context, range);
          sel.selectRange(context, range);
          nodeList = dpr.createNodeList(context, sel.createProcessingSelection(
            context));
        }
        // handle HREF problems on IE with undo (IE will deliberately change the
        // HREF, causing the undo mechanism to fail):
        var helperSpan = context.createElement('span');
        helperSpan.innerHTML = '<a href=\"' + url + '\"></a>';
        attributes.href = helperSpan.childNodes[0].href;
        attributes[CUI.rte.Common.HREF_ATTRIB] = helperSpan.childNodes[0].href;
        if (styleName) {
          attributes.className = styleName;
        }
        if (target) {
          attributes.target = target;
        } else {
          delete attributes.target;
        }
        for (var key in attributes) {
          if (attributes.hasOwnProperty(key)) {
            var attribValue = attributes[key];
            if ((attribValue === null) || (attribValue === undefined) || (attribValue.length === 0) ||
              (attribValue === CUI.rte.commands.Link.REMOVE_ATTRIBUTE)) {
              delete attributes[key];
            }
          }
        }
        nodeList.surround(context, 'a', attributes);
      }
    },

    /**
     * Applies link properties (href, style, target) to the given anchor dom element.
     * @param {HTMLElement} dom DOM element the link properties will be applied (should be
     * @param {String} url URL/href to set
     * @param {String} styleName Name of CSS class to apply
     * @param {String} target target frame of the link
     * @param {Object} addAttributes additional attributes
     * @private
     */
    applyLinkProperties: function (dom, url, styleName, target, addAttributes) {
      var com = CUI.rte.Common;
      dom.href = url;
      dom.setAttribute(CUI.rte.Common.HREF_ATTRIB, url);
      if (target) {
        com.setAttribute(dom, 'target', target);
      } else {
        com.removeAttribute(dom, 'target');
      }
      if (styleName) {
        com.setAttribute(dom, 'class', styleName);
      } else {
        com.removeAttribute(dom, 'class');
      }
      for (var attribName in addAttributes) {
        if (addAttributes.hasOwnProperty(attribName)) {
          var attribValue = addAttributes[attribName];
          if (attribValue && (attribValue.length > 0) &&
            (attribValue !== CUI.rte.commands.Link.REMOVE_ATTRIBUTE)) {
            com.setAttribute(dom, attribName, attribValue);
          } else {
            com.removeAttribute(dom, attribName);
          }
        }
      }
    },

    /**
     * Removes a styled link according to the current selection.
     * @private
     */
    removeLinkFromDom: function (execDef) {
      var dpr = CUI.rte.DomProcessor;
      var context = execDef.editContext;
      var nodeList = execDef.nodeList;
      var links = [];
      nodeList.getAnchors(context, links, true);
      for (var i = 0; i < links.length; i++) {
        dpr.removeWithoutChildren(links[i].dom);
      }
    },

    isCommand: function (cmdStr) {
      var cmdLC = cmdStr.toLowerCase();
      return (cmdLC === 'modifylink') || (cmdLC === 'unlink');
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_BOOKMARK | cmd.PO_SELECTION | cmd.PO_NODELIST;
    },

    execute: function (execDef) {
      switch (execDef.command.toLowerCase()) {
      case 'modifylink':
        this.addLinkToDom(execDef);
        break;
      case 'unlink':
        this.removeLinkFromDom(execDef);
        break;
      }
    },

    queryState: function (selectionDef, cmd) {
      return (selectionDef.anchorCount > 0);
    }

  });

  /**
   * Placeholder object for explicitly removing an attribute
   */
  CUI.rte.commands.Link.REMOVE_ATTRIBUTE = {};


// register command
  CUI.rte.commands.CommandRegistry.register('_link', CUI.rte.commands.Link);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.List
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.List = new Class({

    toString: 'List',

    extend: CUI.rte.commands.Command,

    isCommand: function (cmdStr) {
      var cmdStrLC = cmdStr.toLowerCase();
      return (cmdStrLC === 'insertorderedlist') || (cmdStrLC === 'insertunorderedlist');
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_SELECTION | cmd.PO_BOOKMARK | cmd.PO_NODELIST;
    },

    /**
     * Gets all list items of the current selection. Using this method will not include
     * items of a nested list if a nested list is completely covered in the selection.
     * @private
     */
    getListItems: function (execDef) {
      var context = execDef.editContext;
      return execDef.nodeList.getTags(context, [{
        'extMatcher': function (dom) {
          return {
            'isMatching': CUI.rte.Common.isTag(dom, 'li'),
            'preventRecursionIfMatching': true
          };
        }
      }
      ], true, true);
    },

    /**
     * Gets all list items of the current selection. Using this method will include
     * items of a nested list as well.
     * @private
     */
    getAllListItems: function (execDef) {
      var context = execDef.editContext;
      var allItems = execDef.nodeList.getTags(context, [{
        'matcher': function (dom) {
          return CUI.rte.Common.isTag(dom, 'li');
        }
      }
      ], true, true);
      CUI.rte.ListUtils.postprocessSelectedItems(allItems);
      return allItems;
    },

    /**
     * Gets the defining list element for the specified node list. The defining list element
     * is the list element that belongs to the first node contained in the list.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {CUI.rte.NodeList} nodeList The node list
     * @return {HTMLElement} The defining list DOM; null if the first node of the list
     *         is not part of a list
     */
    getDefiningListDom: function (context, nodeList) {
      var com = CUI.rte.Common;
      var determNode = nodeList.getFirstNode();
      if (determNode === null || determNode === undefined) {
        return null;
      }
      var determDom = determNode.dom;
      while (determDom) {
        if (com.isTag(determDom, com.LIST_TAGS)) {
          return determDom;
        }
        determDom = com.getParentNode(context, determDom);
      }
      return null;
    },

    /**
     * Splits the specified array of list items into separate arrays of items for each
     * top-level list.
     * @private
     */
    splitToTopLevelLists: function (execDef, listItems) {
      var context = execDef.editContext;
      var itemsPerList = [];
      var topLevelLists = [];
      var itemCnt = listItems.length;
      for (var i = 0; i < itemCnt; i++) {
        var itemToCheck = listItems[i];
        var listDom = CUI.rte.ListUtils.getTopListForItem(context, itemToCheck.dom);
        var listIndex = CUI.rte.Common.arrayIndex(topLevelLists, listDom);
        if (listIndex < 0) {
          topLevelLists.push(listDom);
          itemsPerList.push([itemToCheck]);
        } else {
          itemsPerList[listIndex].push(itemToCheck);
        }
      }
      return itemsPerList;
    },

    /**
     * Changes the list type of all selected list items, inserting additional tables
     * as required.
     * @private
     */
    changeItemsListType: function (execDef, listItems, listType) {
      var com = CUI.rte.Common;
      var context = execDef.editContext;
      var itemCnt = listItems.length;
      for (var i = 0; i < itemCnt; i++) {
        var item = listItems[i].dom;
        var list = item.parentNode;
        if (!com.isTag(list, listType)) {
          // Change item ...
          var prevSib = list.previousSibling;
          var nextSib = list.nextSibling;
          var isFirst = (com.getChildIndex(item) === 0);
          var isLast = (com.getChildIndex(item) === (list.childNodes.length - 1));
          if (isFirst && prevSib && com.isTag(prevSib, listType)) {
            // move to preceding list of correct type
            list.removeChild(item);
            prevSib.appendChild(item);
            if (list.childNodes.length === 0) {
              list.parentNode.removeChild(list);
            }
          } else if (isLast && nextSib && com.isTag(nextSib, listType)) {
            // move to succeeding list of correct type
            list.removeChild(item);
            com.insertBefore(nextSib, item, nextSib.firstChild);
            if (list.childNodes.length === 0) {
              list.parentNode.removeChild(list);
            }
          } else {
            // we need a new list
            var newList = context.createElement(listType);
            if (item === list.firstChild) {
              // create new list before existing list
              com.insertBefore(list.parentNode, newList, list);
            } else if (item === list.lastChild) {
              // create new list after existing list
              com.insertBefore(list.parentNode, newList, list.nextSibling);
            } else {
              // split list
              var splitList = list.cloneNode(false);
              com.insertBefore(list.parentNode, splitList, list);
              com.insertBefore(list.parentNode, newList, list);
              while (list.childNodes[0] !== item) {
                var domToMove = list.childNodes[0];
                list.removeChild(domToMove);
                splitList.appendChild(domToMove);
              }
            }
            list.removeChild(item);
            newList.appendChild(item);
            if (list.childNodes.length === 0) {
              list.parentNode.removeChild(list);
            }
          }
        }
      }
    },

    /**
     * Creates a new list from all (allowed) block nodes defined in the selection.
     * @private
     */
    createListFromSelection: function (execDef, listType) {
      var nodeList = execDef.nodeList;
      var context = execDef.editContext;
      // todo distinguish between entire cell and parts of a cell
      var blockLists = nodeList.getEditBlocksByAuxRoots(context, true);
      var listCnt = blockLists.length;
      for (var l = 0; l < listCnt; l++) {
        CUI.rte.ListUtils.createList(context, blockLists[l], listType);
      }
    },

    /**
     * Removes items from a list by appending them to their respective parent item
     * (including a separating "br" line break).
     * @private
     */
    unlistItems: function (execDef, listItems, keepStructure) {
      if (!listItems) {
        listItems = this.getAllListItems(execDef);
      }
      var context = execDef.editContext;
      var itemCnt = listItems.length;
      var itemsDom = [];
      for (var i = 0; i < itemCnt; i++) {
        itemsDom.push(listItems[i].dom);
      }
      CUI.rte.ListUtils.unlistItems(context, itemsDom, keepStructure);
    },


    execute: function (execDef) {
      var com = CUI.rte.Common;
      var context = execDef.editContext;
      var nodeList = execDef.nodeList;
      var command = execDef.command;
      var value = execDef.value;
      var listType = null;
      switch (command.toLowerCase()) {
      case 'insertorderedlist':
        listType = 'ol';
        break;
      case 'insertunorderedlist':
        listType = 'ul';
        break;
      }
      if (listType) {
        var listItems;
        var refList = this.getDefiningListDom(context, nodeList);
        if (refList === null || refList === undefined) {
          // creating new list (and joining existing lists)
          this.createListFromSelection(execDef, listType);
        } else if (!com.isTag(refList, listType)) {
          // change list type of selected items (or entire list)
          listItems = this.getListItems(execDef);
          this.changeItemsListType(execDef, listItems, listType);
        } else {
          // unlist all items of lead list
          listItems = this.getAllListItems(execDef);
          if (listItems.length > 0) {
            var itemsByList = this.splitToTopLevelLists(execDef, listItems);
            var listCnt = itemsByList.length;
            for (var l = 0; l < listCnt; l++) {
              listItems = itemsByList[l];
              this.unlistItems(execDef, listItems, value === true);
            }
          }
        }
      }
    },

    queryState: function (selectionDef, cmd) {
      var com = CUI.rte.Common;
      var context = selectionDef.editContext;
      var nodeList = selectionDef.nodeList;
      var tagName;
      switch (cmd.toLowerCase()) {
      case 'insertorderedlist':
        tagName = 'ol';
        break;
      case 'insertunorderedlist':
        tagName = 'ul';
        break;
      }
      var definingList = this.getDefiningListDom(context, nodeList);
      return ((definingList !== null && definingList !== undefined) && com.isTag(definingList, tagName));
    }

  });

  /**
   * Placeholder for "no list functionality available"
   */
  CUI.rte.commands.List.NO_LIST_AVAILABLE = {};


// register command
  CUI.rte.commands.CommandRegistry.register('_list', CUI.rte.commands.List);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.Outdent
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.Outdent = new Class({

    toString: 'Outdent',

    extend: CUI.rte.commands.Command,

    isCommand: function (cmdStr) {
      return (cmdStr.toLowerCase() === 'outdent');
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_SELECTION | cmd.PO_BOOKMARK | cmd.PO_NODELIST;
    },

    execute: function (execDef) {
      var com = CUI.rte.Common;
      var nodeList = execDef.nodeList;
      var context = execDef.editContext;
      var tagExcl = CUI.rte.commands.Indent.TAGEXCL;
      var indents = nodeList.getTags(context, [{
        'matcher': function (dom) {
          if (com.isRootNode(context, dom)) {
            return false;
          }
          if (com.isTag(dom, com.BLOCK_TAGS) && !com.isTag(dom, tagExcl)) {
            return !!dom.style.marginLeft;
          }
          return com.isTag(dom, 'li');
        }
      }
      ], true, true);
      // check each item if it is actually contained in the selection (may be not the
      // case for nested lists in several situations)
      CUI.rte.ListUtils.postprocessSelectedItems(indents);
      // finally, execute the outdenting
      var nodeCnt = indents.length;
      var lists = [];
      var listItemsToOutdent = [];
      for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
        var nodeToProcess = indents[nodeIndex];
        var dom = nodeToProcess.dom;
        if (com.isTag(dom, com.BLOCK_TAGS)) {
          // handle block nodes ourselves
          var marginLeft = 0;
          if (dom.style.marginLeft) {
            marginLeft = parseInt(dom.style.marginLeft, 10);
            marginLeft -= execDef.value ||
            CUI.rte.commands.Indent.DEFAULT_INDENT_SIZE;
            if (marginLeft <= 0) {
              dom.style.marginLeft = null;
            } else {
              dom.style.marginLeft = marginLeft + 'px';
            }
          }
        } else {
          // list items
          var listDom = CUI.rte.ListUtils.getTopListForItem(context, dom);
          var listIndex = com.arrayIndex(lists, listDom);
          if (listIndex < 0) {
            lists.push(listDom);
            listItemsToOutdent.push([dom]);
          } else {
            listItemsToOutdent[listIndex].push(dom);
          }
        }
      }
      for (var l = 0; l < lists.length; l++) {
        // outdent list items (per top level list)
        var listProcessor = new CUI.rte.ListRepresentation();
        listProcessor.fromList(lists[l]);
        listProcessor.ensureHierarchy(context);
        listProcessor.outdent(context, listItemsToOutdent[l]);
      }
    }

  });


// register command
  CUI.rte.commands.CommandRegistry.register('outdent', CUI.rte.commands.Outdent);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.Paste
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.Paste = new Class({

    toString: 'Paste',

    extend: CUI.rte.commands.Command,

    /**
     * Pre-processing module (DOM-based)
     * @private
     * @type CUI.rte.DomCleanup
     */
    domPreProcessor: null,

    handleLineFeedsPlaceholders: function (context, containers) {
      var com = CUI.rte.Common;
      var containerCnt = containers.length;
      for (var c = 0; c < containerCnt; c++) {
        var lastTextNode = com.getLastTextChild(containers[c], true, false);
        if (com.isTag(lastTextNode, 'br')) {
          if (com.isAttribDefined(lastTextNode, com.BR_TEMP_ATTRIB)) {
            // we need to keep the final placeholder if the previous node is
            // another linefeed or a space (Gecko)
            var prevNode = com.getPreviousCharacterNode(context, lastTextNode,
              com.EDITBLOCK_TAGS);
            if (prevNode && !com.isTag(prevNode, 'br')) {
              var text = com.getNodeText(prevNode);
              if (!com.ua.isGecko || !text || !com.strEndsWith(text, ' ')) {
                lastTextNode.parentNode.removeChild(lastTextNode);
              }
            }
          }
        }
      }
    },

    pasteAsPlainText: function (execDef) {

      var hpr = CUI.rte.HtmlProcessor;
      var dpr = CUI.rte.DomProcessor;
      var sel = CUI.rte.Selection;
      var com = CUI.rte.Common;

      var html = execDef.value.html;
      var text = execDef.value.text;
      var context = execDef.editContext;

      // preprocess plain text if necessary
      var plainText;
      if (text !== null && text !== undefined) {
        plainText = text;
      } else {
        var helperDiv = context.doc.createElement('div');
        helperDiv.innerHTML = html;
        plainText = com.getInnerText(helperDiv);
        plainText = hpr.stripSurroundingWhitespace(plainText, true);
        if (execDef.value.stripHtmlTags) {
          plainText = CUI.rte.Utils.htmlDecode(plainText);
          plainText = CUI.rte.Utils.stripTags(plainText);
        }
      }

      var containersAffected = [];
      // insert paragraph by paragraph (indicated by two linefeeds); different mode if
      // paste is executed inside a list
      var pSel = sel.createProcessingSelection(context);
      var insertNode = pSel.startNode;
      var insertOffset = pSel.startOffset;
      var isListPaste = com.containsTagInPath(context, insertNode, 'li');
      // normalize linefeeds beforehand
      plainText = plainText.replace(/\r\n/g, '\n');
      plainText = plainText.replace(/\r/g, '\n');
      // Tabs to spaces
      plainText = plainText.replace(/\t/g, ' ');
      // use String for split, as IE will remove empty items/lines if a RegExp is used ...
      var splitRegEx = (isListPaste ? '\n' : '\n\n');
      var paras = plainText.split(splitRegEx);
      var paraCnt = paras.length;
      // Gecko-Bug: when everything is selected and something is pasted, it deletes
      // everything and we will have to ensure that we have an empty paragraph we can
      // paste to
      if (com.isRootNode(context, insertNode)) {
        insertNode = dpr.ensureMinimumContent(context);
        insertOffset = null;
      }
      containersAffected.push(dpr.getEditBlock(context, insertNode));

      for (var paraIndex = 0; paraIndex < paraCnt; paraIndex++) {
        if (paraIndex > 0) {
          // insertParagraph and insertText have different interpretations for
          // insertOffset == null -> insertParagraph interprets it as "behind
          // last child node", whereas insertText interprets it as "before first
          // child node"; insertOffset can only be null if an empty line gets
          // pasted (and insertText gets never called), as insertText will never
          // return null as a new insertOffset
          if (insertOffset === null || insertOffset === undefined) {
            var firstTextChild = com.getFirstTextChild(insertNode, true);
            if (firstTextChild && !com.isOneCharacterNode(firstTextChild)) {
              insertNode = firstTextChild;
            }
            insertOffset = 0;
          }
          insertNode = dpr.insertParagraph(context, insertNode, insertOffset);
          insertOffset = null;
          containersAffected.push(insertNode);
        }
        var lines = paras[paraIndex].split('\n');
        var lineCnt = lines.length;
        for (var lineIndex = 0; lineIndex < lineCnt; lineIndex++) {
          var line = lines[lineIndex];
          if (lineIndex > 0) {
            var brNode = context.createElement('br');
            // see above: insertElement/insertParagraph interpret an insertOffset
            // of null differently than insertText does; so we'll have to convert it
            // here
            var elOffset = ((insertOffset === null || insertOffset === undefined) ? 0 : insertOffset);
            dpr.insertElement(context, brNode, insertNode, elOffset);
            insertNode = brNode.parentNode;
            insertOffset = com.getChildIndex(brNode) + 1;
          }
          if (line !== '') {
            var def = dpr.insertText(context, insertNode, insertOffset, line);
            insertNode = def.node;
            insertOffset = def.offset;
          }
        }
      }
      this.handleLineFeedsPlaceholders(context, containersAffected);
      return {
        'startNode': insertNode,
        'startOffset': insertOffset
      };
    },

    /**
     * Cleans up DOM by adjusting the DOM structure (remove unnecessary whitespace,
     * correcting list nesting, removing invalid tags, etc.).
     * @param {CUI.rte.EditContext} context The edit context
     * @param {CUI.rte.EditorKernel} editorKernel The editor kernel
     * @param {HTMLElement} dom Root node to clean up
     * @param {Object} pasteRules The paste rules, as configured through the plugin
     * @private
     */
    cleanUpDom: function (context, editorKernel, dom, pasteRules) {
      var com = CUI.rte.Common;
      var hpr = CUI.rte.HtmlProcessor;
      var pasteRemovalRules = [{
        // extended additional cleanup for paste
        'fn': function (dom) {
          // only handle structural nodes
          if (dom.nodeType !== 1) {
            return false;
          }
          // remove images that point to a file:// location
          if (com.isTag(dom, 'img')) {
            var src = dom['src'];
            // if a RTE-specific SRC attribute is available, use it for more
            // accuracy
            if (dom[com.SRC_ATTRIB]) {
              src = dom[com.SRC_ATTRIB];
            }
            // don't accept images that have a file:// protocol
            if (!src || com.strStartsWith(src, 'file://')) {
              return true;
            }
            var style = com.getAttribute(dom, 'style');
            if (style) {
              var styleDef = hpr.parseStyleDef(style);
              if (styleDef.width) {
                com.setAttribute(dom, 'width', parseInt(styleDef.width, 10));
              }
              if (styleDef.height) {
                com.setAttribute(dom, 'height', parseInt(styleDef.height, 10));
              }

            }
          }
          return false;
        },
        'keepChildren': false
      }, {
        // additional tags to remove
        'tagName': [/* "span" */ 'font'],
        'keepChildren': true
      }
      ];
      CUI.rte.WhitespaceProcessor.process(context, dom, pasteRemovalRules, false);
      this.domPreProcessor.prepareHtmlPaste(editorKernel, dom, pasteRules);
    },

    /**
     * Pastes table content to an existing table, correctly extending it.
     * @param {Object} execDef Execution definition
     * @private
     */
    pasteTableToTable: function (execDef) {
      var com = CUI.rte.Common;
      var context = execDef.editContext;
      var html;
      var pastedDom = execDef.value.dom;
      var pastedTable = com.getTags(pastedDom, 'table');
      if (pastedTable.length !== 1) {
        this.insertHtml(execDef);
        return;
      }
      var undoHtml = context.root.innerHTML;
      var selection = execDef.selection;
      var nodeList = execDef.nodeList;
      var destTable = com.getTagInPath(context, nodeList.commonAncestor, 'table');
      var pasteMatrix = new CUI.rte.TableMatrix();
      pasteMatrix.createTableMatrix(pastedTable[0]);
      pasteMatrix.createFullMatrix();
      var destMatrix = new CUI.rte.TableMatrix();
      destMatrix.createTableMatrix(destTable);
      var selectedCell = null;
      var cells = null;
      var insertCellDom = null;
      var editorKernel = execDef.component;
      var r, c, cellToInsert, insertBefore, insertBeforeDom, pNode;
      if (selection.cellSelection) {
        cells = selection.cellSelection.cells;
        if (cells && (cells.length === 1)) {
          selectedCell = cells[0];
        }
      } else {
        // On IE, there might be a single "td" selected if the caret is placed in an
        // empty cell. This must be handled/considered beforehand.
        if (nodeList.nodes && (nodeList.nodes.length === 1)) {
          var firstNode = nodeList.nodes[0].dom;
          if (com.isTag(firstNode, com.TABLE_CELLS) &&
            (firstNode.childNodes.length === 0)) {
            selectedCell = firstNode;
          }
        }
        if (selectedCell === null || selectedCell === undefined) {
          selectedCell = com.getTagInPath(context, nodeList.commonAncestor,
            com.TABLE_CELLS);
        }
      }
      if (selectedCell) {
        // Mode 1: if only one cell is selected, the existing table is being extended
        // to fit the pasted table.
        var selectedCellDef = destMatrix.getCellDef(selectedCell);
        var pasteSize = pasteMatrix.getTableSize();
        var destSize = destMatrix.getTableSize();
        var destCol = selectedCellDef.col;
        var destRow = selectedCellDef.row;
        var extendCols = (destCol + pasteSize.cols) - destSize.cols;
        var extendRows = (destRow + pasteSize.rows) - destSize.rows;
        extendCols = (extendCols >= 0 ? extendCols : 0);
        extendRows = (extendRows >= 0 ? extendRows : 0);
        destMatrix.extendBy(context, extendCols, extendRows);
        try {
          insertCellDom = destMatrix.mergeToSingleCell(context, destCol, destRow,
            pasteSize.cols, pasteSize.rows);
        } catch (e) {
          context.root.innerHTML = undoHtml;
          if (e.message === 'Invalid table structure.') {
            // todo implement nicely
            editorKernel.getDialogManager().alert(
              CUI.rte.Utils.i18n('commands.paste.alertTitle'),
              CUI.rte.Utils.i18n('commands.paste.alertTableError'));
            return;
          }
          throw e;
        }
        destMatrix.createTableMatrix(destTable);
        destMatrix.createFullMatrix();
        insertCellDom.parentNode.removeChild(insertCellDom);
        for (r = 0; r < pasteSize.rows; r++) {
          for (c = 0; c < pasteSize.cols; c++) {
            cellToInsert = pasteMatrix.fullMatrix[r][c];
            if (cellToInsert.isOrigin) {
              insertBefore = destMatrix.getFollowUpCell(c + destCol,
                r + destRow);
              insertBeforeDom = (insertBefore ? insertBefore.cellDom : null);
              pNode = destMatrix.getRowDom(r + destRow);
              var cellDom = cellToInsert.cellRef.cellDom;
              var helperSpan = context.createElement('span');
              // as dynamic table handling is completely screwed up in IE, we'll
              // have to do it the hard way here ...
              helperSpan.innerHTML = '<table><tr><td></td></tr></table>';
              var tdDom = CUI.rte.Query.selectNode('td:first', helperSpan);
              var trDom = tdDom.parentNode;
              com.replaceNode(tdDom, cellDom);
              html = trDom.innerHTML;
              if (!html) {
                html = '<td>' + (com.ua.isIE ? '&nbsp;' : '<br>') + '</td>';
              }
              if (com.ua.isIE) {
                com.removeAllChildren(helperSpan);
                helperSpan.innerHTML = '<table><tr>' + html + '</tr></table>';
                trDom = CUI.rte.Query.selectNode('tr:first', helperSpan);
              } else {
                trDom.innerHTML = html;
              }
              pNode.insertBefore(trDom.childNodes[0], insertBeforeDom);
            }
          }
        }
      } else if (cells) {
        // Mode 2: If more than one table cell is selected, the selected cells are
        // replaced by the table to be pasted if possible (must be a rectangular cell
        // selection). The table is pasted as a nested table.
        var cellSel = destMatrix.createSelection(selection.cellSelection.cells);
        if (!cellSel.selectionProps.isRect) {
          editorKernel.getDialogManager().alert(
            CUI.rte.Utils.i18n('commands.paste.alertTitle'),
            CUI.rte.Utils.i18n('commands.paste.alertCellSelectionError'));
          return;
        }
        try {
          insertCellDom = destMatrix.mergeToSingleCell(context,
            cellSel.selectionProps.minCol, cellSel.selectionProps.minRow,
            cellSel.selectionProps.cols, cellSel.selectionProps.rows);
        } catch (e) {
          context.root.innerHTML = undoHtml;
          if (e.message === 'Invalid table structure.') {
            // todo implement nicely
            editorKernel.getDialogManager().alert(
              CUI.rte.Utils.i18n('commands.paste.alertTitle'),
              CUI.rte.Utils.i18n('commands.paste.alertTableError'));
            return;
          }
          throw e;
        }
        com.removeAllChildren(insertCellDom);
        insertCellDom.innerHTML = pastedDom.innerHTML;
      }
    },

    /**
     * <p>Removes superfluos DIVs.</p>
     * <p>For example: &lt;div&gt;&lt;p&gt;...&lt;/p&gt;&lt;div&gt; contains a superflous
     * div that has to be discarded (and the contained paragraphs have to be moved up
     * one hierarchical level).</p>
     * @param {HTMLElement} divDom The div to preprocess
     * @private
     */
    // todo move to DomCleanup?
    preprocessDiv: function (divDom) {
      var com = CUI.rte.Common;
      var c, divChildCnt, divChild;
      // recurse first
      divChildCnt = divDom.childNodes.length;
      for (c = divChildCnt - 1; c >= 0; c--) {
        divChild = divDom.childNodes[c];
        if (com.isTag(divChild, 'div')) {
          this.preprocessDiv(divChild);
        }
      }
      // handle Block-Tags that are nested in DIVs correctly
      var hasBlockTags = false;
      divChildCnt = divDom.childNodes.length;
      for (c = divChildCnt - 1; c >= 0; c--) {
        divChild = divDom.childNodes[c];
        if (com.isTag(divChild, com.BLOCK_TAGS)) {
          if (!com.hasTextChild(divChild)) {
            divDom.removeChild(divChild);
          } else {
            hasBlockTags = true;
          }
        }
      }
      if (hasBlockTags) {
        divChildCnt = divDom.childNodes.length;
        for (c = divChildCnt - 1; c >= 0; c--) {
          divChild = divDom.childNodes[c];
          divDom.removeChild(divChild);
          if (divDom.nextSibling) {
            divDom.parentNode.insertBefore(divChild, divDom.nextSibling);
          } else {
            divDom.parentNode.appendChild(divChild);
          }
        }
        divDom.parentNode.removeChild(divDom);
      } else if (!com.hasTextChild(divDom, true)) {
        // if div is without content now, remove it
        divDom.parentNode.removeChild(divDom);
      }
    },

    insertInExistingNode: function (context, insertDef, insertParent) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var sel = CUI.rte.Selection;
      var insertNode = insertDef.startNode;
      var insertOffset = insertDef.startOffset;
      // we can't use insert node and offset if we are pointing behind the end of a
      // text node that's inside a link
      if (insertOffset === sel.getLastSelectionOffset(context, insertNode, false)) {
        var checkNode = insertNode;
        while (checkNode) {
          checkNode = com.getTagInPath(context, checkNode, 'a');
          if (checkNode && com.isAttribDefined(checkNode, 'href')) {
            var nn = com.getNextNode(context, checkNode);
            var ntn = null;
            if (nn !== null && nn !== undefined) {
              ntn = com.getNextCharacterNode(context, nn, com.EDITBLOCK_TAGS);
            }
            if (ntn) {
              insertNode = ntn;
              insertOffset = sel.getFirstSelectionOffset(context, ntn);
            } else {
              insertNode = checkNode.parentNode;
              insertOffset = null;
            }
            break;
          }
        }
      }
      // determine node insert position (we'll use a single node as insert point and
      // move the pasted content nodes before, behind or "as child of" that node insert
      // point)
      var insertBehind, insertAsChild;
      if (insertNode.nodeType === 3) {
        if (insertOffset === 0) {
          insertBehind = false;
          insertAsChild = false;
        } else if (insertOffset === com.getNodeCharacterCnt(insertNode)) {
          insertBehind = true;
          insertAsChild = false;
        } else {
          var splitText = dpr.splitTextNode(context, insertNode, insertOffset);
          insertNode = splitText[splitText.length - 1];
          insertBehind = false;
          insertAsChild = false;
        }
      } else if (com.isOneCharacterNode(insertNode)) {
        insertBehind = (insertOffset === 0) || com.isTag(insertNode, 'br');
        insertAsChild = false;
      } else if (insertNode.nodeType === 1) {
        if ((insertOffset === undefined) ||
          (insertOffset === insertNode.childNodes.length)) {
          insertBehind = false;
          insertAsChild = true;
        } else {
          insertNode = insertNode[insertOffset];
          insertBehind = false;
          insertAsChild = true;
        }
      }
      // insert child by child
      var insertChildren = com.childNodesAsArray(insertParent);
      var insertCnt = insertChildren.length;
      for (var i = 0; i < insertCnt; i++) {
        var childToMove = insertChildren[i];
        insertParent.removeChild(childToMove);
        if (insertAsChild) {
          insertNode.appendChild(childToMove);
        } else if (insertBehind) {
          com.insertBefore(insertNode.parentNode, childToMove,
            insertNode.nextSibling);
          insertNode = childToMove;
        } else {
          com.insertBefore(insertNode.parentNode, childToMove, insertNode);
        }
      }
      // remove duplicate structures (<b>text <b>Pasted</b> text</b> ->
      // <b>text Pasted text</b>)
      var dupCheckEnd = insertChildren[insertCnt - 1];
      var finalNode = com.getLastChild(dupCheckEnd);
      if (finalNode !== null && finalNode !== undefined) {
        dupCheckEnd = finalNode;
      }
      var def = dpr.removeDuplicateStructures(context, insertChildren[0], dupCheckEnd);
      return {
        'startNode': def.endNode,
        'startOffset': CUI.rte.Selection.getLastSelectionOffset(context,
          def.endNode, false)
      };
    },

    insertAsSingleLine: function (context, insertDef, insertParent) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var emptyBlock = dpr.getEmptyLine(context, insertDef);
      if (emptyBlock !== null && emptyBlock !== undefined) {
        // this one is easy: simply replace the empty block
        com.removeAllChildren(emptyBlock);
        com.moveChildren(insertParent, emptyBlock);
        return {
          'startNode': emptyBlock,
          'startOffset': undefined
        };
      }
      // otherwise, insert node-by-node at the specified starting point
      return this.insertInExistingNode(context, insertDef, insertParent);
    },

    // todo move to DomCleanup?
    ensureBlockStructure: function (context, dom) {
      var com = CUI.rte.Common;
      var children = dom.childNodes;
      var childCnt = children.length;
      for (var c = childCnt - 1; c >= 0; c--) {
        var childToProcess = children[c];
        if (!com.isTag(childToProcess, com.BLOCK_TAGS)) {
          var helperPara = context.createElement('p');
          var insertRef = childToProcess.nextSibling;
          dom.removeChild(childToProcess);
          helperPara.appendChild(childToProcess);
          while (c > 0) {
            c--;
            var childToCheck = children[c];
            if (com.isTag(childToCheck, com.BLOCK_TAGS)) {
              c++;
              break;
            }
            dom.removeChild(childToCheck);
            helperPara.insertBefore(childToCheck, helperPara.firstChild);
          }
          com.insertBefore(dom, helperPara, insertRef);
          childToProcess = helperPara;
        }
      }
    },

    preprocessPastedDom: function (editorKernel, pastedDom, pasteRules) {
      var com = CUI.rte.Common;
      var context = editorKernel.getEditContext();
      // preprocess: ensure correct top-level DOM structure of pasted content
      var childCnt = pastedDom.childNodes.length;
      var children = pastedDom.childNodes;
      for (var c = childCnt - 1; c >= 0; c--) {
        var childToPreProcess = children[c];
        if (com.isTag(childToPreProcess, com.BLOCK_TAGS)) {
          if (com.isTag(childToPreProcess, 'div')) {
            this.preprocessDiv(childToPreProcess);
          }
        }
      }
      // preprocess: ensure correct block structure
      this.ensureBlockStructure(context, pastedDom);
    },

    splitExistingNode: function (context, node, offset) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var sel = CUI.rte.Selection;
      // handle begin and end of editing block correctly (must not split there)
      var editBlock = com.getTagInPath(context, node, com.EDITBLOCK_TAGS);
      if (!editBlock) {
        throw new Error('No edit block found. Cannot split node.');
      }
      var firstChild = com.getFirstChild(editBlock);
      if (firstChild === node) {
        if (offset === sel.getFirstSelectionOffset(context, node)) {
          return {
            'insertPoint': editBlock,
            'insertBehind': false
          };
        }
      }
      var lastChild = com.getLastChild(editBlock);
      if (lastChild === node) {
        if (offset === sel.getLastSelectionOffset(context, node, false)) {
          return {
            'insertPoint': editBlock,
            'insertBehind': true
          };
        }
      }
      // include one character node if necessary
      if (com.isOneCharacterNode(node)) {
        if (offset === 0) {
          node = com.getNextNode(context, node);
          offset = null;
        }
      }
      // split
      var insertPoint = dpr.splitToParent(editBlock, node, offset);
      var insertBehind = false;
      return {
        'insertPoint': insertPoint,
        'insertBehind': insertBehind
      };
    },

    /**
     * Inserts the pasted content as HTML. Works around IE problems regarding inserting
     * tables and ensures paste results that are independent from browser-specific
     * implementations.
     * @param {Object} execDef Execution definition
     * @private
     */
    insertHtml: function (execDef) {

      var dpr = CUI.rte.DomProcessor;
      var sel = CUI.rte.Selection;
      var com = CUI.rte.Common;
      var atomicBlocks = CUI.rte.commands.Paste.ATOMIC_PROCESSING_BLOCKS;

      var context = execDef.editContext;
      var pastedDom = execDef.value.dom;
      var pSel = sel.createProcessingSelection(context);
      // handle multi cell selection by pasting to the first selected cell
      if (pSel.cellSelection && pSel.cellSelection.cells) {
        if (pSel.cellSelection.cells.length > 0) {
          var startNode = pSel.cellSelection.cells[0];
          var startOffset = null;
          var ftn = com.getFirstTextChild(startNode, true);
          if (ftn) {
            startNode = ftn;
            startOffset = sel.getFirstSelectionOffset(context, ftn);
          }
          pSel.startNode = startNode;
          pSel.startOffset = startOffset;
          pSel.endNode = null;
          pSel.endOffset = null;
        }
      }
      var isAtomic, insertLoc, c;
      var insertBehind = false;
      var insertAsChild = false;

      this.preprocessPastedDom(execDef.component, pastedDom, execDef.value.pasteRules);
      var children = pastedDom.childNodes;
      var childCnt = children.length;

      if (childCnt === 0) {
        // nothing to paste at all
        return null;
      }

      var caretNode = pSel.startNode;
      var isListInsert = com.getTagInPath(context, caretNode, ['ul', 'ol']);
      // if we got a list as the only thing to insert, and we're inserting in a list,
      // then we'll insert list items instead of an entire list
      if (childCnt === 1) {
        if (com.isTag(children[0], ['ul', 'ol'])) {
          if (isListInsert) {
            pastedDom = children[0];
            children = pastedDom.childNodes;
            childCnt = children.length;
          }
        }
      }

      // if we're inserting into a list, we'll convert all non-list related containers
      // to list items (<p>Para</p> -> <li>Para</li>)
      if (isListInsert) {
        var blueprint = context.createElement('li');
        for (c = childCnt - 1; c >= 0; c--) {
          var child = children[c];
          if (com.isTag(child, ['ul', 'ol'])) {
            // take list items
            var items = child.childNodes;
            while (items.length > 0) {
              var itemToMove = items[0];
              pastedDom.insertBefore(itemToMove, child);
            }
            pastedDom.removeChild(child);
          } else if (!com.isTag(child, 'li')) {
            dpr.changeContainerTag(context, [child], blueprint, false);
          }
        }
        childCnt = children.length;
      }

      if (childCnt === 1) {
        isAtomic = com.isTag(children[0], atomicBlocks);
        if (!isAtomic) {
          return this.insertAsSingleLine(context, pSel, children[0]);
        }
      }

      // if we are inserting multiple blocks into a table, ensure that the table cell
      // contains block content, as otherwise we would destroy the table's structure
      var tableCell = com.getTagInPath(context, caretNode, ['td', 'th']);
      if (tableCell !== null && tableCell !== undefined) {
        this.ensureBlockStructure(context, tableCell);
      }

      // working on a copy of the block list ...
      children = com.childNodesAsArray(pastedDom);
      // if we are pasting to an empty block which is no table cell, we will replace this
      // block with the new content
      var emptyBlock = dpr.getEmptyLine(context, pSel);
      var isFullReplace = (emptyBlock !== null && emptyBlock !== undefined) && !com.isTag(emptyBlock, ['td', 'th']);
      var isEnforcedAtomic = false;
      if (isFullReplace) {
        insertLoc = emptyBlock;
        insertBehind = false;
        isEnforcedAtomic = true;
      }
      if ((emptyBlock !== null && emptyBlock !== undefined) && !isFullReplace) {
        // Gecko will have a "br" node, which is recognized as "empty block" correctly;
        // get rid of it, as we'll replace the entire content
        com.removeAllChildren(emptyBlock);
        insertLoc = emptyBlock;
        insertAsChild = true;
        isEnforcedAtomic = true;
      }
      var finalSelection = null;
      // insert block-by-block
      for (c = 0; c < childCnt; c++) {
        var blockToProcess = children[c];
        isAtomic = com.isTag(blockToProcess, atomicBlocks) || isEnforcedAtomic;
        var isLastChild = (c === (childCnt - 1));
        var insertDef, splitDef, insertNode, insertOffset;
        var insertBlock = false;
        if ((c === 0) && !isAtomic) {
          // first block & non-atomic & no paste on empty block: append paste
          // block to existing content
          insertDef = this.insertInExistingNode(context, pSel, blockToProcess);
          insertNode = insertDef.startNode;
          insertOffset = insertDef.startOffset;
          splitDef = this.splitExistingNode(context, insertNode, insertOffset);
          insertLoc = splitDef.insertPoint;
          insertBehind = splitDef.insertBehind;
        } else if ((c === 0) && isAtomic) {
          // first block & atomic & no paste on empty block: split existing
          // content + insert in-between
          if (!insertAsChild) {
            // handle paste to an empty cell correctly
            splitDef = this.splitExistingNode(context, pSel.startNode,
              pSel.startOffset);
            insertLoc = splitDef.insertPoint;
            insertBehind = splitDef.insertBehind;
          }
          insertBlock = true;
        } else if (isLastChild && !isAtomic && !isFullReplace) {
          // last block & non-atomic & no paste on empty block: prepend paste block
          // to existing content
          if (insertBehind) {
            if (insertLoc.nextSibling) {
              insertNode = com.getFirstTextChild(insertLoc.nextSibling, true);
            } else {
              // we're EOT/EOB; so we'll just insert the entire block
              insertNode = null;
              insertBlock = true;
            }
          } else {
            insertNode = com.getFirstTextChild(insertLoc, true);
          }
          if (insertNode !== null && insertNode !== undefined) {
            insertOffset = sel.getFirstSelectionOffset(context, insertNode);
            insertDef = {
              'startNode': insertNode,
              'startOffset': insertOffset
            };
            insertDef = this.insertInExistingNode(context, insertDef,
              blockToProcess);
            finalSelection = insertDef;
          }
        } else {
          // others: insert behind previous block
          insertBlock = true;
        }
        if (insertBlock) {
          if (insertBehind) {
            com.insertBefore(insertLoc.parentNode, blockToProcess,
              insertLoc.nextSibling);
            insertLoc = blockToProcess;
          } else if (insertAsChild) {
            insertLoc.appendChild(blockToProcess);
          } else {
            com.insertBefore(insertLoc.parentNode, blockToProcess, insertLoc);
          }
          // handle empty blocks correctly
          if (com.ua.isIE) {
            dpr.fixEmptyEditingBlockIE(context, blockToProcess);
          } else {
            var contentNodes = com.getCharacterNodes(blockToProcess);
            if (contentNodes === 0) {
              var placeholder = dpr.createEmptyLinePlaceholder(context, false);
              if (placeholder) {
                var placeholderParent = com.getFirstChild(blockToProcess);
                if (placeholderParent === null || placeholderParent === undefined) {
                  placeholderParent = blockToProcess;
                }
                placeholderParent.appendChild(placeholder);
              }
            }
          }
          // don't forget to calculate new caret position on last container
          if (isLastChild) {
            finalSelection = {
              'startNode': blockToProcess,
              'startOffset': null
            };
          }
        }
      }
      if (isFullReplace) {
        emptyBlock.parentNode.removeChild(emptyBlock);
      }
      return finalSelection;
    },

    /**
     * Executes pasting HTML code to the current selection.
     * @param {Object} execDef Execution definition
     * @private
     */
    pasteAsWordHtml: function (execDef) {

      var sel = CUI.rte.Selection;
      var com = CUI.rte.Common;

      var context = execDef.editContext;

      /*
       var startTc = new Date().getTime();
       */

      // cleanup first
      var pastedDom = execDef.value.dom;
      this.cleanUpDom(context, execDef.component, pastedDom, execDef.value.pasteRules);

      // this would reconstruct the pastedDom and in the process remove do html validation and remove nested paragraphs
      // eg. if pastedDom is <p><p>text</p></p> it would be converted to <p></p><p>text</p><p></p>
      pastedDom.innerHTML = pastedDom.innerHTML;
      // remove the empty paragraphs created above
      com.removeEmptyChildNodes(pastedDom, 'p');

      // detect if we're pasting a table into another table
      var pSel;
      var isTablePaste = com.containsTag(pastedDom, 'table');
      var nodeList = execDef.nodeList;
      var isTableSelection = com.containsTagInPath(context, nodeList.commonAncestor,
        'table');
      if (isTableSelection && isTablePaste) {
        try {
          this.pasteTableToTable(execDef);
        } catch (e) {
          if (e.message !== 'Invalid paste structure.') {
            throw e;
          }
          // todo alert user
        }
      } else {
        // pasting outside an existing table or pasting content not containing a table
        // into an existing table
        pSel = this.insertHtml(execDef);
      }

      /*
       var endTc = new Date().getTime();
       com.ieLog("paste: " + (endTc - startTc) + "ms", true);
       */

      var bookmark;
      if (pSel) {
        bookmark = sel.bookmarkFromProcessingSelection(context, pSel);
      } else {
        bookmark = sel.createSelectionBookmark(context);
      }
      // IE sometimes generates nested blocks, which we'll have to resolve to
      // keep the code consistent. For example: Given an existing content of
      // <h1>Heading</h1><p>Paragraph</p>. Select all. Paste something like <p>para1</p>
      // <p>para2</p>. This will unexpectedly result in <h1><p>para1</p><p>para2</p></h1>.
      // todo check: this should not be necessary anymore, as paste implementation has changed and should handle this differently
      // CUI.rte.DomProcessor.cleanupNestedBlocks(context.root);
      execDef.bookmark = bookmark;
    },

    isCommand: function (cmdStr) {
      return (cmdStr.toLowerCase() === 'paste');
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_BOOKMARK;
    },

    execute: function (execDef) {

      var com = CUI.rte.Common;
      var sel = CUI.rte.Selection;
      var dpr = CUI.rte.DomProcessor;
      var pcmd = CUI.rte.commands.Paste;
      var context = execDef.editContext;
      var value = execDef.value;
      var mode = value.mode;
      var pasteRange = value.pasteRange;
      var editorKernel = execDef.component;
      var cleanUpConfig = editorKernel.htmlRules.serializer.cleanup ?
        editorKernel.htmlRules.serializer.cleanup.paste : undefined;
      cleanUpConfig = cleanUpConfig ? cleanUpConfig : {'tagsToRemove': ['font']};
      this.domPreProcessor = new CUI.rte.DomCleanup(cleanUpConfig);

      // use browser's paste command if necessary
      if (mode === pcmd.MODE_BROWSER) {
        try {
          context.doc.execCommand('paste', false, null);
        } catch (e) {
          throw new Error('Cannot paste.');
        }
        return;
      }

      try {
        // clear selection content
        execDef.component.selectQualifiedRangeBookmark(context, pasteRange);
        var selection = sel.getSelection(context);
        var isCollapsed = (com.ua.isOldIE ? sel.isCollapsed(pasteRange.bookmark)
            : selection.isCollapsed) && !pasteRange.cells;
        if (!isCollapsed) {
          var pSel = execDef.component.createQualifiedSelection(context);
          var cells = (pSel.cellSelection ? pSel.cellSelection.cells : undefined);
          if (!cells || cells.length === 0) {
            CUI.rte.commands.Delete.executeDelete(context);
          } else {
            for (var c = 0; c < cells.length; c++) {
              var cell = cells[c];
              com.removeAllChildren(cell);
              dpr.ensureEmptyLinePlaceholders(context, cell);
            }
          }
        }

        // provide correct selection/nodeList parameters
        execDef.selection = execDef.component.createQualifiedSelection(context);
        execDef.nodeList = dpr.createNodeList(context, execDef.selection);

        var finalPasteSelection;
        switch (mode) {
        case pcmd.MODE_PLAINTEXT:
          finalPasteSelection = this.pasteAsPlainText(execDef);
          break;
        case pcmd.MODE_WORDHTML:
          finalPasteSelection = this.pasteAsWordHtml(execDef);
          break;
        default:
          throw new Error('Invalid paste mode: ' + mode);
        }

        var bookmark = execDef.bookmark;
        if (finalPasteSelection) {
          bookmark = sel.bookmarkFromProcessingSelection(context,
            finalPasteSelection);
        }
        execDef.bookmark = bookmark;

        return {
          'calleeRet': {
            'bookmark': bookmark,
            'geckoEnsureCaretVisibility': true
          }
        };
      } catch (e) {
        try {
          console.log(e);
        } catch (exc) {
          // ignore
        }
      }
      return {
        'calleeRet': {
          'bookmark': execDef.bookmark,
          'geckoEnsureCaretVisibility': true
        }
      };
    }

  });

  /**
   * Paste mode: use browser's paste implementation (should usually not be used, as this may
   * introduce unwanted markup)
   */
  CUI.rte.commands.Paste.MODE_BROWSER = 'browser';

  /**
   * Paste mode: plain text inserts
   */
  CUI.rte.commands.Paste.MODE_PLAINTEXT = 'plaintext';

  /**
   * Paste mode: Word-compatible HTML inserting
   */
  CUI.rte.commands.Paste.MODE_WORDHTML = 'wordhtml';

  /**
   * Block nodes that require atomic pasting
   */
  CUI.rte.commands.Paste.ATOMIC_PROCESSING_BLOCKS = ['table', 'ul', 'ol'];


// register command
  CUI.rte.commands.CommandRegistry.register('paste', CUI.rte.commands.Paste);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.Style
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.Style = new Class({

    toString: 'Style',

    extend: CUI.rte.commands.Command,

    /**
     * Formats the currently selected text fragment with the given CSS style.
     * <p>
     * The currently selected text will be surrounded with a <code>span</code> tag that
     * has the given style name as its <code>class</code> attribute..
     * <p>
     * Note that this method only works on text fragments that have no other styles
     * applied.
     * @private
     */
    addStyle: function (execDef) {
      var sel = CUI.rte.Selection;
      var com = CUI.rte.Common;
      var styleName = execDef.value;
      var selection = execDef.selection;
      var context = execDef.editContext;
      // handle DOM elements
      var selectedDom = sel.getSelectedDom(context, selection);
      var styleableObjects = CUI.rte.plugins.StylesPlugin.STYLEABLE_OBJECTS;
      if (selectedDom && com.isTag(selectedDom, styleableObjects)) {
        com.removeAllClasses(selectedDom);
        com.addClass(selectedDom, styleName);
        return;
      }
      // handle text fragments
      var nodeList = execDef.nodeList;
      if (nodeList) {
        nodeList.surround(execDef.editContext, 'span', {
          'className': styleName
        });
      }
    },

    /**
     * Removes the style of the text fragment that is either selected or is under the current caret position.
     * @private
     */
    removeStyle: function (execDef) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var sel = CUI.rte.Selection;
      var selection = execDef.selection;
      var context = execDef.editContext;
      var styleToRemove = execDef.value;
      var styleName, styleCnt, s;
      // handle DOM elements
      var selectedDom = sel.getSelectedDom(context, selection);
      var styleableObjects = CUI.rte.plugins.StylesPlugin.STYLEABLE_OBJECTS;
      if (selectedDom && com.isTag(selectedDom, styleableObjects)) {
        if (styleToRemove && !styleToRemove.styles) {
          com.removeClass(selectedDom, styleToRemove);
        } else if (styleToRemove && styleToRemove.styles) {
          styleCnt = styleToRemove.styles.length;
          for (s = 0; s < styleCnt; s++) {
            styleName = styleToRemove.styles[s];
            if ((typeof(styleName) === 'object') && styleName.cssName) {
              styleName = styleName.cssName;
            }
            if (com.hasCSS(selectedDom, styleName)) {
              com.removeClass(selectedDom, styleName);
            }
          }
        } else {
          com.removeAllClasses(selectedDom);
        }
        return;
      }
      // handle text selections
      var nodeList = execDef.nodeList;
      var spanTags = nodeList.getTags(context, [{
        matcher: function (dom) {
          return com.isTag(dom, 'span');
        }
      }], true);
      var spansToRemove = [];
      var spanCnt = spanTags.length;
      for (var spanIndex = 0; spanIndex < spanCnt; spanIndex++) {
        var spanToProcess = spanTags[spanIndex].dom;
        if (styleToRemove && !styleToRemove.styles) {
          if (com.hasCSS(spanToProcess, styleToRemove)) {
            spansToRemove.push(spanToProcess);
          }
        } else if (styleToRemove && styleToRemove.styles) {
          styleCnt = styleToRemove.styles.length;
          for (s = 0; s < styleCnt; s++) {
            styleName = styleToRemove.styles[s].cssName;
            if (com.hasCSS(spanToProcess, styleName)) {
              spansToRemove.push(spanToProcess);
              break;
            }
          }
        } else {
          if (spanToProcess.className) {
            spansToRemove.push(spanToProcess);
          }
        }
      }
      var removeCnt = spansToRemove.length;
      for (var r = 0; r < removeCnt; r++) {
        var spanToRemove = spansToRemove[r];
        if (selection.endNode) {
          nodeList.removeNodesByTag(execDef.editContext, spanToRemove.tagName, {'class': spanToRemove.getAttribute('class')}, true);
        } else {
          dpr.removeWithoutChildren(spanToRemove);
        }
      }
    },

    isCommand: function (cmdStr) {
      var cmdLC = cmdStr.toLowerCase();
      return (cmdLC === 'applystyle') || (cmdLC === 'removestyle');
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_BOOKMARK | cmd.PO_SELECTION | cmd.PO_NODELIST;
    },

    execute: function (execDef) {
      switch (execDef.command.toLowerCase()) {
      case 'applystyle':
        this.addStyle(execDef);
        break;
      case 'removestyle':
        this.removeStyle(execDef);
        break;
      }
    },

    queryState: function (selectionDef, cmd) {
      // todo find a meaningful implementation -> list of span tags?
      return false;
    }

  });


// register command
  CUI.rte.commands.CommandRegistry.register('_style', CUI.rte.commands.Style);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.Table
 * @extends CUI.rte.commands.Command
 * @private
 * <p>This class implements the RichText commands for creating and editing a table.</p>
 * <p>The following commands are supported (in parantheses: valid command values)</p>
 * <ul>
 *   <li>createtable</li>
 *   <li>modifytable</li>
 *   <li>removetable</li>
 *   <li>insertrow (before, after)</li>
 *   <li>removerow</li>
 *   <li>insertcolumn (before, after)</li>
 *   <li>removecolumn</li>
 *   <li>modifycell</li>
 *   <li>mergecells</li>
 *   <li>splitcell</li>
 *   <li>ensureparagraph (before, after)</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.Table = new Class({

    toString: 'Table',

    extend: CUI.rte.commands.Command,

    /**
     * @private
     */
    getTable: function (execDef) {
      var com = CUI.rte.Common;
      var context = execDef.editContext;
      return com.getTagInPath(context, execDef.nodeList.commonAncestor, 'table');
    },

    /**
     * @private
     */
    createEmptyCell: function (execDef, refNode) {
      return CUI.rte.TableMatrix.createEmptyCell(execDef.editContext, refNode);
    },

    /**
     * @private
     */
    transferConfigToTable: function (dom, execDef) {
      var com = CUI.rte.Common;
      var config = execDef.value;
      var noneConfig = CUI.rte.commands.Table.CONFIG_NONE;
      var context = execDef.editContext;
      var captionNode = com.getChildNodesByType(dom, 'caption');
      var dpr = CUI.rte.DomProcessor;
      if (config.cellpadding) {
        com.setAttribute(dom, 'cellpadding', config.cellpadding);
      } else {
        com.removeAttribute(dom, 'cellpadding');
      }
      this.handleCellspacing(dom, execDef);
      if (config.cellspacing) {
        com.setAttribute(dom, 'cellspacing', config.cellspacing);
      } else {
        com.removeAttribute(dom, 'cellspacing');
      }
      if (config.border) {
        dom.border = config.border;
        if (config.border === '0') {
          com.addClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
        } else {
          com.removeClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
        }
      } else {
        com.removeAttribute(dom, 'border');
        com.addClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
      }
      if (config.width) {
        com.setAttribute(dom, 'width', config.width);
      } else {
        com.removeAttribute(dom, 'width');
      }
      if (config.height) {
        com.setAttribute(dom, 'height', config.height);
      } else {
        com.removeAttribute(dom, 'height');
      }
      if (config.caption) {
        if (captionNode.length > 0) {
          captionNode = captionNode[0];
        } else {
          captionNode = context.createElement('caption');
          dpr.insertElement(context, captionNode, dom, 0);
        }
        captionNode.innerHTML = config.caption;
      } else {
        if (captionNode.length > 0) {
          captionNode[0].parentNode.removeChild(captionNode[0]);
        }
      }
      var classNames = com.parseCSS(dom);
      for (var i = 0; i < classNames.length; i++) {
        if (classNames[i] !== CUI.rte.Theme.TABLE_NOBORDER_CLASS) {
          com.removeClass(dom, classNames[i]);
        }
      }
      if (config.tableStyle && (config.tableStyle !== noneConfig)) {
        com.addClass(dom, config.tableStyle);
      }
    },

    /**
     * @private
     */
    handleCellspacing: function (dom, execDef) {
      return;
    },

    /**
     * @private
     */
    createTable: function (execDef) {
      var dpr = CUI.rte.DomProcessor;
      var sel = CUI.rte.Selection;
      var com = CUI.rte.Common;
      var context = execDef.editContext;
      var selection = execDef.selection;
      var insertNode = selection.startNode;
      var insertOffset = selection.startOffset;
      var insertBlock = dpr.getScopedBlockNode(context, insertNode);
      if (!insertBlock) {
        return;
      }
      var isAuxRoot = insertBlock.isAuxiliaryRoot;
      insertBlock = insertBlock.dom;
      var insertAsChild = false;
      var removeDom = null;
      if (dpr.isEmptyLineBlock(insertBlock) && !isAuxRoot) {
        removeDom = insertBlock;
        insertNode = insertBlock;
      } else if (com.isTag(insertBlock, com.TABLE_CELLS)) {
        // nested table
        insertNode = insertBlock;
        insertAsChild = true;
        // currently we'll remove all existing child nodes of the existing cell to
        // reduce complexity a bit, but that restriction may be removed later
        com.removeAllChildren(insertNode);
      } else if (dpr.isBlockStart(context, insertNode, insertOffset)) {
        insertNode = insertBlock;
      } else if (dpr.isBlockEnd(context, insertNode, insertOffset)) {
        if (insertBlock.nextSibling) {
          insertNode = insertBlock.nextSibling;
        } else {
          // end of text situation
          insertNode = insertBlock.parentNode;
          insertAsChild = true;
        }
      } else {
        insertNode = dpr.insertParagraph(context, insertNode, insertOffset);
        if (!insertNode) {
          return;
        }
      }
      var config = execDef.value;
      var nodeToInsert;
      var tableDom = null;
      var spanHelperDom = null;
      if (config.html) {
        spanHelperDom = context.createElement('span');
        spanHelperDom.innerHTML = config.html;
        nodeToInsert = spanHelperDom;
      } else {
        tableDom = context.createElement('table');
        nodeToInsert = tableDom;
      }
      if (!insertAsChild) {
        insertNode.parentNode.insertBefore(nodeToInsert, insertNode);
      } else {
        insertNode.appendChild(nodeToInsert);
      }
      if (removeDom) {
        removeDom.parentNode.removeChild(removeDom);
      }
      if (config.html) {
        var tables = CUI.rte.Query.select('table', spanHelperDom);
        for (var t = 0; t < tables.length; t++) {
          if (tables[t].border === 0) {
            com.addClass(tables[t], CUI.rte.Theme.TABLE_NOBORDER_CLASS);
          }
        }
        dpr.removeWithoutChildren(spanHelperDom);
        return;
      }
      var headerConfig = config.header;
      var hasTopHeader = (headerConfig.indexOf('top') >= 0);
      var hasLeftHeader = (headerConfig.indexOf('left') >= 0);
      this.transferConfigToTable(tableDom, execDef);
      var tbody = context.createElement('tbody');
      tableDom.appendChild(tbody);
      var firstCell = null;
      for (var i = 0; i < config.rows; i++) {
        var tr = context.createElement('tr');
        tbody.appendChild(tr);
        for (var j = 0; j < config.columns; j++) {
          var tagName = 'td';
          var cellScope = null;
          if ((i === 0) && hasTopHeader) {
            tagName = 'th';
            cellScope = 'col';
          } else if ((j === 0) && hasLeftHeader) {
            tagName = 'th';
            cellScope = 'row';
          }
          var cell = context.createElement(tagName);
          if (cellScope) {
            com.setAttribute(cell, 'scope', cellScope);
          }
          if (!firstCell) {
            firstCell = cell;
          }
          tr.appendChild(cell);
          var placeholder = dpr.createEmptyLinePlaceholder(context);
          if (placeholder) {
            cell.appendChild(placeholder);
          }
        }
      }
      execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
        'startNode': firstCell,
        'startOffset': null
      });
    },

    /**
     * @private
     */
    modifyTable: function (execDef) {
      var sel = CUI.rte.Selection;
      var com = CUI.rte.Common;
      var table = this.getTable(execDef);
      var config = execDef.value;
      if (table && config) {
        this.transferConfigToTable(table, execDef);
      }
      if (com.ua.isGecko) {
        sel.flushSelection(execDef.editContext);
      } else {
        execDef.bookmark = null;
      }
    },

    /**
     * @private
     */
    removeTable: function (execDef) {
      var sel = CUI.rte.Selection;
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var context = execDef.editContext;
      var table = this.getTable(execDef);
      if (table) {
        var bookmark = sel.bookmarkFromProcessingSelection(context, {
          'startNode': table,
          'startOffset': 0
        });
        var tableParent = table.parentNode;
        tableParent.removeChild(table);
        var cellParent = com.getTagInPath(context, tableParent, ['td', 'th']);
        if (cellParent) {
          dpr.ensureEmptyLinePlaceholders(context, cellParent);
        }
        // prevent completely empty document
        if ((tableParent === context.root) && (tableParent.childNodes.length === 0)) {
          context.root.appendChild(dpr.createEmptyLinePlaceholder(context, true));
        }
        // Gecko keeps the table handles drawn, so play around with the
        // selection to get rid of it
        sel.flushSelection(context);
        execDef.bookmark = bookmark;
      }
    },

    /**
     * @private
     */
    getTableBody: function (execDef) {
      var com = CUI.rte.Common;
      var table = this.getTable(execDef);
      var rows = com.getChildNodesByType(table, 'tr', true);
      if (rows.length > 0) {
        table = rows[0].parentNode;
      }
      return table;
    },

    /**
     * <p>Checks if the specified cell is empty.</p>
     * <p>As most browsers use placeholders in such cases, a cell is empty if it either
     * has bo child not or only a placeholder
     * @param {HTMLElement} cellDom The cell DOM element to check
     * @private
     */
    isEmptyCell: function (cellDom) {
      return CUI.rte.DomProcessor.isEmptyLineBlock(cellDom);
    },

    /**
     * @private
     */
    getSelectedRows: function (execDef) {
      var com = CUI.rte.Common;
      var context = execDef.editContext;
      return execDef.nodeList.getTags(context, [{
        'matcher': function (dom) {
          return com.isTag(dom, 'tr');
        }
      }], true, true);
    },

    /**
     * Get all cells that occupy the same row as the specified cell.
     * @param {Object} execDef Execution definition
     * @param {HTMLElement} cell Reference cell
     * @return {HTMLElement[]} Array containing all cells that occupy the same row
     */
    getEntireRowForCell: function (execDef, cell) {
      var tableDom = this.getTable(execDef);
      var tableMatrix = new CUI.rte.TableMatrix();
      tableMatrix.createTableMatrix(tableDom);
      var cellDef = tableMatrix.getCellDef(cell);
      var baseRow = cellDef.row;
      var rowCells = [];
      if (cellDef) {
        var row = tableMatrix.getRow(baseRow);
        if (row) {
          for (var c = 0; c < row.length; c++) {
            var cellToProcess = row[c];
            // use only cells that actually *start* at the same row (not the ones
            // that intersect by rowspan settings)
            if (cellToProcess.row === baseRow) {
              rowCells.push(cellToProcess.cellDom);
            }
          }
        }
      }
      return rowCells;
    },

    /**
     * Get all cells that occupy the same column as the specified cell.
     * @param {Object} execDef Execution definition
     * @param {HTMLElement} cell Reference cell
     * @return {HTMLElement[]} Array containing all cells that occupy the same column
     */
    getEntireColumnForCell: function (execDef, cell) {
      var tableDom = this.getTable(execDef);
      var tableMatrix = new CUI.rte.TableMatrix();
      tableMatrix.createTableMatrix(tableDom);
      var cellDef = tableMatrix.getCellDef(cell);
      var baseColumn = cellDef.col;
      var colCells = [];
      if (cellDef) {
        var column = tableMatrix.getColumn(baseColumn);
        if (column) {
          for (var c = 0; c < column.length; c++) {
            var cellToProcess = column[c];
            // use only cells that actually *start* at the same column (not the ones
            // that intersect by colspan settings)
            if (cellToProcess.col === baseColumn) {
              colCells.push(cellToProcess.cellDom);
            }
          }
        }
      }
      return colCells;
    },

    /**
     * @private
     */
    insertRow: function (execDef, insertBefore, caretPosition) {
      var sel = CUI.rte.Selection;
      var context = execDef.editContext;
      var rows = this.getSelectedRows(execDef);
      if (rows.length === 1) {
        if (!caretPosition) {
          caretPosition = 'default';
        }
        var cells = this.getSelectedCells(execDef);
        var tableDom = this.getTable(execDef);
        var tableMatrix = new CUI.rte.TableMatrix();
        tableMatrix.createTableMatrix(tableDom);
        var refCellDef = tableMatrix.getCellDef(cells[0].dom);
        var refRow = (insertBefore ? refCellDef.row
          : refCellDef.row + refCellDef.rowSpan - 1);
        var cols = tableMatrix.getRow(refRow);
        var row = context.createElement('tr');
        var refRowDom = tableMatrix.getRowDom(refRow);
        var insertRef = (insertBefore ? refRowDom : refRowDom.nextSibling);
        refRowDom.parentNode.insertBefore(row, insertRef);
        var cellToSelect;
        for (var c = 0; c < cols.length; c++) {
          var cell = cols[c];
          var cellDom = cell.cellDom;
          var newCell = this.createEmptyCell(execDef, cellDom);
          if (cellDom.colSpan > 1) {
            newCell.colSpan = cellDom.colSpan;
          }
          if (caretPosition === 'default') {
            if (cell === refCellDef) {
              cellToSelect = newCell;
            }
          } else if (caretPosition === 'firstCell') {
            if (c === 0) {
              cellToSelect = newCell;
            }
          }
          if (cell.rowSpan === 1) {
            row.appendChild(newCell);
          } else {
            var extendExistingCell = (insertBefore ? (cell.row !== refCellDef.row)
              : ((cell.row + cell.rowSpan - 1) > refRow));
            if (!extendExistingCell) {
              row.appendChild(newCell);
            } else {
              if (caretPosition === 'default') {
                if (cell === refCellDef) {
                  cellToSelect = cellDom;
                }
              } else if (caretPosition === 'firstCell') {
                if (c === 0) {
                  cellToSelect = cellDom;
                }
              }
              cellDom.rowSpan++;
            }
          }
        }
        // Gecko keeps the table handles drawn, so play around with the
        // selection to get rid of it
        sel.flushSelection(context);
        if (cellToSelect) {
          execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
            startNode: cellToSelect,
            startOffset: null
          });
        } else {
          execDef.bookmark = null;
        }
      }
    },

    /**
     * @private
     */
    removeRow: function (execDef) {
      var sel = CUI.rte.Selection;
      var dpr = CUI.rte.DomProcessor;
      var context = execDef.editContext;
      var table = this.getTable(execDef);
      var rows = this.getSelectedRows(execDef);
      if (rows.length === 1) {
        var tableMatrix = new CUI.rte.TableMatrix();
        tableMatrix.createTableMatrix(table);
        var tableSize = tableMatrix.getTableSize();
        if (tableSize.rows === 1) {
          this.removeTable(execDef);
          return;
        }
        var cells = this.getSelectedCells(execDef);
        var cellDef = tableMatrix.getCellDef(cells[0].dom);
        var rowToRemove = tableMatrix.getRow(cellDef.row);
        var cellToSelect;
        if (cellDef.rowSpan > 1) {
          cellToSelect = cellDef.cellDom;
        } else {
          if (cellDef.row < (tableSize.rows - 1)) {
            cellToSelect = tableMatrix.getCellForCoords(cellDef.col,
              cellDef.row + 1);
          } else {
            cellToSelect =
              tableMatrix.getCellForCoords(cellDef.col, cellDef.row - 1);
          }
          if (cellToSelect) {
            cellToSelect = cellToSelect.cellDom;
          } else {
            cellToSelect = table;
          }
        }
        var cellDom;
        for (var c = 0; c < rowToRemove.length; c++) {
          var cellToRemove = rowToRemove[c];
          cellDom = cellToRemove.cellDom;
          if (cellToRemove.rowSpan === 1) {
            // remove
            cellDom.parentNode.removeChild(cellDom);
          } else {
            // decrease rowspan and remove content if necessary
            if (cellToRemove.row === cellDef.row) {
              while (cellDom.childNodes.length > 0) {
                cellDom.removeChild(cellDom.childNodes[0]);
              }
              cellDom.appendChild(context.createTextNode(dpr.NBSP));
              // move cell to next row
              cellDom.parentNode.removeChild(cellDom);
              var insertCellDef = tableMatrix.getRowCellForCoords(c,
                cellDef.row + 1);
              var insertCell = (insertCellDef ? insertCellDef.cellDom : null);
              var parentNode = (insertCell ? insertCell.parentNode
                : tableMatrix.getRowDom(cellDef.row + 1));
              parentNode.insertBefore(cellDom, insertCell);
            }
            cellDom.rowSpan--;
          }
        }
        // remove tr element itself if necessary
        var rowDom = rows[0].dom;
        rowDom.parentNode.removeChild(rowDom);
        // optimize spans if possible
        tableMatrix.createTableMatrix(table);
        tableMatrix.optimizeSpans();
        // Gecko keeps the table handles drawn, so play around with the
        // selection to get rid of it
        sel.flushSelection(context);
        if (cellToSelect) {
          execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
            startNode: cellToSelect,
            startOffset: null
          });
        } else {
          execDef.bookmark = null;
        }
      }
    },

    /**
     * @private
     */
    getSelectedCells: function (execDef) {
      var context = execDef.editContext;
      var cellSelection = execDef.selection.cellSelection;
      if (cellSelection) {
        var cellsSelected = [];
        for (var c = 0; c < cellSelection.cells.length; c++) {
          cellsSelected.push({
            'dom': cellSelection.cells[c]
          });
        }
        return cellsSelected;
      }
      var nodeList = execDef.nodeList;
      var com = CUI.rte.Common;
      var isTableFound = false;
      return nodeList.getTags(context, [{
        'matcher': function (dom) {
          if (isTableFound) {
            return false;
          }
          if (com.isTag(dom, ['td', 'th'])) {
            isTableFound = true;
            return true;
          }
          return false;
        }
      }], true, true);
    },

    /**
     * @private
     */
    insertCol: function (execDef, insertBefore) {
      var sel = CUI.rte.Selection;
      var context = execDef.editContext;
      var cells = this.getSelectedCells(execDef);
      if (cells.length === 1) {
        var tableDom = this.getTable(execDef);
        var tableMatrix = new CUI.rte.TableMatrix();
        tableMatrix.createTableMatrix(tableDom);
        var refCellDef = tableMatrix.getCellDef(cells[0].dom);
        var refCol = (insertBefore ? refCellDef.col
          : refCellDef.col + refCellDef.colSpan - 1);
        var rows = tableMatrix.getColumn(refCol);
        var cellToSelect;
        for (var r = 0; r < rows.length; r++) {
          var cell = rows[r];
          var cellDom = cell.cellDom;
          var newCell = this.createEmptyCell(execDef, cellDom);
          if (cellDom.rowSpan > 1) {
            newCell.rowSpan = cellDom.rowSpan;
          }
          var insertRef = (insertBefore ? cellDom : cellDom.nextSibling);
          if (cell === refCellDef) {
            cellToSelect = newCell;
          }
          if (cell.colSpan === 1) {
            cellDom.parentNode.insertBefore(newCell, insertRef);
          } else {
            var extendExistingCell = (insertBefore ? (cell.col !== refCellDef.col)
              : ((cell.col + cell.colSpan - 1) > refCol));
            if (!extendExistingCell) {
              cellDom.parentNode.insertBefore(newCell, insertRef);
            } else {
              if (cell === refCellDef) {
                cellToSelect = cellDom;
              }
              cellDom.colSpan++;
            }
          }
        }
        // Gecko keeps the table handles drawn, so play around with the
        // selection to get rid of it
        sel.flushSelection(context);
        if (cellToSelect) {
          execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
            startNode: cellToSelect,
            startOffset: null
          });
        } else {
          execDef.bookmark = null;
        }
      }
    },

    /**
     * @private
     */
    removeCol: function (execDef) {
      var sel = CUI.rte.Selection;
      var dpr = CUI.rte.DomProcessor;
      var context = execDef.editContext;
      var table = this.getTable(execDef);
      var cells = this.getSelectedCells(execDef);
      if (cells.length === 1) {
        var tableMatrix = new CUI.rte.TableMatrix();
        tableMatrix.createTableMatrix(table);
        var tableSize = tableMatrix.getTableSize();
        if (tableSize.cols === 1) {
          this.removeTable(execDef);
          return;
        }
        var cellDef = tableMatrix.getCellDef(cells[0].dom);
        var colToRemove = tableMatrix.getColumn(cellDef.col);
        var cellToSelect;
        if (cellDef.colSpan > 1) {
          cellToSelect = cellDef.cellDom;
        } else {
          cellToSelect = tableMatrix.getFollowUpCell(cellDef.col, cellDef.row);
          if (!cellToSelect && (cellDef.col > 0)) {
            cellToSelect = tableMatrix.getCellForCoords(cellDef.col - 1,
              cellDef.row);
          }
          if (cellToSelect) {
            cellToSelect = cellToSelect.cellDom;
          } else {
            cellToSelect = table;
          }
        }
        var cellDom;
        for (var r = 0; r < colToRemove.length; r++) {
          var cellToRemove = colToRemove[r];
          cellDom = cellToRemove.cellDom;
          if (cellToRemove.colSpan === 1) {
            // remove
            cellDom.parentNode.removeChild(cellDom);
          } else {
            // decrease colspan and remove content if necessary
            if (cellToRemove.col === cellDef.col) {
              while (cellDom.childNodes.length > 0) {
                cellDom.removeChild(cellDom.childNodes[0]);
              }
              cellDom.appendChild(context.createTextNode(dpr.NBSP));
            }
            cellDom.colSpan--;
          }
        }
        // optimize spans if possible
        tableMatrix.createTableMatrix(table);
        tableMatrix.optimizeSpans();
        // Gecko keeps the table handles drawn, so play around with the
        // selection to get rid of it
        sel.flushSelection(context);
        if (cellToSelect) {
          execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
            startNode: cellToSelect,
            startOffset: null
          });
        } else {
          execDef.bookmark = null;
        }
      }
    },

    /**
     * @private
     */
    transferConfigToCell: function (context, dom, config) {
      var com = CUI.rte.Common;
      var noneConfig = CUI.rte.commands.Table.CONFIG_NONE;
      var cellTypeChanged = 'false';
      if (config.cellType && (config.cellType !== noneConfig)) {
        if (!com.isTag(dom, config.cellType)) {
          cellTypeChanged = 'true';
          var changedDom = context.createElement(config.cellType);
          com.copyAttributes(dom, changedDom);
          com.replaceNode(dom, changedDom);
          dom = changedDom;
        }
      }
      var cellType = com.isTag(dom, 'td') ? 'td' : 'th';
      if (config.width) {
        com.setAttribute(dom, 'width', config.width);
      } else {
        com.removeAttribute(dom, 'width', config.height);
      }
      if (config.height) {
        com.setAttribute(dom, 'height', config.height);
      } else {
        com.removeAttribute(dom, 'height');
      }
      if (config.align) {
        if (config.align !== noneConfig) {
          dom.style.textAlign = config.align;
        } else {
          dom.style.textAlign = '';
        }
      }
      if (config.valign) {
        if (config.valign !== noneConfig) {
          com.setAttribute(dom, 'valign', config.valign);
        } else {
          com.removeAttribute(dom, 'valign');
        }
      }
      if (config.scope && config.scope !== noneConfig && cellType === 'th') {
        com.setAttribute(dom, 'scope', config.scope);
      } else {
        com.removeAttribute(dom, 'scope');
      }
      if (config.headers && cellType === 'td') {
        com.setAttribute(dom, 'headers', config.headers);
      } else {
        com.removeAttribute(dom, 'headers');
      }
      if (config.id && cellType === 'th') {
        com.setAttribute(dom, 'id', config.id);
      } else {
        com.removeAttribute(dom, 'id');
      }
      com.removeAttribute(dom, 'class');
      if (config.cellStyle && (config.cellStyle !== noneConfig)) {
        com.addClass(dom, config.cellStyle);
      }
      if (config.hiddenheader && cellType === 'th') {
        if (config.hiddenHeaderEditingCSS) {
          com.addClass(dom, config.hiddenHeaderEditingCSS);
        } else {
          com.addInlineStyles(dom, config.hiddenHeaderEditingStyle);
        }
        com.setAttribute(dom, 'hiddenheader', 'true');
      } else if (cellTypeChanged === 'true' || config.handleHiddenHeader === 'true') {
        if (config.hiddenHeaderEditingCSS) {
          com.removeClass(dom, config.hiddenHeaderEditingCSS);
        } else {
          var stylesToRemove = [];
          var editingStyle = config.hiddenHeaderEditingStyle;
          editingStyle = editingStyle.trim();
          var attributes = editingStyle.split(';');
          for (var i = 0; i < attributes.length; i++) {
            var propNameValue = attributes[i].split(':');
            if (propNameValue.length === 2) {
              var propName = propNameValue[0].trim();
              if (propName.length) {
                stylesToRemove.push(propName);
              }
            }
          }
          com.removeInlineStyles(dom, stylesToRemove);
        }
        com.removeAttribute(dom, 'hiddenheader');
      }
    },

    /**
     * @private
     */
    modifyCell: function (execDef) {
      var sel = CUI.rte.Selection;
      var com = CUI.rte.Common;
      var context = execDef.editContext;
      var cells = this.getSelectedCells(execDef);
      var config = execDef.value;
      for (var c = 0; c < cells.length; c++) {
        this.transferConfigToCell(context, cells[c].dom, config);
      }
      // Gecko keeps the table handles drawn, so play around with the
      // selection to get rid of it
      if (com.ua.isGecko) {
        sel.flushSelection(context);
      } else {
        execDef.bookmark = null;
      }
    },

    /**
     * @private
     */
    getExecDefValue: function (execDef) {
      return execDef.value;
    },

    /**
     * @private
     */
    mergeCells: function (execDef) {
      var com = CUI.rte.Common;
      var sel = CUI.rte.Selection;
      var context = execDef.editContext;
      var execDefValue = this.getExecDefValue(execDef);
      var selProps = execDefValue ? execDefValue.selectionProps : null;
      var anchorCell = (selProps ? selProps.anchorCell : null);
      if (anchorCell) {
        var table = this.getTable(execDef);
        var anchorDom = anchorCell.cellDom;
        var colSpan = selProps.cols;
        var rowSpan = selProps.rows;
        var cells = execDefValue.cells;
        var contentNodes = [], i;
        for (var c = 0; c < cells.length; c++) {
          var cellDom = cells[c].cellDom;
          if (cellDom !== anchorDom) {
            if (!this.isEmptyCell(cellDom)) {
              // add space
              contentNodes.push(context.createTextNode(' '));
              var children = cellDom.childNodes;
              for (i = 0; i < children.length; i++) {
                contentNodes.push(children[i]);
              }
            }
            cellDom.parentNode.removeChild(cellDom);
          }
        }
        if (colSpan > 1) {
          com.setAttribute(anchorDom, 'colspan', colSpan);
        } else {
          com.removeAttribute(anchorDom, 'colspan');
        }
        if (rowSpan > 1) {
          com.setAttribute(anchorDom, 'rowspan', rowSpan);
        } else {
          com.removeAttribute(anchorDom, 'rowspan');
        }
        for (i = 0; i < contentNodes.length; i++) {
          anchorDom.appendChild(contentNodes[i]);
        }
        // optimize spans & table structure
        var tableMatrix = new CUI.rte.TableMatrix();
        tableMatrix.createTableMatrix(table);
        tableMatrix.optimizeSpans();
        // Gecko keeps the table handles drawn, so play around with the
        // selection to get rid of it
        sel.flushSelection(context);
        execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
          startNode: anchorDom,
          startOffset: null
        });
      }
    },

    /**
     * @private
     */
    splitCellHorizontally: function (execDef) {
      var sel = CUI.rte.Selection;
      var context = execDef.editContext;
      var table = this.getTable(execDef);
      var cells = this.getSelectedCells(execDef);
      if (table && cells.length === 1) {
        var cell = cells[0].dom;
        var newCell = this.createEmptyCell(execDef);
        if (cell.rowSpan && cell.rowSpan > 1) {
          newCell.rowSpan = cell.rowSpan;
        }
        if (cell.colSpan && cell.colSpan > 1) {
          // if the current cell already has some colspan, decrease by 1
          cell.colSpan = cell.colSpan - 1;
          cell.parentNode.insertBefore(newCell, cell.nextSibling);
        } else {
          // if the cell to be split has no colspan, increase colspan of all
          // cells in this cell's column by 1
          var tableMatrix = new CUI.rte.TableMatrix();
          tableMatrix.createTableMatrix(table);
          tableMatrix.createFullMatrix();
          var cellDef = tableMatrix.getCellDef(cell);
          var col = tableMatrix.getColumn(cellDef.col);
          cell.parentNode.insertBefore(newCell, cell.nextSibling);
          for (var c = 0; c < col.length; c++) {
            if (col[c] !== cellDef) {
              var colSpan = col[c].cellDom.colSpan;
              colSpan = colSpan || 1;
              col[c].cellDom.colSpan = ++colSpan;
            }
          }
        }
        // Gecko keeps the table handles drawn, so play around with the
        // selection to get rid of it
        sel.flushSelection(context);
        execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
          startNode: newCell,
          startOffset: null
        });
      }
    },

    /**
     * @private
     */
    splitCellVertically: function (execDef) {
      var sel = CUI.rte.Selection;
      var context = execDef.editContext;
      var table = this.getTable(execDef);
      var cells = this.getSelectedCells(execDef);
      if (table && cells.length === 1) {
        var cell = cells[0].dom;
        var newCell = this.createEmptyCell(execDef);
        if (cell.colSpan && cell.colSpan > 1) {
          newCell.colSpan = cell.colSpan;
        }
        var tableMatrix = new CUI.rte.TableMatrix();
        tableMatrix.createTableMatrix(table);
        tableMatrix.createFullMatrix();
        var cellDef = tableMatrix.getCellDef(cell);
        if (cell.rowSpan && cell.rowSpan > 1) {
          // if the current cell already has some rowspan, decrease by 1
          var lastCellRow = cellDef.row + cellDef.rowSpan - 1;
          var insertCellDef = tableMatrix.getRowCellForCoords(cellDef.col + 1,
            lastCellRow);
          var insertCell = (insertCellDef ? insertCellDef.cellDom : null);
          var parentNode = (insertCell ? insertCell.parentNode
            : tableMatrix.getRowDom(lastCellRow));
          parentNode.insertBefore(newCell, insertCell);
          cell.rowSpan = cell.rowSpan - 1;
        } else {
          // if the cell to be split has no rowspan, increase rowspan of all
          // cells in this cell's row by 1 and insert a new row
          var row = tableMatrix.getRow(cellDef.row);
          var cellRow = cell.parentNode;
          var newRow = context.createElement('tr');
          newRow.appendChild(newCell);
          cellRow.parentNode.insertBefore(newRow, cellRow.nextSibling);
          for (var c = 0; c < row.length; c++) {
            if (row[c] !== cellDef) {
              var rowSpan = row[c].cellDom.rowSpan;
              rowSpan = rowSpan || 1;
              row[c].cellDom.rowSpan = ++rowSpan;
            }
          }
        }
        // Gecko keeps the table handles drawn, so play around with the
        // selection to get rid of it
        sel.flushSelection(context);
        execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
          startNode: newCell,
          startOffset: null
        });
      }
    },

    ensureParagraph: function (execDef, ensureBefore) {
      var dpr = CUI.rte.DomProcessor;
      var com = CUI.rte.Common;
      var sel = CUI.rte.Selection;
      var context = execDef.editContext;
      var insertNode = null;
      var tableDom = this.getTable(execDef);
      if (!tableDom) {
        return;
      }
      var bodyNode = tableDom.parentNode;
      if (!com.isRootNode(context, bodyNode)) {
        return;
      }
      if (ensureBefore) {
        insertNode = tableDom;
      } else {
        insertNode = tableDom.nextSibling;
      }
      var paraNode = dpr.createEmptyLinePlaceholder(context, true);
      bodyNode.insertBefore(paraNode, insertNode);
      dpr.fixEmptyEditingBlockIE(context, paraNode);
      // Gecko keeps the table handles drawn, so play around with the selection to get
      // rid of it
      sel.flushSelection(context);
      execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
        startNode: paraNode,
        startOffset: 0
      });
    },

    /**
     * @private
     */
    isCommand: function (cmdStr) {
      var com = CUI.rte.Common;
      var cmdLC = cmdStr.toLowerCase();
      return com.strEndsWith(cmdLC, 'table') || com.strEndsWith(cmdLC, 'column') ||
        com.strEndsWith(cmdLC, 'row') || com.strEndsWith(cmdLC, 'cell') ||
        com.strEndsWith(cmdLC, 'cells') || cmdLC === 'ensureparagraph';
    },

    /**
     * @private
     */
    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_BOOKMARK | cmd.PO_SELECTION | cmd.PO_NODELIST;
    },

    /**
     * @private
     */
    execute: function (execDef) {
      var ret;
      var position;
      switch (execDef.command.toLowerCase()) {
      case 'createtable':
        this.createTable(execDef);
        break;
      case 'modifytable':
        this.modifyTable(execDef);
        break;
      case 'removetable':
        this.removeTable(execDef);
        break;
      case 'insertrow':
        var caretPosition = 'default';
        if (typeof(execDef.value) === 'string') {
          position = execDef.value;
        } else {
          position = execDef.value.position;
          caretPosition = execDef.value.caret;
        }
        this.insertRow(execDef, !position || (position === 'before'), caretPosition);
        ret = {
          'calleeRet': {
            'geckoEnsureCaretVisibility': true
          }
        };
        break;
      case 'removerow':
        this.removeRow(execDef);
        break;
      case 'insertcolumn':
        position = execDef.value;
        this.insertCol(execDef, !position || (position === 'before'));
        break;
      case 'removecolumn':
        this.removeCol(execDef);
        break;
      case 'modifycell':
        this.modifyCell(execDef);
        break;
      case 'mergecells':
        this.mergeCells(execDef);
        break;
      case 'splitcell':
        if (execDef.value === 'horizontal') {
          this.splitCellHorizontally(execDef);
        } else if (execDef.value === 'vertical') {
          this.splitCellVertically(execDef);
        }
        break;
      case 'ensureparagraph':
        position = execDef.value;
        this.ensureParagraph(execDef, !position || (position === 'before'));
        ret = {
          'calleeRet': {
            'geckoEnsureCaretVisibility': true
          }
        };
        break;
      }
      return ret;
    },

    /**
     * @private
     */
    queryState: function (selectionDef, cmd) {
      var com = CUI.rte.Common;
      var context = selectionDef.editContext;
      if (cmd === 'table') {
        return com.getTagInPath(context, selectionDef.nodeList.commonAncestor, 'table');
      } else if (cmd === 'modifycell') {
        return CUI.rte.commands.Table.getCellFromNodeList(context,
          selectionDef.nodeList);
      }
      // todo find a meaningful implementation for other commands
      return false;
    }

  });

  /**
   * Gets the table cell where the current selection resides from the specified processing
   * selection.
   * @param {CUI.rte.EditContext} context The edit context
   * @param {Object} selection The processing selection to get the cell from
   * @return {HTMLElement} The cell corresponding to the processing selection; null if the
   *         selection is not cell-related or spans more than one table cell
   */
  CUI.rte.commands.Table.getCellFromSelection = function (context, selection) {
    var com = CUI.rte.Common;
    if (selection.cellSelection && selection.cellSelection.cells) {
      if (selection.cellSelection.cells.length === 1) {
        return selection.cellSelection.cells[0];
      }
      return null;
    }
    var cell = com.getTagInPath(context, selection.startNode, com.TABLE_CELLS);
    if (cell && selection.endNode) {
      var endCell = com.getTagInPath(context, selection.endNode, com.TABLE_CELLS);
      if (endCell !== cell) {
        cell = null;
      }
    }
    return cell;
  };

  /**
   * Gets the table cell that is represented by the specified node list.
   * @param {CUI.rte.EditContext} context The edit context
   * @param {CUI.rte.NodeList} nodeList The node list to get the cell from
   * @return {HTMLElement} The cell corresponding to the node list; null if the
   *         node.list is not cell-related or contains more than one table cell
   */
  CUI.rte.commands.Table.getCellFromNodeList = function (context, nodeList) {
    var com = CUI.rte.Common;
    var cell = com.getTagInPath(context, nodeList.commonAncestor, com.TABLE_CELLS);
    // on IE, we might also have a single empty cell node in the list
    if (cell === null || cell === undefined) {
      if (nodeList.nodes.length === 1) {
        var dom = nodeList.nodes[0].dom;
        if (com.isTag(dom, com.TABLE_CELLS)) {
          cell = dom;
        }
      }
    }
    return cell;
  };

  /**
   * Gets the table cells that are represented by the specified node list.
   * @param {CUI.rte.EditContext} context The edit context
   * @param {CUI.rte.NodeList} nodeList The node list to get the cells from
   * @return {HTMLElement[]} The cell corresponding to the node list
   */
  CUI.rte.commands.Table.getCellsFromNodeList = function (context, nodeList) {
    var com = CUI.rte.Common;
    var cell = com.getTagInPath(context, nodeList.commonAncestor, com.TABLE_CELLS);
    var cells = [];
    // on IE, we might also have a single empty cell node in the list
    if (cell === null || cell === undefined) {
      for (var n = 0; n < nodeList.nodes.length; n++) {
        var dom = nodeList.nodes[n].dom;
        if (com.isTag(dom, com.TABLE_CELLS)) {
          cells.push(dom);
        }
      }
    } else {
      cells.push(cell);
    }
    return cells;
  };

  /**
   * Property placeholder for config value "none"
   * @private
   * @static
   * @final
   * @type Object
   */
  CUI.rte.commands.Table.CONFIG_NONE = {};


// register command
  CUI.rte.commands.CommandRegistry.register('_table', CUI.rte.commands.Table);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.Image
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.Image = new Class({

    toString: 'Image',

    extend: CUI.rte.commands.Command,

    createImage: function (execDef) {
      var value = execDef.value;
      var url = null;
      if (value.path) {
        url = CUI.rte.Utils.processUrl(value.path, CUI.rte.Utils.URL_IMAGE);
      }
      var alt = (value.alt ? value.alt : '');
      var width = (value.width ? value.width : null);
      var height = (value.height ? value.height : null);
      // todo encoding(?)
      if (url) {
        var imgHtml = '<img src=\"' + url + '\" alt=\"' + alt + '\"';
        imgHtml += ' ' + CUI.rte.Common.SRC_ATTRIB + '=\"' + value.path + '\"';
        if (width) {
          imgHtml += ' width=\"' + width + '\"';
        }
        if (height) {
          imgHtml += ' height=\"' + height + '\"';
        }
        imgHtml += '>';
        execDef.component.execCmd('inserthtml', imgHtml);
      }
    },

    applyProperties: function (execDef) {
      var props = execDef.value;
      var com = CUI.rte.Common;
      var selection = execDef.selection;
      if (selection.startNode && (selection.startOffset === null) && !selection.endNode) {
        var node = selection.startNode;
        if (!com.isTag(node, 'img')) {
          return;
        }
        var stylePrefix = 'style.';
        for (var propName in props) {
          if (props.hasOwnProperty(propName)) {
            if (com.strStartsWith(propName, stylePrefix)) {
              var styleName =
                propName.substring(stylePrefix.length, propName.length);
              if (styleName === 'float') {
                // IE < 9 requires to use node.style.styleFloat http://msdn.microsoft.com/en-us/library/ie/ms530755%28v=vs.85%29.aspx
                // All other browsers and IE9 or newer allow node.style.cssFloat http://msdn.microsoft.com/en-us/library/ie/ff974668%28v=vs.85%29.aspx
                if (com.ua.isIE6 || com.ua.isIE7 || com.ua.isIE8) {
                  styleName = 'styleFloat';
                } else {
                  styleName = 'cssFloat';
                }
              }
              node.style[styleName] = props[propName];
            } else {
              node.setAttribute(propName, props[propName]);
            }
          }
        }
        if (com.ua.isGecko) {
          CUI.rte.Selection.flushSelection(execDef.editContext);
        }
      }
    },

    isCommand: function (cmdStr) {
      var cmdLC = cmdStr.toLowerCase();
      return (cmdLC === 'image') || (cmdLC === 'insertimg');
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_BOOKMARK | cmd.PO_SELECTION;
    },

    execute: function (execDef) {
      switch (execDef.command.toLowerCase()) {
      case 'insertimg':
        this.createImage(execDef);
        break;
      case 'image':
        this.applyProperties(execDef);
        break;
      }
    },

    queryState: function (selectionDef, cmd) {
      if (cmd.toLowerCase() === 'image') {
        var img = CUI.rte.commands.Image.getSelectedImage(selectionDef);
        return (img !== null && img !== undefined) && !CUI.rte.genhtml.GenericHtmlRules.isPlaceholder(img);
      }
      return false;
    }

  });

  CUI.rte.commands.Image.getSelectedImage = function (selectionDef) {
    var com = CUI.rte.Common;
    var selection = selectionDef.selection;
    if (selection.startNode && (selection.startOffset === undefined) && !selection.endNode) {
      var node = selection.startNode;
      return (com.isTag(node, 'img') ? node : null);
    }
    return null;
  };

// register command
  CUI.rte.commands.CommandRegistry.register('_image', CUI.rte.commands.Image);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands
 * @private
 * The Command should be implemented by all RTE commands that cannot be handled by the
 * browser's implementation itself.
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.commands.UndoRedo = new Class({

    toString: 'UndoRedo',

    extend: CUI.rte.commands.Command,

    /**
     * The undo manager object for this RichText instance
     * @private
     */
    undoManager: null,

    construct: function () {
      this.undoManager = new CUI.rte.UndoManager(50);
    },

    isCommand: function (cmdStr) {
      var cmdLC = cmdStr.toLowerCase();
      return (cmdLC === 'undo') || (cmdLC === 'redo') || (cmdLC === 'undoconfig') ||
        (cmdLC === 'initializeundo') || (cmdLC === 'addundostep') ||
        (cmdLC === 'clearredohistory') || (cmdLC === 'getundoconfig') ||
        (cmdLC === 'dumpundohistory');
    },

    isUndoable: function (cmdStr) {
      return false;
    },

    requiresInitializedComponent: function (cmdStr) {
      return (cmdStr !== 'undoconfig');
    },

    getProcessingOptions: function () {
      return CUI.rte.commands.Command.PO_NONE;
    },

    execute: function (execDef) {
      var cmdLC = execDef.command.toLowerCase();
      var context = execDef.editContext;
      var retValue;
      switch (cmdLC) {
      case 'undo':
        this.undoManager.undo(context);
        break;
      case 'redo':
        this.undoManager.redo(context);
        break;
      case 'undoconfig':
        if (execDef.value.maxUndoSteps !== undefined) {
          this.undoManager.maxUndoSteps = execDef.value.maxUndoSteps;
        }
        if (execDef.value.history) {
          this.undoManager.undoHistory = execDef.value.history;
        }
        if (execDef.value.activeStep !== undefined) {
          this.undoManager.activeUndoStep = execDef.value.activeStep;
        }
        break;
      case 'getundoconfig':
        retValue = {
          'calleeRet': {
            'maxUndoSteps': this.undoManager.maxUndoSteps,
            'history': this.undoManager.cloneHistory(),
            'activeStep': this.undoManager.activeUndoStep
          }
        };
        break;
      case 'initializeundo':
        this.undoManager.initialize(context);
        break;
      case 'addundostep':
        this.undoManager.addStep(new CUI.rte.UndoManager.Step(context));
        break;
      case 'clearredohistory':
        this.undoManager.clearRedoHistory();
        break;
      case 'dumpundohistory':
        console.log(this.undoManager.createDump());
        break;
      }
      return retValue;
    },

    queryState: function (selectionDef, cmd) {
      var cmdLC = cmd.toLowerCase();
      var state = false;
      switch (cmdLC) {
      case 'undo':
        state = this.undoManager.canUndo();
        break;
      case 'redo':
        state = this.undoManager.canRedo();
        break;
      }
      return state;
    }

  });


// register command
  CUI.rte.commands.CommandRegistry.register('_undoredo', CUI.rte.commands.UndoRedo);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.Plugin
 * <p>This class works as an interface and hence must be extended by all plugin
 * implementations.</p>
 * <p>Each plugin may provide one or more "features", that represent the actual editing
 * action and usually map 1:1 to a UI element (for example, a toolbar button or a context
 * menu entry).</p>
 * <p>Plugins should not be instantiated directly, but registred with
 * {@link CUI.rte.plugins.PluginRegistry} for implicit instantiation.</p>
 * @constructor
 * Creates a new Plugin.
 * @param {CUI.rte.EditorKernel} editorKernel The editor kernel the plugin is used by
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.Plugin = new Class({

    /**
     * @cfg {String/String[]} features
     * Defines which features of the plugin are activated. You may provide a String
     * value of "*" to enable all features of the respective plugin, or provide a String[]
     * that contains the IDs of active features. Features and their IDs are documented
     * at the corresponding plugin class. A String value of "-" can be used to explicitly
     * deactivate all features of the plugin.
     */
    features: null,

    /**
     * @property {String} pluginId
     * @since 5.6
     * The plugin ID
     */
    pluginId: null,

    /**
     * Back reference to the editor kernel the plugin is used from
     * @type CUI.rte.EditorKernel
     * @private
     */
    editorKernel: null,

    /**
     * The configuration of the plugin.
     * @type Object
     * @private
     */
    config: null,

    /**
     * Optional array that excludes the plugin for a certain toolkit by returning false
     * for each of the features. Can be overridden by the config option with the same name.
     * A config value of "-" will enable the plugin for all toolkits - despite the developer
     * may have deliberately decided not to support that toolkit. So the "-" option must be
     * used with care, and it is "use at your own risk".
     * @type Array
     * @private
     */
    excludeForToolkit: null,

    isFeatureEnabled: function (feature) {
      if (!this.config || !this.config.features || (this.config.features[0] === '-')) {
        return false;
      }
      var excludeForToolkit = this.excludeForToolkit;
      if (this.config.excludeForToolkit) {
        if (this.config.excludeForToolkit === '-') {
          excludeForToolkit = undefined;
        } else {
          excludeForToolkit = this.config.excludeForToolkit;
        }
      }
      if (excludeForToolkit && CUI.rte.Utils.isArray(excludeForToolkit)) {
        var toolkit;
        if (this.editorKernel) {
          toolkit = this.editorKernel.uiToolkit;
        } else {
          toolkit = CUI.rte._toolkit;
        }
        if (CUI.rte.Common.arrayContains(excludeForToolkit, toolkit)) {
          return false;
        }
      }
      if (this.config.features === '*') {
        return true;
      }
      var featCnt = this.config.features.length;
      for (var featIndex = 0; featIndex < featCnt; featIndex++) {
        var featureToCheck = this.config.features[featIndex];
        if (featureToCheck === feature) {
          return true;
        }
      }
      return false;
    },

    isAnyFeatureEnabled: function () {
      if (!this.config || !this.config.features || (this.config.features[0] === '-')) {
        return false;
      }
      if (this.config.features === '*') {
        return true;
      }
      return (this.config.features.length > 0);
    },

    construct: function (editorKernel, pluginId) {
      this._init(editorKernel, pluginId);
    },

    _init: function (editorKernel, pluginId) {
      this.editorKernel = editorKernel;
      this.pluginId = pluginId;
    },

    getFeatures: function () {
      // must be overridden by implementing plugins
      return [];
    },

    reportStyles: function () {
      return null;
    },

    notifyPluginConfig: function (pluginConfig) {
      this.config = pluginConfig;
    },

    initializeUI: function (tbGenerator, options) {
      // must be overridden by implementing plugins
    },

    execute: function (pluginCommand, value, envOptions) {
      // must be overridden by implementing plugins
    },

    updateState: function (selDef) {
      // must be overridden by implementing plugins
    },

    handleContextMenu: function (menuBuilder, selDef, context) {
      // may be overridden by implementing plugins if context menu access is required
    },

    manipulateSelection: function (selectionDef) {
      // may be overridden by implementing plugins if manipulating a selection before
      // applying a command/evaluating a selection's state is required
    },

    saveRangeBookmark: function (rangeBookmark) {
      // may be overridden by implementing plugins if saving additional data to a range
      // bookmark is required
    },

    restoreRangeBookmark: function (rangeBookmark) {
      // may be overridden by implementing plugins if restoring additional data from a
      // range bookmark is required
    },

    interceptContent: function (contentType, defs) {
      // may be overridden by implementing plugins if they have to modify/intercept
      // HTML code creation at certain points of processing
      return null;
    },

    getTooltip: function (command) {
      return (this.config.tooltips ? this.config.tooltips[command] : null);
    },

    isHeadless: function (command, value) {
      // must be overridden by plugins that use a dialog/mask/whatever to gather further
      // user input before executing the specified command
      return true;
    }

  });

  /**
   * Default sort index for table controls in table edit mode
   * @static
   * @final
   * @type Number
   * @private
   */
  CUI.rte.plugins.Plugin.SORT_TABLE_TABLEMODE = 0;

  /**
   * Default sort index for edit tools (cut, copy, paste)
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_EDIT = 110;

  /**
   * Default sort index for undo/redo
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_UNDO = 120;

  /**
   * Default sort index for format tools (bold, italic, underlined)
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_FORMAT = 130;

  /**
   * Default sort index for justification (left, center, right)
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_JUSTIFY = 140;

  /**
   * Default sort index for link controls
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_LINKS = 150;

  /**
   * Default sort index for list controls
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_LISTS = 160;

  /**
   * Default sort index for image controls
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_IMAGE = 170;

  /**
   * Default sort index for table controls
   * @static
   * @final
   * @type Number
   * @private
   */
  CUI.rte.plugins.Plugin.SORT_TABLE = 180;

  /**
   * Default sort index for styles
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_STYLES = 350;

  /**
   * Default sort index for paragraph formats
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_PARAFORMAT = 360;

  /**
   * Default sort index for the spellchecker
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_SPELLCHECK = 370;

  /**
   * Default sort index for the font
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_FONT = 370;

  /**
   * Default sort index for generic HTML
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_GENERICHTML = 380;

  /**
   * Default sort index for misc tools
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_MISC = 1000;

  /**
   * Maximum sort index
   * @private
   * @static
   * @final
   * @type Number
   */
  CUI.rte.plugins.Plugin.SORT_MAX = 100000;
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.PluginRegistry
 * This class is used to manage plugins available for rich text editing. Each plugin has a
 * respective identifier by which it can be referenced.
 * @private
 * @since 5.3
 */
(function (CUI) {
  'use strict';
  CUI.rte.plugins.PluginRegistry = (function () {

    var pluginRegistry = {};

    return {

      /**
       * Registers the specified class as a rich text editing plugin.
       * @param {String} pluginId The plugin ID
       * @param {Function} cls The plugin class (must implement
       *        {@link CUI.rte.plugins.Plugin})
       */
      register: function (pluginId, cls) {
        pluginRegistry[pluginId] = cls;
      },

      /**
       * <p>Creates an associatve array, containing instances of all currently registered
       * plugins.</p>
       * <p>The created object may be used by a single {@link CUI.rte.EditorKernel}
       * instance.</p>
       * @param {CUI.rte.EditorKernel} editorKernel The EditorKernel the plugins are
       *        used by
       * @return {Object} Instantiated plugins
       */
      createRegisteredPlugins: function (editorKernel) {
        var registeredPlugins = {};
        for (var pluginId in pluginRegistry) {
          if (pluginRegistry.hasOwnProperty(pluginId)) {
            var plugin = new pluginRegistry[pluginId](editorKernel, pluginId);
            plugin = CUI.rte.Utils.onPluginCreated(plugin);
            registeredPlugins[pluginId] = plugin;
          }
        }
        return registeredPlugins;
      }

    };

  }());
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * <p>This class is used for dispatching plugin-related events, mostly used for
 * communications between editor core and plugins.</p>
 * <p>For example, a widget implementation (such as CUI.rte.RichText) may request
 * the source view from a "suitable" plugin (= a plugin that feels resposible for
 * the respective event type) by sending a "sourceedit" event.
 * @class CUI.rte.plugins.PluginEvent
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.PluginEvent = new Class({

    toString: 'PluginEvent',

    /**
     * @private
     */
    type: null,

    /**
     * @property editContext
     */
    editContext: null,

    construct: function (type, editContext, params) {
      params = params || {};
      this.type = type;
      this.editContext = editContext;
      CUI.rte.Utils.apply(this, params);
    },

    getType: function () {
      return this.type;
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.KeyPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements the basic key handling as a plugin.</p>
 * <p>The plugin ID is "<b>keys</b>".</p>
 * <p><b>Features</b></p>
 * <p>This plugin has no features, as it processes keystrokes globally.</p>
 * @since 5.3
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.KeyPlugin = new Class({

    toString: 'KeyPlugin',

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {Number} tabSize
     * Number of &amp;nbsp;-s to be inserted if the tab key is hit (defaults to 4). Note
     * that the tab key works as a navigation aid when used inside a table, so this option
     * will only take effect outside a table.
     */

    /**
     * @private
     */
    mustEnsureBlocks: false,

    /**
     * @private
     */
    mustHandleAdditionalBR: false,

    /**
     * @private
     */
    isInsideListItem: false,

    /**
     * @private
     */
    parentList: null,

    /**
     * @private
     */
    _init: function (editorKernel) {
      this.inherited(arguments);
      editorKernel.addPluginListener('beforekeydown', this.handleKeyDown, this, this,
        false);
      editorKernel.addPluginListener('keyup', this.handleKeyUp, this, this,
        false);
    },

    /**
     * @private
     */
    isEOB: function (context, selection) {
      var nodeToCheck, offsetToCheck;
      if (CUI.rte.Selection.isSelection(selection)) {
        nodeToCheck = selection.endNode;
        offsetToCheck = selection.endOffset;
      } else {
        nodeToCheck = selection.startNode;
        offsetToCheck = selection.startOffset;
      }
      return CUI.rte.DomProcessor.isBlockEnd(context, nodeToCheck, offsetToCheck);
    },

    /**
     * @private
     */
    isTempBR: function (br) {
      var com = CUI.rte.Common;
      return !com.isNull(br) && (com.isAttribDefined(br, com.BR_TEMP_ATTRIB) ||
        (com.isAttribDefined(br, 'type') &&
        (com.getAttribute(br, 'type', false) === '_moz')));
    },

    /**
     * Handles key strokes.
     * @param {Object} e The plugin event
     * @private
     */
    handleKeyDown: function (e) {

      if (e.cancelKey) {
        return;
      }

      var editBlock, isBlockStart;
      var context = e.editContext;
      var dpr = CUI.rte.DomProcessor;
      var sel = CUI.rte.Selection;
      var com = CUI.rte.Common;
      var lut = CUI.rte.ListUtils;
      var ek = this.editorKernel;

      // on Firefox/Mac, Cmd+<Left> triggers a "History back", even when in
      // contenteditable mode; although we cannot restore the expected behavior
      // (jump to the start of current line) easily, we can at least prevent the "History
      // back" from being executed, hence preventing potential data loss
      if (com.ua.isGecko && com.ua.isMac) {
        if (e.isCtrl() && (e.getCharCode() === com.KEY_STROKES.ARROW_LEFT)) {
          e.cancelKey = true;
          return;
        }
      }

      // IE allows invalid caret positions - we cancel key strokes other than caret keys
      // if this is the case
      var selection = (com.ua.isIE ? ek.createQualifiedSelection(context) : null);
      if (com.ua.isIE && !selection) {
        if (!e.isCaretKey()) {
          e.cancelKey = true;
        }
        return;
      }

      function ensureSelection() {
        if (selection === null || selection === undefined) {
          selection = ek.createQualifiedSelection(context);
        }
        return selection;
      }

      var cancelKey = false;

      // handle TAB key
      if (e.isTab()) {
        var tabStr = '';
        var tabSize = this.config.tabSize;
        for (var nbsp = 0; nbsp < tabSize; nbsp++) {
          tabStr += '&nbsp;';
        }
        ek.execCmd('InsertHTML', tabStr);
        cancelKey = true;
      }

      // handle Space key - current Gecko releases insert an additional <br> if a space
      // is inserted at the end of an edit block
      this.mustHandleAdditionalBR = false;
      if (com.ua.isGecko && (e.isSpace() || e.isBackSpace())) {
        selection = ensureSelection();
        if (this.isEOB(context, selection)) {
          this.mustHandleAdditionalBR = true;
        }
      }

      // handle ENTER key
      this.mustEnsureBlocks = false;
      if (e.isEnter() && !cancelKey) {
        if (!e.isShift()) {
          var useBrowserCmd = false;
          var isBeforeNestedList = false;
          try {
            selection = ensureSelection();
            if (sel.isSelection(selection)) {
              CUI.rte.commands.executeDelete(context);
            }
            selection = ek.createQualifiedSelection(context);
            var node = selection.startNode;
            var offset = selection.startOffset;
            editBlock = dpr.getEditBlock(context, node);
            var nestedLists;
            if (com.isTag(editBlock, 'li')) {
              //setting isInsideListItem to true so as to take
              //appropriate actions on keyup for handling CQ-20604
              this.parentList = editBlock.parentElement;
              this.isInsideListItem = true;
              useBrowserCmd = true;
              // corner case: inserting at the last character of a parent item
              // in a nested list must be handled differently for Gecko browsers
              // (bug #37580)
              nestedLists = lut.getNestedLists(editBlock);
              if (com.ua.isGecko) {
                isBeforeNestedList = lut.isPositionBeforeNestedList(context,
                  node, offset);
                useBrowserCmd = !isBeforeNestedList;
              }
            }
            if (!useBrowserCmd) {
              // if we're inserting before an empty line determinator
              // (<p>line<br><br>|<br>), we need to keep that determinator on
              // the old line and have to insert behind instead
              offset = (dpr.isEmptyLineDeterminator(context, node) ? 0 : offset);
              var para = dpr.insertParagraph(context, node, offset);
              if (isBeforeNestedList) {
                var placeholder = dpr.createGeckoPlaceholder(context);
                com.insertBefore(para, placeholder, nestedLists[0]);
              }
              var nodeToSelect;
              if (com.ua.isGecko) {
                nodeToSelect = com.getFirstChild(para);
                if (!nodeToSelect) {
                  nodeToSelect = para;
                } else if (nodeToSelect.nodeType === 3) {
                  nodeToSelect = nodeToSelect.parentNode;
                }
              } else {
                nodeToSelect = para;
              }
              sel.selectNode(context, nodeToSelect, true);
              // both Gecko, Webkit and IE/W3C-compliant don't change the scroll
              // offset accordingly, so we must do it on our own
              if (!com.isOldIE && context.iFrame) {
                // as we don't support complex layouts yet, this simple
                // calculation is currently enough
                var scrollTop = context.root.scrollTop;
                sel.ensureCaretVisibility(context, scrollTop);
              }
              cancelKey = true;
            }
          } catch (ex) {
            // window.console.log("Error: " + ex);
            // com.ieLog("Error: " + e.message, true);
            // if we cannot insert a paragraph, use browser's ENTER handling instead
            useBrowserCmd = true;
          }
          if (useBrowserCmd) {
            if (com.ua.isGecko) {
              // Workaround for Gecko bug that always inserts lines instead of
              // paragraphs when for example a list is finished by pressing
              // Enter on an empty list item
              this.mustEnsureBlocks = true;
            }
          }
        } else if (com.ua.isWebKit || com.ua.isGecko || com.ua.isIEBRPlaceholder) {
          // handle Shift + Enter for WebKit & Gecko & IE with BR placeholder
          selection = ensureSelection();
          if (sel.isSelection(selection)) {
            CUI.rte.commands.executeDelete(context);
          }
          selection = ek.createQualifiedSelection(context);
          var selNode = selection.startNode;
          var selOffs = selection.startOffset;
          var insertNode = selNode;
          var insertOffset = selOffs;
          if (com.isTag(selNode.parentNode, 'a')) {
            insertNode = selNode.parentNode.parentNode;
            insertOffset = com.getChildIndex(selNode.parentNode) + 1;
          }
          var newBr = context.createElement('br');
          var caretPos = sel.getCaretPos(context);
          if (dpr.isBlockEnd(context, selNode, selOffs) && !dpr.isEmptyLineDeterminator(context, selNode)) {
            isBlockStart = dpr.isBlockStart(context, selNode, selOffs);
            if (!isBlockStart) {
              var helperBr = context.createElement('br');
              com.setAttribute(helperBr, com.BR_TEMP_ATTRIB, 'brEOB');
              dpr.insertElement(context, helperBr, insertNode, insertOffset);
            }
            dpr.insertElement(context, newBr, insertNode, insertOffset);
          } else {
            dpr.insertElement(context, newBr, insertNode, insertOffset);
          }
          var afterBr = com.getNextCharacterNode(context, newBr);
          if (afterBr.nodeType === 1) {
            sel.selectNode(context, afterBr, true);
          } else {
            sel.setCaretPos(context, caretPos + 1);
          }
          // TODO handle scrolling, if required
          cancelKey = true;
        }
      }

      // pre-handle auxiliary roots
      this.auxRootParaNodeCnt = 0;
      if ((e.isBackSpace() || e.isDelete()) && !cancelKey) {
        selection = ensureSelection();
        if (com.ua.isOldIE) { // this is just necessary for IE < 9
          // handle deletion of empty lines before tables
          var emptyLineNode = dpr.getEmptyLine(context, selection);
          if ((emptyLineNode !== null && emptyLineNode !== undefined) && !com.isTag(emptyLineNode, com.TABLE_CELLS)) {
            var pos = sel.getCaretPos(context);
            emptyLineNode.parentNode.removeChild(emptyLineNode);
            if (e.isBackSpace() && (pos > 0)) {
              pos--;
              sel.setCaretPos(context, pos);
            }
            cancelKey = true;
          }
        }
        var nodeList = dpr.createNodeList(context, selection);
        var auxRoot = com.getTagInPath(context, nodeList.commonAncestor,
          dpr.AUXILIARY_ROOT_TAGS);
        if (auxRoot) {
          this.auxRootParaNodeCnt = com.getChildNodesByType(auxRoot, 'p').length;
        }
      }

      //Takes a span and extracts font specific data from its style attribute. Note that if the
      //style attribute contains any property other than font-family and font-size
      //then this span is not considered equivalent to font tags and an empty object is returned.
      //If the span does not contain any style attribute, null is returned.
      function getFontEquivalent(span) {
        if (!span) {
          return null;
        }
        var styleString = com.getAttribute(span, 'style');
        if (!styleString) {
          return null;
        }
        var styles = styleString.split(';');
        var fontEquiv = {};
        var sizeMap = {
          'large': '+1',
          'x-large': '+2',
          'xx-large': '+3',
          '-webkit-xxx-large': '+4',
          'small': '-1',
          'x-small': '-2'
        };
        for (var i = 0; i < styles.length; i++) {
          var style = styles[i];
          if (style === '') {
            continue;
          }
          var splitStyle = style.split(':');
          var prop = splitStyle[0].trim();
          var val = splitStyle[1].trim();
          if (prop === 'font-size') {
            fontEquiv.size = sizeMap[val];
          } else if (prop === 'font-family') {
            fontEquiv.face = val;
          } else {
            return {};
          }
        }
        return fontEquiv;
      }

      //Handle font issue CUI-2731 on chrome. If its block start and backspace is pressed or if its block end
      //and delete is pressed, we search all spans from the paragraph and find the spans which have been created
      //for font tags and replace them with appropriate font tags.
      if (com.ua.isChrome && !cancelKey && (e.isBackSpace() || e.isDelete())) {
        isBlockStart = dpr.isBlockStart(context, selection.startNode, selection.startOffset, true);
        var isBlockEnd = dpr.isBlockEnd(context, selection.startNode, selection.startOffset, true);
        editBlock = dpr.getEditBlock(context, selection.startNode);
        var isInsideList = com.isTag(editBlock, 'li');
        var blockToSearch;
        //get the block in which spans will be searched
        if (!isInsideList) {
          if (e.isBackSpace() && isBlockStart) {
            //if we are not inside a list and backspace is pressed at block start, the block to search would
            //be the previous sibling of current block.
            blockToSearch = com.getBlockNode(context, selection.startNode).previousSibling;
          } else if (e.isDelete() && isBlockEnd) {
            //if we are not inside a list and delete is pressed at block end, the block to search would
            //be the current block.
            blockToSearch = com.getBlockNode(context, selection.startNode);
          }
        } else {
          var list = com.getBlockNode(context, selection.startNode); //will be ul or ol tag.
          var listItem = editBlock;  // li tag
          if (e.isBackSpace() && isBlockStart) {
            //if we are inside a li and backspace is pressed at block start, the block to search would
            //be the previous sibling of list if this is first li else the previous sibling of this li
            if (list.children[0] === editBlock) {
              blockToSearch = list.previousSibling;
            } else {
              blockToSearch = listItem.previousSibling;
            }
          } else if (e.isDelete() && isBlockEnd) {
            //if we are inside a li and delete is pressed at block end, the block to search would be
            //the current li
            blockToSearch = listItem;
          }
        }
        if (blockToSearch) {
          CUI.rte.Utils.defer(function () {
            var spans = com.getChildNodesByType(blockToSearch, 'span', true);
            for (var i = 0; i < spans.length; i++) {
              var span = spans[i];
              var fontEquiv = getFontEquivalent(span);
              var nodeToSurround = span;
              if (fontEquiv) {
                if (fontEquiv.size) {
                  nodeToSurround = dpr.insertAsParent(context, nodeToSurround,
                    'font', {'size': fontEquiv.size});
                }
                if (fontEquiv.face) {
                  dpr.insertAsParent(context, nodeToSurround, 'font', {'face': fontEquiv.face});
                }
                dpr.removeWithoutChildren(span);
              }
            }
          }, 10, this);

        }
      }

      e.cancelKey = cancelKey;
    },

    /**
     * Handles post-processing required for all browsers. The method is called whenever a
     * key has been pressed.
     * @param {Object} e The plugin event
     * @private
     */
    handleKeyUp: function (e) {

      var sel = CUI.rte.Selection;
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var context = e.editContext;
      var ek = this.editorKernel;
      var node, selection;

      // handle Gecko/Webkit <br>-placeholders
      if (com.ua.isGecko || com.ua.isWebKit) {
        this.handleBRPlaceholders(context);
      }

      // handle Webkit adding spans deliberately
      if (com.ua.isWebKit) {
        this.handleJunkSpans(context);
      }

      // handle IE autolinks if necessary; note that this is not necessary anymore with
      // IE >= 9, as this has an option to switch auto linking off (see initialization
      // code in EditorKernel#initializeEditContext)
      if (com.ua.isOldIE) {
        // older IE versions add auto links _after_ the keyup event is triggered
        // (especially when re-adding the link after deleting something in a
        // potential URL), so we use deferred execution here to be sure
        CUI.rte.Utils.defer(this.handleIEAutoLinks, 1, this, [context]);
      }

      if (this.isInsideListItem && com.ua.isWebKit) {
        if (com.isTag(this.parentList.nextSibling, 'div')) {
          var defaultEditBlockType = ek.htmlRules.blockHandling.defaultEditBlockType;
          var emptyBlock = dpr.createEmptyLinePlaceholder(context, true, defaultEditBlockType);
          this.parentList.parentElement.insertBefore(emptyBlock, this.parentList.nextSibling);
          sel.selectNode(context, emptyBlock, true);
          this.parentList.nextSibling.nextSibling.remove();
        }
      }

      // handle "absolutely empty" content
      dpr.ensureMinimumContent(context);
      if (this.mustEnsureBlocks) {
        // workaround for Gecko bug/inconsistency; see handleKeys
        selection = sel.getSelection(context);
        if (selection.focusNode && (selection.focusNode.nodeType === 1)) {
          node = selection.focusNode.childNodes[selection.focusOffset];
          if (com.isRootNode(context, node.parentNode) && com.isTag(node, 'br')) {
            var pNode = dpr.insertAsParent(context, node, 'p', null);
            sel.selectNode(context, pNode, true);
          }
        }
      }

      // handle Gecko's (mis-) behaviour of adding additional br's after inserting a
      // space at the end of an edit block
      var fn, nextNode;
      if (this.mustHandleAdditionalBR) {
        selection = sel.getSelection(context);
        fn = selection.focusNode;
        if (fn) {
          nextNode = fn.nextSibling;
          if (com.isTag(nextNode, 'br')) {
            com.setAttribute(nextNode, com.BR_TEMP_ATTRIB, 'brEOB');
          }
        }
      } else if (e.isDelete()) {
        selection = sel.getSelection(context);
        fn = selection.focusNode;
        if (fn && (fn.nodeType === 3)) {
          var text = fn.nodeValue;
          var isSpaceDelimited = (text.length > 0 ?
            (text.charAt(text.length - 1) === ' ') : false);
          if (isSpaceDelimited) {
            nextNode = fn.nextSibling;
            if (com.isTag(nextNode, 'br') &&
              dpr.isBlockEnd(context, nextNode, null)) {
              com.setAttribute(nextNode, com.BR_TEMP_ATTRIB, 'brEOB');
            }
          }
        }
      }

      if (e.isBackSpace() || e.isDelete()) {
        if (com.ua.isIE) {
          // Yet another IE bug: if the last character of a styled area is deleted,
          // IE stores the physical style internally and inserts all characters
          // typed with that physical style (but not the span we actually need).
          // So we're trying to flush this internal buffer by moving the caret forward
          // and backwards
          try {
            var range = sel.getLeadRange(context);
            var oldRange = range.duplicate();
            if (range.move('character', 1) === 1) {
              sel.selectRange(context, range);
            } else if (range.move('character', -1) === -1) {
              sel.selectRange(context, range);
            }
            sel.selectRange(context, oldRange);
          } catch (ex) {
            // might fail, if for example an EOB anchor is tried being deleted using
            // backspace (which won't work at all on IE); just ignore this
          }
        }
        // handle auxiliary block roots
        selection = this.editorKernel.createQualifiedSelection(context);
        if (selection && !sel.isSelection(selection)) {
          node = selection.startNode;
          var scopedBlock = dpr.getScopedBlockNode(context, node);
          if (scopedBlock) {
            if (!scopedBlock.isAuxiliaryRoot) {
              var blockParent = scopedBlock.dom.parentNode;
              if (com.isTag(blockParent, dpr.AUXILIARY_ROOT_TAGS)) {
                var parentParaNodes = com.getChildNodesByType(blockParent, 'p');
                var parentParaNodeCnt = parentParaNodes.length;
                if ((parentParaNodeCnt === 1) &&
                  (parentParaNodeCnt < this.auxRootParaNodeCnt)) {
                  var blockNode = parentParaNodes[0];
                  // preserve indents & text alignments
                  if (!blockNode.style.textAlign && !blockNode.style.marginLeft) {
                    var bookmark;
                    if (com.ua.isIE) {
                      bookmark = sel.createSelectionBookmark(context);
                    }
                    dpr.removeWithoutChildren(blockNode);
                    if (com.ua.isIE) {
                      sel.selectBookmark(context, bookmark);
                    }
                  }
                }
              }
            }
          }
        }
      }
    },

    /**
     * <p>Handles post-processing required for preventing automatically generated links
     * by IE.</p>
     * @private
     */
    handleIEAutoLinks: function (context) {
      var com = CUI.rte.Common;
      var sel = CUI.rte.Selection;
      var hasRemoved = false;
      var caretPos;
      // remove all links that don't have a _rte_href attribute
      var aTags = context.root.getElementsByTagName('A');
      var aCnt = aTags.length;
      for (var a = aCnt - 1; a >= 0; a--) {
        var anchor = aTags[a];
        if (com.isAttribDefined(anchor, 'href') && !com.isAttribDefined(anchor, com.HREF_ATTRIB)) {
          CUI.rte.DomProcessor.removeWithoutChildren(anchor);
          if (!hasRemoved && com.ua.isOldIE) {
            // IE < 9 may have an invalid selection after removing an auto-link
            // (if caret is inside the auto-link that is being removed), so we
            // save the caret and restore it at the end
            caretPos = sel.getCaretPos(context);
            hasRemoved = true;
          }
        }
      }
      if (hasRemoved && com.ua.isOldIE) {
        sel.setCaretPos(context, caretPos);
      }
    },

    /**
     * <p>Handles &lt;br&gt; placeholders for empty lines.</p>
     * <p>Those placeholders get inserted on Shift+Enter and will either removed in this
     * method if it is not necessary anymore because there was content inserted before or
     * the placeholder marker is removed if there is another br placeholder found
     * directly after the existing placeholder &lt;br&gt;.</p>
     * @private
     */
    handleBRPlaceholders: function (context) {
      var prevNodeText;
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var brTags = context.root.getElementsByTagName('BR');
      var brCnt = brTags.length;
      for (var i = 0; i < brCnt; i++) {
        var brToCheck = brTags[i];
        if (this.isTempBR(brToCheck)) {
          var prevCharNode = com.getPreviousCharacterNode(context, brToCheck,
            com.EDITBLOCK_TAGS);
          var nextCharNode = com.getNextCharacterNode(context, brToCheck,
            com.EDITBLOCK_TAGS);
          if ((!com.isTag(prevCharNode, 'br') && !com.isNull(prevCharNode)) || !com.isNull(nextCharNode)) {
            // additional cases: keep if previous character node ends with a space
            // or is an anchor (anchor: on Gecko only)
            var prevNodeLen = 0;
            var isAnchor = false;
            if (prevCharNode) {
              prevNodeText = com.getNodeText(prevCharNode);
              prevNodeLen = prevNodeText.length;
              isAnchor = com.ua.isGecko &&
                (dpr.checkNamedAnchor(prevCharNode) !== null && dpr.checkNamedAnchor(prevCharNode) !== undefined);
            }
            var lastChar = (prevNodeLen > 0 ? prevNodeText.charAt(prevNodeLen - 1)
              : '');
            if ((lastChar !== ' ') && !isAnchor) {
              brToCheck.parentNode.removeChild(brToCheck);
            }
          }
        }
      }
    },

    /**
     * <p>Handles spans that get inserted deliberately by Webkit.</p>
     * <p>This is for example the case if the user deletes the final character of a
     * sub-/superscripted fragment and then directly adds another character.</p>
     * @param {CUI.rte.EditContext} context The edit context
     */
    handleJunkSpans: function (context) {
      var com = CUI.rte.Common;
      var selection = this.editorKernel.createQualifiedSelection(context);
      if (selection && !selection.isSelection) {
        var toCheck = selection.startNode;
        toCheck = (toCheck.nodeType === 3 ? com.getParentNode(context, toCheck)
          : toCheck);
        if (com.isTag(toCheck, 'span')) {
          var styleAttrib = com.getAttribute(toCheck, 'style', true);
          if (styleAttrib) {
            if (styleAttrib.indexOf('font-size') >= 0) {
              var sel = CUI.rte.Selection;
              var bkm = sel.createSelectionBookmark(context);
              CUI.rte.DomProcessor.removeWithoutChildren(toCheck);
              sel.selectBookmark(context, bkm);
            }
          }
        }
      }
    },

    notifyPluginConfig: function (pluginConfig) {
      pluginConfig = pluginConfig || {};
      CUI.rte.Utils.applyDefaults(pluginConfig, {
        'tabSize': 4
      });
      this.config = pluginConfig;
    }

  });


// register plugin
  CUI.rte.plugins.PluginRegistry.register('keys', CUI.rte.plugins.KeyPlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.SimpleFormatPlugin
 * @extends CUI.rte.plugins.Plugin
 * This class provides the plugin functionality that is required by simple formatting
 * operations.
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.SimpleFormatPlugin = new Class({

    toString: 'SimpleFormatPlugin',

    extend: CUI.rte.plugins.Plugin,

    /**
     * @private
     */
    commands: null,

    /**
     * @private
     */
    commandsUI: null,

    /**
     * @private
     */
    groupDef: null,

    getFeatures: function () {
      return this.commands;
    },

    _init: function (editorKernel, groupId, groupSort, commands) {
      this.inherited(arguments);
      this.groupDef = {
        'id': groupId,
        'sort': groupSort
      };
      this.commands = commands;
    },

    initializeUI: function (tbGenerator) {
      this.commandsUI = [];
      var cmdCnt = this.commands.length;
      for (var cmdIndex = 0; cmdIndex < cmdCnt; cmdIndex++) {
        var command = this.commands[cmdIndex];
        var shortcut = null;
        if (typeof(command) === 'object') {
          shortcut = command.shortcut;
          command = command.command;
          this.commands[cmdIndex] = command;
        }
        if (this.isFeatureEnabled(command)) {
          var commandDef = tbGenerator.createElement(command, this, true,
            this.getTooltip(command));
          this.commandsUI.push(commandDef);
          tbGenerator.addElement(this.groupDef.id, this.groupDef.sort, commandDef,
            (cmdIndex + 1) * 10);
          if (shortcut) {
            this.editorKernel.registerKeyboardShortcut(shortcut, command);
          }
        }
      }
    },

    execute: function (id) {
      this.editorKernel.relayCmd(id);
    },

    updateState: function (selectionDef) {
      var cmdCnt = this.commandsUI.length;
      for (var cmdIndex = 0; cmdIndex < cmdCnt; cmdIndex++) {
        var command = this.commandsUI[cmdIndex];
        command.setSelected(this.editorKernel.queryState(command.id, selectionDef));
      }
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.EditToolsPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements the basic editing functions (cut, copy, paste) as a plugin.</p>
 * <p>The plugin ID is "<b>edit</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>cut</b> - adds the "cut" button</li>
 *   <li><b>copy</b> - adds the "copy" button</li>
 *   <li><b>paste-default</b> - adds a button that allows pasting using the default paste
 *     behaviour (see {@link #defaultPasteMode})</li>
 *   <li><b>paste-plaintext</b> - adds a button that allows pasting the clipboard content
 *     as plain text</li>
 *   <li><b>paste-wordhtml</b> - adds a button that allows pasting HTML-based content. Note
 *     that the HTML will be cleaned before inserting. This method is compatible with
 *     pasting content from Microsoft Word.</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {
  //'use strict';
  CUI.rte.plugins.EditToolsPlugin = new Class({

    toString: 'EditToolsPlugin',

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {String} defaultPasteMode
     * <p>Default mode when pasting is executed using the Ctrl + V key or the main paste
     * button (defaults to "wordhtml").</p>
     * <p>Valid values are:</p>
     * <ul>
     *   <li>"browser" - use browser's paste implementation (should usually not be used, as
     *     this may introduce unwanted markup or markup that could cause the RichText
     *     component to crash);</li>
     *   <li>"plaintext" - for plain text inserts;</li>
     *   <li>"wordhtml" - for Word-compatible HTML pasting (this should suffice for most
     *     use cases, as it will keep most of the formatting, but removes unsuitable
     *     tags and attributes.</li>
     * </ul>
     * @since 5.3
     */

    /**
     * @cfg {Boolean} stripHtmlTags
     * <p>True if HTML tags should be stripped off before inserting it on paste (defaults to
     * true).</p>
     * <p>The use-case for this option is a bit hard to explain: The system clipboard works
     * MIME type-based. If you select text from a web page directly, the clipboard will
     * usually contain a text/plain and a text/html variant of the selected text. The plain
     * text variant will contain no HTML tags at all, the text/html variant will contain
     * HTML as we would expect it. On the other hand, if you copy HTML code from any
     * source view, you will get at least get a text/plain variant, containing all tags.
     * In some cases (for example if you are using Firefox' "View source"), you will get
     * an additional text/html variant, that will contain the HTML-tags in an entitiy
     * encoded way (&amp;lt;b&amp;gt;bold text&amp;lt;/b&amp;gt;). On paste, the browser
     * will paste the text/html variant if available, the text/plain variant otherwise.
     * Given the second use-case, the HTML tags will appear in the pasted content, as
     * they get either entity encoded by the browser (text/plain) or are already
     * entity-encoded (text/html) on paste. This is where this option kicks in: By setting
     * it to true, the HTML tags from such a source code paste get removed before the
     * pasted content is inserted in the text being edited.</p>
     * <p>Note that this optiion will only work if {@link #defaultPasteMode} is set to
     * "plaintext".</p>
     * @since 5.3
     */

    /**
     * @cfg {Object} htmlPasteRules
     * <p>Defines rules to be applied to HTML code when pasting in wordhtml mode.</p>
     * <ul>
     *   <li><code>allowBasics</code> : Object<br>
     *     Defines basic elements to be allowed. Elements are defined as boolean
     *     properties. Available property names are:
     *     <ul>
     *       <li>"bold"</li>
     *       <li>"italic"</li>
     *       <li>"underline"</li>
     *       <li>"subscript"</li>
     *       <li>"suprscript"</li>
     *       <li>"anchor" (for the a tag in common, e.g. links and named anchors)</li>
     *       <li>"image"</li>
     *     </ul>
     *   </li>
     *   <li><code>allowBlockTags</code> : String[]<br>
     *     Defines a list of all allowed block tags. Block tags are headlines (h1, h2, h3),
     *     paragraphs (p), lists (ol, ul), tables (table) and so on (see DTD for details).
     *     </li>
     *   <li><code>allowedAttributes</code> : Object<br>
     *     Added in CQ 5.4<br>
     *     Defines valid attributes for each (or all) elements of pasted content. Only valid
     *     if {@link #prepareHtmlPaste} is used. Defaults to:
     <pre><code>
     {
        "*": [
            "class"
        ],
        "table": [
            "width", "height", "cellspacing", "cellpadding", "border",
        ],
        "td": [
            "width", "height", "colspan", "rowspan"
        ]
    }
     </code></pre></li>
     *   <li><code>fallbackBlockTag</code> : String<br>
     *     Defines the block tag that is used for blocks that use a block tag that is not
     *     included in allowBlockTags. "p" should suffice in most cases.</li>
     *   <li><code>table</code> : Object<br>
     *     Defines the behaviour for tables. The following properties must be set:
     *     <ul>
     *       <li><code>allow</code> : Boolean<br>
     *         True if tables are allowed for pasting.</li>
     *       <li><code>ignoreMode</code> : String<br>
     *         If allow is set to false, this property defines how to handle table content.
     *         Valid values for ignoreMode are:
     *         <ul>
     *           <li>"remove" - removes table content</li>
     *           <li>"paragraph" - turns table cells into paragraphs</li>
     *         </ul>
     *       </li>
     *     </ul>
     *   </li>
     *   <li><code>list</code> : Object<br>
     *     Defines the behaviour for lists. The following properties must be set:
     *     <ul>
     *       <li><code>allow</code> : Boolean<br>
     *         True if lists are allowed for pasting.</li>
     *       <li><code>ignoreMode</code> : String<br>
     *         If allow is set to false, this property defines how to handle list content.
     *         Valid values for ignoreMode are:
     *         <ul>
     *           <li>"remove" - removes list content</li>
     *           <li>"paragraph" - turns list items into paragraphs</li>
     *         </ul>
     *       </li>
     *     </ul>
     *   </li>
     *   <li><code>cssMode</code> : String<br>
     *     Defines how to cope with CSS classes. Valid values are:
     *     <ul>
     *       <li>"keep" - keep all CSS classes "as they are". Note that you might get
     *         unwanted results when pasting from external sources/websites</li>
     *       <li>"remove" - (default) remove all CSS classes</li>
     *       <li>"whitelist" - keep all CSS classes that are whitelisted through
     *         {@link #allowedCssNames}, remove all others.</li>
     *     </ul>
     *   </li>
     *   <li><code>allowedCssNames</code> : String[]<br>
     *     A list of all allowed CSS class names. Only used if cssMode == "whitelist".</li>
     *   <li><code>linkRemoveRegEx</code> : String<br>
     *     A regular expression that defines links that have to be removed. Defaults to
     *     null</li>
     *   <li><code>removeHandlers</code> : Boolean<br>
     *     Determines if handlers (as defined by handlersToRemove) should be
     *     removed from pasted HTML. Defaults to true.</li>
     *   <li><code>handlersToRemove</code> : String[]<br>
     *     Array that contains all handlers to be removed. Defaults to [
     *     "onabort", "onblur", "onchange", "onclick", "ondblclick", "onerror",
     *     "onfocus", "onkeydown", "onkeypress", "onkeyup", "onload", "onmousedown",
     *     "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onreset",
     *     "onselect", "submit", "onunload" ]</li>
     * </ul>
     * @since 5.3
     */

    /**
     * Flag that determines if a paste operation is currently active.
     * @private
     * @type Boolean
     */
    isPasteOperation: false,

    /**
     * The paste range as a bookmark
     * @type Object
     * @private
     */
    pasteRange: null,

    /**
     * The hidden DIV that used to receive the clipboard data
     * @type HTMLElement
     * @private
     */
    clipboard: null,

    /**
     * A div needs to wrapped around the clipboard to prevent issue # CUI-5852
     * Specifically, in case of chrome,
     * if a table is present just adjacent to clipboard ( where the browser will paste content ),
     * chrome removes the formatting of text within all the cells of the table while removing the formatting
     * from the source text being pasted , happens such as when pasting a URL or from an [input type=text] form field
     */
    clipboardWrapper: null,

    /**
     * Value that determines the preferred scrolling offset (Gecko only, for ensuring
     * caret visibility through {@link CUI.rte.Selection#ensureCaretVisibility}
     * @type Number
     * @private
     */
    geckoPreferredScrollingOffset: null,

    /**
     * @private
     */
    cutUI: null,

    /**
     * @private
     */
    copyUI: null,

    /**
     * @private
     */
    pasteDefaultUI: null,

    /**
     * @private
     */
    pastePlainTextUI: null,

    /**
     * @private
     */
    pasteAsWordUI: null,

    /**
     * @private
     */
    pasteDefaultDialog: null,

    /**
     * @private
     */
    pastePlainTextDialog: null,

    /**
     * @private
     */
    pasteWordHtmlDialog: null,

    prePasteBodyStyle: null,

    _editorXOffsetBeforePaste: null,

    _editorYOffsetBeforePaste: null,

    _editorHeightBeforePaste: null,

    _init: function (editorKernel) {
      this.inherited(arguments);
      if (!CUI.rte.Common.ua.isWebKit) {
        editorKernel.addPluginListener('beforekeydown', this.handleKeyDown, this, this,
          false);
      } else {
        editorKernel.addPluginListener('paste', this.handlePaste, this, this, false);
      }
    },

    handleKeyDown: function (e) {
      if (e.cancelKey) {
        return;
      }
      var com = CUI.rte.Common;
      var key = e.getKey();
      if (this.config.defaultPasteMode !== 'browser') {
        var isPasteKey = false;
        if (com.ua.isMac) {
          isPasteKey = (e.isMeta() && (e.getCharCode() === 118)) ||
            (e.isCtrl() && (key === 86));
        } else {
          isPasteKey = (e.isCtrl() && (key === 86)) ||
            (e.isShift() && (key === 45));
        }
        if (isPasteKey) {
          this.beforePaste(e.editContext);
        }
      }
    },

    handlePaste: function (e) {
      if (this.config.defaultPasteMode !== 'browser') {
        this.beforePaste(e.editContext);
      }
    },

    /**
     * <p>Handler that is called when the paste shortcut is hit ("keydown" event) when
     * tags should get stripped from the pasted content.</p>
     * <p>It transfers the focus to a hidden div where pasting actually occurs. The pasted
     * string is later read and inserted in the actual content component (see
     * {@link #afterPaste}).</p>
     * @private
     */
    beforePaste: function (context) {

      if (this.isPasteOperation) {
        return;
      }

      var com = CUI.rte.Common;

      this.isPasteOperation = true;
      this.pasteRange = this.editorKernel.createQualifiedRangeBookmark(context);

      // can't use Ext functionality here, as it doesn't work correctly with the document
      // object of the iframe.
      this.clipboardWrapper = context.createElement('div');

      this.clipboardWrapper.style.position = 'absolute';
      this.clipboardWrapper.style.left = '-10000px';
      this.clipboardWrapper.style.width = '9000px';
      this.clipboardWrapper.style.top = '0px';
      context.root.appendChild(this.clipboardWrapper);

      this.clipboard = context.createElement('div');
      this.clipboard.appendChild(context.createElement('br'));
      this.clipboardWrapper.appendChild(this.clipboard);

      var clipRange;
      if (com.ua.isOldIE) {
        clipRange = context.doc.selection.createRange();
        //force ie to calculate clipRange
        clipRange.moveToElementText(this.clipboard);
        clipRange.select();
      } else {
        this.geckoPreferredScrollingOffset =
          CUI.rte.Selection.getPreferredScrollOffset(context);
        clipRange = context.doc.createRange();
        clipRange.selectNodeContents(this.clipboard);
        var sel = context.win.getSelection();
        sel.removeAllRanges();
        sel.addRange(clipRange);
      }

      if (com.ua.isChrome) {
        var $body = $(context.doc.body);
        this.prePasteBodyStyle = $body.attr('style');
        $body.attr('style', '');
      }

      // save page x,y offsets and the editor height to restore after paste
      this._editorXOffsetBeforePaste = context.root.scrollLeft;
      this._editorYOffsetBeforePaste = context.root.scrollTop;
      this._editorHeightBeforePaste = context.root.scrollHeight;

      CUI.rte.Utils.defer(this.afterPaste, 1, this, [context]);
    },

    /**
     * <p>This is the second part of the "custom paste" implementation.</p>
     * <p>It reads the pasted content from the hidden div and inserts it into the regular
     * content.</p>
     * @private
     */
    afterPaste: function (context) {

      var sel = CUI.rte.Selection;
      var com = CUI.rte.Common;

      if (com.ua.isChrome) {
        var $body = $(context.doc.body);
        $body.attr('style', this.prePasteBodyStyle);
      }

      CUI.rte.DomProcessor.correctGeckoCopyBugs(context, this.clipboard);

      var clipboardHtml = '';
      var clipboardDom = null;
      var clipNodes = this.clipboardWrapper.childNodes;
      // CRTE-108 : Cannot copy and paste the text starting with new line correctly
      // Observed in chrome where chrome does not paste into the clipboard div created above
      // but in a div, created by itself, adjacent to the clipboard div.
      if (clipNodes.length > 1) {
        clipboardHtml = clipNodes[1].innerHTML;
        clipboardDom = clipNodes[1];
      } else {
        clipboardHtml = clipNodes[0].innerHTML;
        clipboardDom = clipNodes[0];
      }

      this.clipboardWrapper.parentNode.removeChild(this.clipboardWrapper);
      if (com.ua.isSafari) {
        CUI.rte.Selection.resetSelection(context, 'start');
      }
      var execRet = this.editorKernel.execCmd('paste', {
        'html': clipboardHtml,
        'dom': clipboardDom,
        'mode': this.config.defaultPasteMode,
        'pasteRange': this.pasteRange,
        'stripHtmlTags': this.config.stripHtmlTags,
        'htmlRules': this.editorKernel.htmlRules,
        'pasteRules': this.config.htmlPasteRules
      });

      if (com.ua.isGecko) {
        if (execRet.geckoEnsureCaretVisibility && context.iFrame) {
          sel.ensureCaretVisibility(context, context.iframe,
            this.geckoPreferredScrollingOffset);
        }
        if (execRet.bookmark) {
          sel.selectBookmark(context, execRet.bookmark);
        }
      } else if (com.ua.isWebKit) {
        if (execRet.geckoEnsureCaretVisibility && context.iFrame) {
          CUI.rte.Utils.defer(function () {
            sel.ensureCaretVisibility(context, context.iframe,
              this.geckoPreferredScrollingOffset);
          }, 1, this);
        }
        if (!context.iFrame) {
          context.root.scrollLeft = this._editorXOffsetBeforePaste;
          context.root.scrollTop = this._editorYOffsetBeforePaste +
            context.root.scrollHeight - this._editorHeightBeforePaste;
        }
      }

      this.clipboard = null;
      this.clipboardWrapper = null;
      this.pasteRange = null;
      this.isPasteOperation = false;
      this.geckoPreferredScrollingOffset = null;
    },

    /**
     * @private
     */
    createPasteDialog: function (type, context, pasteFn, command) {
      var cfg = {
        'type': type,
        'editContext': context,
        'pasteFn': CUI.rte.Utils.scope(pasteFn, this),
        'cancelFn': CUI.rte.Utils.scope(function () {
          this.pasteRange = null;
        }, this),
        'parameters': {
          'command': this.pluginId + '#' + command
        }
      };
      return this.editorKernel.getDialogManager().create(
        CUI.rte.ui.DialogManager.DLG_PASTE, cfg);
    },

    /**
     * @private
     */
    showPasteDialog: function (dialog, context) {
      dialog.setValue('');
      var dm = this.editorKernel.getDialogManager();
      dm.prepareShow(dialog);
      this.pasteRange = this.editorKernel.createQualifiedRangeBookmark(context);
      dm.show(dialog);
    },

    /**
     * @private
     */
    pasteDefault: function (context) {
      var pcmd = CUI.rte.commands.Paste;
      var pasteMode = this.config.defaultPasteMode;
      var pasteDialogMode;
      switch (pasteMode) {
      case pcmd.MODE_BROWSER:
        this.editorKernel.relayCmd('paste', {
          'mode': pasteMode
        });
        return;
      case pcmd.MODE_WORDHTML:
        pasteDialogMode = 'iframe';
        break;
      case pcmd.MODE_PLAINTEXT:
        pasteDialogMode = 'plaintext';
        break;
      default:
        throw new Error('Invalid default paste mode: \'' + pasteMode + '\'.');
      }
      var dm = this.editorKernel.getDialogManager();
      if (dm.isShown(this.pasteDefaultDialog) && dm.toggleVisibility(this.pasteDefaultDialog)) {
        dm.hide(this.pasteDefaultDialog);
        return;
      }
      if (!this.pasteDefaultDialog || dm.mustRecreate(this.pasteDefaultDialog)) {
        this.pasteDefaultDialog = this.createPasteDialog(pasteDialogMode, context,
          this.execPasteDefault, 'paste-default');
      }
      this.showPasteDialog(this.pasteDefaultDialog, context);
    },

    /**
     * @private
     */
    execPasteDefault: function (context, value, isHtml, dom) {
      if (isHtml) {
        this.execPasteWordHtml(context, value, isHtml, dom);
      } else {
        this.execPastePlainText(context, value);
      }
    },

    /**
     * @private
     */
    pastePlainText: function (context) {
      var dm = this.editorKernel.getDialogManager();
      if (dm.isShown(this.pastePlainTextDialog) && dm.toggleVisibility(this.pastePlainTextDialog)) {
        dm.hide(this.pastePlainTextDialog);
        return;
      }
      if (!this.pastePlainTextDialog || dm.mustRecreate(this.pastePlainTextDialog)) {
        this.pastePlainTextDialog = this.createPasteDialog('plaintext', context,
          this.execPastePlainText, 'paste-plaintext');
      }
      this.showPasteDialog(this.pastePlainTextDialog, context);
    },

    /**
     * @private
     */
    execPastePlainText: function (context, value) {
      var pcmd = CUI.rte.commands.Paste;
      this.editorKernel.relayCmd('paste', {
        'mode': pcmd.MODE_PLAINTEXT,
        'text': value,
        'pasteRange': this.pasteRange,
        'stripHtmlTags': this.config.stripHtmlTags
      });
      this.pasteRange = null;
    },

    /**
     * @private
     */
    pasteWordHtml: function (context) {
      var dm = this.editorKernel.getDialogManager();
      if (dm.isShown(this.pasteWordHtmlDialog) && dm.toggleVisibility(this.pasteWordHtmlDialog)) {
        dm.hide(this.pasteWordHtmlDialog);
        return;
      }
      if (!this.pasteWordHtmlDialog || dm.mustRecreate(this.pasteWordHtmlDialog)) {
        this.pasteWordHtmlDialog = this.createPasteDialog('iframe', context,
          this.execPasteWordHtml, 'paste-wordhtml');
      }
      this.showPasteDialog(this.pasteWordHtmlDialog, context);
    },

    /**
     * @private
     */
    execPasteWordHtml: function (context, value, isHtml, dom) {
      var pcmd = CUI.rte.commands.Paste;
      this.editorKernel.relayCmd('paste', {
        'mode': pcmd.MODE_WORDHTML,
        'html': value,
        'dom': dom,
        'pasteRange': this.pasteRange,
        'htmlRules': this.editorKernel.htmlRules,
        'pasteRules': this.config.htmlPasteRules
      });
      this.pasteRange = null;
    },

    getFeatures: function () {
      return ['cut', 'copy', 'paste-default', 'paste-plaintext', 'paste-wordhtml'];
    },

    initializeUI: function (tbGenerator) {
      var plg = CUI.rte.plugins;
      if (this.isFeatureEnabled('cut')) {
        this.cutUI = tbGenerator.createElement('cut', this, false,
          this.getTooltip('cut'));
        tbGenerator.addElement('edit', plg.Plugin.SORT_EDIT, this.cutUI, 10);
      }
      if (this.isFeatureEnabled('copy')) {
        this.copyUI = tbGenerator.createElement('copy', this, false,
          this.getTooltip('copy'));
        tbGenerator.addElement('edit', plg.Plugin.SORT_EDIT, this.copyUI, 10);
      }
      if (this.isFeatureEnabled('paste-default')) {
        this.pasteDefaultUI = tbGenerator.createElement('paste-default', this, false,
          this.getTooltip('paste-default'));
        tbGenerator.addElement('edit', plg.Plugin.SORT_EDIT, this.pasteDefaultUI, 30);
      }
      if (this.isFeatureEnabled('paste-plaintext')) {
        this.pastePlainTextUI = tbGenerator.createElement('paste-plaintext', this,
          false, this.getTooltip('paste-plaintext'));
        tbGenerator.addElement('edit', plg.Plugin.SORT_EDIT, this.pastePlainTextUI, 40);
      }
      if (this.isFeatureEnabled('paste-wordhtml')) {
        this.pasteAsWordUI = tbGenerator.createElement('paste-wordhtml', this, false,
          this.getTooltip('paste-wordhtml'));
        tbGenerator.addElement('edit', plg.Plugin.SORT_EDIT, this.pasteAsWordUI, 50);
      }
    },

    notifyPluginConfig: function (pluginConfig) {
      pluginConfig = pluginConfig || {};
      // workaround for a CUI.rte.Utils#applyDefaults problem (as it seems)
      var removeLinkRemoveRegEx = false;
      if (pluginConfig.htmlPasteRules) {
        removeLinkRemoveRegEx = (pluginConfig.htmlPasteRules.linkRemoveRegEx === '');
      }
      CUI.rte.Utils.applyDefaults(pluginConfig, {
        'defaultPasteMode': 'wordhtml',
        'stripHtmlTags': true,
        'htmlPasteRules': {
          'allowBasics': {
            'bold': true,
            'italic': true,
            'underline': true,
            'anchor': true,
            'image': true,
            'subscript': true,
            'superscript': true
          },
          'allowBlockTags': [
            'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'
          ],
          'allowedAttributes': {
            '*': [
              'class'
            ],
            'table': [
              'width', 'height', 'cellspacing', 'cellpadding', 'border'
            ],
            'td': [
              'width', 'height', 'colspan', 'rowspan', 'valign'
            ],
            'a': [
              'href', 'name', 'title', 'alt'
            ],
            'img': [
              'src', 'title', 'alt', 'width', 'height'
            ],
            'span': [
              'class'
            ]
            /*

             As we don't support changing list types at the moment, we should remove
             it on paste as well to keep the markup in an editable state. Can be
             re-enabled once we support editing the list type.

             ,
             "ul": [
             "type"
             ],
             "ol": [
             "type"
             ]

             */
          },
          'list': {
            'allow': true
          },
          'table': {
            'allow': true
          },
          'linkRemoveRegEx': null
        },
        'tooltips': {
          'cut': {
            'title': CUI.rte.Utils.i18n('plugins.editTools.cutTitle'),
            'text': CUI.rte.Utils.i18n('plugins.editTools.cutText')
          },
          'copy': {
            'title': CUI.rte.Utils.i18n('plugins.editTools.copyTitle'),
            'text': CUI.rte.Utils.i18n('plugins.editTools.copyText')
          },
          'paste-default': {
            'title': CUI.rte.Utils.i18n('plugins.editTools.pasteDefaultTitle'),
            'text': CUI.rte.Utils.i18n('plugins.editTools.pasteDefaultText')
          },
          'paste-plaintext': {
            'title': CUI.rte.Utils.i18n('plugins.editTools.pastePlainTextTitle'),
            'text': CUI.rte.Utils.i18n('plugins.editTools.pastePlainTextText')
          },
          'paste-wordhtml': {
            'title': CUI.rte.Utils.i18n('plugins.editTools.pasteWordHtmlTitle'),
            'text': CUI.rte.Utils.i18n('plugins.editTools.pasteWordHtmlText')
          }
        }
      });
      this.config = pluginConfig;
      if (removeLinkRemoveRegEx) {
        delete this.config.htmlPasteRules.linkRemoveRegEx;
      }
      // some backward compatibility fixes
      if (pluginConfig.htmlPasteRules.table.allowed !== undefined) {
        this.config.htmlPasteRules.table.allow =
          this.config.htmlPasteRules.table.allowed;
        delete this.config.htmlPasteRules.table.allowed;
      }
    },

    execute: function (id, value, env) {
      var context = env.editContext;
      this.pasteRange = this.editorKernel.createQualifiedRangeBookmark(context);
      var cmd = id.toLowerCase();
      switch (cmd) {
      case 'cut':
      case 'copy':
        this.editorKernel.relayCmd(cmd);
        break;
      case 'paste-default':
        this.pasteDefault(context);
        break;
      case 'paste-plaintext':
        this.pastePlainText(context);
        break;
      case 'paste-wordhtml':
        this.pasteWordHtml(context);
        break;
      }
    },

    updateState: function (selDef) {
      if (this.cutUI) {
        this.cutUI.setDisabled(!(selDef.isSelection || selDef.selectedDom));
      }
      if (this.copyUI) {
        this.copyUI.setDisabled(!(selDef.isSelection || selDef.selectedDom));
      }
    },

    isHeadless: function (command, value) {
      return false;
    }

  });


// register plugin
  CUI.rte.plugins.PluginRegistry.register('edit', CUI.rte.plugins.EditToolsPlugin);
}(window.jQuery, window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.FindReplacePlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements find and replace as a plugin.</p>
 * <p>The plugin ID is "<b>findreplace</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>find</b> - adds a button to find text</li>
 *   <li><b>replace</b> - adds a button to find text and replace it with another text</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.FindReplacePlugin = new Class({

    toString: 'FindReplacePlugin',

    extend: CUI.rte.plugins.Plugin,

    /**
     * @private
     */
    findUI: null,

    /**
     * @private
     */
    replaceUI: null,

    /**
     * @private
     */
    findDialog: null,

    /**
     * @private
     */
    replaceDialog: null,

    /**
     * @private
     */
    operationDialog: null,

    /**
     * @private
     */
    currentSearchDef: null,

    /**
     * @private
     */
    savedRange: null,


    find: function (context) {
      var dm = this.editorKernel.getDialogManager();
      var sel = CUI.rte.Selection;
      if (dm.isShown(this.findDialog) && dm.toggleVisibility(this.findDialog)) {
        dm.hide(this.findDialog);
        return;
      }
      this.savedRange = sel.saveNativeSelection(context);
      if (!this.findDialog || dm.mustRecreate(this.findDialog)) {
        var config = {
          'editContext': context,
          'title': CUI.rte.Utils.i18n('plugins.findReplace.findTitle'),
          'isReplace': false,
          'findFn': CUI.rte.Utils.scope(this.execFind, this),
          'cancelFn': CUI.rte.Utils.scope(this.execCancel, this),
          'parameters': {
            'command': this.pluginId + '#find'
          }
        };
        this.findDialog = dm.create(CUI.rte.ui.DialogManager.DLG_FINDREPLACE,
          config);
      }
      this.findDialog.setMode(true, false);
      this.operationDialog = this.findDialog;
      dm.show(this.findDialog);
    },

    execFind: function (context, options, dialog) {
      var com = CUI.rte.Common;
      var sel = CUI.rte.Selection;
      var dpr = CUI.rte.DomProcessor;
      var hasMatchingSel = false;
      sel.restoreNativeSelection(context, this.savedRange);
      var findText = options.findText;
      var matchCase = options.matchCase;
      if (this.currentSearchDef &&
        ((this.currentSearchDef.findText !== findText) ||
        (this.currentSearchDef.matchCase !== matchCase))) {
        this.currentSearchDef = null;
      }
      var match, selection;
      if (!this.currentSearchDef) {
        selection = sel.createProcessingSelection(context);
        var startNode = selection.startNode;
        var startOffset = selection.startOffset;
        if (com.getNodeCharacterCnt(startNode) === 0) {
          startNode = com.getFirstTextChild(startNode, true);
          if (!startNode) {
            startNode = com.getNextCharacterNode(context, selection.startNode);
          }
          if (startNode) {
            startOffset = (startNode.nodeType === 1 ? null : 0);
          } else {
            startOffset = null;
          }
        }
        var searchDoc = new CUI.rte.SearchableDocument();
        searchDoc.create(context.root);
        var config = {
          'ignoreCase': !matchCase
        };
        this.currentSearchDef = {
          'findText': findText,
          'matchCase': matchCase,
          'doc': searchDoc
        };
        var findPos = searchDoc.getRefForNode(startNode);
        if (findPos) {
          findPos = findPos.textPos + startOffset;
          config.startPos = findPos;
        }
        match = searchDoc.find(findText, config);
      } else {
        match = this.currentSearchDef.doc.findNext();
      }
      if (!match) {
        dialog.setMode(false, false);
        this.editorKernel.getDialogManager().alert(
          CUI.rte.Utils.i18n('plugins.findReplace.findReplaceTitle'),
          CUI.rte.Utils.i18n('plugins.findReplace.alertNoMoreResults',
            [findText]),
          CUI.rte.Utils.scope(
            this.operationDialog.focusFindField, this.operationDialog),
          {
            'dialog': this.operationDialog
          });
        this.currentSearchDef.doc.create(context.root);
      }
      if (match && (match.length > 0)) {
        dialog.setMode(false, true);
        var startDef = match[0];
        var endDef = match[match.length - 1];
        selection = {
          'startNode': startDef.node,
          'startOffset': startDef.matchPos - startDef.nodePos,
          'endNode': endDef.node,
          'endOffset': (endDef.matchPos - endDef.nodePos) + endDef.matchChars
        };
        if (com.ua.isIE) {
          this.editorKernel.focus(context);
        }
        var bookmark = sel.bookmarkFromProcessingSelection(context, selection);
        sel.selectBookmark(context, bookmark);
        hasMatchingSel = true;
        if (!com.ua.isOldIE && context.iFrame) {
          // ensure correct scroll offsets for Gecko - which is a "little" bit tricky,
          // as we need to change the DOM and have to restore the DOM accordingly
          // afterwards
          var range = sel.getLeadRange(context);
          var parentNode = range.commonAncestorContainer;
          while (parentNode.nodeType === 3) {
            parentNode = parentNode.parentNode;
          }
          var savedChildren = dpr.saveChildNodes(parentNode);
          var span = context.createElement('span');
          range.surroundContents(span);
          var top = span.offsetTop;
          var parent = span.offsetParent;
          while (parent) {
            top += parent.offsetTop;
            parent = parent.offsetParent;
          }
          var bottom = top + span.offsetHeight;
          var scrollTop = context.root.scrollTop;
          var iframeHeight = context.iFrame.clientHeight;
          var scrollBottom = scrollTop + iframeHeight;
          if (bottom < scrollTop) {
            context.root.scrollTop = top;
          } else if (bottom > scrollBottom) {
            var maxScroll = context.root.scrollHeight;
            if ((maxScroll - bottom) < 8) {
              bottom = maxScroll;
            }
            if (bottom > scrollBottom) {
              context.root.scrollTop = bottom - iframeHeight;
            }
          }
          dpr.removeWithoutChildren(span);
          parentNode.normalize();
          dpr.restoreChildNodes(parentNode, savedChildren);
          sel.selectBookmark(context, bookmark);
        }
        this.savedRange = sel.saveNativeSelection(context);
      }
      return hasMatchingSel;
    },

    replace: function (context) {
      var dm = this.editorKernel.getDialogManager();
      var sel = CUI.rte.Selection;
      if (dm.isShown(this.replaceDialog) && dm.toggleVisibility(this.replaceDialog)) {
        dm.hide(this.replaceDialog);
        return;
      }
      this.savedRange = sel.saveNativeSelection(context);
      if (!this.replaceDialog || dm.mustRecreate(this.replaceDialog)) {
        var config = {
          'editContext': context,
          'isReplace': true,
          'findFn': CUI.rte.Utils.scope(this.execFind, this),
          'replaceFn': CUI.rte.Utils.scope(this.execReplace, this),
          'cancelFn': CUI.rte.Utils.scope(this.execCancel, this),
          'parameters': {
            'command': this.pluginId + '#replace'
          }
        };
        this.replaceDialog = dm.create(CUI.rte.ui.DialogManager.DLG_FINDREPLACE,
          config);
      }
      this.replaceDialog.setMode(true, false);
      this.operationDialog = this.replaceDialog;
      dm.show(this.replaceDialog);
    },

    execReplace: function (context, options, dialog) {
      var com = CUI.rte.Common;
      var dm = this.editorKernel.getDialogManager();
      var sel = CUI.rte.Selection;
      sel.restoreNativeSelection(context, this.savedRange);
      if (options.replaceAll) {
        this.editorKernel.focus(context);
        var searchDoc = new CUI.rte.SearchableDocument();
        searchDoc.create(context.root);
        var config = {
          'ignoreCase': !options.matchCase
        };
        var replaceCnt = 0;
        var match = searchDoc.find(options.findText, config);
        while (match) {
          var startDef = match[0];
          var endDef = match[match.length - 1];
          var selection = {
            'startNode': startDef.node,
            'startOffset': startDef.matchPos - startDef.nodePos,
            'endNode': endDef.node,
            'endOffset': (endDef.matchPos - endDef.nodePos) + endDef.matchChars
          };
          var bookmark = sel.bookmarkFromProcessingSelection(context, selection);
          sel.selectBookmark(context, bookmark);
          // inserthtml can't insert empty strings, so we have to use delete
          // instead; otherwise the browser enters an endless loop
          if (options.replaceText) {
            this.editorKernel.execCmd('inserthtml', CUI.rte.Utils.htmlEncode(
              options.replaceText));
          } else {
            this.editorKernel.execCmd('delete');
          }
          searchDoc.adjustToReplace(options.replaceText);
          replaceCnt++;
          // todo implent more efficently
          searchDoc.create(context.root);
          match = searchDoc.findNext();
        }
        dm.hide(dialog);
        if (replaceCnt > 0) {
          this.editorKernel.getDialogManager().alert(
            CUI.rte.Utils.i18n('plugins.findReplace.replaceAllTitle'),
            CUI.rte.Utils.i18n('plugins.findReplace.alertReplaceResults',
              [options.findText, replaceCnt]),
            CUI.rte.Utils.scope(this.editorKernel.focus,
              this.editorKernel));
        } else {
          this.editorKernel.getDialogManager().alert(
            CUI.rte.Utils.i18n('plugins.findReplace.replaceAllTitle'),
            CUI.rte.Utils.i18n('plugins.findReplace.alertNotFound',
              [options.findText]),
            CUI.rte.Utils.scope(this.editorKernel.focus,
              this.editorKernel));
        }
        this.editorKernel.focus(context);
      } else {
        var preventFind = false;
        try {
          this.editorKernel.focus(context);
          // inserthtml can't insert empty strings, so we have to use delete
          // instead; otherwise the browser enters an endless loop
          if (options.replaceText) {
            this.editorKernel.execCmd('inserthtml', CUI.rte.Utils.htmlEncode(
              options.replaceText));
          } else {
            this.editorKernel.execCmd('delete');
          }
          this.currentSearchDef.doc.adjustToReplace(options.replaceText);
          // todo find a more efficient way than to recreate the entire searchable doc
          this.currentSearchDef.doc.create(context.root);
        } catch (e) {
          if (e.message === 'Could not insert html due to IE limitations.') {
            this.editorKernel.getDialogManager().alert(
              CUI.rte.Utils.i18n('plugins.findReplace.replaceTitle'),
              CUI.rte.Utils.i18n('plugins.findReplace.alertIEProblems'));
            preventFind = true;
          } else {
            throw e;
          }
          this.editorKernel.focus(context);
        }
        this.editorKernel.updateToolbar();
        if (!preventFind) {
          if (com.ua.isIE) {
            this.savedRange = null;
          }
          this.execFind(context, options, dialog);
        } else {
          sel.restoreNativeSelection(context, this.savedRange);
          dialog.setMode(false, false);
        }
      }
    },

    execCancel: function () {
      this.currentSearchDef = null;
    },

    getFeatures: function () {
      return ['find', 'replace'];
    },

    initializeUI: function (tbGenerator) {
      var plg = CUI.rte.plugins;
      if (this.isFeatureEnabled('find')) {
        this.findUI = tbGenerator.createElement('find', this, false,
          this.getTooltip('find'));
        tbGenerator.addElement('findreplace', plg.Plugin.SORT_EDIT + 5, this.findUI,
          100);
      }
      if (this.isFeatureEnabled('replace')) {
        this.replaceUI = tbGenerator.createElement('replace', this, false,
          this.getTooltip('replace'));
        tbGenerator.addElement('findreplace', plg.Plugin.SORT_EDIT + 5, this.replaceUI,
          110);
      }
    },

    notifyPluginConfig: function (pluginConfig) {
      pluginConfig = pluginConfig || {};
      CUI.rte.Utils.applyDefaults(pluginConfig, {
        'tooltips': {
          'find': {
            'title': CUI.rte.Utils.i18n('plugins.findReplace.findTitle'),
            'text': CUI.rte.Utils.i18n('plugins.findReplace.tooltipFind')
          },
          'replace': {
            'title': CUI.rte.Utils.i18n('plugins.findReplace.replaceTitle'),
            'text': CUI.rte.Utils.i18n('plugins.findReplace.tooltipReplace')
          }
        }
      });
      this.config = pluginConfig;
    },

    execute: function (id, value, env) {
      switch (id) {
      case 'find':
        this.find(env.editContext);
        break;
      case 'replace':
        this.replace(env.editContext);
        break;
      }

    },

    updateState: function (selDef) {
      // todo implement
    },

    isHeadless: function (cmd, value) {
      return false;
    }

  });


// register plugin
  CUI.rte.plugins.PluginRegistry.register('findreplace', CUI.rte.plugins.FindReplacePlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.FormatPlugin
 * @extends CUI.rte.plugins.SimpleFormatPlugin
 * <p>This class implements simple character formatting (bold, italic, underlined) as a
 * plugin.</p>
 * <p>The plugin ID is "<b>format</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>bold</b> - adds the "bold" button</li>
 *   <li><b>italic</b> - adds the "italic" button</li>
 *   <li><b>underline</b> - adds the "underline" button</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.FormatPlugin = new Class({

    toString: 'FormatPlugin',

    extend: CUI.rte.plugins.SimpleFormatPlugin,

    _init: function (editorKernel) {
      var plg = CUI.rte.plugins;
      plg.FormatPlugin.prototype.superClass._init.call(this, editorKernel, 'format',
        plg.Plugin.SORT_FORMAT, [{
          'command': 'bold',
          'shortcut': 'b'
        }, {
          'command': 'italic',
          'shortcut': 'i'
        }, {
          'command': 'underline',
          'shortcut': 'u'
        }]);
    },

    notifyPluginConfig: function (pluginConfig) {
      pluginConfig = pluginConfig || {};
      CUI.rte.Utils.applyDefaults(pluginConfig, {
        'features': '*',
        'tooltips': {
          'bold': {
            'title': CUI.rte.Utils.i18n('plugins.format.boldTitle'),
            'text': CUI.rte.Utils.i18n('plugins.format.boldText')
          },
          'italic': {
            'title': CUI.rte.Utils.i18n('plugins.format.italicTitle'),
            'text': CUI.rte.Utils.i18n('plugins.format.italicText')
          },
          'underline': {
            'title': CUI.rte.Utils.i18n('plugins.format.underlineTitle'),
            'text': CUI.rte.Utils.i18n('plugins.format.underlineText')
          }
        }
      });
      this.config = pluginConfig;
    }

  });


// register plugin
  CUI.rte.plugins.PluginRegistry.register('format', CUI.rte.plugins.FormatPlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.JustifyPlugin
 * @extends CUI.rte.plugins.SimpleFormatPlugin
 * <p>This class implements simple character formatting (bold, italic, underlined) as a
 * plugin.</p>
 * <p>The plugin ID is "<b>justify</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>justifyleft</b> - adds a button to left-align the selected block</li>
 *   <li><b>justifyright</b> - adds a button to right-align the selected block</li>
 *   <li><b>justifycenter</b> - adds a button to center the selected block</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.JustifyPlugin = new Class({

    toString: 'JustifyPlugin',

    extend: CUI.rte.plugins.SimpleFormatPlugin,

    _init: function (editorKernel) {
      var plg = CUI.rte.plugins;
      plg.JustifyPlugin.prototype.superClass._init.call(this, editorKernel, 'justify',
        plg.Plugin.SORT_JUSTIFY, ['justifyleft', 'justifycenter', 'justifyright']);
    },

    notifyPluginConfig: function (pluginConfig) {
      pluginConfig = pluginConfig || {};
      CUI.rte.Utils.applyDefaults(pluginConfig, {
        'features': '*',
        'tooltips': {
          'justifyleft': {
            'title': CUI.rte.Utils.i18n('plugins.justify.leftTitle'),
            'text': CUI.rte.Utils.i18n('plugins.justify.leftText')
          },
          'justifycenter': {
            'title': CUI.rte.Utils.i18n('plugins.justify.centerTitle'),
            'text': CUI.rte.Utils.i18n('plugins.justify.centerText')
          },
          'justifyright': {
            'title': CUI.rte.Utils.i18n('plugins.justify.rightTitle'),
            'text': CUI.rte.Utils.i18n('plugins.justify.rightText')
          }
        }
      });
      this.config = pluginConfig;
    }

  });


// register plugin
  CUI.rte.plugins.PluginRegistry.register('justify', CUI.rte.plugins.JustifyPlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.LinkPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements links and anchors as a plugin.</p>
 * <p>The plugin ID is "<b>links</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>modifylink</b> - adds a button to create and modify links</li>
 *   <li><b>unlink</b> - adds a button to remove existing links</li>
 *   <li><b>anchor</b> - adds a button to define anchors</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.LinkPlugin = new Class({

    toString: 'LinkPlugin',

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {Boolean} trimLinkSelection
     * True if leading and trailing whitespace should removed from the selection (not from
     * the actual text/content!) before creating a new link (defaults to true).
     * @since 5.3
     */

    /**
     * @cfg {Object} linkDialogConfig
     * @since 5.3
     */

    /**
     * @cfg {Object} anchorDialogConfig
     * Configuration of the anchor dialog (defaults to { }). You may specify the same
     * config options as for a dialog in the toolkit used. Note that the default value
     * of null implies using a default dialog.
     * @since 5.3
     */

    /**
     * @cfg {String} anchorEditingStyle
     * Style String to be applied on the anchor to make it visible while editing RTE.
     * If this configuration is not provided, the CSS class {@link CUI.rte.Theme.ANCHOR_CLASS} will be used.
     * @since 6.2
     */

    /**
     * @private
     */
    linkDialog: null,

    /**
     * @private
     */
    anchorDialog: null,

    /**
     * @private
     */
    linkUI: null,

    /**
     * @private
     */
    removeLinkUI: null,

    /**
     * @private
     */
    anchorUI: null,

    dialogHelper: null,

    getFeatures: function () {
      return ['modifylink', 'unlink', 'anchor'];
    },

    /**
     * Creates a link using the internal link dialog.
     * @private
     */
    modifyLink: function (context) {
      var com = CUI.rte.Common;
      var dm = this.editorKernel.getDialogManager();
      // hide if dialog is already shown & configured acordingly
      if (dm.isShown(this.linkDialog) && dm.toggleVisibility(this.linkDialog)) {
        dm.hide(this.linkDialog);
        return;
      }
      var dh = CUI.rte.ui.DialogHelper;
      if (!this.linkDialog || dm.mustRecreate(this.linkDialog)) {
        var dialogHelper = dm.createDialogHelper();
        this.dialogHelper = dialogHelper;
        var linkRules = this.editorKernel.htmlRules.links;
        var dialogConfig = {
          'configVersion': 1,
          'defaultDialog': {
            'dialogClass': {
              'type': dh.TYPE_DIALOG
            }
          },
          'parameters': {
            'linkRules': linkRules,
            'editorKernel': this.editorKernel,
            'command': this.pluginId + '#modifylink'
          }
        };
        if (this.config.linkDialogConfig) {
          var addDialogConfig = this.config.linkDialogConfig;
          if (addDialogConfig.linkAttributes) {
            com.removeJcrData(addDialogConfig.linkAttributes);
            var linkAttribs = com.toArray(addDialogConfig.linkAttributes);
            dialogConfig.additionalFields = [];
            var attribCnt = linkAttribs.length;
            var fromModel = function (obj, field) {
              if (dialogHelper.getItemType(field) === dh.TYPE_HIDDEN) {
                return;
              }
              var attribName = dialogHelper.getItemName(field);
              var attribValue = com.getAttribute(obj.dom, attribName);
              if (attribValue) {
                dialogHelper.setItemValue(field, attribValue);
              } else {
                dialogHelper.setItemValue(field, '');
              }
            };
            var toModel = function (obj, field) {
              var attribName = dialogHelper.getItemName(field);
              if (!obj.attributes) {
                obj.attributes = {};
              }
              var value = dialogHelper.getItemValue(field);
              if (value && (value.length > 0)) {
                obj.attributes[attribName] = value;
              } else {
                obj.attributes[attribName] =
                  CUI.rte.commands.Link.REMOVE_ATTRIBUTE;
              }
            };
            for (var a = 0; a < attribCnt; a++) {
              var attrib = linkAttribs[a];
              var type = attrib.type || attrib.xtype;
              var attribName = attrib.attribute;
              var attribLabel = attrib.label || attrib.fieldLabel;
              var itemData = {
                'item': dialogHelper.createItem(type, attribName, attribLabel),
                'fromModel': fromModel,
                'toModel': toModel
              };
              delete attrib.attribute;
              delete attrib.type;
              delete attrib.xtype;
              delete attrib.label;
              delete attrib.fieldLabel;
              CUI.rte.Utils.applyDefaults(itemData.item, attrib);
              dialogConfig.additionalFields.push(itemData);
            }
            delete addDialogConfig.linkAttributes;
          }
          CUI.rte.Utils.applyDefaults(dialogConfig.dialogProperties, addDialogConfig);
        }
        if (linkRules.targetConfig) {
          if (linkRules.targetConfig.mode !== 'blank') {
            dialogConfig.disabledDefaultFields = ['targetBlank'];
          }
          if (linkRules.targetConfig.mode === 'manual') {
            if (!dialogConfig.additionalFields) {
              dialogConfig.additionalFields = {};
            }
            var targetItem = dialogHelper.createItem(dh.TYPE_TEXTFIELD, 'target',
              CUI.rte.Utils.i18n('plugins.link.anchorTitle'));
            dialogConfig.additionalFields.push({
              'item': targetItem,
              'fromModel': function (obj, field) {
                if (obj.dom && obj.dom['target']) {
                  dialogHelper.setItemValue(field, obj.dom['target']);
                }
              },
              'toModel': function (obj, field) {
                if (!obj.attributes) {
                  obj.attributes = {};
                }
                var value = dialogHelper.getItemValue(field);
                if (value && (value.length > 0)) {
                  obj.attributes['target'] = value;
                } else {
                  obj.attributes['target'] = null;
                }
              }
            });
          }
        }
        CUI.rte.Utils.applyDefaults(dialogConfig, this.config.linkDialogConfig || {});
        dialogHelper.configure(dialogConfig);
        var dialogClass = this.getDialogClass();
        if (dialogClass) {
          dialogHelper.registerDialog(dialogClass);
        }
        this.linkDialog = dialogHelper.create();
        dialogHelper.calculateInitialPosition();
      }
      var linkToEdit = null;
      var selectionDef = this.editorKernel.analyzeSelection();
      if (selectionDef.anchorCount === 1) {
        linkToEdit = selectionDef.anchors[0];
      }
      linkToEdit = linkToEdit || {};
      if (typeof linkToEdit.attributes === 'undefined') {
        linkToEdit.attributes = {};
      }
      this.linkDialog.initializeEdit(this.editorKernel, linkToEdit,
        CUI.rte.Utils.scope(this.applyLink, this));
      this.savedRange = CUI.rte.Selection.saveNativeSelection(context);
      dm.show(this.linkDialog);
    },

    getDialogClass: function() {
        return null;
    },

    applyLink: function (context) {
      var linkObj = this.linkDialog.objToEdit;
      if (linkObj) {
        var linkUrl = linkObj.href;
        var cssClass = linkObj.cssClass;
        var target = linkObj.target;
        CUI.rte.Selection.restoreNativeSelection(context, this.savedRange);
        this.editorKernel.relayCmd('modifylink', {
          'url': linkUrl,
          'css': cssClass,
          'target': target,
          'trimLinkSelection': this.config.trimLinkSelection,
          'attributes': linkObj.attributes
        });
      }
    },

    /**
     * Creates an anchor using the anchor dialog.
     * @private
     */
    modifyAnchor: function (context) {
      var dm = this.editorKernel.getDialogManager();
      if (dm.isShown(this.anchorDialog) && dm.toggleVisibility(this.anchorDialog)) {
        dm.hide(this.anchorDialog);
        return;
      }
      if (!this.anchorDialog || dm.mustRecreate(this.anchorDialog)) {
        var editorKernel = this.editorKernel;
        var plugin = this;
        var defaultConfig = {
          execute: function (value) {
            CUI.rte.Selection.restoreNativeSelection(context, plugin.savedRange);
            editorKernel.relayCmd('anchor', { anchorValue : value,
              pluginConfig : plugin.config});
          }
        };
        var dialogConfig;
        if (this.config.anchorDialogConfig) {
          dialogConfig = CUI.rte.Utils.copyObject(this.config.anchorDialogConfig);
        } else {
          dialogConfig = {};
        }
        dialogConfig.parameters = {
          'command': this.pluginId + '#anchor'
        };
        CUI.rte.Utils.applyDefaults(dialogConfig, defaultConfig);
        this.anchorDialog = dm.create(CUI.rte.ui.DialogManager.DLG_ANCHOR,
          dialogConfig);
      } else {
        this.anchorDialog.resetValues();
      }
      dm.prepareShow(this.anchorDialog);
      var selectionDef = this.editorKernel.analyzeSelection(context);
      if (selectionDef.namedAnchorCount === 1) {
        this.anchorDialog.setAnchor(selectionDef.namedAnchors[0]);
      }
      this.savedRange = CUI.rte.Selection.saveNativeSelection(context);
      dm.show(this.anchorDialog);
    },

    initializeUI: function (tbGenerator) {
      var plg = CUI.rte.plugins;
      if (this.isFeatureEnabled('modifylink')) {
        this.linkUI = tbGenerator.createElement('modifylink', this, false,
          this.getTooltip('modifylink'));
        tbGenerator.addElement('links', plg.Plugin.SORT_LINKS, this.linkUI, 10);
      }
      if (this.isFeatureEnabled('unlink')) {
        this.removeLinkUI = tbGenerator.createElement('unlink', this, false,
          this.getTooltip('unlink'));
        tbGenerator.addElement('links', plg.Plugin.SORT_LINKS, this.removeLinkUI, 20);
      }
      if (this.isFeatureEnabled('anchor')) {
        this.anchorUI = tbGenerator.createElement('anchor', this, true,
          this.getTooltip('anchor'));
        tbGenerator.addElement('links', plg.Plugin.SORT_LINKS, this.anchorUI, 30);
      }
    },

    notifyPluginConfig: function (pluginConfig) {
      pluginConfig = pluginConfig || {};
      CUI.rte.Utils.applyDefaults(pluginConfig, {
        'features': '*',
        'trimLinkSelection': true,
        'linkDialogConfig': {
          'targetConfig': {
            'mode': 'manual'
          }
        },
        'anchorDialogConfig': {
          // empty by default
        },
        'tooltips': {
          'modifylink': {
            'title': CUI.rte.Utils.i18n('plugins.link.linkTitle'),
            'text': CUI.rte.Utils.i18n('plugins.link.linkText')
          },
          'unlink': {
            'title': CUI.rte.Utils.i18n('plugins.link.unlinkTitle'),
            'text': CUI.rte.Utils.i18n('plugins.link.unlinkText')
          },
          'anchor': {
            'title': CUI.rte.Utils.i18n('plugins.link.anchorTitle'),
            'text': CUI.rte.Utils.i18n('plugins.link.anchorText')
          }
        }
      });
      this.config = pluginConfig;
    },

    execute: function (cmd, value, env) {
      if (cmd === 'modifylink') {
        this.modifyLink(env.editContext);
      } else if (cmd === 'anchor') {
        this.modifyAnchor(env.editContext);
      } else {
        this.editorKernel.relayCmd(cmd);
      }
    },

    updateState: function (selDef) {
      var hasSingleAnchor = selDef.anchorCount === 1;
      var hasNoAnchor = selDef.anchorCount === 0;
      var selectedNode = selDef.selectedDom;
      var isLinkableObject = false;
      if (selectedNode) {
        isLinkableObject = CUI.rte.Common.isTag(selectedNode,
          CUI.rte.plugins.LinkPlugin.LINKABLE_OBJECTS);
        // placeholder images are not linkable, so we need to check here explicitly
        isLinkableObject &=
          !CUI.rte.genhtml.GenericHtmlRules.isPlaceholder(selectedNode);
      }
      var isCreateLinkEnabled = hasSingleAnchor ||
        ((selDef.isSelection || isLinkableObject) && hasNoAnchor);
      if (this.linkUI) {
        this.linkUI.setDisabled(!isCreateLinkEnabled);
      }
      if (this.removeLinkUI) {
        this.removeLinkUI.setDisabled(!hasSingleAnchor);
      }
      if (this.anchorUI) {
        var hasSingleNamedAnchor = (selDef.namedAnchorCount === 1);
        this.anchorUI.setSelected(hasSingleNamedAnchor);
      }
    },

    isHeadless: function (cmd, value) {
      return (cmd === 'unlink');
    },

    getConfig: function () {
      return this.config;
    }
  });

  /**
   * Array with tag names that define objects (like images) that are linkable when selected
   * @private
   * @static
   * @final
   * @type String[]
   */
  CUI.rte.plugins.LinkPlugin.LINKABLE_OBJECTS = [
    'img'
  ];


// register plugin
  CUI.rte.plugins.PluginRegistry.register('links', CUI.rte.plugins.LinkPlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.ListPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements the list functionality as a plugin.</p>
 * <p>The plugin ID is "<b>lists</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>ordered</b> - adds a button to create or remove an ordered list</li>
 *   <li><b>unordered</b> - adds a button to create or remove an unordered list</li>
 *   <li><b>indent</b> - adds a button to indent list items or blocks</li>
 *   <li><b>outdent</b> - adds a button to outdent list items or blocks</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.ListPlugin = new Class({

    toString: 'ListPlugin',

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {Number} indentSize
     * The size of an indent level in pixels (defaults to 40). Note that this setting
     * only takes effect if the "indent"/"outdent" features of the plugin are enabled and
     * if the indent is applied outside a list.
     * @since 5.3
     */

    /**
     * @cfg {Boolean} keepStructureOnUnlist
     * Defines how to handle the unlisting of nested list items. If set to true, the
     * structure of the two lists will be kept identically by inserting empty list items
     * accordingly. For example: In the given list
     <pre>
     <ul>
     <li>Item 1</li>
     <li>Item 2
     <ul>
     <li>Item 2.1</li>
     <li>Item 2.2</li>
     </ul>
     </li>
     <li>Item 3</li>
     </pre>
     * Item 2.1 is unlisted. This will result in the following markup if
     * keepStructureOnUnlist == true:
     <pre>
     <ul>
     <li>Item 1</li>
     <li>Item 2</li>
     </ul>
     <p>Item 2.1</p>
     <ul>
     <li>&nbsp;
     <ul>
     <li>Item 2.2</li>
     </ul>
     </li>
     <li>Item 3</li>
     </ul>
     </pre>
     * Respectively, if keepStructureOnUnlist == false:
     <pre>
     <ul>
     <li>Item 1</li>
     <li>Item 2</li>
     </ul>
     <p>Item 2.1</p>
     <ul>
     <li>Item 2.2</li>
     <li>Item 3</li>
     </ul>
     </ul>
     </pre>
     * Defaults to false.
     */

    /**
     * @private
     */
    orderedListUI: null,

    /**
     * @private
     */
    unorderedListUI: null,

    /**
     * @private
     */
    indentUI: null,

    /**
     * @private
     */
    outdentUI: null,

    _init: function (editorKernel) {
      this.inherited(arguments);
      editorKernel.addPluginListener('beforekeydown', this.handleOnKey, this, this, false);
    },

    /**
     * This function creates new list entries (<li>) by pressing CRTL+ENTER
     * This workaround should be used if there is a block node within a list entry
     *
     * @param event
     */
    handleOnKey: function (event) {
      var range, rangeNode, parentNode, parentParentNode, newListNode;

      if (event.isEnter() && event.isCtrl()) {
        try {
          if (window.getSelection) {  // all browsers, except IE before version 9
            range = CUI.rte.Selection.getLeadRange(event.editContext);
          }
          else {
            if (document.selection) {   // Internet Explorer 6/7/8
              range = document.selection.createRange();
            }
          }

          rangeNode = range.commonAncestorContainer ? range.commonAncestorContainer :
            range.parentElement ? range.parentElement() : range.item(0);
          parentNode = rangeNode.parentNode ? rangeNode.parentNode : rangeNode.parentElement();

          while (rangeNode !== parentNode && parentNode.tagName !== 'LI') {
            rangeNode = rangeNode.parentNode ? rangeNode.parentNode : rangeNode.parentElement();
            parentNode = rangeNode.parentNode ? rangeNode.parentNode : rangeNode.parentElement();
          }

          if (rangeNode.tagName && rangeNode.tagName !== 'LI' && parentNode.tagName === 'LI') {
            parentParentNode = parentNode.parentNode ? parentNode.parentNode : parentNode.parentElement();

            newListNode = event.editContext.doc.createElement('li');
            newListNode.appendChild(rangeNode);

            if (parentNode.nextSibling) {
              parentParentNode.insertBefore(newListNode, parentNode.nextSibling);
            } else {
              parentParentNode.appendChild(newListNode);
            }

            CUI.rte.Selection.selectNode(event.editContext, newListNode, 1);
          }
        } catch (err) {
          // sometimes a node might be undefined
        }
      }
    },

    getFeatures: function () {
      return ['ordered', 'unordered', 'indent', 'outdent'];
    },

    initializeUI: function (tbGenerator) {
      var plg = CUI.rte.plugins;
      if (this.isFeatureEnabled('unordered')) {
        this.unorderedListUI = tbGenerator.createElement('unordered', this,
          true, this.getTooltip('unordered'));
        tbGenerator.addElement('lists', plg.Plugin.SORT_LISTS, this.unorderedListUI,
          10);
      }
      if (this.isFeatureEnabled('ordered')) {
        this.orderedListUI = tbGenerator.createElement('ordered', this, true,
          this.getTooltip('ordered'));
        tbGenerator.addElement('lists', plg.Plugin.SORT_LISTS, this.orderedListUI, 20);
      }
      if (this.isFeatureEnabled('indent')) {
        this.indentUI = tbGenerator.createElement('indent', this, false,
          this.getTooltip('indent'));
        tbGenerator.addElement('lists', plg.Plugin.SORT_LISTS, this.indentUI, 40);
      }
      if (this.isFeatureEnabled('outdent')) {
        this.outdentUI = tbGenerator.createElement('outdent', this, false,
          this.getTooltip('outdent'));
        tbGenerator.addElement('lists', plg.Plugin.SORT_LISTS, this.outdentUI, 30);
      }
    },

    notifyPluginConfig: function (pluginConfig) {
      pluginConfig = pluginConfig || {};
      CUI.rte.Utils.applyDefaults(pluginConfig, {
        'features': '*',
        'indentSize': 40,
        'keepStructureOnUnlist': false,
        'tooltips': {
          'unordered': {
            'title': CUI.rte.Utils.i18n('plugins.list.ulTitle'),
            'text': CUI.rte.Utils.i18n('plugins.list.ulText')
          },
          'ordered': {
            'title': CUI.rte.Utils.i18n('plugins.list.olTitle'),
            'text': CUI.rte.Utils.i18n('plugins.list.olText')
          },
          'indent': {
            'title': CUI.rte.Utils.i18n('plugins.list.indentTitle'),
            'text': CUI.rte.Utils.i18n('plugins.list.indentText')
          },
          'outdent': {
            'title': CUI.rte.Utils.i18n('plugins.list.outdentTitle'),
            'text': CUI.rte.Utils.i18n('plugins.list.outdentText')
          }
        }
      });
      this.config = pluginConfig;
    },

    execute: function (id) {
      var value;
      if ((id === 'indent') || (id === 'outdent')) {
        value = this.config.indentSize;
      } else if (CUI.rte.Common.strStartsWith(id, 'insert')) {
        value = this.config.keepStructureOnUnlist;
      } else {
        id = 'insert' + id + 'list';
        value = this.config.keepStructureOnUnlist;
      }
      this.editorKernel.relayCmd(id, value);
    },

    updateState: function (selDef) {
      var context = selDef.editContext;
      var state, isDisabled;
      if (this.orderedListUI) {
        state = this.editorKernel.queryState('insertorderedlist', selDef);
        isDisabled = (state === null || state === undefined) ||
          (state === CUI.rte.commands.List.NO_LIST_AVAILABLE);
        this.orderedListUI.setSelected((state === true) || (state === null || state === undefined));
        this.orderedListUI.setDisabled(isDisabled);
      }
      if (this.unorderedListUI) {
        state = this.editorKernel.queryState('insertunorderedlist', selDef);
        isDisabled = (state === null || state === undefined) ||
          (state === CUI.rte.commands.List.NO_LIST_AVAILABLE);
        this.unorderedListUI.setSelected((state === true) || (state === null || state === undefined));
        this.unorderedListUI.setDisabled(isDisabled);
      }
      if (this.outdentUI) {
        // outdent is only available if the current selection has some indent
        this.outdentUI.setDisabled(!this.editorKernel.queryState('indent', selDef));
      }
      if (this.indentUI) {
        // indent is basically always available - but not if the selection contains
        // "first items", which cannot be indented using reasonable HTML
        var isEnabled = true;
        var listItems = selDef.nodeList.getTags(context, [{
          'matcher': function (dom) {
            return CUI.rte.Common.isTag(dom, 'li');
          }
        }
        ], true, true);
        var itemCnt = listItems.length;
        for (var i = 0; i < itemCnt; i++) {
          var itemDom = listItems[i].dom;
          if (!itemDom.previousSibling) {
            var parentItemDom = itemDom.parentNode.parentNode;
            var isParentInSelection = false;
            for (var c = 0; c < itemCnt; c++) {
              if (listItems[c].dom === parentItemDom) {
                isParentInSelection = true;
                break;
              }
            }
            if (!isParentInSelection) {
              isEnabled = false;
              break;
            }
          }
        }
        this.indentUI.setDisabled(!isEnabled);
      }
    }

  });


// register plugin
  CUI.rte.plugins.PluginRegistry.register('lists', CUI.rte.plugins.ListPlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.MiscToolsPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements miscellaneous tools (sourceview, special chars) as a plugin.</p>
 * <p>The plugin ID is "<b>misctools</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>specialchars</b> - adds an icon to invoke a dialog that may be used for
 *     inserting characters that are not easily accessible via the keyboard</li>
 *   <li><b>sourceedit</b> - adds an icon that allows to switch to source edit mode</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.MiscToolsPlugin = new Class({

    toString: 'MiscToolsPlugin',

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {Object} specialCharsConfig
     * <p>Configuration of the special characters component. Valid config properties are:
     * </p>
     * <ul>
     *   <li><code>chars</code> : Object<br>
     *     Table of characters to be added to the special character dialog. Choose the
     *     property name for each element at your discretion. Each element defines a single
     *     character or a range of characters:
     *     <ul>
     *       <li>Use an "entity" property (String) to specify the HTML entity of a single
     *         character (for example: "&amp;copy;").</li>
     *       <li>Use "rangeStart" (Number)/"rangeEnd" (Number) properties to specify a range
     *         of unicode characters. Both rangeStart and rangeEnd must specify the numeric
     *         representation of a unicode character. Note that the character specified as
     *         rangeEnd is also included in the specified range.</li>
     *     </ul>
     *   </li>
     *   <li><code>tableCls</code> : String<br>
     *     The CSS class to be used for formatting the table that displays the special
     *     characters.</li>
     *   <li><code>cellCls</code> : String<br>
     *     The CSS class to be used for formatting cells of the character table.</li>
     *   <li><code>overCls</code> : String<br>
     *     The CSS class to be used for formatting cells of the character table if
     *     rolledover.</li>
     *   <li><code>magnifyCls</code> : String<br>
     *     CSS class to be used for the magnified view of the currently rolledover
     *     character.</li>
     * </ul>
     * <p>Defaults to:</p>
     <pre>
     {
         "tableCls": "richtext-scd-table",
         "cellCls": "richtext-scd-cell",
         "overCls": "richtext-scd-cell-over",
         "magnifyCls": "richtext-scd-magnify",
         "chars": {
             "copyright": {
                 "entity": "&copy;"
             },
             "registered": {
                 "entity": "&reg;"
             },
             "trademark": {
                 "entity": "&trade;"
             }
         }
     }
     </pre>
     * @since 5.3
     */

    /**
     * @private
     */
    specialCharsUI: null,

    /**
     * @private
     */
    sourceEditUI: null,

    /**
     * @private
     */
    specialCharsDialog: null,

    /**
     * @private
     */
    savedRange: null,


    getFeatures: function () {
      return ['specialchars', 'sourceedit'];
    },

    initializeUI: function (tbGenerator) {
      var plg = CUI.rte.plugins;
      if (this.isFeatureEnabled('specialchars')) {
        this.specialCharsUI = tbGenerator.createElement('specialchars', this, false,
          this.getTooltip('specialchars'));
        tbGenerator.addElement('misc', plg.Plugin.SORT_MISC, this.specialCharsUI, 100);
      }
      if (this.isFeatureEnabled('sourceedit') && this.editorKernel.canEditSource()) {
        this.sourceEditUI = tbGenerator.createElement('sourceedit', this, true,
          this.getTooltip('sourceedit'));
        tbGenerator.addElement('misc', plg.Plugin.SORT_MISC, this.sourceEditUI, 110);
      }
    },

    /**
     * Inserts a special character using the corresponding dialog.
     * @private
     */
    insertSpecialChars: function (context) {
      var dm = this.editorKernel.getDialogManager();
      if (dm.isShown(this.specialCharsDialog) &&
        dm.toggleVisibility(this.specialCharsDialog)) {
        dm.hide(this.specialCharsDialog);
        return;
      }
      this.savedRange = CUI.rte.Selection.saveNativeSelection(context);
      if (!this.specialCharsDialog || dm.mustRecreate(this.specialCharsDialog)) {
        var defaultConfig = {
          'insertCharacter': CUI.rte.Utils.scope(function (charToInsert) {
            this.insertCharacter(charToInsert);
          }, this),
          'parameters': {
            'command': this.pluginId + '#specialchars'
          }
        };
        var dialogConfig = this.config.specialCharsConfig || {};
        CUI.rte.Utils.applyDefaults(dialogConfig, defaultConfig);
        this.specialCharsDialog = dm.create(CUI.rte.ui.DialogManager.DLG_SPECCHARS,
          dialogConfig);
        // would throw a SecurityError if set in dialogConfig or while creating the
        // dialog
        this.specialCharsDialog.editContext = context;
      }
      dm.show(this.specialCharsDialog);
    },

    insertCharacter: function (charToInsert) {
      CUI.rte.Selection.restoreNativeSelection(this.specialCharsDialog.editContext, this.savedRange);
      this.editorKernel.relayCmd('InsertHTML', charToInsert);
    },

    notifyPluginConfig: function (pluginConfig) {
      // configuring "special characters" dialog
      pluginConfig = pluginConfig || {};
      var defaults = {
        // TODO use toolkit-specific dialog configuration
        'specialCharsConfig': {
          'tableCls': 'richtext-scd-table',
          'rowCls': undefined,
          'cellCls': 'richtext-scd-cell',
          'overCls': 'richtext-scd-cell-over',
          'magnifyCls': 'richtext-scd-magnify',
          'chars': {
            'copyright': {
              'entity': '&copy;'
            },
            'registered': {
              'entity': '&reg;'
            },
            'trademark': {
              'entity': '&trade;'
            }
          }
        },
        'tooltips': {
          'sourceedit': {
            'title': CUI.rte.Utils.i18n('plugins.miscTools.sourceEditTitle'),
            'text': CUI.rte.Utils.i18n('plugins.miscTools.sourceEditText')
          },
          'specialchars': {
            'title': CUI.rte.Utils.i18n('plugins.miscTools.specialCharsTitle'),
            'text': CUI.rte.Utils.i18n('plugins.miscTools.specialCharsText')
          }
        }
      };
      if (pluginConfig.specialCharsConfig && pluginConfig.specialCharsConfig.chars) {
        delete defaults.specialCharsConfig.chars;
      }
      CUI.rte.Utils.applyDefaults(pluginConfig, defaults);
      this.config = pluginConfig;
    },

    execute: function (id, value, options) {
      var context = options.editContext;
      if (id === 'specialchars') {
        this.insertSpecialChars(context);
      } else if ((id === 'sourceedit') && this.sourceEditUI) {
        // defer is required for correct temporary focus handling
        CUI.rte.Utils.defer(this.editorKernel.requestSourceEdit, 1,
          this.editorKernel, [this.sourceEditUI.isSelected()]);
      }
    },

    updateState: function (selDef) {
      var context = selDef.editContext;
      if (this.specialCharsUI !== null && this.specialCharsUI !== undefined) {
        var cells = selDef.nodeList.getTags(context, [{
          'tagName': ['td', 'th']
        }
        ], false);
        var disable = (cells.length > 0);
        this.specialCharsUI.setDisabled(disable);
      }
    },

    isHeadless: function (cmd, value) {
      return (cmd !== 'specialchars');
    }

  });


// register plugin
  CUI.rte.plugins.PluginRegistry.register('misctools',
    CUI.rte.plugins.MiscToolsPlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.ParagraphFormatPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements paragraph formats (h1, h2, p, etc.)  as a plugin.</p>
 * <p>The plugin ID is "<b>paraformat</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>paraformat</b> - adds a format selector (formats will always be applied on block
 *     scope).</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.ParagraphFormatPlugin = new Class({

    toString: 'ParagraphFormatPlugin',

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {Object/Object[]} formats
     * <p>Defines the block formats (p, h1, h2, h3, ...) that are applicable to paragraphs.
     * </p>
     * <p>You can choose a deliberate (but unique) property name for each format, if you
     * chosoe to provide an Object rather than a Object[]. Each element (of the Array) or
     * property value (if choosing the Object representation) must have the following
     * properties:</p>
     * <ul>
     *   <li><code>tag</code> : String<br>
     *     The name of the tag that represents the block format (for example: "p", "h1",
     *     "h2", ...)</li>
     *   <li><code>description</code> : String<br>
     *     The text that represents the paragraph format in the format selector</li>
     * </uL>
     * <p>Note that this configuration only takes effect if the
     * {@link CUI.rte.plugins.ParagraphFormatPlugin "paraformat" plugin} is enabled.
     * Also note that you can't set additional DOM attributes using the "paraformat"
     * plugin.</p>
     * <p>Defaults to:</p>
     <pre>
     [
     {
         "tag": "p",
         "description": CUI.rte.Utils.i18n("Paragraph")
     }, {
        "tag": "h1",
        "description": CUI.rte.Utils.i18n("Heading 1")
    }, {
        "tag": "h2",
        "description": CUI.rte.Utils.i18n("Heading 2")
    }, {
        "tag": "h3",
        "description": CUI.rte.Utils.i18n("Heading 3")
    }
     ]
     </pre>
     * @since 5.3
     */

    /**
     * @private
     */
    cachedFormats: null,

    /**
     * @private
     */
    formatUI: null,

    getFeatures: function () {
      return ['paraformat'];
    },

    /**
     * @private
     */
    getFormatId: function (dom) {
      var tagName = dom.tagName.toLowerCase();
      var formats = this.getFormats();
      var formatCnt = formats.length;
      for (var f = 0; f < formatCnt; f++) {
        var formatDef = formats[f];
        if (formatDef.tag && (formatDef.tag === tagName)) {
          return formatDef.tag;
        }
      }
      return null;
    },

    getFormats: function () {
      var com = CUI.rte.Common;
      if (this.cachedFormats === null || this.cachedFormats === undefined) {
        this.cachedFormats = this.config.formats || {};
        com.removeJcrData(this.cachedFormats);
        this.cachedFormats = com.toArray(this.cachedFormats, 'tag', 'description');
      }
      return this.cachedFormats;
    },

    setFormats: function (formats) {
      this.cachedFormats = formats;
    },

    hasFormatsConfigured: function () {
      return !!this.config.formats;
    },

    getFormatById: function (formats, id) {
      var formatCnt = formats.length;
      for (var f = 0; f < formatCnt; f++) {
        if (formats[f].tag === id) {
          return formats[f];
        }
      }
      return null;
    },

    initializeUI: function (tbGenerator) {
      var plg = CUI.rte.plugins;
      if (this.isFeatureEnabled('paraformat')) {
        this.formatUI = tbGenerator.createParaFormatter('paraformat', this, null,
          this.getFormats());
        tbGenerator.addElement('paraformat', plg.Plugin.SORT_PARAFORMAT, this.formatUI,
          10);
      }
    },

    notifyPluginConfig: function (pluginConfig) {
      pluginConfig = pluginConfig || {};
      var defaults = {
        'formats': [{
          'tag': 'p',
          'description': CUI.rte.Utils.i18n('plugins.paraFormat.defaultP')
        }, {
          'tag': 'h1',
          'description': CUI.rte.Utils.i18n('plugins.paraFormat.defaultH1')
        }, {
          'tag': 'h2',
          'description': CUI.rte.Utils.i18n('plugins.paraFormat.defaultH2')
        }, {
          'tag': 'h3',
          'description': CUI.rte.Utils.i18n('plugins.paraFormat.defaultH3')
        }
        ]
      };
      // remove predefined formats if userdefined formats are specified; otherwise both
      // would get merged
      if (pluginConfig.formats) {
        delete defaults.formats;
      }
      CUI.rte.Utils.applyDefaults(pluginConfig, defaults);
      this.config = pluginConfig;
    },

    execute: function (cmd) {
      if (this.formatUI) {
        var formatId = this.formatUI.getSelectedFormat();
        if (formatId) {
          this.editorKernel.relayCmd('format', this.getFormatById(this.getFormats(),
            formatId));
        }
      }
    },

    updateState: function (selDef) {
      if (!this.formatUI) {
        return;
      }
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var formatToSelect = null;
      var nodeList = selDef.nodeList;
      var nodeToCheck = nodeList.commonAncestor;
      var hasParentFormat = false;
      var formats = {};
      var noFormatCnt = 0;
      var formatCnt = 0;
      var auxRoot = null;
      while (nodeToCheck) {
        if (nodeToCheck.nodeType === 1) {
          formatToSelect = this.getFormatId(nodeToCheck);
          if (formatToSelect) {
            formats[formatToSelect] = true;
            hasParentFormat = true;
            formatCnt++;
            break;
          } else if (com.isTag(nodeToCheck, dpr.AUXILIARY_ROOT_TAGS)) {
            if (auxRoot === null || auxRoot === undefined) {
              auxRoot = nodeToCheck;
            }
          }
        }
        nodeToCheck = nodeToCheck.parentNode;
      }
      // check first level nodes also, if no parent format has been detected
      if (!hasParentFormat) {
        var nodeCnt = nodeList.nodes.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
          nodeToCheck = nodeList.nodes[nodeIndex];
          if (nodeToCheck.dom.nodeType === 1) {
            var newFormat = this.getFormatId(nodeToCheck.dom);
            if (newFormat) {
              if (!formats[newFormat]) {
                formats[newFormat] = true;
                formatCnt++;
              }
              if (formatToSelect === null || formatToSelect === undefined) {
                formatToSelect = newFormat;
              }
            } else {
              noFormatCnt++;
            }
          } else {
            noFormatCnt++;
          }
        }
      }
      this.formatUI.selectFormat(formatToSelect, auxRoot, formatCnt, noFormatCnt);
    }

  });


// register plugin
  CUI.rte.plugins.PluginRegistry.register('paraformat',
    CUI.rte.plugins.ParagraphFormatPlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.SubSuperScriptPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements sub- and superscript as a plugin.</p>
 * <p>The plugin ID is "<b>subsuperscript</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>subscript</b> - adds a button to format the selected text with subscript</li>
 *   <li><b>superscript</b> - adds a button to format the selected text with superscript
 *     </li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.SubSuperScriptPlugin = new Class({

    toString: 'SubSuperScriptPlugin',

    extend: CUI.rte.plugins.Plugin,

    /**
     * @private
     */
    subscriptUI: null,

    /**
     * @private
     */
    superscriptUI: null,


    getFeatures: function () {
      return ['subscript', 'superscript'];
    },

    initializeUI: function (tbGenerator) {
      var plg = CUI.rte.plugins;
      if (this.isFeatureEnabled('subscript')) {
        this.subscriptUI = tbGenerator.createElement('subscript', this, true,
          this.getTooltip('subscript'));
        tbGenerator.addElement('format', plg.Plugin.SORT_FORMAT, this.subscriptUI, 100);
      }
      if (this.isFeatureEnabled('superscript')) {
        this.superscriptUI = tbGenerator.createElement('superscript', this, true,
          this.getTooltip('superscript'));
        tbGenerator.addElement('format', plg.Plugin.SORT_FORMAT, this.superscriptUI,
          110);
      }
    },

    execute: function (id) {
      this.editorKernel.relayCmd(id);
    },

    updateState: function (selDef) {
      var hasSubscript = this.editorKernel.queryState('subscript', selDef);
      var hasSuperscript = this.editorKernel.queryState('superscript', selDef);
      if (this.subscriptUI !== null && this.subscriptUI !== undefined) {
        this.subscriptUI.setSelected(hasSubscript);
      }
      if (this.superscriptUI !== null && this.superscriptUI !== undefined) {
        this.superscriptUI.setSelected(hasSuperscript);
      }
    },

    notifyPluginConfig: function (pluginConfig) {
      // configuring "special characters" dialog
      pluginConfig = pluginConfig || {};
      var defaults = {
        'tooltips': {
          'subscript': {
            'title': CUI.rte.Utils.i18n('plugins.subSuperScript.subTitle'),
            'text': CUI.rte.Utils.i18n('plugins.subSuperScript.subText')
          },
          'superscript': {
            'title': CUI.rte.Utils.i18n('plugins.subSuperScript.superTitle'),
            'text': CUI.rte.Utils.i18n('plugins.subSuperScript.superText')
          }
        }
      };
      CUI.rte.Utils.applyDefaults(pluginConfig, defaults);
      this.config = pluginConfig;
    }

  });


// register plugin
  CUI.rte.plugins.PluginRegistry.register('subsuperscript',
    CUI.rte.plugins.SubSuperScriptPlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.AbstractTablePlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class provides the basic table functionality as an abstract plugin.</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>table</b> - adds a button/context menu entry for creating new tables and editing
 *     the properties of existing tables</li>
 *   <li><b>removetable</b> - adds a context menu entry for removing a table</li>
 *   <li><b>insertrow</b> - adds a context menu entry for inserting a table row</li>
 *   <li><b>removerow</b> - adds a context menu entry for removing an existing table row
 *     </li>
 *   <li><b>insertcolumn</b> - adds a context menu entry for inserting a table column</li>
 *   <li><b>removecolumn</b> - adds a context menu entry for removing a table column</li>
 *   <li><b>cellprops</b> - adds a context menu entry for editing cell properties</li>
 *   <li><b>mergecells</b> - adds a context menu entry for merging selected cells (added in
 *     5.3)</li>
 *   <li><b>splitcell</b> - adds a context menu entry for splitting an existing cell (added
 *     in 5.3)</li>
 *   <li><b>selectrow</b> - adds a context menu entry for selecting an entire row (added in
 *     5.3)</li>
 *   <li><b>selectcolumn</b> - adds a context menu entry for selecting an entire column
 *     (added in 5.3)</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.AbstractTablePlugin = new Class({

    toString: 'AbstractTablePlugin',

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {String} editMode
     * <p>Specifies the edit mode the RichText component is running (defaults to "default").
     * "table" represents the table mode which is used to allow editing a single table
     * only.<p>
     * <p>In table mode, the following restrictions apply:</p>
     * <ul>
     *   <li>The user can not enter text outside the table boundaries.</li>
     *   <li>The "Create table" context menu item is not available.</li>
     *   <li>The "Remove table" context menu item is not available.</li>
     * </ul>
     * <p>Note that there might be additional differences on the plugin-level; for
     * example the "table" plugin will add several icons to the toolbar in table mode,
     * which won't appear in default mode. Also note that in table mode, the "table" plugin
     * is automatically enabled with all features if you don't specify a specific
     * configuration for the table plugin (see {@link #rtePlugins}).</p>
     * @since 5.3
     */

    /**
     * @cfg {Object} defaultValues
     * <p>The default values for for newly created tables. May have the following
     * properties:</p>
     * <ul>
     *   <li><code>columns</code> : String<br>
     *     The initial number of columns of the table</li>
     *   <li><code>rows</code> : String<br>
     *     The initial number of rows of the table</li>
     *   <li><code>header</code> : String<br>
     *     Defines if the table should contain headers; valid values are: "none" for no
     *     headers, "top" for creating header cells for the first row, "left" for
     *     creating header cells for the first column, "topleft" for creating header
     *     cells for the first row and the first column</li>
     *   <li><code>width</code> : String (optional)<br>
     *     The initial table width</li>
     *   <li><code>height</code> : String (optional)<br>
     *     The initial table height</li>
     *   <li><code>cellspacing</code> : String (optional)<br>
     *     The initial cell spacing value of the table</li>
     *   <li><code>cellpadding</code> : String (optional)<br>
     *     The initial cell padding value of the table</li>
     *   <li><code>border</code> : String (optional)<br>
     *     The initial border value of the table</li>
     *   <li><code>tableTemplate</code> : String<br>
     *     A HTML template for creating the table</li>
     * </ul>
     * <p>Note that all properties should be provided as Strings.</p>
     * <p>Notes on using templates for creating a new table:</p>
     * <ul>
     *   <li>If you are specifying a table template (using the tableTemplate property), all
     *     other table properties are ignored. Templates take precedence over all other
     *     properties.</li>
     *   <li>The template must contain plain HTML code only. Currently no placeholders are
     *     supported.</li>
     * </ul>
     * <p>Defaults to: { "cellspacing": "0", "cellpadding": "1", "border": "1", "columns":
     * "3", "rows": "2", "header": "none", "tableTemplate": null }</p>
     * @since 5.3
     */

    /**
     * @cfg {Object/Object[]} tableStyles
     * <p>Defines CSS classes that are available to the user for styling a table. There are
     * two ways of specifying each table style:</p>
     * <ol>
     *   <li>Providing tableStyles as an Object: Use the CSS class name as property name.
     *   Specify the text that should appear in the style selector as property value
     *   (String).</li>
     *   <li>Providing tableStyles as an Object[]: Each element has to provide "cssName"
     *   (the CSS class name) and "text" (the text that appears in the style selector)
     *   properties.</li>
     * </ol>
     * <p>Styling is applied by adding a corresponding "class" attribute to the table
     * element appropriately.</p>
     * <p>Defaults to null.</p>
     * @since 5.3
     */

    /**
     * @cfg {Object} tablePropConfig
     * <p>This object configures the table properties dialog. It consists of the following
     * properties:</p>
     * <ul>
     *   <li><code>tableStyles</code> : Object<br>
     *     Object that defines the styles that are available for styling a table. This was
     *     the way of defining table styles for CQ 5.2. This is deprecated now; use
     *     {@link #tableStyles} as of CQ 5.3.</li>
     *   <li><code>defaultValues</code> : Object<br>
     *     Object that defines the default values for newly created tables. This was the
     *     way of defining default values for CQ 5.2. This is deprecated now; use
     *     {@link #defaultValues} as of CQ 5.3.</li>
     * </ul>
     * <p>Defaults to null (as of CQ 5.3) or (CQ 5.2):
     <pre>
     {
         "tableStyles": null,
         "defaultValues": {
             "cellspacing": "0",
             "cellpadding": "1",
             "border": "1",
             "columns": "3",
             "rows": "2",
             "header": "none"
         }
     }
     </pre>
     */

    /**
     * @cfg {Object|Object[]} cellStyles
     * <p>Defines CSS classes that are available to the user for styling a table cell. There
     * are two ways of specifying the CSS classes:</p>
     * <ol>
     *   <li>Providing cellStyles as an Object: Use the CSS class name as property name.
     *   Specify the text that should appear in the style selector as property value
     *   (String).</li>
     *   <li>Providing cellStyles as an Object[]: Each element has to provide "cssName" (the
     *   CSS class name) and "text" (the text that appears in the style selector)
     *   properties.</li>
     * </ol>
     * <p>Defaults to null</p>
     * @since 5.3
     */

    /**
     * @cfg {Object} cellPropConfig
     * <p>This object configures the cell properties dialog. It consists of the following
     * properties:</p>
     * <ul>
     *   <li><code>cellStyles</code> : Object<br>
     *     Object that defines the styles that are available for styling a table cell. This
     *     was the way of defining cell styles for CQ 5.2. This is deprecated now; use
     *     {@link #cellStyles} as of CQ 5.3.</li>
     *     </li>
     * </ul>
     * <p>Defaults to null (as of CQ 5.3) resp. { "cellStyles": null } (CQ 5.2)</p>
     */

    /**
     * @cfg {String} hiddenHeaderClassName
     * <p>Specifies the name of the CSS class that will be applied on the hidden-header cell, when
     * the richtext is not being edited. Apply CSS on this class to hide the hidden-header cell.</p>
     * <p>User can either provide this class or a style String {@link #hiddenHeaderStyle}.</p>
     * <p>Please note that 'hiddenHeaderClassName' is given more priority than 'hiddenHeaderStyle'.</p>
     * @since 6.2
     */

    /**
     * @cfg {String} hiddenHeaderStyle
     * <p>Specifies the Style String that will be applied on the hidden-header cell, when
     * the richtext is <b>not</b> being edited.</p>
     * <p>User can either provide this style String or {@link #hiddenHeaderClassName}.</p>
     * <p>Please note that 'hiddenHeaderClassName' is given more priority than 'hiddenHeaderStyle'.</p>
     * <p>Default value : "display: block; height: 1px; width: 1px; overflow: hidden; position: absolute; top: -10px;"</p>
     * @since 6.2
     */

    /**
     * @cfg {String} hiddenHeaderEditingCSS
     * <p>Specifies the name of the CSS class that will be applied on the hidden-header cell, when
     * the richtext <b>is</b> being edited. Apply CSS on this class to differentiate the hidden-header cell from other cells.</p>
     * <p>User can either provide this class or a style String {@link #hiddenHeaderEditingStyle}.</p>
     * <p>Please note that 'hiddenHeaderEditingCSS' is given more priority than 'hiddenHeaderEditingStyle'.</p>
     * @since 6.2
     */

    /**
     * @cfg {String} hiddenHeaderEditingStyle
     * <p>Specifies the Style String that will be applied on the hidden-header cell, when
     * the richtext <b>is</b> being edited.</p>
     * <p>User can either provide this style String or the class {@link #hiddenHeaderEditingCSS}.</p>
     * <p>Please note that 'hiddenHeaderEditingCSS' is given more priority than 'hiddenHeaderEditingStyle'.</p>
     * <p>Default value : "background-color: rgb(215,215,215);"</p>
     * @since 6.2
     */

    /**
     * @private
     */
    tableUI: null,

    /**
     * @private
     */
    insertRowBeforeUI: null,

    /**
     * @private
     */
    insertRowAfterUI: null,

    /**
     * @private
     */
    removeRowUI: null,

    /**
     * @private
     */
    insertColBeforeUI: null,

    /**
     * @private
     */
    insertColAfterUI: null,

    /**
     * @private
     */
    removeColUI: null,

    /**
     * @private
     */
    tableSelection: null,

    /**
     * @private
     */
    tablePropsDialog: null,

    /**
     * @private
     */
    currentSelectionDef: null,

    _init: function (editorKernel) {
      this.inherited(arguments);
      editorKernel.addPluginListener('mousedown', this.clearSelectionHandler, this,
        this, false);
      editorKernel.addPluginListener('mouseup', this.addSelectionHandler, this,
        this, false);
      editorKernel.addPluginListener('keydown', this.handleSelectionOnKey, this,
        this, false);
      editorKernel.addPluginListener('commandexecuted', this.clearSelectionHandler, this,
        this, false);
      editorKernel.addPluginListener('beforekeydown', this.handleTableKeys, this,
        this, false, 250);
    },

    /**
     * @private
     */
    checkTableSelectionWindow: function(context, e) {
		  return;
    },

    isTableMode: function () {
      return (this.config.editMode === CUI.rte.plugins.AbstractTablePlugin.EDITMODE_TABLE);
    },

    handleTableKeys: function (e) {
      if (e.cancelKey) {
        return;
      }
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var sel = CUI.rte.Selection;
      var context = e.editContext;
      var selection, cells;

      // Webkit allows selections outside a table in table edit mode; avoid selection from going outside
      // or ignore keystrokes there.
      if (this.isTableMode()) {
        if (com.ua.isWebKit || com.ua.isIE9) {
          selection = this.editorKernel.createQualifiedSelection(context);
          if (!selection || !com.containsTagInPath(context, selection.startNode, 'tr')) {
            if (!(e.isCtrl && e.getCharCode() === 90)) {
              cells = com.getChildNodesByType(context.root, ['th', 'td'], true);
              if (cells.length > 0) {
                var cellToSelect;
                if (com.isAncestor(context, context.root.firstChild, selection.startNode)) {
                  cellToSelect = cells[0];
                } else {
                  cellToSelect = cells[cells.length - 1];
                }
                sel.selectNode(context, cellToSelect, true);
              }
              dpr.removeNonTableBlocks(context);
              e.cancelKey = true;
            }
          } else {
            var selectionCell = com.getTagInPath(context, selection.startNode, ['td', 'th']);
            var tableInfo = this.getTableInfo(this.currentSelectionDef, context);
            var tableMatrix = tableInfo['tableMatrix'];
            var cellInfo = tableMatrix.getCellInfo(selectionCell);
            if (e.isCtrl() && !e.isShift() && (e.getCharCode() === com.KEY_STROKES.ARROW_LEFT ||
              e.getCharCode() === com.KEY_STROKES.ARROW_RIGHT)) {
              e.cancelKey = true;
            } else if (cellInfo.isFirstRow && cellInfo.isFirstCol) {
              if (e.getCharCode() === com.KEY_STROKES.ARROW_UP && !e.isShift()) {
                e.cancelKey = true;
              } else if (!sel.isSelection(selection) && !selection.startOffset &&
                (e.getCharCode() === com.KEY_STROKES.ARROW_LEFT || e.getCharCode() === com.KEY_STROKES.ARROW_UP)) {
                e.cancelKey = true;
              } else {
                  this.checkTableSelectionWindow(context, e);
              }
            } else if (cellInfo.isLastRow && cellInfo.isLastCol) {
              if (e.getCharCode() === com.KEY_STROKES.ARROW_DOWN && !e.isShift()) {
                e.cancelKey = true;
              } else if (!sel.isSelection(selection) &&
                (dpr.isBlockEnd(context, selection.startNode, selection.startOffset) ||
                ((selection.startOffset === null || selection.startOffset === undefined) && selection.startNode.tagName.toLowerCase() === 'td')) &&
                (e.getCharCode() === com.KEY_STROKES.ARROW_RIGHT || e.getCharCode() === com.KEY_STROKES.ARROW_DOWN)) {
                e.cancelKey = true;
              }
            }
          }
        }
      }
      // handle Tab key
      if (e.isTab() && !e.cancelKey) {
        // handle Tab in Tables differently (jump to next cell, or insert a new row
        // at the end of the table)
        if (!selection) {
          selection = this.editorKernel.createQualifiedSelection(context);
        }
        if (!sel.isSelection(selection)) {
          this.editorKernel.execCmd('addundostep');
          var tableCell = CUI.rte.commands.Table.getCellFromSelection(
            context, selection);
          if (tableCell) {
            var nextCell, prevCell, rowParent, rows, rowIndex, preferredScrollOffset;
            var row = tableCell.parentNode;
            cells = com.getChildNodesByType(row, com.TABLE_CELLS, false);
            var cellIndex = com.arrayIndex(cells, tableCell) + 1;
            if (!e.isShift()) {
              if (cellIndex < cells.length) {
                nextCell = cells[cellIndex];
              } else {
                rowParent = row.parentNode;
                rows = com.getChildNodesByType(rowParent, 'tr', false);
                rowIndex = com.arrayIndex(rows, row) + 1;
                if (rowIndex < rows.length) {
                  row = rows[rowIndex];
                  cells = com.getChildNodesByType(row, com.TABLE_CELLS, false);
                  nextCell = cells[0];
                }
              }
              if (nextCell === null || nextCell === undefined) {
                this.editorKernel.relayCmd('insertrow', {
                  'position': 'after',
                  'caret': 'firstCell'
                });
              }
              if (nextCell !== null && nextCell !== undefined) {
                preferredScrollOffset = (com.ua.isIE ? null
                  : sel.getPreferredScrollOffset(context));
                sel.selectNode(context, nextCell, true);
                if (com.ua.isGecko && context.iFrame) {
                  sel.ensureCaretVisibility(context, context.iFrame,
                    preferredScrollOffset);
                }
              }
            } else {
              if (cellIndex > 1) {
                  prevCell = cells[cellIndex-2];
              } else {
                  rowParent = row.parentNode;
                  rows = com.getChildNodesByType(rowParent, 'tr', false);
                  rowIndex = com.arrayIndex(rows, row) + 1;
                  if (rowIndex > 1) {
                      row = rows[rowIndex-2];
                      cells = com.getChildNodesByType(row, com.TABLE_CELLS, false);
                      prevCell = cells[cells.length - 1];
                  }
              }
              if (prevCell !== null) {
                  preferredScrollOffset = (com.ua.isIE ? null
                      : sel.getPreferredScrollOffset(context));
                  sel.selectNode(context, prevCell, true);
                  if (com.ua.isGecko && context.iFrame) {
                      sel.ensureCaretVisibility(context, context.iFrame,
                          preferredScrollOffset);
                  }
              }
          }
            e.cancelKey = true;
          }
        }
      }
    },

    handleSelectionOnKey: function (e) {
      if (this.tableSelection) {
        if (e.isBackSpace() || e.isDelete()) {
          this.clearSelectionContent(e.editContext);
        }
      }
      this.clearSelectionHandler(e);
    },

    /**
     * @private
     */
    addSelectionHandler: function (e) {
      var com = CUI.rte.Common;
      var sel = CUI.rte.Selection;
      var cancelEvent = false;
      var addToSelection = (e.getType() === 'mouseup') && (e.getButton() === 0) &&
        e.isCtrl();
      if (addToSelection && (com.ua.isIE || com.ua.isWebKit)) {
        var context = e.editContext;
        var pSelection = sel.createProcessingSelection(context);
        var cell = CUI.rte.commands.Table.getCellFromSelection(context, pSelection);
        if (cell) {
          if (cell) {
            this.addCellToSelection(cell);
            e.preventDefault();
          }
          cancelEvent = true;
        }
      }
      return cancelEvent;
    },

    /**
     * @private
     */
    clearSelectionHandler: function (e) {
      var com = CUI.rte.Common;
      var context = e.editContext;
      var type = e.getType();
      var addToSelection = (type === 'mousedown') && (e.getButton() === 0) &&
        e.isCtrl();
      if (this.tableSelection) {
        var removeSelection = false;
        if (type === 'keydown') {
          var key = e.getKey();
          if (key >= 32) {
            // additionaly filter Cmd key on Mac - otherwise the selection would
            // get removed if the user releases Cmd and presses it again to add
            // further cells to the selection
            if (!com.ua.isMac || (key !== 91)) {
              removeSelection = true;
            }
          }
        } else if (type === 'mousedown') {
          removeSelection = !addToSelection && (e.getButton() !== 2);
        } else if (type === 'commandexecuted') {
          switch (e.cmd.toLowerCase()) {
          case 'removetable':
            this.tableSelection = null;
            break;
          case 'addundostep':
          case 'clearredohistory':
            break;
          case 'removerow':
          case 'removecolumn':
          case 'undo':
          case 'redo':
          case 'insertrow':
          case 'insertcolumn':
          case 'splitcell':
          case 'mergecells':
            removeSelection = true;
            break;
          case 'modifycell':
            this.refreshTableSelection();
            break;
          default:
            break;
          }
        }
        if (removeSelection) {
          this.removeTableSelection();
        }
      }
      if (type === 'commandexecuted') {
        if (com.ua.isGecko) {
          var flushSelection = false;
          // this should be sufficient to detect table selections in an easy way
          var selection = e.editContext.win.getSelection();
          if (selection.rangeCount > 1) {
            flushSelection = true;
          } else if (selection.rangeCount === 1) {
            var rangeToCheck = selection.getRangeAt(0);
            var parentDom = rangeToCheck.commonAncestorContainer;
            if (parentDom && (com.getTagInPath(context, parentDom, 'table'))) {
              flushSelection = true;
            }
          }
          if (flushSelection) {
            CUI.rte.Selection.flushSelection(e.editContext, true);
          }
        }
      }
    },

    /**
     * @private
     */
    addTableSelection: function (selectionDef) {
      var com = CUI.rte.Common;
      if (this.tableSelection) {
        this.removeTableSelection();
      }
      var cellCnt = selectionDef.length;
      for (var c = 0; c < cellCnt; c++) {
        var cell = selectionDef[c];
        com.addClass(cell, CUI.rte.Theme.TABLESELECTION_CLASS);
      }
      this.tableSelection = selectionDef;
    },

    /**
     * @private
     */
    addCellToSelection: function (cellToAdd) {
      var com = CUI.rte.Common;
      if (!this.tableSelection) {
        this.tableSelection = [];
      }
      com.addClass(cellToAdd, CUI.rte.Theme.TABLESELECTION_CLASS);
      this.tableSelection.push(cellToAdd);
    },

    /**
     * @private
     */
    removeTableSelection: function () {
      var com = CUI.rte.Common;
      var cellCnt = this.tableSelection.length;
      for (var c = 0; c < cellCnt; c++) {
        var cell = this.tableSelection[c];
        com.removeClass(cell, CUI.rte.Theme.TABLESELECTION_CLASS);
      }
      this.tableSelection = null;
    },

    /**
     * @private
     */
    refreshTableSelection: function () {
      var com = CUI.rte.Common;
      var cellCnt = this.tableSelection.length;
      var newSelection = [];
      for (var c = 0; c < cellCnt; c++) {
        var cell = this.tableSelection[c];
        if (cell.parentNode === null || cell.parentNode === undefined) {
          com.removeClass(cell, CUI.rte.Theme.TABLESELECTION_CLASS);
        } else {
          com.addClass(cell,CUI.rte.Theme.TABLESELECTION_CLASS);
          newSelection.push(cell);
        }
      }
      this.tableSelection = newSelection;
    },

    /**
     * @private
     */
    clearSelectionContent: function (context) {
      var dpr = CUI.rte.DomProcessor;
      var cellCnt = this.tableSelection.length;
      for (var c = 0; c < cellCnt; c++) {
        var cell = this.tableSelection[c];
        var nodeCnt = cell.childNodes.length;
        for (var n = nodeCnt - 1; n >= 0; n--) {
          cell.removeChild(cell.childNodes[0]);
        }
        var placeholder = dpr.createEmptyLinePlaceholder(context, false);
        if (placeholder) {
          cell.appendChild();
        }
      }
    },

    /**
     * @private
     */
    createOrEditTable: function (options, enforceNewTable) {
      var context = options.editContext;
      this.savedRange = options.savedRange;
      this.editorKernel.selectQualifiedRangeBookmark(context, this.savedRange);
      var table = this.editorKernel.queryState('table');
      var propConfig;
      var tableTemplate = null;
      if (table && !enforceNewTable) {
        // change properties
        propConfig = {
          'editContext': context,
          'cmd': 'modifytable',
          'table': table,
          'parameters': {
            'command': this.pluginId + '#modifytable'
          }
        };
      } else {
        // create new table
        tableTemplate = CUI.rte.Compatibility.getConfigValue(this.config,
          'defaultValues.tableTemplate');
        if (!tableTemplate) {
          propConfig = {
            'cmd': 'createtable',
            'table': null,
            'parameters': {
              'command': options.command ? options.command : this.pluginId + '#table'
            }
          };
        }
      }
      var editorKernel = this.editorKernel;
      if (!tableTemplate && propConfig) {
        propConfig.listeners = {
          'show': function () {
            editorKernel.fireUIEvent('dialogshow');
          },
          'hide': function () {
            editorKernel.fireUIEvent('dialoghide');
          }
        };
      }
      if (tableTemplate) {
        // create new table directly through template
        this.editorKernel.selectQualifiedRangeBookmark(context, this.savedRange);
        this.editorKernel.relayCmd('createtable', {
          'html': tableTemplate
        });
      } else {
        // display table properties dialog if not shown already
        var dm = this.editorKernel.getDialogManager();
        if (dm.isShown(this.tablePropsDialog) && dm.toggleVisibility(this.tablePropsDialog)) {
          dm.hide(this.tablePropsDialog);
          return;
        }
        this.showTablePropsUI(propConfig, context);
      }
    },

    //must be overriden by child classes for displaying the edit dialog
    showTablePropsUI: function (propConfig, context) {
      return;
    },

    /**
     * @private
     */
    execCreateOrEditTable: function (cmd, tableConfig, context) {
      this.editorKernel.selectQualifiedRangeBookmark(context, this.savedRange);
      if (cmd && tableConfig) {
        this.editorKernel.relayCmd(cmd, tableConfig);
      }
    },

    /**
     * @private
     */
    editCellProps: function (options) {
      var context = options.editContext;
      this.savedRange = options.savedRange;
      this.editorKernel.selectQualifiedRangeBookmark(context, this.savedRange);
      var cells = [];
      if (options && options.selectionContext) {
        // should not use queryState("modifycell") for context menu invoking, as IE's
        // selection handling is way too buggy to get/set a valid range/selection at
        // this point, so prefer selection if provided on plugin call
        var selectionContext = options.selectionContext;
        cells = CUI.rte.commands.Table.getCellsFromNodeList(context,
          selectionContext.nodeList);
      } else {
        // it is safe to use queryState for toolbar-invoked plugin calls
        cells.push(this.editorKernel.queryState('modifycell'));
      }
      if (!cells) {
        return;
      }
      var cfg = {
        'editContext': context,
        'pluginConfig': this.config,
        'cells': cells,
        'execFn': CUI.rte.Utils.scope(this.execEditCellProps, this)
      };
      var dm = this.editorKernel.getDialogManager();
      var dialog = dm.create(CUI.rte.ui.DialogManager.DLG_CELLPROPS, cfg);
      dm.show(dialog);
    },

    /**
     * @private
     */
    execEditCellProps: function (cellConfig, context) {
      this.editorKernel.selectQualifiedRangeBookmark(context, this.savedRange);
      if (cellConfig) {
        var hiddenHeaderConfig = this.getHiddenHeaderConfig();
        if (hiddenHeaderConfig.hiddenHeaderEditingCSS) {
          cellConfig['hiddenHeaderEditingCSS'] = hiddenHeaderConfig.hiddenHeaderEditingCSS;
        } else {
          cellConfig['hiddenHeaderEditingStyle'] = hiddenHeaderConfig.hiddenHeaderEditingStyle;
        }
        cellConfig['handleHiddenHeader'] = 'false';
        this.editorKernel.relayCmd('modifyCell', cellConfig);
      }
    },

    /**
     * @private
     */
    selectRow: function (def) {
      var tableMatrix = def.tableMatrix;
      var cell = def.cell;
      var cellDef = tableMatrix.getCellDef(cell);
      var row = tableMatrix.getRow(cellDef.row);
      var cells = [];
      for (var c = 0; c < row.length; c++) {
        cells[c] = row[c].cellDom;
      }
      this.addTableSelection(cells);
    },

    /**
     * @private
     */
    selectColumn: function (def) {
      var tableMatrix = def.tableMatrix;
      var cell = def.cell;
      var cellDef = tableMatrix.getCellDef(cell);
      var column = tableMatrix.getColumn(cellDef.col);
      var cells = [];
      for (var c = 0; c < column.length; c++) {
        cells[c] = column[c].cellDom;
      }
      this.addTableSelection(cells);
    },

    /**
     * @private
     */
    getFeatures: function () {
      // must be overridden by implementing plugins
      return [
        'table', 'removetable', 'insertrow', 'removerow', 'insertcolumn',
        'removecolumn', 'cellprops', 'mergecells', 'splitcell',
        'selectrow', 'selectcolumn'
      ];
    },

    reportStyles: function () {
      var compat = CUI.rte.Compatibility;
      var styles = [];
      var tableStyles = this.config.tableStyles;
      if (tableStyles !== null && tableStyles !== undefined) {
        tableStyles = compat.convertToArray(tableStyles, 'cssName', 'text');
        compat.changeDeprecatedPropertyName(tableStyles, 'className', 'cssName');
        styles.push({
          'type': 'table',
          'styles': tableStyles
        });
      }
      var cellStyles = this.config.cellStyles;
      if (cellStyles !== null && cellStyles !== undefined) {
        cellStyles = compat.convertToArray(cellStyles, 'cssName', 'text');
        compat.changeDeprecatedPropertyName(cellStyles, 'className', 'cssName');
        styles.push({
          'type': 'cell',
          'styles': cellStyles
        });
      }
      return (styles.length > 0 ? styles : null);
    },

    notifyPluginConfig: function (pluginConfig) {
      pluginConfig = pluginConfig || {};
      CUI.rte.Utils.applyDefaults(pluginConfig, {
        'tableStyles': null,
        'cellStyles': null,
        'defaultValues': {
          'cellspacing': '0',
          'cellpadding': '1',
          'border': '1',
          'columns': '3',
          'rows': '2',
          'header': 'none'
        },
        'tablePropConfig': {
          'basicDefs': true,
          'basicStyling': true
        },
        'cellPropConfig': {
          'basicDefs': true
        },
        'hiddenHeaderConfig': {
          'hiddenHeaderStyle': 'display: block; height: 1px; width: 1px; overflow: hidden; position: absolute; top: -10px;',
          'hiddenHeaderEditingStyle': 'background-color: rgb(215,215,215);'
        },
        'tooltips': {
          'table': {
            'title': CUI.rte.Utils.i18n('plugins.table.tableTitle'),
            'text': CUI.rte.Utils.i18n('plugins.table.tableText')
          },
          'cellprops': {
            'title': CUI.rte.Utils.i18n('plugins.table.cellTitle'),
            'text': CUI.rte.Utils.i18n('plugins.table.cellText')
          },
          'insertrow-before': {
            'title': CUI.rte.Utils.i18n('plugins.table.insertAboveTitle'),
            'text': CUI.rte.Utils.i18n('plugins.table.insertAboveText')
          },
          'insertrow-after': {
            'title': CUI.rte.Utils.i18n('plugins.table.insertBelowTitle'),
            'text': CUI.rte.Utils.i18n('plugins.table.insertBelowText')
          },
          'removerow': {
            'title': CUI.rte.Utils.i18n('plugins.table.deleteRowTitle'),
            'text': CUI.rte.Utils.i18n('plugins.table.deleteRowText')
          },
          'insertcolumn-before': {
            'title': CUI.rte.Utils.i18n('plugins.table.insertLeftTitle'),
            'text': CUI.rte.Utils.i18n('plugins.table.insertLeftText')
          },
          'insertcolumn-after': {
            'title': CUI.rte.Utils.i18n('plugins.table.insertRightTitle'),
            'text': CUI.rte.Utils.i18n('plugins.table.insertRightText')
          },
          'removecolumn': {
            'title': CUI.rte.Utils.i18n('plugins.table.deleteColumnTitle'),
            'text': CUI.rte.Utils.i18n('plugins.table.deleteColumnText')
          }
        }
      });
      this.config = pluginConfig;
    },

    /**
     * @private
     */
    initializeTableModeUI: function(tbGenerator) {
      var plg = CUI.rte.plugins;
      // use a more detailed toolbar in table mode
      if (this.isFeatureEnabled('table') && !this.isTableToolbarMode()) {
        this.tableUI = tbGenerator.createElement('table', this, false,
          this.getTooltip('table'), 'x-edit-table-properties');
        tbGenerator.addElement('table', plg.Plugin.SORT_TABLE_TABLEMODE,
          this.tableUI, 10);
      }
      if (this.isFeatureEnabled('cellprops')) {
        this.cellPropsUI = tbGenerator.createElement('cellprops', this, false,
          this.getTooltip('cellprops'));
        tbGenerator.addElement('table', plg.Plugin.SORT_TABLE_TABLEMODE,
          this.cellPropsUI, 20);
      }
      if (this.isFeatureEnabled('insertrow')) {
        this.insertRowBeforeUI = tbGenerator.createElement('insertrow-before', this,
          false, this.getTooltip('insertrow-before'), null, {
            'cmd': 'insertrow',
            'cmdValue': 'before'
          });
        tbGenerator.addElement('table.row', plg.Plugin.SORT_TABLE_TABLEMODE + 1,
          this.insertRowBeforeUI, 10);
        this.insertRowAfterUI = tbGenerator.createElement('insertrow-after', this,
          false, this.getTooltip('insertrow-after'), null, {
            'cmd': 'insertrow',
            'cmdValue': 'after'
          });
        tbGenerator.addElement('table.row', plg.Plugin.SORT_TABLE_TABLEMODE + 1,
          this.insertRowAfterUI, 20);
      }
      if (this.isFeatureEnabled('removerow')) {
        this.removeRowUI = tbGenerator.createElement('removerow', this, false,
          this.getTooltip('removerow'));
        tbGenerator.addElement('table.row', plg.Plugin.SORT_TABLE_TABLEMODE + 1,
          this.removeRowUI, 30);
      }
      if (this.isFeatureEnabled('insertcolumn')) {
        this.insertColBeforeUI = tbGenerator.createElement('insertcolumn-before',
          this, false, this.getTooltip('insertcolumn-before'), null, {
            'cmd': 'insertcolumn',
            'cmdValue': 'before'
          });
        tbGenerator.addElement('table.col', plg.Plugin.SORT_TABLE_TABLEMODE + 2,
          this.insertColBeforeUI, 10);
        this.insertColAfterUI = tbGenerator.createElement('insertcolumn-after',
          this, false, this.getTooltip('insertcolumn-after'), null, {
            'cmd': 'insertcolumn',
            'cmdValue': 'after'
          });
        tbGenerator.addElement('table.col', plg.Plugin.SORT_TABLE_TABLEMODE + 2,
          this.insertColAfterUI, 20);
      }
      if (this.isFeatureEnabled('removecolumn')) {
        this.removeColUI = tbGenerator.createElement('removecolumn', this, false,
          this.getTooltip('removecolumn'));
        tbGenerator.addElement('table.col', plg.Plugin.SORT_TABLE_TABLEMODE + 2,
          this.removeColUI, 30);
      }
    },

    /**
     * @private
     */
    initializeUI: function(tbGenerator) {
      var plg = CUI.rte.plugins;
      // todo use correct tooltips for table mode buttons
      if (!this.isTableMode()) {
        if (this.isFeatureEnabled('table')) {
          this.tableUI = tbGenerator.createElement('table', this, false,
            this.getTooltip('table'));
          tbGenerator.addElement('table', plg.Plugin.SORT_TABLE, this.tableUI, 10);
        }
      } else {
        this.initializeTableModeUI(tbGenerator);
      }
    },

    /**
     * @private
     */
    execute: function (cmdId, value, options) {
      var context = options.editContext;
      if (!options.savedRange) {
        options.savedRange = this.editorKernel.createQualifiedRangeBookmark(context);
      }
      var cmd = cmdId;
      var sepPos = cmdId.indexOf('.', cmdId);
      if (sepPos > 0) {
        cmd = cmdId.substring(0, sepPos);
        value = cmdId.substring(sepPos + 1, cmdId.length);
      }
      if (cmd === 'table') {
        this.createOrEditTable(options, false);
      } else if (cmd === 'createtable') {
        this.createOrEditTable(options, true);
      } else if (cmd === 'cellprops') {
        this.editCellProps(options);
      } else if (cmd === 'selectrow') {
        this.selectRow(value);
        this.editorKernel.deferFocus();
      } else if (cmd === 'selectcolumn') {
        this.selectColumn(value);
        this.editorKernel.deferFocus();
      } else {
        this.editorKernel.relayCmd(cmd, value);
      }
    },

    /**
     * @private
     */
    updateState: function (selDef) {
      this.currentSelectionDef = selDef;
      if (this.isTableMode()) {
        var context = selDef.editContext;
        var com = CUI.rte.Common;
        var nodeList = selDef.nodeList;
        var singleCell = CUI.rte.commands.Table.getCellFromNodeList(context,
          nodeList);
        var isSingleCell = (singleCell !== null && singleCell !== undefined);
        var tableDom = com.getTagInPath(context, nodeList.commonAncestor, 'table');
        if (tableDom) {
          var tableMatrix = new CUI.rte.TableMatrix();
          tableMatrix.createTableMatrix(tableDom);
          var size = tableMatrix.getTableSize();
          if (this.removeRowUI) {
            this.removeRowUI.setDisabled((size.rows === 1) || !isSingleCell);
          }
          if (this.removeColUI) {
            this.removeColUI.setDisabled((size.cols === 1) || !isSingleCell);
          }
          if (this.insertColBeforeUI) {
            this.insertColBeforeUI.setDisabled(!isSingleCell);
          }
          if (this.insertColAfterUI) {
            this.insertColAfterUI.setDisabled(!isSingleCell);
          }
          if (this.insertRowBeforeUI) {
            this.insertRowBeforeUI.setDisabled(!isSingleCell);
          }
          if (this.insertRowAfterUI) {
            this.insertRowAfterUI.setDisabled(!isSingleCell);
          }
        }
      }
    },

    /**
     * @private
     */
    getTableInfo: function (selDef, context) {
      var com = CUI.rte.Common;
      var nodeList = selDef.nodeList;
      var singleCell = CUI.rte.commands.Table.getCellFromNodeList(context, nodeList);
      var isSingleCell = (singleCell !== null && singleCell !== undefined);
      var tableDom = com.getTagInPath(context, nodeList.commonAncestor, 'table');
      var isTable = isSingleCell || (tableDom !== null && tableDom !== undefined);
      var tableMatrix;
      if (isTable) {
        tableMatrix = new CUI.rte.TableMatrix();
        tableMatrix.createTableMatrix(tableDom);
      }
      return {
        'singleCell': singleCell,
        'isSingleCell': isSingleCell,
        'tableMatrix': tableMatrix,
        'tableDom': tableDom,
        'isTable': isTable
      };
    },

    /**
     * @private
     */
    handleContextMenu: function (menuBuilder, selDef, context) {
      var com = CUI.rte.Common;
      var isTableMode = this.isTableMode();
      var tableInfo = this.getTableInfo(selDef, context);
      var singleCell = tableInfo['singleCell'];
      var isSingleCell = tableInfo['isSingleCell'];
      var tableMatrix = tableInfo['tableMatrix'];
      var isTable = tableInfo['isTable'];
      var selection = selDef.selection;
      var cellSel = null;
      var cellSubItems = [];
      var canRemoveCol = true;
      var canRemoveRow = true;
      if (isTable && isTableMode) {
        var size = tableMatrix.getTableSize();
        canRemoveCol = (size.cols > 1);
        canRemoveRow = (size.rows > 1);
      }
      if (isTable && !isSingleCell) {
        if (selection.cellSelection) {
          cellSel = tableMatrix.createSelection(selection.cellSelection.cells);
        }
      }

      if (isSingleCell) {
        if (this.isFeatureEnabled('cellprops')) {
          cellSubItems.push({
            'text': CUI.rte.Utils.i18n('plugins.table.cellProps'),
            'plugin': this,
            'cmd': 'cellprops',
            'iconCls': 'rte-cellprops'
          });
        }
      }
      if (cellSel !== null && cellSel !== undefined) {
        if (this.isFeatureEnabled('mergecells')) {
          if (cellSel.selectionProps.isRect) {
            var selProps = cellSel.selectionProps;
            // prevent merging of cells if they are spread across thead/tbody/tfoot
            var spansMultipleSections = selProps.spansThead && (selProps.spansTbody || selProps.spansTfoot) ||
              selProps.spansTbody && (selProps.spansThead || selProps.spansTfoot) ||
              selProps.spansTfoot && (selProps.spansThead || selProps.spansTbody);
            if (!spansMultipleSections) {
              cellSubItems.push({
                'text': CUI.rte.Utils.i18n('plugins.table.mergeCells'),
                'plugin': this,
                'cmd': 'mergecells',
                'cmdValue': cellSel,
                'iconCls': 'rte-cellmerge'
              });
            }
          }
          cellSubItems.push({
            'text': CUI.rte.Utils.i18n('plugins.table.cellProps'),
            'plugin': this,
            'cmd': 'cellprops',
            'iconCls': 'rte-cellprops'
          });
        }
      } else if (isSingleCell) {
        if (this.isFeatureEnabled('mergecells')) {
          var cellInfo = tableMatrix.getCellInfo(singleCell);
          if (!cellInfo.isLastCol) {
            cellSel = tableMatrix.createSelection(singleCell);
            cellSel.expand(1, 0);
            if (cellSel.selectionProps.isRect) {
              cellSubItems.push({
                'text': CUI.rte.Utils.i18n('plugins.table.mergeRight'),
                'plugin': this,
                'cmd': 'mergecells',
                'cmdValue': cellSel,
                'iconCls': 'rte-cellmerge'
              });
            }
          }
          if (!cellInfo.isLastRow) {
            cellSel = tableMatrix.createSelection(singleCell);
            cellSel.expand(0, 1);
            if (cellSel.selectionProps.isRect) {
              cellSubItems.push({
                'text': CUI.rte.Utils.i18n('plugins.table.mergeDown'),
                'plugin': this,
                'cmd': 'mergecells',
                'cmdValue': cellSel,
                'iconCls': 'rte-cellmerge'
              });
            }
          }
        }
      }
      if (isSingleCell) {
        if (this.isFeatureEnabled('splitcell')) {
          cellSubItems.push({
            'text': CUI.rte.Utils.i18n('plugins.table.splitHor'),
            'plugin': this,
            'cmd': 'splitcell',
            'cmdValue': 'horizontal',
            'iconCls': 'rte-cellsplit-horizontal'
          });
          cellSubItems.push({
            'text': CUI.rte.Utils.i18n('plugins.table.splitVert'),
            'plugin': this,
            'cmd': 'splitcell',
            'cmdValue': 'vertical',
            'iconCls': 'rte-cellsplit-vertical'
          });
        }
      }
      if (cellSubItems.length > 0) {
        menuBuilder.addItem(menuBuilder.createItem({
          'text': CUI.rte.Utils.i18n('plugins.table.cell'),
          'subItems': cellSubItems,
          'iconCls': 'rte-cell'
        }));
      }

      if (isSingleCell) {
        var colSubItems = [];
        if (this.isFeatureEnabled('insertcolumn')) {
          colSubItems.push({
            'text': CUI.rte.Utils.i18n('plugins.table.insertBefore'),
            'plugin': this,
            'cmd': 'insertcolumn',
            'cmdValue': 'before',
            'iconCls': 'rte-insertcolumn-before'
          });
          colSubItems.push({
            'text': CUI.rte.Utils.i18n('plugins.table.insertAfter'),
            'plugin': this,
            'cmd': 'insertcolumn',
            'cmdValue': 'after',
            'iconCls': 'rte-insertcolumn-after'
          });
        }
        if (this.isFeatureEnabled('removecolumn') && canRemoveCol) {
          colSubItems.push({
            'text': CUI.rte.Utils.i18n('plugins.table.remove'),
            'plugin': this,
            'cmd': 'removecolumn',
            'iconCls': 'rte-removecolumn'
          });
        }
        if (colSubItems.length > 0) {
          menuBuilder.addItem(menuBuilder.createItem({
            'text': CUI.rte.Utils.i18n('plugins.table.column'),
            'subItems': colSubItems,
            'iconCls': 'rte-column'
          }));
        }
      }
      if (isSingleCell) {
        var rowSubItems = [];
        if (this.isFeatureEnabled('insertrow')) {
          rowSubItems.push({
            'text': CUI.rte.Utils.i18n('plugins.table.insertBefore'),
            'plugin': this,
            'cmd': 'insertrow',
            'cmdValue': 'before',
            'iconCls': 'rte-insertrow-before'
          });
          rowSubItems.push({
            'text': CUI.rte.Utils.i18n('plugins.table.insertAfter'),
            'plugin': this,
            'cmd': 'insertrow',
            'cmdValue': 'after',
            'iconCls': 'rte-insertrow-after'
          });
        }
        if (this.isFeatureEnabled('removerow') && canRemoveRow) {
          rowSubItems.push({
            'text': CUI.rte.Utils.i18n('plugins.table.remove'),
            'plugin': this,
            'cmd': 'removerow',
            'iconCls': 'rte-removerow'
          });
        }
        if (rowSubItems.length > 0) {
          menuBuilder.addItem(menuBuilder.createItem({
            'text': CUI.rte.Utils.i18n('plugins.table.row'),
            'subItems': rowSubItems,
            'iconCls': 'rte-row'
          }));
        }
        if (this.isFeatureEnabled('table')) {
          menuBuilder.addItem(menuBuilder.createItem({
            'text': CUI.rte.Utils.i18n('plugins.table.tableProps'),
            'plugin': this,
            'cmd': 'table',
            'iconCls': 'rte-tableprops'
          }));
        }
        if (this.isFeatureEnabled('removetable') && !isTableMode) {
          menuBuilder.addItem(menuBuilder.createItem({
            'text': CUI.rte.Utils.i18n('plugins.table.removeTable'),
            'plugin': this,
            'cmd': 'removetable',
            'iconCls': 'rte-removetable'
          }));
        }
        if (this.isFeatureEnabled('table')) {
          menuBuilder.addItem(menuBuilder.createItem({
            'text': CUI.rte.Utils.i18n('plugins.table.nestedTable'),
            'plugin': this,
            'cmd': 'createtable',
            'iconCls': 'rte-createtable'
          }));
        }
        var hasSeparator = false;
        if (this.isFeatureEnabled('selectrow') && isSingleCell) {
          if (!hasSeparator) {
            menuBuilder.addItem(menuBuilder.createSeparator());
            hasSeparator = true;
          }
          menuBuilder.addItem(menuBuilder.createItem({
            'text': CUI.rte.Utils.i18n('plugins.table.selectRow'),
            'plugin': this,
            'cmd': 'selectrow',
            'cmdValue': {
              'tableMatrix': tableMatrix,
              'cell': singleCell
            }
          }));
        }
        if (this.isFeatureEnabled('selectcolumn') && isSingleCell) {
          if (!hasSeparator) {
            menuBuilder.addItem(menuBuilder.createSeparator());
            hasSeparator = true;
          }
          menuBuilder.addItem(menuBuilder.createItem({
            'text': CUI.rte.Utils.i18n('plugins.table.selectColumn'),
            'plugin': this,
            'cmd': 'selectcolumn',
            'cmdValue': {
              'tableMatrix': tableMatrix,
              'cell': singleCell
            }
          }));
        }
        if (!isTableMode) {
          var pNode = tableInfo['tableDom'].parentNode;
          if (com.isRootNode(context, pNode)) {
            var tableIndex = com.getChildIndex(tableInfo['tableDom']);
            if ((tableIndex === 0) || com.isTag(pNode.childNodes[tableIndex - 1], 'table')) {
              menuBuilder.addItem(menuBuilder.createItem({
                'text': CUI.rte.Utils.i18n('plugins.table.insertParaBefore'),
                'plugin': this,
                'cmd': 'ensureparagraph',
                'cmdValue': 'before'
              }));
            }
            if ((tableIndex === (pNode.childNodes.length - 1)) ||
              com.isTag(pNode.childNodes[tableIndex + 1], 'table')) {
              menuBuilder.addItem(menuBuilder.createItem({
                'text': CUI.rte.Utils.i18n('plugins.table.insertParaAfter'),
                'plugin': this,
                'cmd': 'ensureparagraph',
                'cmdValue': 'after'
              }));
            }
          }
        }
      }
      var isObject = (selection.startNode.nodeType === 1) && !selection.endNode &&
        (selection.startOffset === null || selection.startOffset === undefined);
      if (!isTable && !isObject) {
        if (this.isFeatureEnabled('table') && !isTableMode) {
          menuBuilder.addItem(menuBuilder.createItem({
            'text': CUI.rte.Utils.i18n('plugins.table.createTable'),
            'plugin': this,
            'cmd': 'table',
            'iconCls': 'rte-createtable'
          }));
        }
      }
    },

    /**
     * @private
     */
    manipulateSelection: function (selectionDef) {
      if (this.tableSelection) {
        selectionDef.cellSelection = {
          'cells': this.tableSelection,
          'otherContent': false
        };
      }
    },

    /**
     * @private
     */
    saveRangeBookmark: function (rangeBookmark) {
      if (this.tableSelection) {
        rangeBookmark.cells = this.tableSelection;
      }
    },

    /**
     * @private
     */
    restoreRangeBookmark: function (rangeBookmark) {
      if (rangeBookmark.cells) {
        this.addTableSelection(rangeBookmark.cells);
      }
    },

    /**
     * Creates HTML for a new table according to the plugin's configuration.
     * @private
     */
    createEmptyTableHTML: function () {
      var tableInit = this.config.defaultValues || {};
      if (tableInit.tableTemplate) {
        return tableInit.tableTemplate;
      }

      var colCnt = tableInit.columns || 1;
      var rowCnt = tableInit.rows || 1;
      var tableHtml = '<table';
      for (var attrib in tableInit) {
        if (tableInit.hasOwnProperty(attrib)) {
          var prefixPos = attrib.indexOf(':');
          var hasInvalidPrefix = false;
          if (prefixPos >= 0) {
            var prefix = attrib.substring(0, prefixPos);
            hasInvalidPrefix = (prefix === 'jcr');
          }
          if ((attrib !== 'columns') && (attrib !== 'rows') && (attrib !== 'header') && !hasInvalidPrefix) {
            tableHtml += ' ' + attrib + '=\'' +
              CUI.rte.Utils.htmlEncode(tableInit[attrib]) + '\'';
          }
        }
      }
      tableHtml += '>';
      for (var r = 0; r < rowCnt; r++) {
        tableHtml += '<tr>';
        for (var c = 0; c < colCnt; c++) {
          tableHtml += CUI.rte.TableMatrix.createEmptyCellMarkup();
        }
        tableHtml += '</tr>';
      }
      tableHtml += '</table>';
      return tableHtml;
    },

    interceptContent: function (contentType, defs) {
      if (!this.isTableMode()) {
        return null;
      }
      var context = (defs ? defs.editContext : null);
      if (contentType === 'emptyContent') {
        return this.createEmptyTableHTML();
      } else if (contentType === 'postprocessDom') {
        CUI.rte.DomProcessor.removeNonTableBlocks(context);
      } else if (contentType === 'cleanDom') {
        if (this.tableSelection) {
          this.removeTableSelection();
        }
      }
      return null;
    },

    isHeadless: function (cmd, value) {
      return false;
    },

    isTableToolbarMode: function () {
      return false;
    },

    getHiddenHeaderConfig: function () {
      return this.config.hiddenHeaderConfig;
    }

  });


  /**
   * Constant that defines "default editing mode" (i.e. word processing)
   * @static
   * @final
   * @type String
   */
  CUI.rte.plugins.AbstractTablePlugin.EDITMODE_DEFAULT = 'default';

  /**
   * Constant that defines "table editing mode" (will allow table content only; some other
   * restrictions apply)
   * @static
   * @final
   * @type String
   */
  CUI.rte.plugins.AbstractTablePlugin.EDITMODE_TABLE = 'table';
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.AbstractImagePlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements the editing of image properties as a plugin.</p>
 * <p>The plugin ID is "<b>image</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>image</b> - provides functionality for setting some image properties
 *     (currently only alignment is supported)</li>
 * </ul>
 * @since 5.3
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.AbstractImagePlugin = new Class({

    toString: 'AbstractImagePlugin',

    extend: CUI.rte.plugins.Plugin,


    getFeatures: function () {
      return ['image'];
    },

    notifyPluginConfig: function (pluginConfig) {
      this.config = pluginConfig;
    },

    execute: function (pluginCommand, value, envOptions) {
      if (pluginCommand === 'imageProps') {

        var context = envOptions.editContext;
        var selectionDef = envOptions.selectionContext;
        var image = CUI.rte.commands.Image.getSelectedImage(selectionDef);
        this.savedRange = envOptions.savedRange;

        var propConfig = {
          'cmd': 'image',
          'editContext': context,
          'execFn': CUI.rte.Utils.scope(this.execModifyImage, this),
          'image': image
        };
        var dm = this.editorKernel.getDialogManager();
        var dialog = dm.create(CUI.rte.ui.DialogManager.DLG_IMAGEPROPS, propConfig);
        dm.prepareShow(dialog);
        dm.show(dialog);
      }
      else if (pluginCommand === 'image') {
        this.editorKernel.relayCmd('image', value);
      }
    },

    /**
     * @private
     */
    execModifyImage: function (cmd, imageConfig) {
      if (cmd && imageConfig) {
        var context = this.editorKernel.getEditContext();
        this.editorKernel.selectQualifiedRangeBookmark(context, this.savedRange);
        this.editorKernel.relayCmd(cmd, imageConfig);
      }
    }
  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.UndoRedoPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements undo/redo functionality as a plugin.</p>
 * <p>The plugin ID is "<b>undo</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>undo</b> - adds a button for undoing a single undo step</li>
 *   <li><b>redo</b> - adds a button for redoing a single undo step</li>
 * </ul>
 * @since 5.3
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.UndoRedoPlugin = new Class({

    toString: 'UndoRedoPlugin',

    extend: CUI.rte.plugins.Plugin,

    undoUI: null,

    redoUI: null,

    /**
     * @cfg {Number} maxUndoSteps
     * Number of maximum undo steps (defaults to 50); use 0 to disable undo/redo completely
     * @since 5.3
     */
    maxUndoSteps: 0,

    /**
     * Flag that determines if we are currently in a "Delete"-Sequence (which will be
     * recorded as a single undo step)
     * @type Boolean
     * @private
     */
    isDeleteSequence: false,

    /**
     * Flag that determines if we are currently in a "Caret movement"-Sequence (which will
     * be handled specially regarding undo undo)
     * @type Boolean
     * @private
     */
    isCaretMovement: false,

    _init: function (editorKernel) {
      this.inherited(arguments);
      editorKernel.addPluginListener('mouseup', this.addUndoStep, this, this, false);
      editorKernel.addPluginListener('beforekeydown', this.handleKeyDown, this, this,
        false);
      editorKernel.addPluginListener('keyup', this.handleKeyUp, this, this,
        false);
      editorKernel.addPluginListener('beforecommandexecuted', this.handleCommand, this,
        this, false);
      editorKernel.addPluginListener('commandexecuted', this.handleCommand, this, this,
        false);
    },

    addUndoStep: function () {
      this.editorKernel.execCmd('addundostep');
    },

    handleCommand: function (e) {
      if (!e.customCommand || e.customCommand.isUndoable(e.cmd)) {
        this.addUndoStep();
      }
    },

    handleKeyDown: function (e) {
      // todo will this prevent some undo action from being recorded?
      if (e.cancelKey) {
        return;
      }
      var key = e.getKey();
      var isControl = e.isCtrl();
      var isShift = e.isShift();
      var isUndoKey = isControl && !isShift && (key === 90);
      var isRedoKey = (isControl && !isShift && (key === 89)) ||
        (isShift && isControl && (key === 90));       // Cmd + Shift + Z on Mac
      /*
       if (isControl && (key == 68)) {
       this.editorKernel.relayCmd("dumpundohistory");
       e.cancelKey = true;
       }
       */
      if (isUndoKey || isRedoKey) {
        e.cancelKey = true;
        this.editorKernel.relayCmd(isUndoKey ? 'undo' : 'redo');
      } else if (e.isSpace()) {
        // record a undo step if the space bar has been pressed
        this.editorKernel.execCmd('addundostep');
      } else if ((e.isBackSpace()) || (e.isDelete())) {
        if (!this.isDeleteSequence) {
          this.editorKernel.execCmd('addundostep');
          this.isDeleteSequence = true;
        }
      } else if (e.isCaretMovement()) {
        if (!this.isCaretMovement) {
          this.editorKernel.execCmd('addundostep');
          this.isCaretMovement = true;
        }
      } else {
        if (this.isDeleteSequence || this.isCaretMovement) {
          if (this.isDeleteSequence) {
            // take a snapshot of the content after the deletion sequence
            this.editorKernel.execCmd('addundostep');
          }
          this.isDeleteSequence = false;
          this.isCaretMovement = false;
        }
        if ((key > 32) && (key !== 224)) {
          this.editorKernel.execCmd('clearredohistory');
        }
      }
    },

    handleKeyUp: function (e) {
      if (e.isEnter()) {
        // record a undo step if return has been pressed
        this.editorKernel.execCmd('addundostep');
      }
    },

    getFeatures: function () {
      return ['undo', 'redo'];
    },

    notifyPluginConfig: function (pluginConfig) {
      var defaults = {
        'maxUndoSteps': 50,
        'tooltips': {
          'undo': {
            'title': CUI.rte.Utils.i18n('plugins.undoRedo.undoTitle'),
            'text': CUI.rte.Utils.i18n('plugins.undoRedo.undoText')
          },
          'redo': {
            'title': CUI.rte.Utils.i18n('plugins.undoRedo.redoTitle'),
            'text': CUI.rte.Utils.i18n('plugins.undoRedo.redoText')
          }
        }
      };
      CUI.rte.Utils.applyDefaults(pluginConfig, defaults);
      this.config = pluginConfig;
      var commandCfg = {
        'maxUndoSteps': this.config.maxUndoSteps,
        'history': this.config.history,
        'activeStep': this.config.activeStep
      };
      this.editorKernel.execCmd('undoconfig', commandCfg);
    },

    initializeUI: function (tbGenerator) {
      var plg = CUI.rte.plugins;
      if (this.isFeatureEnabled('undo')) {
        this.undoUI = new tbGenerator.createElement('undo', this, false,
          this.getTooltip('undo'));
        tbGenerator.addElement('undo', plg.Plugin.SORT_UNDO, this.undoUI, 100);
      }
      if (this.isFeatureEnabled('redo')) {
        this.redoUI = new tbGenerator.createElement('redo', this, false,
          this.getTooltip('redo'));
        tbGenerator.addElement('undo', plg.Plugin.SORT_UNDO, this.redoUI, 110);
      }
    },

    execute: function (pluginCommand, value, envOptions) {
      if (pluginCommand === 'undo') {
        this.editorKernel.relayCmd('undo', value);
      } else if (pluginCommand === 'redo') {
        this.editorKernel.relayCmd('redo', value);
      }
    },

    updateState: function (selectionDef) {
      if (this.undoUI) {
        this.undoUI.setDisabled(!this.editorKernel.queryState('undo', selectionDef));
      }
      if (this.redoUI) {
        this.redoUI.setDisabled(!this.editorKernel.queryState('redo', selectionDef));
      }
    }

  });


// register plugin
  CUI.rte.plugins.PluginRegistry.register('undo', CUI.rte.plugins.UndoRedoPlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.genhtml.Detector
 * <p>This class works as an interface for a detector module.</p>
 * <p>A detector is responsible for deciding if a provided DOM node is matching the
 * detector's purpose and configuration (for example, it matches a specific tag and/or
 * set of attributes).</p>
 * <p>Detectors are used by applicable converters to determine if they are responsible for
 * handling a specific DOM node.</p>
 * @since 6.3
 */

/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.genhtml.Detector = new Class({

  toString: 'Detector',

  /**
   * <p>Configures the detector.</p>
   * <p>Basically, the configuration is dependent on the detector implementation. But
   * there are some mandatory/shared properties:</p>
   * <ul>
   *   <li><b>type</b> - the type of the detector (as registered at
   *     {@link CUI.rte.genhtml.DetectorRegistry))</li>
     * </ul>
     * @param {Object} config The configuration
   */
  configure: function (config) {
    throw new Error('Detector#configure is not implemented.');
  },

  /**
   * <p>Checks if the specified DOM node fulfills the criteria represented by the
   * detector (type + configuration).</p>
   * <p>For example, a tag/attribute-based detector would check here if the DOM node has
   * a suitable tagName property and matches a configured set of attributes.</p>
   * @param {Node} domNode The DOM node
   * @return {Boolean} True if the specified DOM node matches
   */
  accepts: function (domNode) {
    throw new Error('Detector#accepts is not implemented.');
  }

});

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function (CUI) {
  'use strict';

  CUI.rte.genhtml.DetectorRegistry = (function () {

  var _detectors = {};

  return {

    toString: 'DetectorRegistry',

    register: function (typeStr, detectorClass) {
      _detectors[typeStr] = detectorClass;
    },

    create: function (typeStr) {
      if (_detectors.hasOwnProperty(typeStr)) {
        return new _detectors[typeStr]();
      }
      return undefined;
    }

  };

})();

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.genhtml.Converter
 * <p>This class works as an interface for a converter module.</p>
 * <p>A converter is responsible for:</p>
 * <ul>
 *   <li>declaring itself responsible for a certain DOM node</li>
 *   <li>creating the placeholder for DOM nodes it is responsible for</li>
 *   <li>converting the placeholder back to suitable nodes</li>
 * </ul>
 * <p>Generally, each converter carries a specific internal name that needs to be
 * specified on the placeholder (_rte_placeholder attribute).</p>
 * <p>The detailed implementation is up to the converter module; it could be as simple
 * as storing HTML code on the placeholder DOM as a payload or as complex as using
 * data attributes for re-creating the HTML fragment "on the fly" (= on each serialization).
 * </p>
 * <p>Typical converters use detectors {@see CUI.rte.genhtml.Detector} to determine if they
 * are responsible or handling a specific DOM node. This allows for more flexibility, as a
 * converter can be used in different contexts. But it's not mandatory to use detectors if
 * a converter is tied to a very specific use case.</p>
 * @since 6.3
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.genhtml.Converter = new Class({

    toString: 'Converter',

    /**
     * <p>Configures the converter module.</p>
     * <p>The configuration is dependent on the converter implementation, but it has the
     * following default properties:</p>
     * <ul>
     *   <li><b>type</b> - The type of the converter (as registered with
     *     {@link CUI.rte.genhtml.ConverterRegistry}).</li>
     *   <li><b>name</b> - The name of the converter instance (unique per editor).</li>
     *   <li><b>detectors</b> - (optional) The detectors (@see CUI.rte.genhtml.Detector} to
     *     be used for checking responsibility)
     * </ul>
     * @param {Object} config The configuration
     */
    configure: function (config) {
      throw new Error('Converter#configure not implemented.');
    },

    /**
     * Determines if the converter module is responsible for handling the specified DOM node
     * as generic HTML.
     * @param {Node} domNode The DOM node to check
     * @return True if the converter is responsible for handling the DOM node
     */
    accepts: function (domNode) {
      throw new Error('Converter#accepts not implemented.');
    },

    /**
     * <p>Serializes the provided placeholder DOM node.</p>
     * <p>This means that the target HTML has to be extracted from the specified placeholder
     * DOM and restored to a matching target DOM. This target DOM has to be returned. The
     * placeholder node is then replaced by the target DOM <b>by the callee</b>.</p>
     * <p>This method is only called if {@link #accepts} returned true for the specified
     * placeholder node.</p>
     * <p>The return value ("replacement definition") has the following properties:</p>
     * <ul>
     *   <li><b>replacement</b> - a DOM node or an array of DOM nodes the placeholder node
     *     will be replaced by</li>
     *   <li><b>keepEmptyContainers</b> - true to keep otherwise empty editing blocks after
     *     the serialization (defaults to false). If a placeholder node is placed outside
     *     an edit block, one will be automatically added to keep the placeholder fully
     *     editable (this happens on deserialization). On serialization, that automatically
     *     added block will be removed again unless this value is set to true. Note that
     *     the edit block will always be kept if regular HTML is added to that block during
     *     the editing process.</li>
     * </ul>
     * @param {CUI.rte.EditContext} context The editor context
     * @param {Node} placeholderNode The placeholder node
     * @return {Object} The replacement definition (see above)
     */
    serialize: function (context, placeholderNode) {
      throw new Error('Converter#serialize not implemented.');
    },

    /**
     * <p>Deserializes the provided DOM node.</p>
     * <p>This means that the generic HTML has to be extracted from the specified DOM (the
     * exact way to do this is left to the converter implementation), create a placeholder
     * DOM and store the generic HTML in an appropriate way on this placeholder node. The
     * DOM node is then replaced by the placeholder DOM <b>by the callee</b>.</p>
     * <p>This method is only called if {@link #accepts} returned true for the specified
     * DOM node.</p>
     * <p>The return value ("replacement definition") has the following properties:</p>
     * <ul>
     *   <li><b>replacement</b> - a DOM node or an array of DOM nodes the placeholder node
     *     will be replaced by</li>
     * </ul>
     * <p>The DOM node provided can be null/undefined; in this case a suitable placeholder
     * node that can be edited through an {@link CUI.rte.genhtml.Editor} should be created.
     * </p>
     * @param {CUI.rte.EditContext} context The editor context
     * @param {Node} domNode The DOM node
     * @return {Object} The replacement definition (see above)
     */
    deserialize: function (context, domNode) {
      throw new Error('Converter#deserialize not implemented.');
    },

    /**
     * <p>Returns the name of the converter.</p>
     * @return {String} The name
     */
    getName: function () {
      throw new Error('Converter#getName not implemented.');
    }

  });


  CUI.rte.genhtml.Converter.AbstractConverter = new Class({

    toString: 'Converter.AbstractConverter',

    name: null,

    rules: null,

    detectors: undefined,

    extend: CUI.rte.genhtml.Converter,

    configure: function (config, rules) {
      this.rules = rules;
      this.detectors = [];
      this.name = (config.hasOwnProperty('name') ?
        config.name : 'c_' + new Date().getTime() + '_' + Math.floor(Math.random() * 1000));
      if (config.hasOwnProperty('detectors')) {
        var detectors = config.detectors;
        detectors = CUI.rte.Common.toArray(detectors);
        if (detectors && CUI.rte.Utils.isArray(detectors)) {
          for (var d = 0; d < detectors.length; d++) {
            var detectorDef = detectors[d];
            if (detectorDef.hasOwnProperty('type')) {
              var type = detectorDef.type;
              var detector = CUI.rte.genhtml.DetectorRegistry.create(type);
              detector.configure(detectorDef || {});
              this.detectors.push(detector);
            }
          }
        }
      }
    },

    accepts: function (domNode) {
      var com = CUI.rte.Common;
      var phAttrib = CUI.rte.genhtml.GenericHtmlRules.PLACEHOLDER_ATTRIB;
      if (com.isAttribDefined(domNode, phAttrib)) {
        // check acceptance for serialization - value of placeholder attribute must
        // match the name of the converter
        return (com.getAttribute(domNode, phAttrib, true) === this.name);
      }
      // for deserialization, we need to ask the detectors if this converter is
      // responsible for handling the DOM node
      for (var d = 0; d < this.detectors.length; d++) {
        if (this.detectors[d].accepts(domNode)) {
          return true;
        }
      }
      return false;
    },

    getName: function () {
      return this.name;
    },

    _createPlaceholderImage: function (context) {
      var com = CUI.rte.Common;
      var phAttrib = CUI.rte.genhtml.GenericHtmlRules.PLACEHOLDER_ATTRIB;

      var placeholder = context.createElement('img');
      com.setAttribute(placeholder, 'src', CUI.rte.Theme.BLANK_IMAGE);
      if (this.rules.usePlaceholderStyle) {
        com.setAttribute(placeholder, 'style', this.rules.placeholderStyle);
      } else {
        com.addClass(placeholder, this.rules.placeholderClass);
      }
      com.setAttribute(placeholder, phAttrib, this.name);
      return placeholder;
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function (CUI) {
  'use strict';

  CUI.rte.genhtml.ConverterRegistry = (function () {

  var _converters = {};

  return {

    toString: 'ConverterRegistry',

    register: function (typeStr, converterClass) {
      _converters[typeStr] = converterClass;
    },

    create: function (typeStr) {
      if (_converters.hasOwnProperty(typeStr)) {
        return new _converters[typeStr]();
      }
      return undefined;
    }

  };

})();

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.genhtml.ConverterChain = new Class({

  toString: 'ConverterChain',

  _chain: undefined,

  initialize: function (config, rules) {
    var com = CUI.rte.Common;
    this._chain = [];
    if (config.hasOwnProperty('converters')) {
      var converters = config.converters;
      converters = com.toArray(converters);
      if (converters && CUI.rte.Utils.isArray(converters)) {
        for (var c = 0; c < converters.length; c++) {
          var converterDef = converters[c];
          if (converterDef.hasOwnProperty('type')) {
            var type = converterDef.type;
            var converter = CUI.rte.genhtml.ConverterRegistry.create(type);
            converter.configure(converterDef, rules);
            this._chain.push(converter);
          }
        }
      }
      delete config.converters;
    }
  },

  _execute: function (context, domNode, fnName) {
    var converted;
    for (var c = 0; c < this._chain.length; c++) {
      var converter = this._chain[c];
      if (converter.accepts(domNode)) {
        converted = converter[fnName](context, domNode);
        break;
      }
    }

    if (converted && converted.hasOwnProperty('replacement')) {
      var replacement = converted.replacement;
      if (!CUI.rte.Utils.isArray(replacement)) {
        replacement = [replacement];
      }
      var parent = CUI.rte.Common.getParentNode(context, domNode);
      if (parent) {
        for (var r = 0; r < replacement.length; r++) {
          parent.insertBefore(replacement[r], domNode);
        }
        parent.removeChild(domNode);
        converted.parent = parent;
      }
    }

    return converted;
  },

  serialize: function (context, domNode) {
    return this._execute(context, domNode, 'serialize');
  },

  deserialize: function (context, domNode) {
    return this._execute(context, domNode, 'deserialize');
  },

  getByName: function (name) {
    for (var c = 0; c < this._chain.length; c++) {
      var converter = this._chain[c];
      if (converter.getName() === name) {
        return converter;
      }
    }
    return undefined;
  }

});

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.genhtml.Editor = new Class({

  toString: 'Editor',

  config: function (config, toolkitInfo) {
    throw new Error('Editor.config not implemented.');
  },

  start: function (dom, callback) {
    throw new Error('Editor.start not implemented.');
  }

});

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function (CUI) {
  'use strict';

  CUI.rte.genhtml.EditorRegistry = (function () {

  var _editors = {};

  return {

    toString: 'EditorRegistry',

    register: function (typeStr, editorClass) {
      _editors[typeStr] = editorClass;
    },

    create: function (typeStr) {
      if (_editors.hasOwnProperty(typeStr)) {
        return new _editors[typeStr]();
      }
      return undefined;
    }

  };

})();

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.genhtml.RawConverter = new Class({

    toString: 'RawConverter',

    extend: CUI.rte.genhtml.Converter.AbstractConverter,

    keepEmptyContainers: false,

    configure: function (config) {
      this.inherited(arguments);
      this.keepEmptyContainers = !!config.keepEmptyContainers;
    },

    serialize: function (context, placeholderNode) {
      var com = CUI.rte.Common;
      var pylAttrib = CUI.rte.genhtml.RawConverter.PAYLOAD_ATTRIB;

      var payload = com.getAttribute(placeholderNode, pylAttrib, true);
      payload = (payload !== null && payload !== undefined ? payload : '');
      var payloadDiv = context.createElement('div');
      payloadDiv.innerHTML = payload;

      var replacement = [];
      for (var c = 0; c < payloadDiv.childNodes.length; c++) {
        replacement.push(payloadDiv.childNodes[c]);
      }
      return {
        'replacement': replacement,
        'keepEmptyContainers': this.keepEmptyContainers
      };
    },

    deserialize: function (context, domNode) {
      var com = CUI.rte.Common;
      var pylAttrib = CUI.rte.genhtml.RawConverter.PAYLOAD_ATTRIB;

      var payload = '';
      if (domNode) {
        switch (domNode.nodeType) {
          case 1:
            payload = com.getOuterHTML(context, domNode);
            break;
          case 8:
            payload = '<!--' + domNode.nodeValue + '-->';
            break;
          default:
            payload = domNode.nodeValue;
            break;
        }
      }

      var placeholder = this._createPlaceholderImage(context);
      com.setAttribute(placeholder, pylAttrib, payload);
      return {
        'replacement': placeholder
      };
    }

  });

  CUI.rte.genhtml.RawConverter.PAYLOAD_ATTRIB = '_rte_payload';

  // register converter
  CUI.rte.genhtml.ConverterRegistry.register('raw', CUI.rte.genhtml.RawConverter);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.genhtml.CustomConverter = new Class({

  toString: 'CustomConverter',

  extend: CUI.rte.genhtml.Converter.AbstractConverter

  // TODO implement

});

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.genhtml.ElementDetector = new Class({

  toString: 'ElementDetector',

  extend: CUI.rte.genhtml.Detector

  // TODO implement

});

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.genhtml.NodeTypeDetector = new Class({

    toString: 'NodeTypeDetector',

    extend: CUI.rte.genhtml.Detector,

    value: null,

    configure: function (config) {
      if (config.hasOwnProperty('value')) {
        this.value = parseInt(config.value);
      }
    },

    accepts: function (domNode) {
      if ((this.value === null || this.value === undefined) || isNaN(this.value)) {
        return false;
      }
      return (domNode.nodeType === this.value);
    }

  });

  // register detector
  CUI.rte.genhtml.DetectorRegistry.register('nodeType', CUI.rte.genhtml.NodeTypeDetector);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.genhtml.GenericHtmlRules
 * <p>This class defines the rules for managing "generic HTML".</p>
 * <p>Generic HTML is HTML that can't be edited directly by the RTE. Instead, a placholder
 * (typically an image) that is carrying the generic HTML code as a payload is used during
 * editing.</p>
 * <p>The serialize/deserialize methods of this class leverage a configurable hierarchy of
 * converters to create placeholders from uneditable HTML (deserialization) and convert
 * them back to the HTML (serialization) before the edited HTML code (the entire HTML, not
 * only the uneditable fragment) is persisted.</p>
 * @since 6.3
 * @constructor
 * Creates a GenericHtmlRules object.
 * @param {Object} config The configuration
 */

/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.genhtml.GenericHtmlRules = new Class({

  toString: 'GenericHtmlRules',

  usePlaceholderStyle: false,

  placeholderStyle: null,

  placeholderClass: null,

  converterChain: null,


  construct: function (config) {
    config = config || {};
    var defaults = {
      'usePlaceholderStyle': (CUI.rte.Theme.PLACEHOLDER_STYLE !== null),
      'placeholderStyle': CUI.rte.Theme.PLACEHOLDER_STYLE,
      'placeholderClass': CUI.rte.Theme.PLACEHOLDER_CLASS
    };
    CUI.rte.Utils.applyDefaults(config, defaults);
    this.converterChain = new CUI.rte.genhtml.ConverterChain();
    this.converterChain.initialize(config, this);
    CUI.rte.Utils.apply(this, config);
  },

  /**
   * @private
   */
  _execute: function (context, dom, fnName, isRoot, blocksToRemove) {
    var com = CUI.rte.Common;
    var ignoreRecursion = false;
    if (!isRoot) {
      var converted = this.converterChain[fnName](context, dom);
      if (converted !== null && converted !== undefined) {
        ignoreRecursion = true;
        if (!converted.keepEmptyContainers && blocksToRemove) {
          var replacement = converted.replacement;
          var parent = converted.parent;
          if (com.isTag(parent, com.EDITBLOCK_TAGS) &&
            parent.childNodes.length === replacement.length) {
            blocksToRemove.push(parent);
          }
        }
      }
    }

    if (!ignoreRecursion) {
      var children = dom.childNodes;
      for (var c = 0; c < children.length; c++) {
        this._execute(context, children[c], fnName, false, blocksToRemove);
      }
    }
  },

  /**
   * @private
   */
  _remove: function (toRemove) {
    for (var r = 0; r < toRemove.length; r++) {
      if (toRemove[r].parentNode) {
        CUI.rte.DomProcessor.removeWithoutChildren(toRemove[r]);
      }
    }
  },

  /**
   * Serializes the generic HTML parts of the DOM tree starting at the specified DOM node.
   * @param {CUI.rte.EditContext} context The editor context
   * @param {Node} dom The DOM node
   */
  serialize: function (context, dom) {
    var blocksToRemove = [];
    this._execute(context, dom, 'serialize', true, blocksToRemove);
    this._remove(blocksToRemove);
  },

  /**
   * Deserializes the generic HTML parts of the DOM tree starting at the specified DOM
   * node.
   * @param {CUI.rte.EditContext} context The editor context
   * @param {Node} dom The DOM node
   */
  deserialize: function (context, dom) {
    this._execute(context, dom, 'deserialize', true);
  }

});

  /**
   * Check if the specified DOM node is used as a placeholder object which carries generic
   * HTML and therefore has to be treated specially in some situations.
   * @param {Node} dom The node to check
   * @returns {Boolean} True if the specified DOM node is a placeholder object, carrying
   *          generic HTML
   * @static
   */
  CUI.rte.genhtml.GenericHtmlRules.isPlaceholder = function (dom) {
    var com = CUI.rte.Common;
    var phAttrib = CUI.rte.genhtml.GenericHtmlRules.PLACEHOLDER_ATTRIB;
    return com.isAttribDefined(dom, phAttrib);
  };

  CUI.rte.genhtml.GenericHtmlRules.PLACEHOLDER_ATTRIB = '_rte_placeholder';

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.genhtml.GenericHtmlPlugin = new Class({

  toString: 'Detector',

  extend: CUI.rte.plugins.Plugin,

  tools: null,

  toolUI: null,

  placeholderNode: null,

  defaultConverter: null,

  excludeForToolkit: ['ext'],


  _createTools: function () {
    this.tools = [];
    if (this.config.hasOwnProperty('tools')) {
      var toolDefs = this.config.tools;
      toolDefs = CUI.rte.Common.toArray(toolDefs);
      if (CUI.rte.Utils.isArray(toolDefs)) {
        for (var t = 0; t < toolDefs.length; t++) {
          var toolDef = toolDefs[t];
          if (toolDef.hasOwnProperty('converter') &&
            toolDef.hasOwnProperty('editor')) {
            this.tools.push({
              'ui': toolDef.ui,
              'converter': toolDef.converter,
              'editor': toolDef.editor,
              'editorConfig': toolDef.editorConfig
            });
          }
        }
        delete this.config.tools;
      }
    }
  },

  getFeatures: function () {
    return ['generichtml'];
  },

  initializeUI: function (tbGenerator, options) {
    var plg = CUI.rte.plugins;
    this._createTools();
    if (this.isFeatureEnabled('generichtml')) {
      this.toolUI = tbGenerator.createElement('generichtml', this, false,
        this.getTooltip('generichtml'));
      tbGenerator.addElement('generichtml', plg.Plugin.SORT_GENERICHTML,
        this.toolUI, 10);
    }
  },

  notifyPluginConfig: function (pluginConfig) {
    pluginConfig = pluginConfig || {};
    CUI.rte.Utils.applyDefaults(pluginConfig, {
      'tooltips': {
        'generichtml': {
          'title': CUI.rte.Utils.i18n('plugins.generichtml.generichtmlTitle'),
          'text': CUI.rte.Utils.i18n('plugins.generichtml.tooltipGenerichtml')
        }
      }
    });
    this.config = pluginConfig;
  },

  execute: function (pluginCommand, value, envOptions) {
    var com = CUI.rte.Common;
    var ghr = CUI.rte.genhtml.GenericHtmlRules;
    var self = this;

    var context = envOptions.editContext;
    if (this.placeholderNode === null || this.placeholderNode === undefined) {
      var converterId = this.defaultConverter;
      if (!converterId) {
        if (this.tools.length > 0) {
          converterId = this.tools[0].converter;
        }
      }
      if (!converterId) {
        return;
      }
      var converterChain = this.editorKernel.htmlRules.genericHtml.converterChain;
      var createConverter = converterChain.getByName(converterId);
      this.placeholderNode = createConverter.deserialize(context).replacement;
    }

    var converter = com.getAttribute(this.placeholderNode, ghr.PLACEHOLDER_ATTRIB,
      true);
    var toolIndex = com.arrayIndex(this.tools, converter,
      function (element, cmp) {
        return element.converter === cmp;
      });
    if (toolIndex >= 0) {
      var tool = this.tools[toolIndex];
      var editorId = tool.editor;
      var toolkitId = this.editorKernel.uiToolkit;

      var editor = CUI.rte.genhtml.EditorRegistry.create(editorId);
      editor.config(tool.editorConfig || {}, {
        'id': toolkitId,
        'toolkit': CUI.rte.ui.ToolkitRegistry.get(toolkitId),
        'editorKernel': this.editorKernel
      });
      editor.start(this.placeholderNode, function (dom, requiresDelete) {
        var parentNode = dom.parentNode;
        if (requiresDelete) {
          var sel = CUI.rte.Selection;
          var bookmark = sel.createSelectionBookmark(context);
          if (parentNode) {
            parentNode.removeChild(dom);
          }
          sel.selectBookmark(context, bookmark);
        } else {
          if (!parentNode) {
            self.editorKernel.execCmd('inserthtml',
              com.getOuterHTML(context, dom));
          }
        }
      });
    }
  },

  updateState: function (selDef) {
    var com = CUI.rte.Common;
    var ghr = CUI.rte.genhtml.GenericHtmlRules;
    var selectedNode = selDef.selectedDom;
    var isPlaceholder = false;
    if (selectedNode) {
      if (ghr.isPlaceholder(selectedNode)) {
        var converter = com.getAttribute(selectedNode, ghr.PLACEHOLDER_ATTRIB,
          true);
        isPlaceholder = com.arrayContains(this.tools, converter,
          function (element, cmp) {
            return element.converter === cmp;
          });
      }
    }
    this.placeholderNode = undefined;
    if (this.toolUI) {
      // this.toolUI.setDisabled(!isPlaceholder);
      if (isPlaceholder) {
        this.placeholderNode = selectedNode;
      }
    }
  },

  isHeadless: function (command, value) {
    return (this.tools.length === 0);
  }

});

  // register plugin
  CUI.rte.plugins.PluginRegistry.register('generichtml', CUI.rte.genhtml.GenericHtmlPlugin);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';

  CUI.rte.genhtml.RawPayloadEditor = new Class({

    toString: 'RawPayloadEditor',

    extend: CUI.rte.genhtml.Editor,

    editorKernel: null,

    editorDialog: null,

    processor: null,

    config: function (config, toolkitInfo) {
      var dh = CUI.rte.ui.DialogHelper;
      var pla = CUI.rte.genhtml.RawConverter.PAYLOAD_ATTRIB;
      var self = this;

      var title = '';
      var processorId = null;
      if (config) {
        processorId = config.processor;
        title = CUI.rte.Utils.i18n(config.title);
      }
      if (!processorId) {
        throw new Error('Missing processor for the raw HTML.');
      }
      this.processor = CUI.rte.genhtml.RawPayloadEditor.ProcessorRegistry
        .create(processorId);
      if (!this.processor) {
        throw new Error('Invalid processor for the raw HTML: ' + processorId);
      }

      this.editorKernel = toolkitInfo.editorKernel;
      var dm = this.editorKernel.getDialogManager();
      var dialogHelper = dm.createDialogHelper();
      var dialogConfig = {
        'configVersion': 1,
        'defaultDialog': {
          'dialogClass': {
            'type': 'rtedefaultdialog'
          }
        },
        'parameters': {
          'editorKernel': this.editorKernel,
          'command': 'generichtml#generichtml',
          'selfDestroy': true
        },
        'dialogProperties': {
          'title': title
        },
        'dialogItems': [
          {
            'item': dialogHelper.createItem(dh.TYPE_TEXTAREA, 'payload', ''),
            'fromModel': function (obj, field) {
              var value = CUI.rte.Common.getAttribute(obj, pla, true);
              value = self.processor.preprocess(value);
              field.value = value;
            },
            'toModel': function (obj, field) {
              var value = self.processor.postprocess(field.value);
              CUI.rte.Common.setAttribute(obj, pla, value);
            },
            'validate': function (field) {
              var value = field.value;
              if (value.trim().length === 0) {
                // empty content is always allowed - we're deleting then
                return true;
              }
              return self.processor.validate(value);
            }
          }
        ]
      };
      dialogHelper.configure(dialogConfig);
      this.editorDialog = dialogHelper.create();
      dialogHelper.calculateInitialPosition();
    },

    start: function (dom, callback) {
      this._callback = callback;
      var dm = this.editorKernel.getDialogManager();
      this.editorDialog.initializeEdit(this.editorKernel, dom,
        CUI.rte.Utils.scope(this.applyEdit, this));
      dm.show(this.editorDialog);
    },

    applyEdit: function (context, dom) {
      if (this._callback) {
        var pla = CUI.rte.genhtml.RawConverter.PAYLOAD_ATTRIB;
        var requiresDelete = !CUI.rte.Common.isAttribDefined(dom, pla);
        this._callback(dom, requiresDelete);
      }
    }

  });

  CUI.rte.genhtml.RawPayloadEditor.Processor = new Class({

    toString: 'RawPayloadEditor.Validator',

    preprocess: function (content) {
      throw new Error('Processor.preprocess not implemented.');
    },

    postprocess: function (content) {
      throw new Error('Processor.postprocess not implemented.');
    },

    validate: function (content) {
      throw new Error('Processor.validate not implemented.');
    }

  });

  CUI.rte.genhtml.RawPayloadEditor.ProcessorRegistry = (function () {

    var _processors = {};

    return {

      toString: 'RawPayloadEditor.ProcessorRegistry',

      register: function (typeStr, editorClass) {
        _processors[typeStr] = editorClass;
      },

      create: function (typeStr) {
        if (_processors.hasOwnProperty(typeStr)) {
          return new _processors[typeStr]();
        }
        return undefined;
      }

    };

  })();

  CUI.rte.genhtml.RawPayloadEditor.CommentProcessor = new Class({

    toString: 'RawPayloadEditor.CommentProcessor',

    extend: CUI.rte.genhtml.RawPayloadEditor.Processor,

    _hasLeadingSpaces: false,

    preprocess: function (content) {
      var com = CUI.rte.Common;
      if (!com.strStartsWith(content, '<!--') || !com.strEndsWith(content, '-->')) {
        return '';
      }
      var comment = content.substring('<!--'.length, content.length - '-->'.length);
      if (com.strStartsWith(comment, ' ') && com.strEndsWith(comment, ' ')) {
        this._hasLeadingSpaces = true;
        comment = comment.substring(1, comment.length - 1);
      }
      return comment;
    },

    postprocess: function (content) {
      if (content.trim().length === 0) {
        return '';
      }
      var spc = (this._hasLeadingSpaces ? ' ' : '');
      return '<!--' + spc + content + spc + '-->';
    },

    validate: function (content) {
      return (content.indexOf('<!--') < 0) && (content.indexOf('-->') < 0);
    }

  });

  CUI.rte.genhtml.EditorRegistry.register('rawpayload', CUI.rte.genhtml.RawPayloadEditor);
  CUI.rte.genhtml.RawPayloadEditor.ProcessorRegistry
    .register('comment', CUI.rte.genhtml.RawPayloadEditor.CommentProcessor);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * This class defines the toolkit abstraction layer for the underlying UI toolkit.
 * @class CUI.rte.ui.Toolkit
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.ui.Toolkit = new Class({

    toString: 'Toolkit',

    toolkitData: {},

    initialize: function () {
      // can be overridden for additional initialization the first time the toolkit
      // is acquired
    },

    requiresInit: function () {
      throw new Error('Toolkit#requiresInit is not implemented by the specific toolkit.');
    },

    createToolbarBuilder: function (hint) {
      throw new Error('Toolkit#createToolbarBuilder is not implemented by the specific ' +
        'toolkit.');
    },

    createContextMenuBuilder: function (editorKernel) {
      throw new Error('Toolkit#createContextMenuBuilder is not implemented by the ' +
        'specific toolkit.');
    },

    createDialogManager: function (editorKernel) {
      throw new Error('Toolkit#createDialogManager is not implemented by the specific ' +
        'toolkit.');
    },

    /**
     * Adds toolkit specific data.
     * <p>
     * Overwrites existing data under the same name.
     * @param {String} name The name/key of the data
     * @param {*} value The data
     */
    addToolkitData: function (name, value) {
      this.toolkitData[name] = value;
    },

    /**
     * Removes toolkit specific data.
     * <p>
     * Call is ignored if no data is available under the specified name.
     * @param {String} name The name/key of the data
     */
    removeToolkitData: function (name) {
      if (this.toolkitData.hasOwnProperty(name)) {
        delete this.toolkitData[name];
      }
    },

    /**
     * Checks if toolkit specific data is available under the specified name.
     * @param {String} name the name/key of the data
     * @returns {Boolean} true if respective data is avaialble
     */
    hasToolkitData: function (name) {
      return this.toolkitData.hasOwnProperty(name);
    },

    /**
     * Retrieves toolkit specific data for a given name.
     * @param {String} name The name/key of the data
     * @returns {*} The data; undefined, if no data is available for the name
     */
    getToolkitData: function (name) {
      if (this.toolkitData.hasOwnProperty(name)) {
        return this.toolkitData[name];
      }
      return undefined;
    }

  });

  CUI.rte.ui.Toolkit.TBHINT_LOCAL = 'local';

  CUI.rte.ui.Toolkit.TBHINT_GLOBAL = 'global';
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function (CUI) {
  'use strict';
  CUI.rte.ui.ToolkitRegistry = (function () {

    var toolkits = {};

    return {

      /**
       * Registers a "potential" toolkit implementation.
       * @param {String} toolkitName The toolkit name
       * @param {Function} Cls The constructor ("class") of the toolkit
       */
      register: function (toolkitName, Cls) {
        toolkits[toolkitName] = {
          'initialized': false,
          'obj': new Cls()
        };
      },

      /**
       * Initializes the specified toolkit.
       * @param {String} toolkitName The toolkit
       * @param {Function} callback (optional) Callback that is executed when the toolkit
       *        has been fully initialized
       * @throws Error if no toolkit has been registered for the specified toolkit name
       */
      initialize: function (toolkitName, callback) {
        if (!toolkits.hasOwnProperty(toolkitName)) {
          throw new Error('No toolkit registered for type \'' + toolkitName + '\'');
        }
        CUI.rte._toolkit = toolkitName;
        var toolkitDef = toolkits[toolkitName];
        var toolkit = toolkitDef.obj;
        if (!toolkitDef.initialized && toolkit.requiresInit()) {
          toolkit.initialize(function () {
            toolkitDef.initialized = true;
            if (callback) {
              callback(toolkit);
            }
          });
        } else {
          if (callback) {
            callback(toolkit);
          }
        }
      },

      /**
       * Gets a toolkt by its name or the currently used toolkit (if already initialized).
       * @param {String} toolkitName (optional) The name of the toolkit; undefined to
       *        determine the currently used toolkit (if already initialized)
       * @returns {CUI.rte.ui.Toolkit} The toolkit
       * @throws Error if the specified toolkit does not exist or is not initialized
       */
      get: function (toolkitName) {
        toolkitName = toolkitName || CUI.rte._toolkit;
        if (!toolkits.hasOwnProperty(toolkitName)) {
          throw new Error('No toolkit registered for type \'' + toolkitName + '\'');
        }
        var toolkitDef = toolkits[toolkitName];
        var toolkit = toolkitDef.obj;
        if (!toolkitDef.initialized) {
          if (toolkit.requiresInit()) {
            throw new Error('Toolkit not yet initialized.');
          } else {
            toolkitDef.initialized = true;
          }
        }
        return toolkitDef.obj;
      }

    };

  }(window.CUI));
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * <p>This class is used for UI-related events.</p>
 * <p>UI-related events are used for communication between the toolkit-specific
 * implementation and the editor core. For example, a dialog (toolkit-specific) fires
 * events when it is shown or hidden to inform the editor's core about such actions.
 * The editor core then dispatches the event to registered listeners - allowing
 * other plugins to react on events triggered by an originating plugin.</p>
 * @type CUI.rte.ui.UIEvent
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.ui.UIEvent = new Class({

    toString: 'UIEvent',

    /**
     * The event type
     * @type String
     * @private
     */
    type: null,

    /**
     * The edit context for the event
     * @property editContext
     */
    editContext: null,

    /**
     * Creates a new UI-related event.
     * @param {String} type The event type
     * @param {CUI.rte.EditContext} editContext The edit context
     * @param {Object} params The parameters (content is dependent on the event type)
     */
    construct: function (type, editContext, params) {
      params = params || {};
      this.type = type;
      this.editContext = editContext;
      CUI.rte.Utils.apply(this, params);
    },

    /**
     * Returns the UI event's type.
     * @return {String} The event type
     */
    getType: function () {
      return this.type;
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.ui.ToolbarBuilder
 * @private
 * <p>This class is used to build toolbars from plugins.</p>
 * <p>Each toolbar consists of several groups of toolbar items. Each group is separated
 * from other groups visually. Each group has a sorting index to determine its position
 * relative to other groups. Each toolbar item has a sorting index to determine its position
 * relative to other icons of the same group.</p>
 * @constructor
 * Creates a new ToolbarBuilder
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.ui.ToolbarBuilder = new Class({

    toString: 'ToolbarBuilder',

    /**
     * @private
     */
    groups: null,

    construct: function () {
      this.groups = [];
    },

    /**
     * @private
     */
    insertInArray: function (array, element) {
      var sort = element.sort;
      var itemCnt = array.length;
      for (var i = 0; i < itemCnt; i++) {
        if (array[i].sort && array[i].sort > sort) {
          array.splice(i, 0, element);
          return;
        }
      }
      array.push(element);
    },

    /**
     * @private
     */
    getGroupById: function (groupId) {
      var groupCnt = this.groups.length;
      for (var i = 0; i < groupCnt; i++) {
        if (this.groups[i].id === groupId) {
          return this.groups[i];
        }
      }
    },

    /**
     * Add a new toolbar item.
     * @param {String} groupId ID of the group the item belongs to
     * @param {Number} groupSort Group sorting index
     * @param {CUI.rte.ui.TbElement} element Toolbar item to add
     * @param {Number} elementSort Element sorting index
     */
    addElement: function (groupId, groupSort, element, elementSort) {
      var group = this.getGroupById(groupId);
      if (!group) {
        group = {
          'id': groupId,
          'sort': groupSort,
          'elements': []
        };
        this.insertInArray(this.groups, group);
      }
      this.insertInArray(group.elements, {
        'sort': elementSort,
        'def': element
      });
    },

    /**
     * Create the toolbar as a suitable Ext component.
     * @return {CUI.rte.ui.Toolbar} The toolbar
     */
    createToolbar: function (editorKernel, options) {
      // must be overridden by the implementing class
      return null;
    },

    createElement: function (id, plugin, toggle, tooltip, css, cmdDef) {
      // must be overridden by the implementing class
      throw new Error('ToolbarBuilder#createElement is not implemented.');
    },

    createParaFormatter: function (id, plugin, tooltip, formats) {
      // must be overridden by the implementing class
      throw new Error('ToolbarBuilder#createParaFormatter is not implemented.');
    },

    createStyleSelector: function (id, plugin, tooltip, styles) {
      // must be overridden by the implementing class
      throw new Error('ToolbarBuilder#createStyleSelector is not implemented.');
    }

  });

  /**
   * @static
   * @final
   * @type Number
   * @private
   */
  CUI.rte.ui.ToolbarBuilder.MAIN_TOOLBAR = 0;

  /**
   * @static
   * @final
   * @type Number
   * @private
   */
  CUI.rte.ui.ToolbarBuilder.STYLE_TOOLBAR = 1;
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.ui.Toolbar = new Class({

    toString: 'Toolbar',

    /**
     * The toolbar type
     */
    tbType: null,

    /**
     * The toolkit-specific representation of the toolbar
     */
    toolkitRep: null,

    construct: function (toolkitRep) {
      this.toolkitRep = toolkitRep;
    },

    getToolkitRep: function () {
      return this.toolkitRep;
    },

    getItem: function (itemId) {
      throw new Error('Toolbar#getItem is not implemented.');
    },

    getHeight: function () {
      throw new Error('Toolbar#getHeight is not implemented.');
    },

    adjustToWidth: function (width) {
      // may be overridden by implementing toolbar if adjustments to the available width
      // for the toolbar are required
    },

    startEditing: function (editorKernel) {
      // may be overridden by implementing toolbar if special handling is required,
      // for example the toolbar is only shown during editing
    },

    finishEditing: function () {
      // may be overridden by implementing toolbar if special handling is required,
      // for example the toolbar is only shown during editing
    },

    enable: function () {
      throw new Error('Toolbar#enable is not implemented.');
    },

    disable: function (excludeItems) {
      throw new Error('Toolbar#disable is not implemented.');
    },

    destroy: function () {
      throw new Error('Toolbar#destroy is not implemented.');
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.ui.TbElement
 * @private
 * This class represents a single element for use in
 * {@link CUI.rte.ui.ToolbarBuilder}.
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.ui.TbElement = new Class({

    toString: 'TbElement',

    id: null,

    plugin: null,

    toggle: null,

    tooltip: null,

    toolbar: null,

    construct: function (id, plugin, toggle, tooltip, css, cmdDef) {
      this._init.apply(this, arguments);
    },

    _init: function (id, plugin, toggle, tooltip, css, cmdDef) {
      this.id = id;
      this.plugin = plugin;
      this.toggle = toggle;
      this.css = (css ? css : 'x-edit-' + id);
      this.cmdDef = cmdDef;
      if (tooltip) {
        this.tooltip = tooltip;
        this.tooltip.cls = 'x-html-editor-tip';
      } else {
        this.tooltip = null;
      }
    },

    getToolbar: function () {
      return CUI.rte.ui.ToolbarBuilder.MAIN_TOOLBAR;
    },

    addToToolbar: function (toolbar) {
      throw new Error('TbElement#addToToolbar is not implemented.');
    },

    notifyToolbar: function (toolbar) {
      throw new Error('TbElement#notifyToolbar is not implemented.');
    },

    createToolbarDef: function () {
      throw new Error('TbElement#createToolbarDef is not implemented.');
    },

    setDisabled: function (isDisabled) {
      throw new Error('TbElement#setDisabled is not implemented.');
    },

    setSelected: function (isSelected, suppressEvent) {
      throw new Error('TbElement#setSelected is not implemented.');
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.ui.TbParaFormatter
 * @extends CUI.rte.ui.TbElement
 * @private
 * This class represents a paragraph formatter element for use in
 * {@link CUI.rte.ui.ToolbarBuilder}.
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.ui.TbParaFormatter = new Class({

    extend: CUI.rte.ui.TbElement,

    formatSelector: null,

    formats: null,

    construct: function () {
      // Dummy constructor to keep constructor chain alive
    },

    _init: function (id, plugin, toggle, tooltip, css, cmdDef, formats) {
      this.inherited(arguments);
      this.formats = formats;
    },

    notifyToolbar: function (toolbar) {
      this.toolbar = toolbar;
    },

    getToolbar: function () {
      return CUI.rte.ui.ToolbarBuilder.STYLE_TOOLBAR;
    },

    initializeSelector: function () {
      // must be overridden by implementing classes
      throw new Error('tbParaFormatter#initializeSelector is not implemented.');
    },

    getSelectorDom: function () {
      // must be overridden by implementing classes
      throw new Error('TbParaFormatter#getSelectorDom is not implemented.');
    },

    getSelectedFormat: function () {
      // must be overridden by implementing classes
      throw new Error('TbParaFormatter#getSelectedFormat is not implemented.');
    },

    selectFormat: function (formatToSelect, auxRoot, formatCnt, noFormatCnt) {
      throw new Error('TbParaFormatter#selectFormat is not implemented.');
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.ui.TbStyleSelector
 * @extends CUI.rte.ui.TbElement
 * @private
 * This class represents a style selecting element for use in
 * {@link CUI.rte.ui.ToolbarBuilder}.
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.ui.TbStyleSelector = new Class({

    toString: 'TbStyleSelector',

    extend: CUI.rte.ui.TbElement,

    styleSelector: null,

    styles: null,

    _init: function (id, plugin, toggle, tooltip, css, cmdDef, styles) {
      this.inherited(arguments);
      this.styles = styles;
    },

    /**
     * Creates HTML code for rendering the options of the style selector.
     * @return {String} HTML code containing the options of the style selector
     * @private
     */
    createStyleOptions: function () {
      var htmlCode = '<option value=\'\'>[None]</option>';
      if (this.styles) {
        var styleCnt = this.styles.length;
        for (var s = 0; s < styleCnt; s++) {
          var styleToAdd = this.styles[s];
          var className = styleToAdd.cssName;
          var text = styleToAdd.text;
          htmlCode += '<option value=\'' + className + '\'>' + text + '</option>';
        }
      }
      return htmlCode;
    },

    notifyToolbar: function (toolbar) {
      this.toolbar = toolbar;
    },

    getToolbar: function () {
      return CUI.rte.ui.ToolbarBuilder.STYLE_TOOLBAR;
    },

    initializeSelector: function () {
      // must be overridden by implementing classes
      throw new Error('TbStyleSelector#initializeSelector is not implemented.');
    },

    getSelectorDom: function () {
      // must be overridden by implementing classes
      throw new Error('TbStyleSelector#getSelectorDom is not implemented.');
    },

    getSelectedStyle: function () {
      // must be overridden by implementing classes
      throw new Error('TbStyleSelector#getSelectedStyle is not implemented.');
    },

    selectStyles: function (styles, selDef) {
      // must be overridden by implementing classes
      throw new Error('TbStyleSelector#selectStyles is not implemented.');
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.ui.ContextMenuBuilder
 * @private
 * This class is used to build the context menu from plugins in a implementation-independent
 * way.
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.ui.ContextMenuBuilder = new Class({

    toString: 'ContextMenuBuilder',

    /**
     * List of items
     * @private
     * @type Array
     */
    items: null,

    /**
     * The menu built/managed
     * @private
     * @type Object
     */
    menu: null,


    construct: function (editorKernel) {
      this.items = [];
      this.editorKernel = editorKernel;
    },

    addItem: function (itemToAdd) {
      this.items.push(itemToAdd);
    },

    clear: function () {
      this.items.length = 0;
    },

    build: function (selectionContext, context) {
      // must be overridden by implementing classes
      throw new Error('ContextMenuBuilder#build is not implemented.');
    },

    createItem: function (config) {
      // must be overridden by implementing classes
      throw new Error('ContextMenuBuilder#createItem is not implemented.');
    },

    createSeparator: function () {
      // must be overridden by implementing classes
      throw new Error('ContextMenuBuilder#createSeparator is not implemented.');
    },

    // TODO move to a separate class that abstracts the context menu itself

    showAt: function (x, y) {
      // must be overridden by implementing classes
      throw new Error('ContextMenuBuilder#showAt is not implemented.');
    },

    hideAll: function () {
      // must be overridden by implementing classes
      throw new Error('ContextMenuBuilder#hide is not implemented.');
    },

    isVisible: function () {
      // must be overridden by implementing classes
      throw new Error('ContextMenuBuilder#isVisible is not implemented.');
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.ui.CmItem
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.ui.CmItem = new Class({

    toString: 'CmItem',

    build: function (menu, editorKernel, editContext, selectionContext) {
      // must be overridden by implementing class
      throw new Error('CmItem#build is not implemented.');
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.ui.CmSeparator
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.ui.CmSeparator = new Class({

    toString: 'CmSeparator',

    build: function (menu) {
      // must be overridden by implementing classes
      throw new Error('CmSeparator#build must be overridden by implementing classes.');
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * This class should be overridden by toolkit-specific dialog implementations.
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.ui.DialogManager = new Class({

    // Interface ---------------------------------------------------------------------------

    create: function (dialogId, config) {
      throw new Error('DialogManager#create must be implemented');
    },

    mustRecreate: function (dialog) {
      throw new Error('DialogManager#mustRecreate must be implemented');
    },

    show: function (dialog) {
      throw new Error('DialogManager#show must be implemented');
    },

    hide: function (dialog) {
      throw new Error('DialogManager#hide must be implemented');
    },

    alert: function (title, message, fn) {
      throw new Error('DialogManager#alert must be implemented');
    },

    isShown: function (dialog) {
      throw new Error('DialogManager#isShown must be implemented');
    },

    createDialogHelper: function () {
      throw new Error('DialogManager#createDialogHelper must be implemented');
    },


    // Optional Extensions -----------------------------------------------------------------

    prepareShow: function (dialog) {
      // may be overridden if showing a dialog needs to be prepared
    },

    toggleVisibility: function (dialog) {
      // may be overridden if showing a dialog twice (without hiding in-between) will
      // hide the dialog instead of showing again/keep showing
      return false;
    }

  });

  /**
   * ID for the "link" dialog
   * @type {String}
   */
  CUI.rte.ui.DialogManager.DLG_LINK = 'linkDialog';

  /**
   * ID for the "anchor" dialog
   * @type {String}
   */
  CUI.rte.ui.DialogManager.DLG_ANCHOR = 'anchorDialog';

  /**
   * ID for the "find &amp; replace" dialog
   * @type {String}
   */
  CUI.rte.ui.DialogManager.DLG_FINDREPLACE = 'findReplaceDialog';

  /**
   * ID for the "paste" dialog
   * @type {String}
   */
  CUI.rte.ui.DialogManager.DLG_PASTE = 'pasteDialog';

  /**
   * ID for the "special chars" dialog
   * @type {String}
   */
  CUI.rte.ui.DialogManager.DLG_SPECCHARS = 'specCharsDialog';

  /**
   * ID for the "spellchecker" dialog
   * @type {String}
   */
  CUI.rte.ui.DialogManager.DLG_SPELLCHECKER = 'spellCheckerDialog';

  /**
   * ID for the "table properties" dialog
   * @type {String}
   */
  CUI.rte.ui.DialogManager.DLG_TABLEPROPS = 'tablePropsDialog';

  /**
   * ID for the "cell properties" dialog
   * @type {String}
   */
  CUI.rte.ui.DialogManager.DLG_CELLPROPS = 'cellPropsDialog';

  /**
   * ID for the "table and cell properties" dialog
   * @type {String}
   */
  CUI.rte.ui.DialogManager.DLG_TABLEANDCELLPROPS = 'tableAndCellPropsDialog';

  /**
   * ID for the "image properties" dialog
   * @type {String}
   */
  CUI.rte.ui.DialogManager.DLG_IMAGEPROPS = 'imagePropsDialog';
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.ui.DialogHelper
 * @private
 * <p>The DialogHelper provides helper functionality for creating extensible dialogs from
 * inside the richtext editor. It should be used by plugins to create and display
 * dependent dialogs.</p>
 * <p>The following features are available:</p>
 * <ul>
 *   <li>The default, "out-of-the-box" dialog can be extended with additional fields.</li>
 *   <li>Fields that are contained in the default dialog may be disabled as required.</li>
 *   <li>The default dialog may be replaced completely by a custom dialog.</li>
 * </ul>
 * @constructor
 * Creates a new DialogHelper with the specified configuration.
 * @param {Object} dialogConfig The dialog's configuration
 * @param {CUI.rte.EditorKernel} editorKernel The editor kernel the dialog is used from
 * @since 5.3
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.ui.DialogHelper = new Class({

    toString: 'DialogHelper',

    /**
     * @cfg {Number} configVersion
     * Defines the version of the dialog configuration provided. Must currently be set to
     * 1 to use the extensible configuration. If no value is specified, the config is used
     * "as is" for CQ 5.2 compatibility.
     */
    configVersion: null,

    /**
     * @cfg {Object} defaultDialog
     * Defines the default dialog. This config property should only be set by the respective
     * plugin and not be used for customization. The object must contain an array named
     * items that contains Ext field definitions (as known from other component definitions)
     * or an Object named dialogClass which defines the xtype and optionally a
     * jcr:primaryType property. Additionally, an Object named dialogProperties can be
     * provided, which contains further dialog properties (such as width, height, title,
     * etc.). Note that each of the fields in the items array must contain a "name"
     * property which is used for referencing the field from other places.
     */
    defaultDialog: null,

    /**
     * @cfg {Object[]} additionalFields
     * <p>Array containing additional fields that have to be added to the default fields of
     * the dialog. Each element must have the following properties:</p>
     * <ul>
     *   <li><code>item</code> : String<br>
     *     The definition of the field (using a standard Ext item definition). Must contain
     *     a name property for further referencing.</li>
     *   <li><code>previousItem</code> : String<br>
     *     Name of the field that is located before the field to add. This is used to
     *     provide a certain sort order of the fields.</li>
     *   <li><code>fromModel</code> : Function<br>
     *     A function that is responsible for transferring the data from the model (usually
     *     the DOM object that is edited by the dialog, but actually depends on the
     *     context the DialogHelper is used in) to the additional field.</li>
     *   <li><code>toModel</code> : Function<br>
     *     A function that is responsible for transferring the user input from the
     *     additional field to the model (usually the DOM object that is edited by the
     *     dialog, but actually depends on the context the DialogHelper is used in)</li>
     * </ul>
     */
    additionalFields: null,

    /**
     * @cfg {String[]} disabledDefaultFields
     * An array of strings that contain the names of the default fields that should get
     * disabled. The actual names depend on the fields specified by {@link #defaultFields}.
     */
    disabledDefaultFields: null,

    /**
     * @cfg {Object} dialogProperties
     * Additional, overridden or customized dialog properties, such as width, height or
     * title.
     */
    dialogProperties: null,

    /**
     * @cfg {Object} dialogItems
     * The items of the dialog (optional, if not determined by the template)
     */
    dialogItems: null,

    /**
     * Currently edited dialog (set in {@link #create})
     * @private
     * @type Object
     */
    dialogProcessed: null,

    /**
     * @cfg {Object} customDialog
     * <p>Config object that is used for replacing the default dialog by a completely
     * customized dialog.</p>
     * <p>The config object is a typical Ext component definition. If a jcr:primaryType
     * property is included, the customized dialog will be instantiated using the
     * respective toolkit's default method for instantiating dialogs indirectly. Otherwise
     * it is instantiated directly using the toolkit's standard component builder.</p>
     * <p>Note that all other config options are ignored if a custom dialog is used.</p>
     */
    customDialog: null,

    /**
     * The editor kernel the dialog is used from
     * @publicProp
     * @type CUI.rte.EditorKernel
     */
    editorKernel: null,


    construct: function (dialogConfig, editorKernel) {
      if (arguments.length === 1) {
        // required for backwards compatibility
        editorKernel = dialogConfig;
        dialogConfig = undefined;
      }
      this.editorKernel = editorKernel;
      if (dialogConfig) {
        this.configure(dialogConfig);
      }
    },

    configure: function (dialogConfig) {
      if (!dialogConfig.configVersion) {
        dialogConfig = {
          'configVersion': 1,
          'customDialog': dialogConfig
        };
      }
      CUI.rte.Utils.apply(this, dialogConfig);
    },

    /**
     * @protected
     */
    instantiateDialog: function (dialogConfig) {
      throw new Error(
        'DialogHelper#instantiateDialog must be implemented in a toolkit-specific ' +
        'way');
    },

    /**
     * @private
     */
    createCustomDialog: function () {
      return this.instantiateDialog(this.customDialog);
    },

    /**
     * <p>Adds the additional fields to the specified dialog item configuration.</p>
     * <p>This method is used by {@link CUI.rte.ui.Window.BaseWindow} to apply custom
     * configuration. It should not be called directly.</p>
     * @private
     */
    addAdditionalItems: function (dialogItems) {
      var additionalFields = [];
      if (this.additionalFields) {
        var fieldCnt = this.additionalFields.length;
        for (var f = 0; f < fieldCnt; f++) {
          var fieldToAdd = this.additionalFields[f];
          if (fieldToAdd.item && fieldToAdd.item.name) {
            var isInserted = false;
            if (fieldToAdd.insertBefore) {
              var itemCnt = dialogItems.length;
              for (var i = 0; i < itemCnt; i++) {
                var itemToCheck = dialogItems[i];
                if (itemToCheck.name === fieldToAdd.insertBefore) {
                  dialogItems.splice(i, 0, fieldToAdd.item);
                  isInserted = true;
                  break;
                }
              }
            }
            if (!isInserted) {
              dialogItems.push(fieldToAdd.item);
            }
            if (fieldToAdd.validator) {
              fieldToAdd.item.validator = fieldToAdd.validator;
              fieldToAdd.item.evaluateValidatorsFirst = true;
            }
            additionalFields.push({
              'name': fieldToAdd.item.name,
              'fromModel': fieldToAdd.fromModel,
              'toModel': fieldToAdd.toModel
            });
          }
        }
      }
      return additionalFields;
    },

    /**
     * <p>Removes the disabled fields from the specified dialog item configuration.</p>
     * <p>This method is used by {@link CUI.rte.ui.Window.BaseWindow} to apply custom
     * configuration. It should not be called directly.</p>
     * @private
     */
    removeDisabledItems: function (dialogItems) {
      var com = CUI.rte.Common;
      if (this.disabledDefaultFields) {
        var itemCnt = dialogItems.length;
        for (var i = itemCnt - 1; i >= 0; i--) {
          var item = dialogItems[i];
          if (com.arrayContains(this.disabledDefaultFields, item.name)) {
            dialogItems.splice(i, 1);
          }
        }
      }
    },

    /**
     * <p>Merges two objects recursively.</p>
     * <p>Note that this method does not work with top-level Arrays.</p>
     * @param {Object} obj The base object
     * @param {Object} objToAppend The object that is merged into obj
     * @private
     */
    mergeObjects: function (obj, objToAppend) {
      for (var key in objToAppend) {
        if (objToAppend.hasOwnProperty(key)) {
          var value = objToAppend[key];
          if (typeof(value) === 'object') {
            var copyObj = CUI.rte.Utils.copyObject(value);
            if (obj[key]) {
              CUI.rte.Utils.applyDefaults(obj[key], copyObj);
            } else {
              obj[key] = copyObj;
            }
          } else {
            obj[key] = value;
          }
        }
      }
    },

    /**
     * @private
     */
    createExtensibleDialog: function () {
      if (!this.defaultDialog) {
        throw new Error('Invalid dialogConfig; missing property defaultDialog');
      }
      if (this.defaultDialog.dialogClass) {
        var dialogConfig = CUI.rte.Utils.copyObject(this.defaultDialog.dialogClass);
        if (this.defaultDialog.dialogProperties) {
          this.mergeObjects(dialogConfig, this.defaultDialog.dialogProperties);
        }
        if (this.dialogProperties) {
          this.mergeObjects(dialogConfig, this.dialogProperties);
        }
        if (this.dialogItems) {
          dialogConfig.dialogItems = this.dialogItems;
        }
        if (this.parameters) {
          dialogConfig.parameters = this.parameters;
        }
        return this.instantiateDialog(dialogConfig);
      } else if (this.defaultDialog.items) {
        // todo implement
        return null;
      } else {
        throw new Error('Invalid dialogConfig; missing property defaultDialog.items ' +
          'or defaultDialog.dialogClass.');
      }
    },

    /**
     * Creates the dialog as specified by the configuration that was passed to the
     * constructor.
     * @return {Object} The toolkit specific object representing the dialog
     */
    create: function () {
      if (this.customDialog) {
        this.dialogProcessed = this.createCustomDialog();
      } else {
        this.dialogProcessed = this.createExtensibleDialog();
      }
      return this.dialogProcessed;
    },

    /**
     * Calculates a suitable dialog position for the specified editor kernel.
     * @param {String} hint A positioning hint; allowed values are: "default"
     */
    calculateInitialPosition: function (hint) {
      if (this.dialogProcessed) {
        this.dialogProcessed.setPosition(this.editorKernel.calculateWindowPosition(
          hint));
      }
    },

    /**
     * Creates a new item of the specified type with the specified config.
     * @param {String} type The Item's type
     */
    createItem: function (type, name, label) {
      throw new Error(
        'DialogHelper#createItem must be implemented in a toolkit-specific way');
    },

    /**
     * Returns the type of the specified, toolkit-specific item
     * @param {Object} item The item to retrieve the type from
     */
    getItemType: function (item) {
      throw new Error(
        'DialogHelper#getItemType must be implemented in a toolkit-specific way');
    },

    /**
     * Returns the name of the specified, toolkit-specific item
     * @param {Object} item The item
     * @return {String} The item's name
     */
    getItemName: function (item) {
      throw new Error(
        'DialogHelper#getItemName must be implemented in a toolkit-specific way');
    },

    /**
     * Returns the current value of the specified, toolkit-specific item
     * @param {Object} item The item
     * @return {String} The current item value
     */
    getItemValue: function (item) {
      throw new Error(
        'DialogHelper#getItemValue must be implemented in a toolkit-specific way');
    },

    /**
     * Sets the specified, toolkit-specific item's value.
     * @param {Object} item The item
     * @param {String} value The value to set
     */
    setItemValue: function (item, value) {
      throw new Error(
        'DialogHelper#setItemValue must be implemented in a toolkit-specific way');
    },

    /**
     * Registers the dialog class
     */
    registerDialog: function() {
      throw new Error(
        'DialogHelper#registerDialog must be implemented in a toolkit-specific way');
    }


  });

  /**
   * The dialog's type for indirect instantiation
   * @type {String}
   */
  CUI.rte.ui.DialogHelper.TYPE_DIALOG = 'rtelinkdialog';

  /**
   * Item type: Text field
   * @type {String}
   */
  CUI.rte.ui.DialogHelper.TYPE_TEXTFIELD = 'textfield';

  /**
   * Item type: Text area
   * @type {String}
   */
  CUI.rte.ui.DialogHelper.TYPE_TEXTAREA = 'textarea';

  /**
   * Item type: Hidden field
   * @type {String}
   */
  CUI.rte.ui.DialogHelper.TYPE_HIDDEN = 'hidden';
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function($, CUI) {

  'use strict';
  /**
   * @class CUI.rte.Theme
   * The theme-specific constants for the RTE component.
   * @static
   * @singleton
   * @ignore
   */
  CUI.rte.Theme = (function() {

    return {

      /**
       * The default height of a rich text editor component, including the toolbar(s)
       * (defaults to 210)
       * @static
       * @final
       * @type Number
       * @ignore
       */
      DEFAULT_HEIGHT: 210,

      /**
       * The default path where the required stylesheets are located (defaults to
       * "/libs/cq/widgets/themes/default/widgets/form/RichText" [5.2] resp.
       * "/libs/cq/ui/widgets/themes/default/widgets/form/RichText" [as of 5.3])
       * @static
       * @final
       * @type String
       * @ignore
       */
      DEFAULT_REQCSS_PATH: '/libs/cq/ui/rte/themes/default/internal',

      /**
       * CSS class to be used for styling an anchor (defauls to "rte-anchor")
       * @static
       * @final
       * @type String
       * @ignore
       */
      ANCHOR_CLASS: 'rte-anchor',

      /**
       * CSS class to be used for styling a generic HTML placeholder (defaults to
       * "rte-placeholder")
       * @static
       * @final
       * @type String
       * @ignore
       */
      PLACEHOLDER_CLASS: 'rte-placeholder',

      /**
       * CSS style to be used for styling a generic HTML placeholder if no class
       * should be used (defaults to undefined)
       * @static
       * @final
       * @type String
       * @ignore
       */
      PLACEHOLDER_STYLE: null,

      /**
       * CSS class to be used for styling a table with no actual border (defaults to
       * "rte-forcedborder")
       * @static
       * @final
       * @type String
       * @ignore
       */
      TABLE_NOBORDER_CLASS: 'rte-forcedborder',

      /**
       * CSS class to be used for custom selections within a table (defaults to
       * "rte-tableselection")
       * @static
       * @final
       * @type String
       * @since 5.3
       * @ignore
       */
      TABLESELECTION_CLASS: 'rte-tableselection',

      /**
       * CSS class that is added to active toolbar items
       */
      TOOLBAR_ACTIVE: 'is-active',

      /**
       * CSS class that is added to disabled toolbar items
       * @ignore
       */
      TOOLBARITEM_DISABLED_CLASS: 'is-disabled',

      /**
       * CSS class that is added to selected toolbar items
       * @ignore
       */
      TOOLBARITEM_SELECTED_CLASS: 'is-selected',

      /**
       * Blank image path
       */
      BLANK_IMAGE: '../../resources/images/blank.png'

    };

  }());

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, CUI) {

  'use strict';
  CUI.rte.UIUtils = (function () {

    return {

      addStyleSheet: function (cssToAdd, doc) {
        doc = doc || document;
        if (!CUI.rte.Utils.isArray(cssToAdd)) {
          cssToAdd = [cssToAdd];
        }
        var headEl = doc.getElementsByTagName('head')[0];
        var styleSheet = doc.createElement('style');
        styleSheet.type = 'text/css';
        headEl.appendChild(styleSheet);
        var cssText = '';
        var cssCnt = cssToAdd.length;
        for (var c = 0; c < cssCnt; c++) {
          var css = cssToAdd[c];
          cssText += css['.name'] + ' {\n';
          for (var key in css) {
            if (css.hasOwnProperty(key) && (key !== '.name')) {
              cssText += '    ' + key + ': ' + css[key] + ';\n';
            }
          }
          cssText += '}\n\n';
        }
        styleSheet.innerHTML = cssText;
        return styleSheet;
      },

      removeStyleSheet: function (styleSheet) {
        styleSheet.parentNode.removeChild(styleSheet);
      },

      getUIContainer: function ($editable) {
        var $ui = $editable.data('rte-ui');
        if ($ui) {
          return $ui;
        }
        var editableDom = $editable[0].previousSibling;
        while (editableDom && (editableDom.nodeType !== 1)) {
          editableDom = editableDom.previousSibling;
        }
        if (!editableDom || !CUI.rte.Common.hasCSS(editableDom, 'rte-ui')) {
          return null;
        }
        return $(editableDom);
      },

      createOrGetUIContainer: function ($editable) {
        var $container = CUI.rte.UIUtils.getUIContainer($editable);
        if (!$container) {
          $container = $('<div class=\'rte-ui\'></div>');
          $editable.before($container);
        }
        return $container;
      },

      getToolbar: function ($editableOrContainer, tbType) {
        tbType = tbType || 'inline';
        var $container = $editableOrContainer.hasClass('rte-ui') ?
          $editableOrContainer :
          CUI.rte.UIUtils.getUIContainer($editableOrContainer);
        if (!$container || !$container.length) {
          return null;
        }
        var $toolbar = $container.find(
          'div[data-type=\'' + tbType + '\'] > coral-buttongroup.rte-toolbar');
        if (!$toolbar || !$toolbar.length) {
          return null;
        }
        return $toolbar;
      },

      getToolbarContainer: function ($container, tbType) {
        tbType = tbType || 'inline';
        var $tbCont = $container.find('div[data-type=\'' + tbType + '\']');
        if (!$tbCont || !$tbCont.length) {
          return null;
        }
        return $tbCont;
      },

      getPopover: function (ref, tbType, $container) {
        tbType = tbType || 'inline';
        return $container.find('div[data-type=\'' + tbType + '\'] > ' +
          'coral-popover[data-id=\'' + ref + '\']');
      },

      getPopoverTrigger: function (ref, tbType, $containerOrToolbar) {
        tbType = tbType || 'inline';
        var $toolbar = ($containerOrToolbar.hasClass('rte-toolbar') ?
          $containerOrToolbar :
          CUI.rte.UIUtils.getToolbar($containerOrToolbar, tbType));
        return $toolbar.find('button[data-action=\'' + ref + '\']');
      },

      getElement: function (ref, tbType, $container) {
        tbType = tbType || 'inline';
        return $container.find('div[data-type=\'' + tbType + '\'] ' +
          'button[data-action=\'' + ref + '\']');
      },

      getDialog: function (ref, tbType, $container) {
        tbType = tbType || 'inline';
        var $dialog = $container.find('div[data-type=\'' + tbType + '\'] > ' +
          'coral-popover[data-rte-dialog=\'' + ref + '\']');
        if (($dialog.length === 0) && (tbType !== 'global')) {
          $dialog = $container.find('div[data-type=\'global\'] > ' +
            'coral-popover[data-rte-dialog=\'' + ref + '\']');
        }
        return $dialog;
      },

      /**
       * Returns the specified UI "space". Creates it, if it is not yet available.
       * @param {String} mode The mode the UI space is used for
       * @param $container The UI container
       * @return {jQuery} The UI space
       */
      getSpace: function (mode, $container) {
        var $uiSpace = $container.find('> div[data-type=\'' + mode + '\']');
        if (!$uiSpace.length) {
          $uiSpace = $(Coral.templates.RichTextEditor['ui_space']({
            'mode': mode
          }));
          $container.append($uiSpace);
        }
        return $uiSpace;
      },

      killEvent: function (e) {
        e.stopPropagation();
        e.preventDefault();
      },

      /**
       * <p>Determines the "clipping parent" of the specified DOM object.</p>
       * <p>The clipping parent is a DOM object that might clip the visible area of
       * the specified DOM object by specifiying a suitable "overflow" attribute.</p>
       * @param {jQuery} $dom The jQuery-wrapped DOM object
       * @return {jQuery} The clipping parent as a jQuery object; undefined if no
       *         clipping parent exists
       */
      getClippingParent: function ($dom) {
        var $clipParent;
        var $body = $(document.body);
        while ($dom[0] !== $body[0]) {
          var ovf = $dom.css('overflow');
          var ovfX = $dom.css('overflowX');
          var ovfY = $dom.css('overflowY');
          if ((ovfX !== 'visible') || (ovfY !== 'visible') || (ovf !== 'visible')) {
            $clipParent = $dom;
            break;
          }
          $dom = $dom.parent();
        }
        return $clipParent;
      },

      getEditorOffsets: function (context) {
        var top = 0;
        var left = 0;
        var editorDoc = context.doc;
        while (editorDoc !== document) {
          var win = CUI.rte.Common.getWindowForDocument(editorDoc);
          if (win.frameElement) {
            var offsets = $(win.frameElement).offset();
            top += offsets.top;
            left += offsets.left;
          } else {
            break;
          }
          editorDoc = win.frameElement.ownerDocument;
        }
        return {
          'top': top,
          'left': left
        };
      },

      isUnder: function ($parent, $obj) {
        if (!$parent || ($parent.length === 0)) {
          return false;
        }
        if (!$obj || ($obj.length === 0)) {
          return false;
        }
        var obj = $parent[0];
        var toTest = $obj[0];
        while (toTest.tagName !== 'BODY') {
          if (toTest === obj) {
            return true;
          }
          toTest = toTest.parentNode;
        }
        return false;
      }

    };

  }());

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, CUI) {

  'use strict';
  CUI.rte.ConfigUtils = (function () {

    function getPluginDef(action) {
      if (action) {
        var sepPos = action.indexOf('#');
        if (sepPos > 0) {
          var plugin = action.substring(0, sepPos);
          var feature = action.substring(sepPos + 1);
          return {
            'plugin': plugin,
            'feature': feature
          };
        }
      }
      return null;
    }

    return {

      createFeaturesFromToolbar: function ($container, $toolbar) {
        var featureDefs = [];
        // first, analyze the toolbar
        var $buttons = $toolbar.find('button.rte-toolbar-item');
        $buttons.each(function () {
          var pluginDef = getPluginDef($(this).data('action'));
          if (pluginDef) {
            featureDefs.push(pluginDef);
          }
        });
        // then, analyze popovers
        var $popovers = $container.find(
          'coral-popover button.rte-toolbar-item');
        $popovers.each(function () {
          var pluginDef = getPluginDef($(this).data('action'));
          if (pluginDef) {
            featureDefs.push(pluginDef);
          }
        });
        return featureDefs;
      },

      getValidConfig: function (config) {
        var pluginConfigs;
        if (!config.hasOwnProperty('rtePlugins')) {
          return config;
        }
        /*
        * Parses a comma separated list if values into an actual array
        *
        * @param value
        * @returns {*}
        */
        function parseConfigValue(value) {
            if (value.indexOf(',') > -1) {
                value = value.split(',');
            }

            if (!$.isArray(value)) {
                value = [value];
            }

            return value;
        }

        pluginConfigs = config['rtePlugins'];
        for (var pluginConfig in pluginConfigs) {
          if (pluginConfigs.hasOwnProperty(pluginConfig)) {
            if (pluginConfigs[pluginConfig].features) {
              var features = pluginConfigs[pluginConfig].features;
              if (!(features instanceof Array) && features !== '*') {
                pluginConfigs[pluginConfig].features = parseConfigValue(features);
              }
            }
          }
        }

        function validatePopovers(popovers) {
          for (var popover in popovers) {
            if (popovers.hasOwnProperty(popover) && popovers[popover].items) {
              popovers[popover].items = popovers[popover].items instanceof Array ||
              popovers[popover].items.indexOf(':') > 0 ?
                popovers[popover].items : [popovers[popover].items];
            }
          }
        }

        var uiSettings = config['uiSettings'];
        if (uiSettings && uiSettings.cui) {
          if (uiSettings.cui.inline && uiSettings.cui.inline.popovers) {
            validatePopovers(uiSettings.cui.inline.popovers);
          }
          if (uiSettings.cui.fullscreen && uiSettings.cui.fullscreen.popovers) {
            validatePopovers(uiSettings.cui.fullscreen.popovers);
          }
        }
        return config;
      },

      mergeConfigAndFeatures: function (config, features) {
        if (!features || (features.length === 0)) {
          return config;
        }
        var pluginConfig;
        if (config.hasOwnProperty('rtePlugins')) {
          pluginConfig = config['rtePlugins'];
        } else {
          pluginConfig = {};
          config['rtePlugins'] = pluginConfig;
        }
        var featureCnt = features.length;
        for (var f = 0; f < featureCnt; f++) {
          var feature = features[f];
          var pluginId = feature.plugin;
          var featureId = feature.feature;
          var cfg, plgFeature;
          if (!pluginConfig.hasOwnProperty(pluginId)) {
            cfg = {};
            pluginConfig[pluginId] = cfg;
          } else {
            cfg = pluginConfig[pluginId];
          }
          if (cfg.hasOwnProperty('features')) {
            plgFeature = cfg['features'];
            if (CUI.rte.Utils.isArray(plgFeature)) {
              plgFeature.push(featureId);
            } else {
              if (plgFeature !== '*') {
                plgFeature = [featureId];
                cfg['features'] = plgFeature;
              }
            }
          } else {
            plgFeature = [featureId];
            cfg['features'] = plgFeature;
          }
        }
        return config;
      },

      loadConfigAndStartEditing: function (rte, $editable, configCallback) {

        $editable.addClass('is-initializing');

        var features;
        var $container = CUI.rte.UIUtils.getUIContainer($editable);
        var $toolbar = CUI.rte.UIUtils.getToolbar($editable);

        function processConfig(config, useFixedInlineToolbar) {
          config = CUI.rte.ConfigUtils.getValidConfig(config);
          if (configCallback) {
            config = configCallback(config);
          }
          config = CUI.rte.ConfigUtils.mergeConfigAndFeatures(config, features);
          rte.start(config, useFixedInlineToolbar);
          $editable.removeClass('is-initializing');
        }

        if ($toolbar && ($toolbar.length > 0)) {
          features = CUI.rte.ConfigUtils.createFeaturesFromToolbar($container,
            $toolbar);
        }
        var config = {};
        var configObj = $editable.data('config');
        if (configObj) {
          if (typeof configObj === 'string') {
            try {
              config = $.parseJSON(configObj);
            } catch (e) {
              // use default config
            }
          } else {
            config = configObj;
          }
          processConfig(config);
        } else {
          var configPath = $editable.data('config-path');
          var useFixedInlineToolbar = $editable.data('use-fixed-inline-toolbar');
          if (configPath) {
            $.ajax({
              'url': configPath,
              'dataType': 'json',
              'success': function (data) {
                processConfig(data, useFixedInlineToolbar);
              },
              'error': function () {
                processConfig({}, useFixedInlineToolbar);
              }
            });
          } else {
            processConfig(config, useFixedInlineToolbar);
          }
        }
        $editable.data('rteinstance', rte);
      }

    };

  }());

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.CUIDomCleanup
 * @extends CUI.rte.DomCleanup
 * @private
 * This class extends CUI.rte.DomCleanup to add CUI specific functionality.
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.CUIDomCleanup = new Class({

    toString: 'CUIDomCleanup',

    extend: CUI.rte.DomCleanup,

    handleCellSpacingAttribute: function (dom) {
      var com = CUI.rte.Common;
      var dcu = CUI.rte.DomCleanup;
      var fullScreenAdapter = this.editorKernel.getEditContext().getState('fullscreenadapter');
      if (fullScreenAdapter && fullScreenAdapter.isFullScreen() && com.isTag(dom, 'table')) {
        if (this.processingMode === dcu.PRE) {
          var cellSpacing = com.getAttribute(dom, 'cellspacing');
          if (cellSpacing) {
            com.addInlineStyles(dom, {'border-collapse': 'separate', 'border-spacing': cellSpacing + 'px'});
          } else {
            com.addInlineStyles(dom, {'border-collapse': 'initial', 'border-spacing': 'initial'});
          }
        } else {
          com.removeInlineStyles(dom, ['border-collapse', 'border-spacing']);
        }
      }
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.FullScreen
 * @extends CUI.rte.commands.Command
 * @private
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.commands.FullScreen = new Class({

    toString: 'FullScreen',

    extend: CUI.rte.commands.Command,

    adapter: undefined,

    isCommand: function (cmdStr) {
      var cmdLC = cmdStr.toLowerCase();
      return (cmdLC === 'fullscreen-toggle') || (cmdLC === 'fullscreen-start') ||
        (cmdLC === 'fullscreen-finish') || (cmdLC === 'setfullscreenadapter');
    },

    isUndoable: function (cmdStr) {
      return false;
    },

    getProcessingOptions: function () {
      var cmd = CUI.rte.commands.Command;
      return cmd.PO_SELECTION;
    },

    execute: function (execDef) {
      var updateToolbar = false;
      var oppositeKernel;
      switch (execDef.command.toLowerCase()) {
      case 'setfullscreenadapter':
        this.adapter = execDef.value;
        execDef.editContext.setState('fullscreenadapter', execDef.value);
        break;
      case 'fullscreen-toggle':
        if (this.adapter) {
          var fullScreenMode = this.adapter.isFullScreen();
          if (fullScreenMode) {
            oppositeKernel = this.adapter.finish();
          } else {
            oppositeKernel = this.adapter.start(execDef.value);
          }
          updateToolbar = true;
        }
        break;
      case 'fullscreen-start':
        if (this.adapter) {
          oppositeKernel = this.adapter.start(execDef.value);
          updateToolbar = true;
        }
        break;
      case 'fullscreen-finish':
        if (this.adapter) {
          oppositeKernel = this.adapter.finish();
          updateToolbar = true;
        }
        break;
      }
      if (updateToolbar && oppositeKernel) {
        CUI.rte.Utils.defer(oppositeKernel.updateToolbar, 1, oppositeKernel);
      }
      return {
        preventBookmarkRestore: true
      };
    },

    queryState: function (selectionDef, cmd) {
      if (this.adapter) {
        return this.adapter.isFullScreen();
      }
      return false;
    }

  });


// register command
  CUI.rte.commands.CommandRegistry.register('fullscreen', CUI.rte.commands.FullScreen);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.FullScreenAdapter
 * Adapter interface for activating/deactivating full screen mode.
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.commands.FullScreenAdapter = new Class({

    start: function () {
      // must be implemented
    },

    finish: function () {
      // must be implemented
    },

    isFullScreen: function () {
      // must be implemented
    },

    toggleSourceEdit: function (sourceEditMode) {
      // must be implemented
    }

  });
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.commands.CUITable
 * @extends CUI.rte.commands.Table
 * @private
 * <p>This class provided the CUI specific functionality for creating and editing a table.</p>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.commands.CUITable = new Class({

    toString: 'CUITable',

    extend: CUI.rte.commands.Table,

    /**
     * Handle cellspacing in fullscreen mode. Coral UI currently uses global style definition for table element, and
     * adds some css for border-collapse and border-spacing which results in cellspacing attribute being ignored.
     * Hence, we need to border-collapse and border-spacing as inline styles to table element to achieve the desired
     * effect of cellspacing. In non-FSM, we expect the border-* styles to take precedence over the cellspacing/-padding
     * attributes, as they will as well after leaving edit mode.
     * @private
     */
    handleCellspacing: function (dom, execDef) {
      var com = CUI.rte.Common;
      var config = execDef.value;
      var fullscreenadapter = execDef.editContext.getState('fullscreenadapter');
      if (!fullscreenadapter || !fullscreenadapter.isFullScreen()) {
        return;
      }
      if (config.cellspacing) {
        com.addInlineStyles(dom, {'border-collapse': 'separate', 'border-spacing': config.cellspacing + 'px'});
      } else {
        com.addInlineStyles(dom, {'border-collapse': 'initial', 'border-spacing': 'initial'});
      }
    },

    getExecDefValue: function (execDef) {
      var isTableMode = execDef.value.isTableMode;
      var com = CUI.rte.Common;
      var nodeList = execDef.nodeList;
      var selection = execDef.selection;
      var singleCell = CUI.rte.commands.Table.getCellFromNodeList(execDef.editContext, nodeList);
      var isSingleCell = (singleCell !== null && singleCell !== undefined);
      var tableDom = com.getTagInPath(execDef.editContext, nodeList.commonAncestor, 'table');
      var isTable = isSingleCell || (tableDom !== null && tableDom !== undefined);
      var cellSel = null;
      var tableMatrix;
      var canRemoveCol = true;
      var canRemoveRow = true;
      if (isTable) {
        tableMatrix = new CUI.rte.TableMatrix();
        tableMatrix.createTableMatrix(tableDom);
        if (isTableMode) {
          var size = tableMatrix.getTableSize();
          canRemoveCol = (size.cols > 1);
          canRemoveRow = (size.rows > 1);
        }
      }
      if (isTable && !isSingleCell) {
        if (selection.cellSelection) {
          cellSel = tableMatrix.createSelection(selection.cellSelection.cells);
        }
      }
      if (!cellSel && isSingleCell) {
        var cellInfo = tableMatrix.getCellInfo(singleCell);
        if (!cellInfo.isLastCol && execDef.value.direction === 'right') {
          cellSel = tableMatrix.createSelection(singleCell);
          cellSel.expand(1, 0);
        }
        if (!cellInfo.isLastRow && execDef.value.direction === 'down') {
          cellSel = tableMatrix.createSelection(singleCell);
          cellSel.expand(0, 1);
        }
      }
      return cellSel;
    }

  });

// register command
  CUI.rte.commands.CommandRegistry.register('_table', CUI.rte.commands.CUITable);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.AbstractSpellCheckerPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements the spellchecker functionality as a plugin.</p>
 * <p>The plugin ID is "<b>spellcheck</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>checktext</b> - adds a button to spellcheck the entire text</li>
 * </ul>
 * @since 5.3
 */
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {
  //'use strict';
  CUI.rte.plugins.AbstractSpellCheckerPlugin = new Class({

    toString: 'AbstractSpellCheckerPlugin',

    extend: CUI.rte.plugins.Plugin,

    /**
     * @private
     */
    checkTextUI: null,

    isInspectionOn: false,

    spellcheckerDialog: null,

    /**
     * @private
     */
    misSpelledWords: null,

    doCheckText: function (html, contentPath, successFn, failureFn) {
      //must be implemented by child class to do the spellchecking
    },

    /**
     * @cfg {String} invalidStyle
     * Style definition that is used to mark wrongly spelled words; defaults to
     * "background-color: #ffffaa;"
     */

    /**
     * @cfg {String} invalidClass
     * CSS class that is used to mark wrongly spelled words; defaults to null
     */

    /**
     * @private
     */
    checkText: function (context) {
      this.clearInvalidationMarks(context);
      this.doCheckText(this.editorKernel.getProcessedHtml(), this.editorKernel.getContentPath(),
        CUI.rte.Utils.scope(this.checkSuccess, this), CUI.rte.Utils.scope(this.checkFailure, this));
    },

    checkSuccess: function (spellcheckResults) {
      var hasErrors = false;
      var words = spellcheckResults.words;
      var wordCnt = words.length;
      this.misSpelledWords = [];
      for (var w = 0; w < wordCnt; w++) {
        var word = words[w];
        var result = word.result;
        if (!result.isCorrect) {
          var startPos = word.start;
          var charCnt = word.chars;
          var suggestions = result.suggestions;
          this.misSpelledWords.push({
            'word': word,
            'span': this.markInvalidWord(this.editorKernel.getEditContext(), startPos, charCnt, suggestions)[0]
          });
          hasErrors = true;
        }
      }
      if (!hasErrors) {
        this.editorKernel.getDialogManager().alert(
          CUI.rte.Utils.i18n('plugins.spellCheck.spellChecking'),
          CUI.rte.Utils.i18n('plugins.spellCheck.noMistakeAlert'));
        return;
      }
      this.isInspectionOn = true;
      this.checkTextUI.setHighlighted(true);
    },

    checkFailure: function () {
      this.checkTextUI.setSelected(false);
      this.editorKernel.getDialogManager().alert(
        CUI.rte.Utils.i18n('plugins.spellCheck.spellChecking'),
        CUI.rte.Utils.i18n('plugins.spellCheck.failAlert'));
    },

    markInvalidWord: function (context, startPos, charCnt, suggestions) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var startDef = com.getNodeAtPosition(context, startPos, true);
      var endDef = com.getNodeAtPosition(context, startPos + charCnt, true);
      // handle EOP situations correctly
      var endNode = endDef.dom;
      var endOffset = endDef.offset;
      if ((endNode.nodeType === 1) && (endDef.offset === null || endDef.offset === undefined)) {
        var baseEndNode = endNode;
        endNode = com.getLastTextChild(baseEndNode);
        if (!endNode) {
          endNode = com.getPreviousTextNode(context, baseEndNode);
        }
        endOffset = com.getNodeCharacterCnt(endNode);
      }
      var nodeList = dpr.createNodeList(context, {
        'startNode': startDef.dom,
        'startOffset': startDef.offset,
        'endNode': endNode,
        'endOffset': endOffset
      });
      var suggAttrib = null;
      if (suggestions !== null && suggestions !== undefined) {
        var suggCnt = suggestions.length;
        for (var s = 0; s < suggCnt; s++) {
          var suggestion = suggestions[s];
          if (s === 0) {
            suggAttrib = suggestion;
          } else {
            suggAttrib += '|' + suggestion;
          }
        }
      }
      var attribs = {
        '_rtetemp': 'spchk'
      };
      if (this.config.invalidStyle) {
        attribs['style'] = this.config.invalidStyle;
      }
      if (this.config.invalidClass) {
        attribs['className'] = this.config.invalidClass;
      }
      if (suggAttrib !== null && suggAttrib !== undefined) {
        attribs['_rtespchksugg'] = suggAttrib;
      }
      return nodeList.surround(context, 'span', attribs);
    },

    clearInvalidationMarks: function (context) {
      var dpr = CUI.rte.DomProcessor;
      dpr.removeTagsFromHierarchy(context.root, {
        'tagName': 'span',
        'attribValues': {'_rtetemp': 'spchk'}
      });
      this.isInspectionOn = false;
      this.checkTextUI.setHighlighted(false);
    },

    _init: function (editorKernel) {
      this.inherited(arguments);
      //this key up handler will be called only when the dialog is closed because editor kernel is locked when
      //dialog is open. So we will have to attach a handler later when the dialog is shown and remove it when
      //dialog is hidden.
      editorKernel.addPluginListener('keyup', this.handleOnKey, this, this, false);
      editorKernel.addPluginListener('sourceedit', this.handleSourceEdit, this, this,
        false);
    },

    handleOnKey: function (e) {
      if (!this.isAnyFeatureEnabled()) {
        return;
      }

      //if it is not a caret key or caret movement (page up, down, end, home),
      //clear the invalid checks and close dialog
      if (e.charCode < 33 || e.charCode > 40) {
        var dm = this.editorKernel.getDialogManager();
        var context = this.editorKernel.getEditContext();
        this.clearInvalidationMarks(context);
        this.checkTextUI.setSelected(false);
        // hide if dialog is already shown
        if (dm.isShown(this.spellcheckerDialog)) {
          dm.hide(this.spellcheckerDialog);
        }
      }
    },

    handleSourceEdit: function (e) {
      // deselect spellcheck button if sourceedit mode has been enabled, as results will
      // get invalid and highlights be removed anyway
      if (e.enabled && this.checkTextUI) {
        this.checkTextUI.setSelected(false, true);
      }
    },

    getFeatures: function () {
      return ['checktext'];
    },

    initializeUI: function (tbGenerator) {
      var plg = CUI.rte.plugins;
      if (this.isFeatureEnabled('checktext')) {
        this.checkTextUI = tbGenerator.createElement('checktext', this, true,
          this.getTooltip('checktext'));
        tbGenerator.addElement('spellcheck', plg.Plugin.SORT_LISTS, this.checkTextUI,
          10);
      }
    },

    getMisSpelledWord: function (selectionBookmark) {
      if (!selectionBookmark || !this.misSpelledWords) {
        return;
      }
      for (var w = 0; w < this.misSpelledWords.length; w++) {
        if (this.misSpelledWords[w] === null || this.misSpelledWords[w] === undefined) {
          continue;
        }
        var word = this.misSpelledWords[w].word;
        if (word.start <= selectionBookmark.startPos &&
          word.start + word.chars >= selectionBookmark.startPos + selectionBookmark.charCnt) {
          return {'index': w, 'word': this.misSpelledWords[w]};
        }
      }
    },

    handleSecondClick: function (context) {
      var dm = this.editorKernel.getDialogManager();
      // hide if dialog is already shown
      if (dm.isShown(this.spellcheckerDialog) && dm.toggleVisibility(this.spellcheckerDialog)) {
        dm.hide(this.spellcheckerDialog);
        return;
      }
      var sel = CUI.rte.Selection;
      var selectionBookmark = sel.createSelectionBookmark(context);
      var misSpelledWordObject = this.getMisSpelledWord(selectionBookmark);

      if (selectionBookmark && misSpelledWordObject) {
        var misSpelledIndex = misSpelledWordObject.index;
        var misSpelledWord = misSpelledWordObject.word;
        //limit the suggestions to 5
        var suggestions = [];
        suggestions = misSpelledWord.word.result.suggestions.slice(0, 5);
        var suggestionCount = suggestions.length;
        //trim the length of a suggestion to 25. send the original word as well as trimmed word. The trimmed version
        //would be displayed in suggestion popover and original would be used to replace the content.
        for (var s = 0; s < suggestionCount; s++) {
          var suggestion = suggestions[s];
          var suggestionsObject = {
            'display': suggestion.length > 25 ?
              suggestion.substring(0, 22) + '...' : suggestion,
            'original': suggestion
          };
          suggestions.push(suggestionsObject);
        }
        if (!suggestionCount) {
          suggestions = [{'display': CUI.rte.Utils.i18n('plugins.spellCheck.noSuggestions')}];
        }
        var dialogConfig = {'suggestions': suggestions.slice(suggestionCount)};
        dialogConfig.parameters = {
          'command': this.pluginId + '#checktext'
        };
        this.spellcheckerDialog = dm.create(CUI.rte.ui.DialogManager.DLG_SPELLCHECKER, dialogConfig);
        var self = this;
        this.spellcheckerDialog.$dialog.on('click.rte-dialog', 'button[data-type=\'replaceWord\']',
          function (e) {
            var replacement = $(e.currentTarget).data('value');
            var span = misSpelledWord.span;
            span.innerHTML = replacement;
            CUI.rte.DomProcessor.removeWithoutChildren(span);
            self.misSpelledWords[misSpelledIndex] = null;
            dm.hide(self.spellcheckerDialog);
            e.preventDefault();
            e.stopPropagation();
          }
        );
        this.spellcheckerDialog.onShow = function () {
          $(self.editorKernel.getEditContext().root).on('keyup.rte-spellcheckerDialogOpen',
            CUI.rte.Utils.scope(self.handleOnKey, self));
        };
        this.spellcheckerDialog.onHide = function () {
          $(self.editorKernel.getEditContext().root).off('keyup.rte-spellcheckerDialogOpen');
        };
        this.spellcheckerDialog.show();
      } else {
        this.clearInvalidationMarks(context);
      }
    },

    execute: function (id, value, env) {
      switch (id) {
      case 'checktext':
        if (!this.isInspectionOn) {
          this.checkText(env.editContext);
        } else {
          this.handleSecondClick(env.editContext);
        }
        break;
      }
    },

    updateState: function (selDef) {
      // nothing to do here
    }

  });
}(window.jQuery, window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.ControlPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements some control functionality as a plugin.</p>
 * <p>The plugin ID is "<b>control</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>close</b> - adds a button that dispatches a "close" request</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.ControlPlugin = new Class({

    toString: 'ControlPlugin',

    extend: CUI.rte.plugins.Plugin,


    getFeatures: function () {
      return ['close', 'save'];
    },

    initializeUI: function (tbGenerator) {
      var plg = CUI.rte.plugins;
      if (this.isFeatureEnabled('close')) {
        this.closeUI = tbGenerator.createElement('close', this, false,
          this.getTooltip('close'));
        tbGenerator.addElement('control', plg.Plugin.SORT_MAX - 1, this.closeUI, 10000);
      }
      if (this.isFeatureEnabled('save')) {
        this.saveUI = tbGenerator.createElement('save', this, false,
          this.getTooltip('save'));
        tbGenerator.addElement('control', plg.Plugin.SORT_MAX - 1, this.saveUI, 20000);
      }
    },

    notifyPluginConfig: function (pluginConfig) {
      pluginConfig = pluginConfig || {};
      CUI.rte.Utils.applyDefaults(pluginConfig, {
        'features': '*',
        'tooltips': {
          'close': {
            'title': CUI.rte.Utils.i18n('plugins.control.closeTitle'),
            'text': CUI.rte.Utils.i18n('plugins.control.closeText')
          },
          'save': {
            'title': CUI.rte.Utils.i18n('plugins.control.saveTitle')
          }
        }
      });
      this.config = pluginConfig;
    },

    execute: function (cmd, value, env) {
      if (cmd === 'close') {
        this.editorKernel.fireUIEvent('requestClose');
      }
      if (cmd === 'save') {
        this.editorKernel.fireUIEvent('requestSave');
      }
    },

    updateState: function (selDef) {
      // nothing to do
    }

  });


// register plugin
  CUI.rte.plugins.PluginRegistry.register('control', CUI.rte.plugins.ControlPlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.FullScreenPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements full screen functionality as a plugin.</p>
 * <p>The plugin ID is "<b>fullscreen</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>toggle</b> - adds a button that toggles fullscreen mode</li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.FullScreenPlugin = new Class({

    toString: 'FullScreenPlugin',

    extend: CUI.rte.plugins.Plugin,

    toggleUI: null,

    startUI: null,

    finishUI: null,


    // Plugin implementation ---------------------------------------------------------------

    getFeatures: function () {
      return ['toggle', 'start', 'finish'];
    },

    _init: function (editorKernel) {
      this.inherited(arguments);
    },

    initializeUI: function (tbGenerator) {
      var plg = CUI.rte.plugins;
      if (this.isFeatureEnabled('toggle')) {
        this.toggleUI = tbGenerator.createElement('toggle', this, false,
          this.getTooltip('toggle'));
        tbGenerator.addElement('control', plg.Plugin.SORT_MAX - 1, this.toggleUI,
          12);
      }
      if (this.isFeatureEnabled('start')) {
        this.startUI = tbGenerator.createElement('start', this, false,
          this.getTooltip('start'));
        tbGenerator.addElement('control', plg.Plugin.SORT_MAX - 1, this.startUI,
          10);
      }
      if (this.isFeatureEnabled('finish')) {
        this.finishUI = tbGenerator.createElement('finish', this, false,
          this.getTooltip('finish'));
        tbGenerator.addElement('control', plg.Plugin.SORT_MAX - 1, this.finishUI,
          11);
      }
    },

    notifyPluginConfig: function (pluginConfig) {
      pluginConfig = pluginConfig || {};
      CUI.rte.Utils.applyDefaults(pluginConfig, {
        'features': '*',
        'tooltips': {
          'toggle': {
            'title': CUI.rte.Utils.i18n('plugins.fullscreen.toggleTitle'),
            'text': CUI.rte.Utils.i18n('plugins.fullscreen.toggleText')
          },
          'start': {
            'title': CUI.rte.Utils.i18n('plugins.fullscreen.startTitle'),
            'text': CUI.rte.Utils.i18n('plugins.fullscreen.startText')
          },
          'finish': {
            'title': CUI.rte.Utils.i18n('plugins.fullscreen.finishTitle'),
            'text': CUI.rte.Utils.i18n('plugins.fullscreen.finishText')
          }
        }
      });
      this.config = pluginConfig;
    },

    execute: function (cmd) {
      var externalStyleSheetObj = this.config.externalStyleSheets ?
      {'externalStyleSheets': this.config.externalStyleSheets} : undefined;
      this.editorKernel.execCmd('fullscreen-' + cmd, externalStyleSheetObj);
      // prevent transferring the focus to the original editor automatically - the
      // full screen editor should have it already
      return {
        'preventTouchFocus': true
      };
    },

    updateState: function (selDef) {
      // nothing to do
    }

  });


// register plugin
  CUI.rte.plugins.PluginRegistry.register('fullscreen', CUI.rte.plugins.FullScreenPlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.ImagePlugin
 * @extends CUI.rte.plugins.AbstractImagePlugin
 * <p>This class implements the editing of image properties as a plugin.</p>
 * <p>The plugin ID is '<b>image</b>'.</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>image</b> - adds context menu entries for setting some image properties
 *     (currently only alignment is supported)</li>
 * </ul>
 * @since 5.3
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.ImagePlugin = new Class({

    toString: 'ImagePlugin',

    /**
     * private
     **/
    imageDialog: null,

    selectedImageNode: null,

    isButtonDisabled: true,

    extend: CUI.rte.plugins.AbstractImagePlugin,

    /**
     * Creates the Image Button visible in the toolbar.
     * @param tbGenerator
     */
    initializeUI: function (tbGenerator) {
      var plg = CUI.rte.plugins;
      if (this.isAnyFeatureEnabled()) {
        this.imageUI = tbGenerator.createElement('imageProps', this, false, this.getTooltip('image'));
        tbGenerator.addElement('image', plg.Plugin.SORT_IMAGE, this.imageUI, 10);
      }
    },

    // overrides CUI.rte.plugins.AbstractImagePlugin#notifyPluginConfig
    notifyPluginConfig: function(pluginConfig) {
      CUI.rte.Utils.scope(this.superClass.notifyPluginConfig, this)(pluginConfig);
      CUI.rte.Utils.applyDefaults(pluginConfig, {
        'tooltips': {
          'image': {
            'title': CUI.rte.Utils.i18n('plugins.image.imageTitle')
          }
        }
      });
    },

    execute: function (pluginCommand, value, envOptions) {
      // todo implement
      if (pluginCommand === 'imageProps') {

        var context = envOptions.editContext;
        var dpr = CUI.rte.DomProcessor;
        //Necessarily calling a private function
        var selection = this.editorKernel.createQualifiedSelection(context);
        var nodelist = dpr.createNodeList(context, selection);
        var selectionDef = {
          'selection': selection,
          'nodelist': nodelist
        };
        var image = CUI.rte.commands.Image.getSelectedImage(selectionDef);
        //Required for bookmark purposes.
        this.savedRange = this.editorKernel.createQualifiedRangeBookmark(context);

        var dm = this.editorKernel.getDialogManager();
        if (dm.isShown(this.imageDialog) && dm.toggleVisibility(this.imageDialog)) {
          dm.hide(this.imageDialog);
          return;
        }
        //Creates the image dialog for the first time
        if (!this.imageDialog || dm.mustRecreate(this.imageDialog)) {
          var propConfig = {
            'cmd': 'image',
            'image': image,
            'editContext': context,
            'execFn': CUI.rte.Utils.scope(this.execModifyImage, this),
            'parameters': {
              'command': this.pluginId + '#imageProps'
            }
          };
          this.imageDialog = dm.create(CUI.rte.ui.DialogManager.DLG_IMAGEPROPS, propConfig);
        }
        this.imageDialog.initializeEdit(this.editorKernel, this.selectedImageNode, CUI.rte.Utils.scope(this.execModifyImage, this));
        dm.prepareShow(this.imageDialog);
        dm.show(this.imageDialog);
      }
      //Executes the required command on the selected image object
      else if (pluginCommand === 'image') {
        this.editorKernel.relayCmd('image', value);
      }
    },

    updateState: function(selDef) {
      var selectedNode = selDef.selectedDom;
      var isImage = false;
      if (selectedNode) {
        // only non-placeholder images are editable
        isImage = CUI.rte.Common.isTag(selectedNode, 'img') &&
                !CUI.rte.genhtml.GenericHtmlRules.isPlaceholder(selectedNode);
        if (isImage) {
          if (this.imageUI) {
            this.imageUI.setDisabled(false);
          }
          this.selectedImageNode = selectedNode;
        } else {
          if (this.imageUI) {
            this.imageUI.setDisabled(true);
          }
        }
      } else {
        if (this.imageUI) {
          this.imageUI.setDisabled(true);
        }
      }
    },

    isHeadless: function (command, value) {
      return false;
    }
  });

// register plugin
  CUI.rte.plugins.PluginRegistry.register('image', CUI.rte.plugins.ImagePlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.plugins.StylesPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements styling text fragments with a CSS class (using "span" tags) as a
 * plugin.</p>
 * <p>The plugin ID is "<b>styles</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>styles</b> - adds a style selector (styles will be applied on selection scope)
 *     </li>
 * </ul>
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.StylesPlugin = new Class({

    toString: 'StylePlugin',

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {Object/Object[]} styles
     * <p>Defines CSS classes that are available to the user for formatting text fragments
     * (defaults to { }). There are two ways of specifying the CSS classes:</p>
     * <ol>
     *   <li>Providing styles as an Object: Use the CSS class name as property name.
     *   Specify the text that should appear in the style selector as property value
     *   (String).</li>
     *   <li>Providing styles as an Object[]: Each element has to provide "cssName" (the
     *   CSS class name) and "text" (the text that appears in the style selector)
     *   properties.</li>
     * </ol>
     * <p>Styling is applied by adding "span" elements with corresponding "class"
     * attributes appropriately.</p>
     * @since 1.11
     */

    /**
     * @private
     */
    cachedStyles: null,

    /**
     * @private
     */
    stylesUI: null,


    getFeatures: function () {
      return ['styles'];
    },

    reportStyles: function () {
      return [{
        'type': 'text',
        'styles': this.getStyles()
      }
      ];
    },

    getStyles: function () {
      var com = CUI.rte.Common;
      if (!this.cachedStyles) {
        this.cachedStyles = this.config.styles;
        if (this.cachedStyles) {
          // take styles from config
          com.removeJcrData(this.cachedStyles);
          this.cachedStyles = com.toArray(this.cachedStyles, 'cssName', 'text');
        } else {
          this.cachedStyles = [];
        }
      }
      return this.cachedStyles;
    },

    setStyles: function (styles) {
      this.cachedStyles = styles;
    },

    hasStylesConfigured: function () {
      return !!this.config.styles;
    },

    initializeUI: function (tbGenerator, options) {
      var plg = CUI.rte.plugins;
      if (this.isFeatureEnabled('styles')) {
        this.stylesUI = new tbGenerator.createStyleSelector('styles', this, null,
          this.getStyles());
        tbGenerator.addElement('styles', plg.Plugin.SORT_STYLES, this.stylesUI, 10);
      }
    },

    notifyPluginConfig: function (pluginConfig) {
      pluginConfig = pluginConfig || {};
      CUI.rte.Utils.applyDefaults(pluginConfig, {});
      this.config = pluginConfig;
    },

    execute: function (cmdId, styleDef) {
      if (!this.stylesUI) {
        return;
      }
      var cmd = null;
      var tagName;
      var className;
      switch (cmdId.toLowerCase()) {
      case 'applystyle':
        cmd = 'style';
        tagName = 'span';
        className = ((styleDef !== null && styleDef !== undefined) ? styleDef
          : this.stylesUI.getSelectedStyle());
        break;
      }
      if (cmd && tagName && className) {
        this.editorKernel.relayCmd(cmd, {
          'tag': tagName,
          'attributes': {
            'class': className
          }
        });
      }
    },

    updateState: function (selDef) {
      if (!this.stylesUI) {
        return;
      }
      var com = CUI.rte.Common;
      var styles = selDef.startStyles;
      var actualStyles = [];
      var s;
      var styleableObject = selDef.selectedDom;
      if (styleableObject) {
        if (!CUI.rte.Common.isTag(selDef.selectedDom,
            CUI.rte.plugins.StylesPlugin.STYLEABLE_OBJECTS)) {
          styleableObject = null;
        }
      }
      var stylesDef = this.getStyles();
      var styleCnt = stylesDef.length;
      if (styleableObject) {
        for (s = 0; s < styleCnt; s++) {
          var styleName = stylesDef[s].cssName;
          if (com.hasCSS(styleableObject, styleName)) {
            actualStyles.push({
              'className': styleName
            });
          }
        }
      } else {
        var checkCnt = styles.length;
        for (var c = 0; c < checkCnt; c++) {
          var styleToProcess = styles[c];
          for (s = 0; s < styleCnt; s++) {
            if (stylesDef[s].cssName === styleToProcess.className) {
              actualStyles.push(styleToProcess);
              break;
            }
          }
        }
      }
      this.stylesUI.selectStyles(actualStyles, selDef);
    }

  });

  /**
   * Array with tag names that define objects (like images) that are styleable when selected
   * @private
   * @static
   * @final
   * @type String[]
   */
  CUI.rte.plugins.StylesPlugin.STYLEABLE_OBJECTS = [
    'img'
  ];


// register plugin
  CUI.rte.plugins.PluginRegistry.register('styles', CUI.rte.plugins.StylesPlugin);
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.plugins.TablePlugin = new Class({

    toString: 'TablePlugin',

    extend: CUI.rte.plugins.AbstractTablePlugin,

    mergeCellsRightUI: null,

    mergeCellsDownUI: null,

    mergeCellsUI: null,

    splitCellsHorizontalUI: null,

    splitCellsVerticalUI: null,

    modifyTableOrCellUI: null,

    tableAndCellPropsDialog: null,

    insertParaPosition: null,

    tableToolbarTbType: 'tableEditOptions',

    /**
     * In case of table mode, the table edit toolbar needs to be the default FSM toolbar. To do this we switch to
     * tableToolbar the first time updateState is called, so we need this to keep track if default switch to table
     * toolbar is done.
     * @private
     */
    defaultSwitchDone: false,

    isTableToolbarMode: function () {
      return true;
    },

    // overrides CUI.rte.plugins.AbstractTablePlugin#notifyPluginConfig
    notifyPluginConfig: function(pluginConfig) {
      CUI.rte.Utils.scope(this.superClass.notifyPluginConfig, this)(pluginConfig);
      if (this.isAnyFeatureEnabled() && this.config.features !== '*') {
        if (this.config.features.indexOf('createoredit') === -1) {
          this.config.features.push('createoredit');
        }
        if (this.config.features.indexOf('exitTableEditing') === -1) {
          this.config.features.push('exitTableEditing');
        }
      }
      CUI.rte.Utils.applyDefaults(pluginConfig, {
        'tooltips': {
          'mergecells-right': {
            'title': CUI.rte.Utils.i18n('plugins.table.mergeRight')
          },
          'mergecells-down': {
            'title': CUI.rte.Utils.i18n('plugins.table.mergeDown')
          },
          'mergecells': {
            'title': CUI.rte.Utils.i18n('plugins.table.mergeCells')
          },
          'splitcell-horizontal': {
            'title': CUI.rte.Utils.i18n('plugins.table.splitHor')
          },
          'splitcell-vertical': {
            'title': CUI.rte.Utils.i18n('plugins.table.splitVert')
          },
          'selectrow': {
            'title': CUI.rte.Utils.i18n('plugins.table.selectRow')
          },
          'selectcolumn': {
            'title': CUI.rte.Utils.i18n('plugins.table.selectColumn')
          },
          'ensureparagraph': {
            'title': CUI.rte.Utils.i18n('plugins.table.ensureparagraph')
          },
          'modifytableandcell': {
            'title': CUI.rte.Utils.i18n('plugins.table.modifytableandcell')
          },
          'removetable': {
            'title': CUI.rte.Utils.i18n('plugins.table.removeTable')
          },
          'exitTableEditing': {
            'title': CUI.rte.Utils.i18n('plugins.table.exitTableEditing')
          }
        }
      });
    },

    // overrides CUI.rte.plugins.Plugin#isFeatureEnabled
    isFeatureEnabled: function(feature) {
      if (feature === 'mergecells-right' || feature === 'mergecells-down' || feature === 'splitcell-horizontal' ||
        feature === 'splitcell-vertical' || feature === 'insertrow-before' || feature === 'insertrow-after' ||
        feature === 'insertcolumn-before' || feature === 'insertcolumn-after') {
        feature = feature.split('-')[0];
      } else if (feature === 'modifytableandcell') {
        return CUI.rte.Utils.scope(this.superClass.isFeatureEnabled, this)('table') ||
          CUI.rte.Utils.scope(this.superClass.isFeatureEnabled, this)('cellprops');
      }
      return CUI.rte.Utils.scope(this.superClass.isFeatureEnabled, this)(feature);
    },

    switchToTableToolbar: function () {
      if (!this.editorKernel.hasBackgroundToolbar(this.tableToolbarTbType)) {
        this.editorKernel.addBackgroundToolbar({
          'tbType': this.tableToolbarTbType,
          'isFullScreen': this.editorKernel.getEditContext().getState('fullscreenadapter').isFullScreen(),
          'isSticky': this.editorKernel.getToolbar().isSticky()
        });
      }
      this.editorKernel.setActiveToolbar(this.tableToolbarTbType);
    },

    // overrides CUI.rte.plugins.AbstractTablePlugin#showTablePropsUI
    showTablePropsUI: function (propConfig, context) {
      var dm = this.editorKernel.getDialogManager();
      if (propConfig.cmd === 'createtable') {
        if (!this.tablePropsDialog || dm.mustRecreate(this.tablePropsDialog)) {
          propConfig.editContext = context;
          propConfig.pluginConfig = this.config;
          propConfig.execFn = CUI.rte.Utils.scope(this.execCreateOrEditTable, this);
          this.tablePropsDialog = dm.create(CUI.rte.ui.DialogManager.DLG_TABLEPROPS, propConfig);
        }
        dm.show(this.tablePropsDialog);
      } else {
        this.switchToTableToolbar();
      }

    },


    showTableAndCellPropsUI: function (propConfig, context) {
      var dm = this.editorKernel.getDialogManager();
      if (!this.tableAndCellPropsDialog || dm.mustRecreate(this.tableAndCellPropsDialog)) {
        propConfig.editContext = context;
        propConfig.pluginConfig = this.config;
        propConfig.execFn = CUI.rte.Utils.scope(this.execEditTableAndCell, this);
        this.tableAndCellPropsDialog = dm.create(CUI.rte.ui.DialogManager.DLG_TABLEANDCELLPROPS, propConfig);
      }
      dm.show(this.tableAndCellPropsDialog);
    },

    execEditTableAndCell: function (cmd, tableAndCellConfig, context) {
      this.editorKernel.selectQualifiedRangeBookmark(context, this.savedRange);
      var tableConfig = {}, cellConfig = {};
      for (var key in tableAndCellConfig) {
        if (tableAndCellConfig.hasOwnProperty(key)) {
          if (key.indexOf('cell-') === 0) {
            cellConfig[key.split('cell-')[1]] = tableAndCellConfig[key];
          } else {
            tableConfig[key] = tableAndCellConfig[key];
          }
        }
      }
      var hiddenHeaderConfig = this.getHiddenHeaderConfig();
      if (hiddenHeaderConfig.hiddenHeaderEditingCSS) {
        cellConfig['hiddenHeaderEditingCSS'] = hiddenHeaderConfig.hiddenHeaderEditingCSS;
      } else {
        cellConfig['hiddenHeaderEditingStyle'] = hiddenHeaderConfig.hiddenHeaderEditingStyle;
      }
      cellConfig['handleHiddenHeader'] = 'true';
      if (cmd === 'modifytableandcell' && tableAndCellConfig) {
        this.editorKernel.relayCmd('modifytable', tableConfig);
        this.editorKernel.relayCmd('modifyCell', cellConfig);
      }
    },

    modifyTableAndCell: function (options) {
      var table = this.editorKernel.queryState('table');
      if (table) {
        var context = options.editContext;
        this.savedRange = options.savedRange;
        this.editorKernel.selectQualifiedRangeBookmark(context, this.savedRange);
        var propConfig = {
          'editContext': context,
          'cmd': 'modifytableandcell',
          'table': table,
          'parameters': {
            'command': this.pluginId + '#modifytableandcell'
          }
        };
        var dm = this.editorKernel.getDialogManager();
        if (dm.isShown(this.tableAndCellPropsDialog) && dm.toggleVisibility(this.tableAndCellPropsDialog)) {
          dm.hide(this.tableAndCellPropsDialog);
          return;
        }
        this.showTableAndCellPropsUI(propConfig, context);
      }

    },

    // overrides CUI.rte.plugins.AbstractTablePlugin#execute
    execute: function (cmdId, value, options) {
      var cmd = cmdId, isInsideTable;
      var tableInfo;
      var sepPos = cmdId.indexOf('.', cmdId);
      if (sepPos > 0) {
        cmd = cmdId.substring(0, sepPos);
        value = cmdId.substring(sepPos + 1, cmdId.length);
      }
      if (!value && (cmd === 'selectrow' || cmd === 'selectcolumn') && this.currentSelectionDef) {
        tableInfo = this.getTableInfo(this.currentSelectionDef, options.editContext);
        value = {
          'tableMatrix': tableInfo['tableMatrix'],
          'cell': tableInfo['singleCell']
        };
      }
      if (cmd === 'ensureparagraph') {
        tableInfo = this.getTableInfo(this.currentSelectionDef, options.editContext);
        if (this.insertParaPosition) {
          value = this.insertParaPosition;
        }
      }
      if (cmd === 'modifytableandcell') {
        var context = options.editContext;
        if (!options.savedRange) {
          options.savedRange = this.editorKernel.createQualifiedRangeBookmark(context);
        }
        this.modifyTableAndCell(options);
      } else if (cmd === 'exitTableEditing') {
        this.editorKernel.swapToolbar();
      } else if (cmd === 'createoredit') {
        isInsideTable = this.editorKernel.queryState('table');
        if (!isInsideTable && !this.isFeatureEnabled('table')) {
          return;
        }
        options.command = 'table#createoredit';
        CUI.rte.Utils.scope(this.superClass.execute, this)('table', value, options);
      } else {
        CUI.rte.Utils.scope(this.superClass.execute, this)(cmdId, value, options);
      }
    },

    // overrides CUI.rte.plugins.AbstractTablePlugin#updateState
    updateState: function (selDef) {
      CUI.rte.Utils.scope(this.superClass.updateState, this)(selDef);
      var com = CUI.rte.Common;
      var activeToolbar = this.editorKernel.getToolbar();
      if (this.isTableMode() && activeToolbar.tbType === 'fullscreen' && !this.defaultSwitchDone) {
        this.switchToTableToolbar();
        this.defaultSwitchDone = true;
      }
      if (!activeToolbar || activeToolbar.tbType !== this.tableToolbarTbType) {
        return;
      }
      var context = selDef.editContext;
      var tableInfo = this.getTableInfo(selDef, context);
      this.insertParaPosition = null;
      if (!tableInfo.isTable) {
        this.editorKernel.setActiveToolbar('fullscreen');
      } else {
        var tableMatrix = tableInfo['tableMatrix'];
        var isSingleCell = tableInfo['isSingleCell'];
        var selection = selDef.selection;
        var cellSel = null;
        if (!isSingleCell && selection.cellSelection) {
          cellSel = tableMatrix.createSelection(selection.cellSelection.cells);
        }
        if (isSingleCell) {
          //single cell is selected, enable all elements first and later disable them based on selection
          this.editorKernel.enableToolbar(this.tableToolbarTbType);
          var cellInfo = tableMatrix.getCellInfo(tableInfo['singleCell']);
          var pNode = tableInfo['tableDom'].parentNode;
          var tableIndex = com.getChildIndex(tableInfo['tableDom']);
          if (this.mergeCellsUI) {
            this.mergeCellsUI.setDisabled(true);
          }
          if (this.mergeCellsDownUI && cellInfo.isLastRow) {
            this.mergeCellsDownUI.setDisabled(true);
          }
          if (this.mergeCellsRightUI && cellInfo.isLastCol) {
            this.mergeCellsRightUI.setDisabled(true);
          }
          if (this.ensureParagraphUI) {
            if (com.isRootNode(context, pNode)) {
              this.insertParaPosition = cellInfo.isLastRow && ((tableIndex === (pNode.childNodes.length - 1)) ||
              com.isTag(pNode.childNodes[tableIndex + 1], 'table')) ? 'after' : null;
              if (!this.insertParaPosition) {
                this.insertParaPosition = cellInfo.isFirstRow && ((tableIndex === 0) ||
                com.isTag(pNode.childNodes[tableIndex - 1], 'table')) ? 'before' : null;
              }
              this.ensureParagraphUI.setDisabled(this.insertParaPosition ? false : true);
            } else {
              this.ensureParagraphUI.setDisabled(true);
            }
          }
          if (this.isTableMode()) {
            var size = tableMatrix.getTableSize();
            this.removeColUI.setDisabled(size.cols <= 1);
            this.removeRowUI.setDisabled(size.rows <= 1);
          }
        } else {
          this.editorKernel.disableToolbar(this.tableToolbarTbType);
          if (cellSel && cellSel.selectionProps.isRect) {
            var selProps = cellSel.selectionProps;
            // prevent merging of cells if they are spread across thead/tbody/tfoot
            var spansMultipleSections = selProps.spansThead && (selProps.spansTbody || selProps.spansTfoot) ||
              selProps.spansTbody && (selProps.spansThead || selProps.spansTfoot) ||
              selProps.spansTfoot && (selProps.spansThead || selProps.spansTbody);
            this.mergeCellsUI.setDisabled(spansMultipleSections);
          }
          this.modifyTableOrCellUI.setDisabled(false);
          this.exitTableEditingUI.setDisabled(false);
        }
      }
    },

    // overrides CUI.rte.plugins.AbstractTablePlugin#removeTableSelection
    removeTableSelection: function () {
      CUI.rte.Utils.scope(this.superClass.removeTableSelection, this)();
      this.editorKernel.enableToolbar(this.tableToolbarTbType);
    },

    /*
     * Fix for CUI - 5950
     * Overrides CUI.rte.plugins.AbstractTablePlugin#checkTableSelectionWindow
     * Checks if the current selection is outside the table window or not
     * To-Do - Check Table Selection Window after table supoort in dialog mode will be provided
     */
    checkTableSelectionWindow: function(context, e) {
      if ($(context.win.getSelection().anchorNode).hasClass('rte-editor')) {
        e.cancelKey  = true;
      }
    },

    // overrides CUI.rte.plugins.AbstractTablePlugin#initializeUI
    initializeUI: function (tbGenerator) {
      var plg = CUI.rte.plugins;
      var isTableMode = this.isTableMode();
      /**
       * Even if a single feature is enabled, we need a table button in the FSM toolbar to be able to switch to
       * tabletoolbar mode. Since it should not be mandatory to enable 'table' feature to be able to use other
       * features of table plugin, we are introducing a new setting createoredit. By using 'table#creatoredit'
       * instead of 'table#table' in uiSettings, user would be able to see the table button in FSM toolbar
       * even if 'table' feature is disabled and some other feature(s) is(are) enabled.
       * We are still supporting 'table#table' (for backward compatibility). Using 'table#table' in uiSettings
       * will show table button in FSM toolbar only if 'table' feature is enabled.
       */
      this.tableUI = tbGenerator.createElement('table', this, false, this.getTooltip('table'));
      tbGenerator.addElement('table', plg.Plugin.SORT_TABLE, this.tableUI, 10);

      this.createOrEditTableUI = tbGenerator.createElement('createoredit', this, false, this.getTooltip('table'));
      tbGenerator.addElement('table', plg.Plugin.SORT_TABLE, this.createOrEditTableUI, 20);

      this.initializeTableModeUI(tbGenerator);

      if (this.isFeatureEnabled('mergecells')) {
        this.mergeCellsRightUI = tbGenerator.createElement('mergecells-right', this,
          false, this.getTooltip('mergecells-right'), null, {
            'cmd': 'mergecells',
            'cmdValue': {'direction': 'right', 'isTableMode': isTableMode}
          });
        tbGenerator.addElement('table.cell', plg.Plugin.SORT_TABLE_TABLEMODE + 3,
          this.mergeCellsRightUI, 10);
        this.mergeCellsDownUI = tbGenerator.createElement('mergecells-down', this,
          false, this.getTooltip('mergecells-down'), null, {
            'cmd': 'mergecells',
            'cmdValue': {'direction': 'down', 'isTableMode': isTableMode}
          });
        tbGenerator.addElement('table.cell', plg.Plugin.SORT_TABLE_TABLEMODE + 3,
          this.mergeCellsDownUI, 20);
        this.mergeCellsUI = tbGenerator.createElement('mergecells', this,
          false, this.getTooltip('mergecells'), null, {
            'cmd': 'mergecells',
            'cmdValue': {'isTableMode': isTableMode}
          });
        tbGenerator.addElement('table.cell', plg.Plugin.SORT_TABLE_TABLEMODE + 3,
          this.mergeCellsUI, 30);

      }
      if (this.isFeatureEnabled('splitcell')) {
        this.splitCellHorizontalUI = tbGenerator.createElement('splitcell-horizontal', this,
          false, this.getTooltip('splitcell-horizontal'), null, {
            'cmd': 'splitcell',
            'cmdValue': 'horizontal'
          });
        tbGenerator.addElement('table.cell', plg.Plugin.SORT_TABLE_TABLEMODE + 4,
          this.splitCellHorizontalUI, 10);
        this.splitCellVerticalUI = tbGenerator.createElement('splitcell-vertical', this,
          false, this.getTooltip('splitcell-vertical'), null, {
            'cmd': 'splitcell',
            'cmdValue': 'vertical'
          });
        tbGenerator.addElement('table.cell', plg.Plugin.SORT_TABLE_TABLEMODE + 4,
          this.splitCellVerticalUI, 20);

      }
      if (this.isFeatureEnabled('selectrow')) {
        this.selectRowUI = tbGenerator.createElement('selectrow', this, false,
          this.getTooltip('selectrow'));
        tbGenerator.addElement('table', plg.Plugin.SORT_TABLE_TABLEMODE + 5,
          this.selectRowUI, 10);
      }
      if (this.isFeatureEnabled('selectcolumn')) {
        this.selectColumnUI = tbGenerator.createElement('selectcolumn', this, false,
          this.getTooltip('selectcolumn'));
        tbGenerator.addElement('table', plg.Plugin.SORT_TABLE_TABLEMODE + 5,
          this.selectColumnUI, 20);
      }
      if (!isTableMode) {
        this.ensureParagraphUI = tbGenerator.createElement('ensureparagraph', this, false,
          this.getTooltip('ensureparagraph'));
        tbGenerator.addElement('table', plg.Plugin.SORT_TABLE_TABLEMODE + 6,
          this.ensureParagraphUI, 10);
      }
      if (this.isFeatureEnabled('table') || this.isFeatureEnabled('cellprops')) {
        this.modifyTableOrCellUI = tbGenerator.createElement('modifytableandcell', this, false,
          this.getTooltip('table'));
        tbGenerator.addElement('table', plg.Plugin.SORT_TABLE_TABLEMODE + 7,
          this.modifyTableOrCellUI, 10);
      }
      if (!isTableMode) {
        if (this.isFeatureEnabled('removetable')) {
          this.removeTableUI = tbGenerator.createElement('removetable', this, false,
            this.getTooltip('removetable'));
          tbGenerator.addElement('table', plg.Plugin.SORT_TABLE_TABLEMODE + 7,
            this.removeTableUI, 20);
        }
      }

      this.exitTableEditingUI = tbGenerator.createElement('exitTableEditing', this, false,
        this.getTooltip('exitTableEditing'));
      tbGenerator.addElement('table', plg.Plugin.SORT_TABLE_TABLEMODE + 8,
        this.exitTableEditingUI, 10);
    }
  });

  CUI.rte.plugins.TablePlugin.EDITMODE_DEFAULT = CUI.rte.plugins.AbstractTablePlugin.EDITMODE_DEFAULT;

  CUI.rte.plugins.TablePlugin.EDITMODE_TABLE = CUI.rte.plugins.AbstractTablePlugin.EDITMODE_TABLE;

// register plugin
  CUI.rte.plugins.PluginRegistry.register('table', CUI.rte.plugins.TablePlugin);

}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.ToolkitImpl = new Class({

    toString: 'ToolkitImpl',

    extend: CUI.rte.ui.Toolkit,

    initialize: function (cb) {
      // currently not required
    },

    requiresInit: function () {
      return false;
    },

    createToolbarBuilder: function (hint) {
      return new CUI.rte.ui.cui.CuiToolbarBuilder();
    },

    createContextMenuBuilder: function (editorKernel) {
      return new CUI.rte.ui.cui.CuiContextMenuBuilder(editorKernel);
    },

    createDialogManager: function (editorKernel) {
      return new CUI.rte.ui.cui.CuiDialogManager(editorKernel);
    }

  });

  CUI.rte.ui.ToolkitRegistry.register('cui', CUI.rte.ui.cui.ToolkitImpl);

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function (CUI) {
  'use strict';
  CUI.rte.ui.ToolkitDefs = (function () {

    return {

      CONFIG_ADAPTER: 'ConfigAdapter'

    };

  }());
}(window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.ToolbarImpl = new Class({

    toString: 'ToolbarImpl',

    /**
     * @type CUI.rte.EditorKernel
     */
    editorKernel: null,

    extend: CUI.rte.ui.Toolbar,

    elementMap: null,

    $container: null,

    $editable: null,

    $toolbar: null,

    $clipParent: null,

    /**
     * @type CUI.rte.ui.cui.PopoverManager
     */
    popover: null,

    preferredToolbarPos: null,

    _popoverStyleSheet: null,

    _tbHideTimeout: null,

    _recordedScrollTop: null,

    _offsets: null,

    _isClipped: false,

    _isSticky: false,

    _initialRange: null,

    /**
     * Internal state variable to remember that after popover positioning we deliberately
     * transferred focus to edit context.
     */
    _selfCausedFocus: false,

    /**
     * Offset of popover from toolbar.
     */
    _POPOVER_OFFSET_FROM_TOOLBAR: 5,

    NO_OFFSETS: {
      'top': 0,
      'left': 0
    },

    construct: function (elementMap, $editable, tbType, isSticky) {
      this.elementMap = elementMap;
      this.$editable = $editable;
      this._isSticky = !!isSticky;
      this.tbType = (tbType || 'inline');
      this.$container = CUI.rte.UIUtils.getUIContainer(this.$editable);
      this.$toolbar = CUI.rte.UIUtils.getToolbar(this.$editable, tbType);
      if (isSticky) {
        this.$toolbar.addClass('is-sticky');
        this.$toolbar.removeClass('is-floating');
      } else {
        this.$toolbar.addClass('is-floating');
        this.$toolbar.removeClass('is-sticky');
      }
      this.popover = new CUI.rte.ui.cui.PopoverManager(this.$container, this.tbType);
    },

    _getClipOffsets: function () {
      var context = this.editorKernel.getEditContext();
      if (context.doc !== document) {
        if (this._isClipped) {
          return {
            'top': this.$clipParent.scrollTop(),
            'left': this.$clipParent.scrollLeft()
          };
        }
        return this.NO_OFFSETS;
      }
      return (this._isClipped ? this.$clipParent.offset() : this.NO_OFFSETS);
    },

    /**
     * Calculates the internal offsets for the toolbar. Those are required to correctly
     * position a toolbar that is contained in another document than the edited div.
     * @private
     * @return {{top:Number,left:Number}} The offsets
     */
    _calcInternalOffsets: function () {
      this._isClipped = CUI.rte.UIUtils.isUnder(this.$clipParent, this.$container);
      if (this._isClipped) {
        return this.$clipParent.offset();
      }
      return this.NO_OFFSETS;
    },

    /**
     * Calculates the optimal toolbart position, which is directly above the editable div.
     * The position might not be valid; this has to be considered separately.
     * @private
     */
    _calcOptimum: function (popoverData) {
      var editablePos = this.$editable.offset();
      var offsetTop = 0;
      var offsetLeft = 0;
      if (this._isClipped) {
        var offset = this._getClipOffsets();
        offsetTop = offset.top;
        offsetLeft = offset.left;
      }
      var tbHeight = this.$toolbar.outerHeight();
      return {
        'left': editablePos.left - offsetLeft,
        'top': editablePos.top - tbHeight - offsetTop - 5
      };
    },

    /**
     * <p>Calculates the vertical coordinates of the "forbidden area" where the toolbar
     * should not be positioned if possible.</p>
     * <p>This is usually the vertical screen estate the current selection takes. On
     * touch devices, approximal values for native elements (the notorious "callout"
     * ...) are added.</p>
     * @param {Object} selection The current processing selection
     * @return {{start: Number, end: Number}} The vertical screen estate reserved for
     *         selection + native stuff; undefined for invalid selections
     * @private
     */
    _calcForbidden: function (selection) {
      var dpr = CUI.rte.DomProcessor;
      var sel = CUI.rte.Selection;
      var com = CUI.rte.Common;
      var forbidden;
      var context = this.editorKernel.getEditContext();
      selection = selection || this.editorKernel.createQualifiedSelection(context);
      if (selection && selection.startNode && this.editorKernel.hasFocus) {
        var startNode = selection.startNode;
        var startOffset = selection.startOffset;
        var endNode = selection.endNode;
        var endOffset = selection.endOffset;
        var isSel = sel.isSelection(selection);
        var area = dpr.calcScreenEstate(context, startNode, startOffset, endNode,
          endOffset);
        var yStart = area.startY - (isSel ? com.ua.calloutHeight : 0);
        var yEnd = area.endY;
        if (this._isClipped) {
          var offs = this._getClipOffsets();
          yStart -= offs.top;
          yEnd -= offs.top;
        }
        forbidden = {
          'start': yStart - (isSel ? com.ua.selectionHandlesHeight : 0),
          'end': yEnd + (isSel ? com.ua.selectionHandlesHeight : 0)
        };
      }
      return forbidden;
    },

    /**
     * Calculates the vertical screen estate that is actually available (approximately).
     * @param {jQuery} $win The window object, wrapped in a jQuery object
     * @return {{min: Number, max: Number}} The minimum/maximum vertical coordinates that
     *         are available
     * @private
     */
    _calcAvail: function ($win) {
      var com = CUI.rte.Common;
      var screenKeyboardHeight = com.getScreenKeyboardHeight();
      var availHeight = $win.height() - screenKeyboardHeight;
      // the scroll offsets of the clipping parent are handled by jQuery
      // automatically, so we don't have to take care of it here
      if (this._isClipped) {
        var context = this.editorKernel.getEditContext();
        if (context.doc !== document) {
          var offsets = this.$clipParent.offset();
          availHeight -= offsets.top;
        }
      }
      // special case: on touch, we need to consider the main window's scroll offset
      // as well
      // TODO check if required on desktop as well (when used outside a clipParent)
      var min = 0;
      if (com.ua.isTouch) {
        min = $win.scrollTop();
      }
      return {
        'min': min,
        'max': min + availHeight
      };
    },

    /**
     * Calculates the vertical coordinates of the UI (toolbar + popover/if applicable).
     * @param {Number} tbTop The toolbar's top coordinate
     * @param {Number} tbHeight The toolbar's height
     * @param {Number} popoverHeight The popover's height; 0 if no popover is shown
     * @param {String} popoverAlign The popover's alignment ("top" or "bottom")
     * @return {{y1: Number, y2: Number}} The top and bottom coordinates of the UI
     * @private
     */
    _calcUITotal: function (tbTop, tbHeight, popoverHeight, popoverAlign) {
      var y1 = tbTop;
      var y2 = tbTop + tbHeight;
      if (popoverAlign === 'top') {
        y1 -= popoverHeight;
      } else {
        y2 += popoverHeight;
      }
      return {
        'y1': y1,
        'y2': y2
      };
    },

    _calcUIPosition: function ($win, selection) {
      var popoverData = this.popover.calc();
      var optimum = this._calcOptimum(popoverData);
      if (!this.preferredToolbarPos) {
        this.preferredToolbarPos = optimum;
      }

      // Update offsets again to take care if the offset of the
      // parent container is changed after editing has already started.
      this._offsets = this._calcInternalOffsets();

      var tbLeft, tbTop, popoverAlign;
      var tbHeight = this.$toolbar.outerHeight();
      var totalHeight = tbHeight + popoverData.height;
      if (!this._isSticky) {
        tbLeft = this.preferredToolbarPos.left;
        tbTop = this.preferredToolbarPos.top;
        popoverAlign = 'top';
        var avail = this._calcAvail($win || $(window));
        // see if the toolbar still fits into the screen
        if (tbTop < avail.min) {
          tbTop = avail.min;
          popoverAlign = 'bottom';
        } else if ((tbTop + tbHeight) > avail.max) {
          tbTop = avail.max - totalHeight;
          popoverAlign = 'bottom';
        } else {
          // if we can keep the toolbar at the same position by changing the alignment
          // of the popover, we try it
          if ((tbTop - popoverData.height) < avail.min) {
            popoverAlign = 'bottom';
          }
        }
        // check if we need to move the toolbar due to current selection state and
        // what has probably been added to screen by the browser (for example, the
        // callout and the screen keyboard on an iPad)
        var forbidden = this._calcForbidden(selection);
        if (forbidden) {
          var totalPos = this._calcUITotal(tbTop, tbHeight, popoverData.height,
            popoverAlign);
          // console.log("a, f, t, o: ", avail, forbidden, totalPos, optimum);
          if ((totalPos.y2 > forbidden.start) && (totalPos.y1 < forbidden.end)) {
            // The toolbar is in the "forbidden area", overlapping either the
            // current selection and/or the callout (iPad). In such cases, we
            // first check if we can place it above the forbidden area if we
            // allow moving the toolbar, starting with an optimal position ...
            if (((optimum.top - popoverData.height) > avail.min) &&
              ((optimum.top + tbHeight) < forbidden.start)) {
              popoverAlign = 'top';
              tbTop = optimum.top;
            } else if ((forbidden.start - totalHeight) > avail.min) {
              // ..., otherwise see if it fits above somewhere else than at
              // the optimal position, ...
              popoverAlign = 'top';
              tbTop = forbidden.start - tbHeight;
            } else if ((forbidden.end + totalHeight) <= avail.max) {
              // ..., otherwise we try to move the toolbar under the selection
              popoverAlign = 'bottom';
              tbTop = forbidden.end;
            } else {
              // if that is not possible, we move it as far to the bottom as
              // possible, which will hide part of the selection, but should
              // avoid conflicting with the (potential) callout completely
              popoverAlign = 'bottom';
              tbTop = avail.max - totalHeight;
            }
          }
        }
      } else {
        tbLeft = 0;
        tbTop = 0;
        popoverAlign = 'bottom';
      }
      // calculate popover position
      var popoverTop;
      if (popoverAlign === 'top') {
        popoverTop = tbTop - popoverData.height;
      } else {
        var $trigger = this.popover.$popoverTrigger;
        var heightOffs = tbHeight;
        if ($trigger && ($trigger.length === 1)) {
          heightOffs = $trigger.position().top;
          heightOffs += $trigger.outerHeight();
        }
        popoverTop = tbTop + heightOffs;
      }
      this.preferredToolbarPos = {
        'left': tbLeft,
        'top': tbTop
      };
      return {
        'toolbar': {
          'left': tbLeft + this._offsets.left,
          'top': tbTop + this._offsets.top
        },
        'popover': {
          'left': popoverData.xOffset + tbLeft + this._offsets.left,
          'top': popoverTop + this._offsets.top + (popoverAlign === 'bottom' ? 1 : -1) * this._POPOVER_OFFSET_FROM_TOOLBAR,
          'align': popoverAlign
        }
      };
    },

    _updateUI: function () {
      var pos = this._calcUIPosition();
      if (pos) {
        this.$toolbar.offset(pos['toolbar']);
        this.popover.setPosition(pos['popover'], !this._isSticky);
      }
    },

    _handleScrolling: function (e) {
      var context = this.editorKernel.getEditContext();
      var scrollTop = (this.$clipParent || $(context.win)).scrollTop();
      if (this._recordedScrollTop !== scrollTop) {
        if (CUI.rte.Common.ua.isTouch && !this.editorKernel.isLocked() && !this._isSticky) {
          this.hideTemporarily();
        } else {
          // Update optimal position based on scroll, and update the UI
          var popoverData = this.popover.calc();
          this.preferredToolbarPos = this._calcOptimum(popoverData);
          this._updateUI();
        }
        this._recordedScrollTop = scrollTop;
      }
    },

    _handleUpdateState: function (e) {
      if (!this.editorKernel.isLocked()) {
        switch (e.origin) {
        case 'event':
          break;
        case 'command':
          this.popover.hide(true);
          break;
        }
        this._updateUI();
      }
    },

    _initializePopovers: function () {
      var self = this;
      this.$container.on('click.rte-toolbar', 'button[data-action^=\'#\']',
        function (e) {
          var $trigger = $(this);
          if (!$trigger.hasClass(CUI.rte.Theme.TOOLBARITEM_DISABLED_CLASS)) {
            var show = !self.popover.isShown() || !self.popover.isTriggeredBy($trigger);
            self.popover.hide(true);
            if (show) {
              self.popover.use($(e.currentTarget).data('action').substring(1),
                $trigger, self.$toolbar);
            }
            self._updateUI();
            CUI.rte.Utils.defer(function(){self.editorKernel.focus();}, 100);
            e.stopPropagation();
          }
        });
      this.$container.find('.rte-popover').each(function () {
        $(this).pointer('click.rte-toolbar', function (e) {
          if ($(e.target).closest('button').attr('disabled') === 'disabled') {
            e.stopPropagation();
          }
        });
      });
      // initialize single selection triggers (that adapt the icon to the currently
      // chosen child element)
      var $singleSelectTriggers = this.$toolbar.find(
        '.rte--trigger.rte--singleSelect');
      $singleSelectTriggers.each(function () {
        var icon = this.icon;
        var $this = $(this);
        $this.data('base-icon', icon);
        $this.data('current-icon', icon);
      });
    },

    hide: function (isAutoHide) {
      this.popover.hide(isAutoHide);
      // use "visibility" property instead of "display" - the latter would destroy the
      // layout on show() on Safari Mobile
      this.$toolbar.css('visibility', 'hidden');
    },

    isHidden: function () {
      return (this.$toolbar.css('visibility') === 'hidden');
    },

    hideTemporarily: function (onShowCallback) {
      if (this._tbHideTimeout) {
        window.clearTimeout(this._tbHideTimeout);
        this._tbHideTimeout = undefined;
      }
      if (!this.isHidden()) {
        this.hide(true);
      }
      var self = this;
      this._tbHideTimeout = window.setTimeout(function () {
        self.show();
        self._tbHideTimeout = undefined;
        if (onShowCallback) {
          onShowCallback();
        }
      }, 1000);
    },

    show: function () {
      // use "visibility" property instead of "display" - the latter would destroy the
      // layout on Safari Mobile
      this.$toolbar.css('visibility', 'visible');
      this._updateUI();
    },

    getToolbarContainer: function () {
      return this.$container;
    },

    getToolbar: function () {
      return this.$toolbar;
    },

    getItem: function (itemId) {
      return this.elementMap[itemId];
    },

    getHeight: function () {
      return 0;
    },

    getPopoverManager: function () {
      return this.popover;
    },

    createPopoverTriggerToElementMapping: function () {
      for (var id in this.elementMap) {
        if (this.elementMap.hasOwnProperty(id)) {
          var elementDef = this.elementMap[id].element;
          var action = elementDef.plugin.pluginId + '#' + elementDef.id;
          var $element = CUI.rte.UIUtils.getElement(action, this.tbType,
            this.$container);
          var $popover = $element.closest('coral-popover');
          if ($popover.length) {
            var popoverRef = '#' + $popover.data('id');
            var $trigger = CUI.rte.UIUtils.getPopoverTrigger(popoverRef,
              this.tbType, this.$toolbar);
            this.popover.addTriggerToElement($trigger, $element);
          }
        }
      }
    },

    triggerUIUpdate: function () {
      this._updateUI();
    },

    startEditing: function (editorKernel) {
      this.editorKernel = editorKernel;
      this.popover.notifyEditStart(editorKernel);
      this.editorKernel.addUIListener('updatestate', this._handleUpdateState, this);
      this.$toolbar.addClass(CUI.rte.Theme.TOOLBAR_ACTIVE);
      this.$clipParent = CUI.rte.UIUtils.getClippingParent(this.$container);
      this._offsets = this._calcInternalOffsets();
      this._initializePopovers();
      this._updateUI();
      var self = this;
      // Several browsers propagate click events on disabled items to parent elements,
      // others don't. To be sure, cancel all click events that arrive at the toolbar.
      this.$toolbar.pointer('click.rte-toolbar', function (e) {
        if ($(e.target).closest('button').attr('disabled') === 'disabled') {
          e.stopPropagation();
        }
      });
      // Clicking a button in the toolbar leads to an unwanted focus transfer; ignore
      // it by disabling focus handling on mousedown and enabling it again on
      // mouseup (after blur); event order is: (touchstart) -> (touchend) -> (tap)
      // -> mousedown -> blur (on opposite component) -> mouseup -> (click)
      this.$container.on('mousedown.rte-toolbar', '.rte-toolbar-item',
        function (e) {
          self.editorKernel.disableFocusHandling();
        });
      $(document).on('mouseup.rte-toolbar',
        function (e) {
          self.editorKernel.enableFocusHandling();
        });
      $(window).on('scroll.rte-toolbar', function (e) {
        self._handleScrolling(e);
      });
      if (this.$clipParent) {
        // provide a onclick handler for the clip parent, as otherwise no click
        // events would be sent to finish editing
        this.$clipParent.on('click.rte-toolbar', function () {
          // do nothing
        });
        // handle scrolling of the clip parent
        this.$clipParent.on('scroll.rte-toolbar', function (e) {
          self._handleScrolling(e);
        });
      }
    },

    finishEditing: function () {
      this.popover.hide(true);
      this.$toolbar.removeClass(CUI.rte.Theme.TOOLBAR_ACTIVE);
      $(window).off('scroll.rte-toolbar');
      this.$container.off('mousedown.rte-toolbar click.rte-toolbar');
      $(document).off('mouseup.rte-toolbar');
      if (this.$clipParent) {
        this.$clipParent.off('scroll.rte-toolbar');
        this.$clipParent.off('click.rte-toolbar');
        this.$clipParent = undefined;
      }
      this._isClipped = false;
      this.editorKernel.removeUIListener('updatestate', this._handleUpdateState,
        this);
      this.$container.find('.rte-popover').each(function () {
        $(this).off('click.rte-toolbar');
      });
    },

    enable: function () {
      if (!this.editorKernel.isLocked()) {
        for (var itemId in this.elementMap) {
          if (this.elementMap.hasOwnProperty(itemId)) {
            var item = this.elementMap[itemId].element;
            item.setDisabled(false);
          }
        }
      }
    },

    disable: function (excludeItems) {
      if (!this.editorKernel.isLocked()) {
        for (var itemId in this.elementMap) {
          if (this.elementMap.hasOwnProperty(itemId)) {
            if (!excludeItems || (excludeItems.indexOf(itemId) < 0)) {
              var item = this.elementMap[itemId].element;
              item.setDisabled(true);
            }
          }
        }
      }
    },

    destroy: function () {
      // as the toolbar items might be kept on the screen visually, we're disabling
      // them before destroying the data model; otherwise the toolbar will stay active in
      // serveral situations where the blur event doesn't kick in (mainly with mobile
      // devices)
      this.disable();
      for (var itemId in this.elementMap) {
        if (this.elementMap.hasOwnProperty(itemId)) {
          var item = this.elementMap[itemId].element;
          if (item.destroy) {
            item.destroy();
          }
        }
      }
      this.elementMap = {};
    },

    isSticky: function () {
      return this._isSticky;
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.PopoverManager = new Class({

    toString: 'ToolbarImpl',

    $container: null,

    $popover: null,

    popover: null,

    $popoverTrigger: null,

    triggerToElements: null,

    tbType: null,

    _popoverXOffset: 0,

    _popoverBorder: 0,

    _popoverStyleSheet: null,

    autoHideFn: undefined,

    _isHiding: false,

    construct: function ($container, tbType) {
      this.$popover = null;
      this.popover = null;
      this.$popoverTrigger = null;
      this.$container = $container;
      this.triggerToElements = [];
      this.tbType = tbType;
    },

    /**
     * When showing the popover, the element will get focused out of screen,
     * so this function should be used to get scroll positions.
     * Returns an array of objects like {el : HTML_ELEMENT, top: scroll_top_of_el}
     */
    _getScrollTops: function() {
      var scrollParentTops = [];
      if (this.$popover) {
        this.$popover.parents().filter(function () {
          return $(this).css('overflow-y').match(/(auto|scroll)/);
        }).each(function() {
          scrollParentTops.push({el: this, top: this.scrollTop});
        });
      }
      return scrollParentTops;
    },

    /**
     * Utility method to set the scroll tops of elements provided in the passed array.
     * @param scrollParentTops - an array of objects like {el : HTML_ELEMENT, top: scroll_top_of_el}
     */
    _setScrollTops: function(scrollParentTops) {
      $.each(scrollParentTops, function(index, value) {
        $(value.el).scrollTop(value.top);
      });
    },

    /**
     * Sets the position of the popover
     * @param {{top:Number}, {left:Number}} pos The popover position;
     */
    setPosition: function (pos, isToolbarFloating) {
      var $popover = this.$popover, offsetSet, deferFunc, scrollParentTops,  crossCheckCount = 0, success;
      var deferInterval = 20, consecutiveSuccessRequired = isToolbarFloating ? 1 : 3, self = this;
      if ($popover) {
        this._calculatedPos = pos;
        scrollParentTops = this._getScrollTops();
        // Setting the popover position is tricky here. Sometimes the popover is itself adjusting. None of the
        // events thrown by popover seemed useful. There were one or other edge cases with each one of those since its
        // positioning calls get mixed with RTE trying to position it. So creating a deferred-recursive function
        // which keeps on deferring itself unless it is sure a few consecutive times that it has placed the popover
        // on the desired position.
        deferFunc = function () {
          $popover.offset(pos);
          self._setScrollTops(scrollParentTops);
          offsetSet = $popover.offset();
          success = Math.abs(offsetSet.top - pos.top) <= 1 && Math.abs(offsetSet.left - pos.left) <= 1;
          if (success) {
            crossCheckCount++;
          } else {
            crossCheckCount = 0;
          }
          if (crossCheckCount < consecutiveSuccessRequired) {
            CUI.rte.Utils.defer(deferFunc, deferInterval);
          }
        };
        deferFunc();
      }
    },

    /**
     * Calculates the height of the current popover.
     * @return {{height: Number}} The total height height. The value is 0 if no popover is
     *         currently shown
     */
    calc: function () {
      var $p = this.$popover;
      if (!$p) {
        return {
          'width': 0,
          'height': 0,
          'padX': 0,
          'padY': 0
        };
      }
      var padX = $p.outerWidth() - $p.width();
      var padY = $p.outerHeight() - $p.height();
      return {
        'width': $p.outerWidth(),
        'height': $p.outerHeight(),
        'xOffset': this._popoverXOffset,
        'padX': padX,
        'padY': padY
      };
    },

    addTriggerToElement: function ($trigger, $element) {
      var trigger = $trigger[0];
      var element = $element[0];
      var triggerElements = this.getElementsForTrigger($trigger);
      if (!triggerElements) {
        triggerElements = {
          'trigger': trigger,
          'elements': []
        };
        this.triggerToElements.push(triggerElements);
      }
      var elements = triggerElements.elements;
      if (!CUI.rte.Common.arrayContains(elements, element)) {
        elements.push(element);
      }
    },

    getElementsForTrigger: function ($trigger) {
      var trigger = $trigger[0];
      var triggerCnt = this.triggerToElements.length;
      for (var t = 0; t < triggerCnt; t++) {
        if (this.triggerToElements[t].trigger === trigger) {
          return this.triggerToElements[t];
        }
      }
      return undefined;
    },

    getTriggerForElement: function ($element) {
      var element = $element[0];
      var triggerCnt = this.triggerToElements.length;
      for (var t = 0; t < triggerCnt; t++) {
        var triggerElements = this.triggerToElements[t];
        var elements = triggerElements.elements;
        var elementCnt = elements.length;
        for (var e = 0; e < elementCnt; e++) {
          if (elements[e] === element) {
            return $(triggerElements.trigger);
          }
        }
      }
      return undefined;
    },

    isShown: function ($popover) {
      if (!$popover) {
        return !!this.$popover;
      }
      return (this.$popover === $popover);
    },

    isTriggeredBy: function ($trigger) {
      return this.$popoverTrigger && ($trigger[0] === this.$popoverTrigger[0]);
    },

    use: function (ref, $trigger, $toolbar, autoHideFn) {
      this.autoHideFn = autoHideFn;
      this.$toolbar = $toolbar;
      this.$popoverTrigger = $trigger;
      if (ref.jquery) {
        this.$popover = ref;
      } else {
        this.$popover = CUI.rte.UIUtils.getPopover(ref, this.tbType,
          this.$container);
      }
      if (this.$popover.length) {
        this.popover = this.$popover[0];
        var triggerOffs = $trigger.offset();
        var triggerCenter = ($trigger.width() / 2);
        var toolbarOffs = $toolbar.offset();
        var triggerDX = triggerOffs.left - toolbarOffs.left;
        var popoverWidth = this.$popover.outerWidth();
        var pageWidth = $('body').outerWidth();
        this._popoverBorder =
          (this.$popover.outerHeight() - this.$popover.innerHeight()) / 2;
        var popoverX =
          Math.round(triggerDX + triggerCenter - (popoverWidth / 2)) +
          this._popoverBorder;
        if (popoverX < 0) {
          popoverX = 0;
        }
        if (popoverX + toolbarOffs.left + popoverWidth > pageWidth) {
          popoverX = pageWidth - popoverWidth - toolbarOffs.left;
        }
        this._popoverXOffset = popoverX;
        // must be shown before calculating positions, as jQuery will miscalculate
        // position:absolute otherwise
        this.popover.set({
          target: $trigger[0],
          collision: Coral.Overlay.collision.NONE,
          alignAt: Coral.Overlay.align.LEFT_BOTTOM,
          alignMy: Coral.Overlay.align.LEFT_TOP
        });
        this.popover.show();
      } else {
        this.$popover = null;
        this.popover = null;
      }
    },

    hide: function (isAutoHide) {
      // break if we are already in the process of hiding the popover
      if (this._isHiding) {
        return false;
      }
      this._isHiding = true;
      if (this.$popoverTrigger) {
        this.$popoverTrigger = null;
      }
      var mustHide = !!this.$popover;
      if (mustHide) {
        if (this.autoHideFn && isAutoHide) {
          this.autoHideFn();
        }
        this._popoverStyleSheet = null;
        this._popoverXOffset = 0;
        this.popover.hide();
        this.$popover = null;
        this.popover = null;
      }
      this.autoHideFn = undefined;
      this._isHiding = false;
      return mustHide;
    },

    notifyEditStart: function (editorKernel) {
      this.editorKernel = editorKernel;
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.ElementImpl = new Class({

    toString: 'ElementImpl',

    extend: CUI.rte.ui.TbElement,

    dom: null,

    $ui: null,


    notifyGroupBorder: function (isFirst) {
      // TODO ...?
    },


    // Interface implementation ------------------------------------------------------------

    addToToolbar: function (toolbar) {
      var commandRef = this.plugin.pluginId + '#' + this.id;
      toolbar.push({
        'ref': commandRef,
        'plugin': this.plugin.pluginId,
        'command': this.id,
        'tooltip': this.tooltip ? this.tooltip.title : ''
      });
    },

    notifyToolbar: function (toolbar, skipHandlers) {
      var pluginId = this.plugin.pluginId;
      var self = this;
      var $cont = toolbar.getToolbarContainer();
      var $tbCont = CUI.rte.UIUtils.getToolbarContainer($cont, toolbar.tbType);
      var $newUI = $tbCont.find(
        'button[data-action="' + pluginId + '#' + this.id + '"]');
      if ($newUI.length <= 0) {
        // this element doesn't exist in the passed toolbar.
        return;
      }
      this.$ui = $newUI;
      this.toolbar = toolbar;
      if (!skipHandlers) {
        this.$ui.on('click.rte-handler', function (e) {
          var editorKernel = self.plugin.editorKernel;
          if (!self.$ui.hasClass(CUI.rte.Theme.TOOLBARITEM_DISABLED_CLASS)) {
            var editContext = editorKernel.getEditContext();
            if (self.toggle && !self._isHighlighted) {
              self.setSelected(!self.isSelected());
            }
            editContext.setState('CUI.SelectionLock', 1);
            var cmd = (self.cmdDef ? self.cmdDef.cmd : self.id);
            var cmdValue = (self.cmdDef ? self.cmdDef.cmdValue : undefined);
            var env = {
              'editContext': editContext
            };
            if (self.plugin.isHeadless(cmd, cmdValue)) {
              var dm = editorKernel.getDialogManager();
              dm.hide();
            }
            var opts = self.plugin.execute(cmd, cmdValue, env);
            editorKernel.enableFocusHandling();
            if (!opts || !opts.preventTouchFocus) {
              editorKernel.focus(editContext);
            }
          }
          e.stopPropagation();
        });
      }
    },

    createToolbarDef: function () {
      return {
        'id': this.id,
        'element': this
      };
    },

    setDisabled: function (isDisabled) {
      // Background toolbars like tableEditOptions toolbar might not be created during RTE initialization. So the
      // following check is required as $ui would be null for the elements meant for the background toolbar until
      // that toolbar is created.
      if (!this.$ui) {
        return;
      }
      if (isDisabled) {
        this.$ui.addClass(CUI.rte.Theme.TOOLBARITEM_DISABLED_CLASS);
        this.$ui.attr('disabled', 'disabled');
      } else {
        this.$ui.removeClass(CUI.rte.Theme.TOOLBARITEM_DISABLED_CLASS);
        this.$ui.removeAttr('disabled');
      }
    },

    setHighlighted: function (isHighlighted) {
      // see #setDisabled for explanation as to why this check is required
      if (!this.$ui) {
        return;
      }
      this._isHighlighted = isHighlighted;
      if (isHighlighted) {
        this.$ui.addClass('is-itemHighlighted');
      } else {
        this.$ui.removeClass('is-itemHighlighted');
      }
    },

    setSelected: function (isSelected, suppressEvent) {
      // see #setDisabled for explanation as to why this check is required
      if (!this.$ui) {
        return;
      }
      this._isSelected = isSelected;
      if (isSelected) {
        this.$ui.addClass(CUI.rte.Theme.TOOLBARITEM_SELECTED_CLASS);
      } else {
        this.$ui.removeClass(CUI.rte.Theme.TOOLBARITEM_SELECTED_CLASS);
      }
      var pm = this.toolbar.getPopoverManager();
      var $trigger = pm.getTriggerForElement(this.$ui);
      if ($trigger && $trigger.length) {
        var elements = pm.getElementsForTrigger($trigger);
        elements = (elements ? elements.elements : []);
        var selected = [];
        var elementCnt = elements.length;
        for (var e = 0; e < elementCnt; e++) {
          var $el = $(elements[e]);
          if ($el.hasClass(CUI.rte.Theme.TOOLBARITEM_SELECTED_CLASS)) {
            selected.push($el);
          }
        }
        if (selected.length > 0) {
          $trigger.addClass('is-itemsSelected');
        } else {
          $trigger.removeClass('is-itemsSelected');
        }
        var baseIcon = $trigger.data('base-icon');
        if (baseIcon) {
          var targetIcon = baseIcon;
          if (selected.length === 1) {
            var selIcon = selected[0].icon;
            targetIcon = (selIcon ? selIcon : targetIcon);
          }
          var currentIcon = $trigger.data('current-icon');
          if (currentIcon !== targetIcon) {
            if (currentIcon) {
              $trigger.icon = '';
            }
            $trigger.icon = targetIcon;
            $trigger.data('current-icon', targetIcon);
          }
        }
      }
    },

    isSelected: function () {
      return this._isSelected;
    },

    destroy: function () {
      // see #setDisabled for explanation as to why this check is required
      if (!this.$ui) {
        return;
      }
      this.$ui.off('click.rte-handler');
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.ParaFormatterImpl = new Class({

    toString: 'ParaFormatterImpl',

    extend: CUI.rte.ui.TbParaFormatter,


    // Stuff -------------------------------------------------------------------------------

    notifyGroupBorder: function () {
      // do nothing
    },

    _getFormatId: function ($button) {
      var formatId = null;
      var targetId = $button.data('action');
      var hashPos = targetId.indexOf('#');
      if (hashPos >= 0) {
        formatId = targetId.substring(hashPos + 1);
      }
      return formatId;
    },

    _resetSelection: function () {
      this.$ui.each(function () {
        this.icon = '';
      });
    },

    _select: function (formatToSelect) {
      var self = this;
      this.$ui.each(function () {
        var $fmtItem = $(this);
        var formatId = self._getFormatId($fmtItem);
        if (formatId && (formatId === formatToSelect)) {
          this.icon = 'check' ;
        }
      });
    },


    // Interface implementation ------------------------------------------------------------

    addToToolbar: function (toolbar) {
      this.toolbar = toolbar;
    },

    notifyToolbar: function (toolbar, skipHandlers) {
      this.toolbar = toolbar;
      var self = this;
      var pluginId = this.plugin.pluginId;
      var tbType = toolbar.tbType;
      var $cont = toolbar.getToolbarContainer();
      if (!this.plugin.hasFormatsConfigured()) {
        var formats = [];
        var $popover = CUI.rte.UIUtils.getPopover(pluginId, tbType, $cont);
        var $formatItems = $popover.find('li');
        $formatItems.each(function () {
          var $button = $(this).find('button');
          var href = $button.data('action');
          var action = href.split('#');
          if ((action.length === 2) && (action[0] === pluginId)) {
            formats.push({
              'tag': action[1],
              'description': $button.text()
            });
          }
        });
        this.plugin.setFormats(formats);
      }
      var $tbCont = CUI.rte.UIUtils.getToolbarContainer($cont, tbType);
      this.$trigger = $tbCont.find('button[data-action="#' + pluginId + '"]');
      this.$ui = $tbCont.find('button[data-action^="' + pluginId + '#"]');
      if (!skipHandlers) {
        this.$ui.on('click.rte-handler', function (e) {
          if (!self.$ui.hasClass(CUI.rte.Theme.TOOLBARITEM_DISABLED_CLASS)) {
            var $target = $(e.target);
            if (!$target.is('button')) {
              $target = $target.closest('button');
            }
            self._resetSelection();
            self._select(self._getFormatId($target));
            var editContext = self.plugin.editorKernel.getEditContext();
            editContext.setState('CUI.SelectionLock', 1);
            self.plugin.execute();
            self.plugin.editorKernel.enableFocusHandling();
            self.plugin.editorKernel.focus(editContext);
          }
          // e.stopPropagation();
        });
      }
    },

    createToolbarDef: function () {
      return {
        'id': this.id,
        'element': this
      };
    },

    initializeSelector: function () {
      // TODO ...?
    },

    getSelectorDom: function () {
      return this.$ui;
    },

    selectFormat: function (formatToSelect, auxRoot, formatCnt, noFormatCnt) {
      this._resetSelection();
      if ((formatToSelect !== null && formatToSelect !== undefined) && (formatCnt === 1) && (noFormatCnt === 0)) {
        this._select(formatToSelect);
      }
      this.setDisabled((noFormatCnt > 0) && (auxRoot === null || auxRoot === undefined));
      this.setSelected((formatToSelect !== null) && (formatToSelect !== undefined));
    },

    getSelectedFormat: function () {
      var format = null;
      var self = this;
      this.$ui.each(function () {
        var $fmtItem = $(this);
        if (this.icon === 'check') {
          format = self._getFormatId($fmtItem);
        }
        return !format;
      });
      return format;
    },

    setDisabled: function (isDisabled) {
      var com = CUI.rte.Common;
      if (com.ua.isTouchInIframe) {
        // workaround for CUI-649; see ElementImpl#setDisabled for an explanation
        this.$trigger.css('display', 'none');
      }
      if (isDisabled) {
        this.$trigger.addClass(CUI.rte.Theme.TOOLBARITEM_DISABLED_CLASS);
        this.$trigger.attr('disabled', 'disabled');
      } else {
        this.$trigger.removeClass(CUI.rte.Theme.TOOLBARITEM_DISABLED_CLASS);
        this.$trigger.removeAttr('disabled');
      }
      if (com.ua.isTouchInIframe) {
        // part 2 of workaround for CUI-649
        var self = this;
        window.setTimeout(function () {
          self.$trigger.css('display', 'inline-block');
        }, 1);
      }
    },

    setSelected: function (isSelected, suppressEvent) {
      this._isSelected = isSelected;
      if (isSelected) {
        this.$trigger.addClass(CUI.rte.Theme.TOOLBARITEM_SELECTED_CLASS);
      } else {
        this.$trigger.removeClass(CUI.rte.Theme.TOOLBARITEM_SELECTED_CLASS);
      }
    },

    isSelected: function () {
      return this._isSelected;
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.StyleSelectorImpl = new Class({

    toString: 'StyleSelectorImpl',

    extend: CUI.rte.ui.TbStyleSelector,

    // Helpers -----------------------------------------------------------------------------

    notifyGroupBorder: function () {
      // do nothing
    },

    _getStyleId: function ($button) {
      var styleId = null;
      var targetId = $button.data('action');
      var hashPos = targetId.indexOf('#');
      if (hashPos >= 0) {
        styleId = targetId.substring(hashPos + 1);
      }
      return styleId;
    },

    _resetSelection: function () {
      this.$ui.each(function () {
        this.icon = '';
      });
    },

    _select: function (styleToSelect) {
      var self = this;
      this.$ui.each(function () {
        var $fmtItem = $(this);
        var styleId = self._getStyleId($fmtItem);
        if (styleId && (styleId === styleToSelect)) {
          this.icon = 'check' ;
        }
      });
    },


    // Interface implementation ------------------------------------------------------------

    addToToolbar: function (toolbar) {
      this.toolbar = toolbar;
    },

    notifyToolbar: function (toolbar, skipHandlers) {
      this.toolbar = toolbar;
      var self = this;
      var pluginId = this.plugin.pluginId;
      var $cont = toolbar.getToolbarContainer();
      var tbType = toolbar.tbType;
      if (!this.plugin.hasStylesConfigured()) {
        var styles = [];
        var $popover = CUI.rte.UIUtils.getPopover(pluginId, tbType, $cont);
        var $styleItems = $popover.find('li');
        $styleItems.each(function () {
          var $button = $(this).find('button');
          var href = $button.data('action');
          var action = href.split('#');
          if ((action.length === 2) && (action[0] === pluginId)) {
            styles.push({
              'cssName': action[1],
              'text': $button.text()
            });
          }
        });
        this.plugin.setStyles(styles);
      }
      var $tbCont = CUI.rte.UIUtils.getToolbarContainer($cont, tbType);
      this.$trigger = $tbCont.find('button[data-action="#' + pluginId + '"]');
      this.$ui = $tbCont.find('button[data-action^="' + pluginId + '#"]');
      if (!skipHandlers) {
        this.$ui.on('click.rte-handler', function (e) {
          if (!self.$ui.hasClass(CUI.rte.Theme.TOOLBARITEM_DISABLED_CLASS)) {
            var targetId = $(this).data('action');
            var hashPos = targetId.indexOf('#');
            var style = targetId.substring(hashPos + 1);
            var editContext = self.plugin.editorKernel.getEditContext();
            editContext.setState('CUI.SelectionLock', 1);
            self.plugin.execute('applystyle', style);
            self.plugin.editorKernel.enableFocusHandling();
            self.plugin.editorKernel.focus(editContext);
          }
          // e.stopPropagation();
        });
      }
    },

    createToolbarDef: function () {
      return {
        'id': this.id,
        'element': this
      };
    },

    initializeSelector: function () {
      // TODO ...?
    },

    getSelectorDom: function () {
      return this.$ui;
    },

    getSelectedStyle: function () {
      return null;
    },

    selectStyles: function (styles, selDef) {
      this.setSelected(styles.length > 0);
      this._resetSelection();
      for (var s = 0; s < styles.length; s++) {
        this._select(styles[s].className);
      }
    },

    setDisabled: function (isDisabled) {
      var com = CUI.rte.Common;
      if (com.ua.isTouchInIframe) {
        // workaround for CUI-649; see ElementImpl#setDisabled for an explanation
        this.$trigger.css('display', 'none');
      }
      if (isDisabled) {
        this.$trigger.addClass(CUI.rte.Theme.TOOLBARITEM_DISABLED_CLASS);
        this.$trigger.attr('disabled', 'disabled');
      } else {
        this.$trigger.removeClass(CUI.rte.Theme.TOOLBARITEM_DISABLED_CLASS);
        this.$trigger.removeAttr('disabled');
      }
      if (com.ua.isTouchInIframe) {
        // part 2 of workaround for CUI-649
        var self = this;
        window.setTimeout(function () {
          self.$trigger.css('display', 'inline-block');
        }, 1);
      }
    },

    setSelected: function (isSelected, suppressEvent) {
      this._isSelected = isSelected;
      if (isSelected) {
        this.$trigger.addClass(CUI.rte.Theme.TOOLBARITEM_SELECTED_CLASS);
      } else {
        this.$trigger.removeClass(CUI.rte.Theme.TOOLBARITEM_SELECTED_CLASS);
      }
    },

    isSelected: function () {
      return this._isSelected;
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  var ICONS = {

    // Popover triggers
    '#format': 'text',
    '#justify': 'textLeft',
    '#lists': 'textBulleted',
    '#styles': 'textStyle',
    '#paraformat': 'textParagraph',

    // Commands
    'format#bold': 'textBold',
    'format#italic': 'textItalic',
    'format#underline': 'textUnderline',
    'subsuperscript#subscript': 'textSubscript',
    'subsuperscript#superscript': 'textSuperscript',
    'edit#cut': 'cut',
    'edit#copy': 'copy',
    'edit#paste-default': 'paste',
    'edit#paste-plaintext': 'pasteText',
    'edit#paste-wordhtml': 'pasteHTML',
    'justify#justifyleft': 'textLeft',
    'justify#justifycenter': 'textCenter',
    'justify#justifyright': 'textRight',
    'lists#unordered': 'textBulleted',
    'lists#ordered': 'textNumbered',
    'lists#outdent': 'textIndentDecrease',
    'lists#indent': 'textIndentIncrease',
    'links#modifylink': 'link',
    'links#unlink': 'linkOff',
    'links#anchor': 'anchor',
    'table#table': 'table',
    'table#createoredit': 'table',
    'table#insertcolumn-before': 'tableColumnAddLeft',
    'table#insertcolumn-after': 'tableColumnAddRight',
    'table#removecolumn': 'tableColumnRemoveCenter',
    'table#insertrow-before': 'tableRowAddTop',
    'table#insertrow-after': 'tableRowAddBottom',
    'table#removerow': 'tableRowRemoveCenter',
    'table#mergecells-right': 'tableRowMerge',
    'table#mergecells-down': 'tableColumnMerge',
    'table#mergecells': 'tableMergeCells',
    'table#splitcell-horizontal': 'tableRowSplit',
    'table#splitcell-vertical': 'tableColumnSplit',
    'table#modifytableandcell': 'tableEdit',
    'table#selectrow': 'tableSelectRow',
    'table#selectcolumn': 'tableSelectColumn',
    'table#ensureparagraph': 'textParagraph',
    'table#removetable': 'delete',
    'table#exitTableEditing': 'close',
    'image#imageProps': 'image',
    'spellcheck#checktext': 'spellcheck',
    'undo#undo': 'undo',
    'undo#redo': 'redo',
    'findreplace#find': 'search',
    'findreplace#replace': 'findAndReplace',
    'generichtml#generichtml': 'code',
    'misctools#specialchars': 'star',
    'misctools#sourceedit': 'fileCode',
    'fullscreen#toggle': 'fullScreen',
    'fullscreen#start': 'fullScreen',
    'fullscreen#finish': 'fullScreenExit',
    'control#close': 'close',
    'control#save': 'check'
  };

  var CLASSES = {
    '#format': 'rte--multiSelect',
    '#justify': 'rte--singleSelect',
    'fullscreen#toggle': 'rte--modechanger',
    'fullscreen#start': 'rte--modechanger',
    'fullscreen#finish': 'rte--modechanger',
    'control#close': 'rte--modechanger',
    'control#save': 'rte--modechanger',
    'links#modifylink': 'rte--trigger',
    'links#anchor': 'rte--trigger',
    'findreplace#find': 'rte--trigger',
    'findreplace#replace': 'rte--trigger',
    'misctools#specialchars': 'rte--trigger'
  };

  CUI.rte.ui.cui.CuiToolbarBuilder = new Class({

    toString: 'CuiToolbarBuilder',

    extend: CUI.rte.ui.ToolbarBuilder,

    $editable: null,

    uiSettings: undefined,

    additionalClasses: {},

    // Helpers -------------------------------------------------------------------------

    _getUISettings: function (options) {
      if (this.uiSettings) {
        return this.uiSettings;
      }
      if (options && options.uiSettings && options.uiSettings.cui) {
        this.uiSettings = options.uiSettings.cui;
      } else {
        this.uiSettings = $.extend(true, {}, CUI.rte.ui.cui.DEFAULT_UI_SETTINGS);
      }
      var tk = CUI.rte.ui.ToolkitRegistry.get('cui');
      var adapter = tk.getToolkitData(CUI.rte.ui.ToolkitDefs.CONFIG_ADAPTER);
      if (typeof adapter === 'function') {
        this.uiSettings = adapter(this.uiSettings, 'uiSettings', options.componentType);
      }
      return this.uiSettings;
    },

    _registerIcons: function (iconDefs) {
      if (!iconDefs) {
        return;
      }
      CUI.rte.Common.removeJcrData(iconDefs);
      for (var node in iconDefs) {
        if (iconDefs.hasOwnProperty(node)) {
          var icon = iconDefs[node];
          if (icon.command && icon.icon) {
            this.registerIcon(icon.command, icon.icon);
          }
        }
      }
    },

    registerIcon: function (commandRef, iconName) {
      var iconClassPrefix = 'coral-Icon coral-Icon--';
      if (iconName.indexOf(iconClassPrefix) !== -1) {
          var iconNameStartIndex = iconName.indexOf(iconClassPrefix) + iconClassPrefix.length;
          iconName = iconName.substring(iconNameStartIndex);
          var iconNameEndIndex = iconName.indexOf(' ');
          if (iconNameEndIndex !== -1) {
            iconName = iconName.substring(0, iconNameEndIndex);
          }
      }
      ICONS[commandRef] = iconName;
    },

    _getIconForCommand: function (commandRef) {
      if (ICONS.hasOwnProperty(commandRef)) {
        return ICONS[commandRef];
      }
      return undefined;
    },

    _registerAllAdditionalClasses: function (clsDefs) {
      var com = CUI.rte.Common;
      if (!clsDefs) {
        return;
      }
      com.removeJcrData(clsDefs);
      for (var node in clsDefs) {
        if (clsDefs.hasOwnProperty(node)) {
          var clsDef = clsDefs[node];
          if (clsDef.command && !com.isNull(clsDef.classes)) {
            this.registerAdditionalClasses(clsDef.command, clsDef.classes);
          }
        }
      }
    },

    /**
     * @param {String} commandRef The command refence (#trigger for popup triggers;
     *        plugin#command for active RTE buttons
     * @param {String} cssClasses Additional CSS classes; space separated
     */
    registerAdditionalClasses: function (commandRef, cssClasses) {
      CLASSES[commandRef] = cssClasses;
    },

    _getClassesForCommand: function (commandRef) {
      if (CLASSES.hasOwnProperty(commandRef)) {
        return CLASSES[commandRef];
      }
      if (this.additionalClasses && this.additionalClasses.hasOwnProperty(commandRef)) {
        return this.additionalClasses[commandRef];
      }
      return undefined;
    },

    _buildToolbar: function ($editable, elements, options) {

      var addClasses;
      var popoverDefs;
      var items = [];
      var poItems = [];
      var popoverItemTpl = Coral.templates.RichTextEditor['popover_item'];

      function getItem(id) {
        var itemCnt = items.length;
        for (var i = 0; i < itemCnt; i++) {
          if (items[i].ref === id) {
            return items[i];
          }
        }
        return null;
      }

      var self = this;
      this.additionalClasses = options.additionalClasses;
      function createPopoverItem(poItemDef) {
        // toolbar-separators have been removed.
        // ignore '-' for backwards compatibility of configuration
        if (poItemDef !== '-') {
          // popover item
          var poItem = getItem(poItemDef);
          if (poItem) {
            var cmd = poItem.ref;
            addClasses = self._getClassesForCommand(cmd);
            addClasses = (addClasses ? ' ' + addClasses : '');
            poItem.icon = poItem.icon || self._getIconForCommand(cmd);
            poItem.addClasses = addClasses;
            poItems.push(popoverItemTpl(poItem));
          }
        }
      }

      function createDynamicPopover(itemDef) {
        var defs = itemDef.split(':');
        if (defs.length >= 2) {
          var plugin = options.editorKernel.getPlugin(defs[0]);
          var propName = defs[1];
          var prop = plugin[propName];
          if (plugin && prop) {
            if (typeof prop === 'function') {
              prop = prop.call(plugin);
            }
            if (prop) {
              defs[2] = defs[2].replace('-', '_');
              var dynamicPoItem = Coral.templates.RichTextEditor[defs[2]](prop);
              poItems.push(dynamicPoItem);
            }
          }
        }
      }

      function featureEnabled(pluginId, feature) {
        var plugin = options.editorKernel.getPlugin(pluginId);
        var isEnabled;
        if (feature) {
          isEnabled = plugin.isFeatureEnabled(feature);
        } else {
          isEnabled = plugin.isAnyFeatureEnabled();
        }
        return isEnabled;
      }

      function popoverAvailable(popoverDef) {
        if (!popoverDefs) {
          return false;
        }
        var id = popoverDef.substring(1);
        if (popoverDefs.hasOwnProperty(id)) {
          var popoverItems = popoverDefs[id].items;
          if (popoverItems) {
            if ((typeof popoverItems === 'string') &&
              (popoverItems.indexOf(':') > 0)) {
              var def = popoverItems.split(':');
              if (featureEnabled(def[0])) {
                return true;
              }
            } else {
              for (var i = 0; i < popoverItems.length; i++) {
                var ref = popoverItems[i].split('#');
                if (featureEnabled(ref[0], ref[1])) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      }

      var com = CUI.rte.Common;
      var uiSettings = this._getUISettings(options);

      for (var e = 0; e < elements.length; e++) {
        elements[e].addToToolbar(items);
      }
      // reorder according to settings
      com.removeJcrData(uiSettings);
      var toolbars = [];
      var toolbarTpl = Coral.templates.RichTextEditor['toolbar'];
      var itemTpl = Coral.templates.RichTextEditor['toolbar_item'];
      var triggerTpl = Coral.templates.RichTextEditor['popover_trigger'];
      var popoverTpl = Coral.templates.RichTextEditor['popover'];
      var popovercontentTpl = Coral.templates.RichTextEditor['popovercontent'];
      for (var tbId in uiSettings) {
        if (uiSettings.hasOwnProperty(tbId)) {
          var toolbar = uiSettings[tbId];
          var tbItems = [];
          var popovers = [];
          var itemDefs = toolbar.toolbar;
          if (!itemDefs) {
            continue;
          }
          popoverDefs = toolbar.popovers;

          // toolbar
          var itemCnt = itemDefs.length;
          for (var i = 0; i < itemCnt; i++) {
            var itemToAdd = itemDefs[i];
            if (itemToAdd && itemToAdd.length) {
              if (itemToAdd.charAt(0) === '#') {
                if (popoverAvailable(itemToAdd)) {
                  // popover trigger
                  addClasses = this._getClassesForCommand(itemToAdd);
                  addClasses = (addClasses ? ' ' + addClasses : '');
                  var tooltip = itemToAdd.charAt(1).toUpperCase() + itemToAdd.substr(2);
                  tbItems.push(triggerTpl({
                    'ref': itemToAdd,
                    'icon': this._getIconForCommand(itemToAdd),
                    'addClasses': addClasses,
                    'tooltip': CUI.rte.Utils.i18n('popover.trigger.plugins.' + tooltip),
                    'variant': 'quiet' // (tbId === 'inline' ? 'secondary' : 'quiet')
                  }));
                }
              } else if (itemToAdd !== '-') {
                // toolbar-separators have been removed.
                // ignore '-' for backwards compatibility of configuration
                // regular item
                var element = getItem(itemToAdd);
                if (element &&
                  featureEnabled(element.plugin, element.command)) {
                  addClasses = this._getClassesForCommand(itemToAdd);
                  addClasses = (addClasses ? ' ' + addClasses : '');
                  element.icon = element.icon ||
                    this._getIconForCommand(element.ref);
                  element.addClasses = addClasses;
                  if (addClasses.indexOf('rte--trigger') !== -1) {
                    element.trigger = true;
                  }
                  element.variant = 'quiet'; // (tbId === 'inline' ? 'secondary' : 'quiet');
                  tbItems.push(itemTpl(element));
                }
              }
            }
          }
          // popovers
          if (popoverDefs) {
            com.removeJcrData(popoverDefs);
            for (var p in popoverDefs) {
              if (popoverDefs.hasOwnProperty(p)) {
                poItems = [];
                var popoverToProcess = popoverDefs[p];
                var poItemDefs = popoverToProcess.items;
                var popover = popoverTpl({
                  'ref': popoverToProcess.ref
                });
                if (CUI.rte.Utils.isString(poItemDefs)) {
                  createDynamicPopover(poItemDefs);
                  popover.childNodes[0].content.appendChild(poItems[0]);
                } else {
                  var poItemCnt = poItemDefs.length;
                  for (var pi = 0; pi < poItemCnt; pi++) {
                    createPopoverItem(poItemDefs[pi]);
                  }
                  popover.childNodes[0].content.appendChild(popovercontentTpl({'popoverItems': poItems}));
                }
                popovers.push(popover);
              }
            }
          }

          // add representation
          toolbars.push({
            'id': tbId,
            'toolbar': toolbarTpl({
              'toolbarItems': tbItems
            }),
            'popovers': popovers
          });
        }
      }

      var $toolbar = $(Coral.templates.RichTextEditor['tb_container']({
        'toolbars': toolbars
      }));
      var $ui = CUI.rte.UIUtils.createOrGetUIContainer($editable);
      $ui.append($toolbar);
    },

    // Toolbar management --------------------------------------------------------------

    /**
     * Notify all elements to use the passed toolbar.
     * @param {CUI.rte.ui.Toolbar} toolbar The toolbar to use
     * @param {Boolean} skipHandlers true to skip attaching handlers to buttons
     */
    notifyToolbar: function (toolbar, skipHandlers) {
      var groupCnt = this.groups.length;
      for (var groupIndex = 0; groupIndex < groupCnt; groupIndex++) {
        var groupElements = this.groups[groupIndex].elements;
        var elCnt = groupElements.length;
        for (var elIndex = 0; elIndex < elCnt; elIndex++) {
          var element = groupElements[elIndex].def;
          var toolbarDef = element.createToolbarDef();
          if (toolbarDef !== null && toolbarDef !== undefined) {
            element.notifyToolbar(toolbar, skipHandlers);
          }
        }
      }
    },

    /**
     * Create the abstracted toolbar.
     * @return {CUI.rte.ui.Toolbar} The toolbar
     * @ignore
     */
    createToolbar: function (options) {
      var com = CUI.rte.Common;
      var toolbarItems = [];
      var elements = [];
      var elementMap = {};
      var groupCnt = this.groups.length;

      // create data model
      var hasMembers = false;
      for (var groupIndex = 0; groupIndex < groupCnt; groupIndex++) {
        var groupElements = this.groups[groupIndex].elements;
        var elCnt = groupElements.length;
        for (var elIndex = 0; elIndex < elCnt; elIndex++) {
          var element = groupElements[elIndex].def;
          if ((elIndex === 0) && hasMembers) {
            toolbarItems.push('-');
            hasMembers = false;
          }
          var toolbarDef = element.createToolbarDef();
          if (toolbarDef !== null && toolbarDef !== undefined) {
            if (!CUI.rte.Utils.isArray(toolbarDef)) {
              toolbarDef = [toolbarDef];
            }
            var itemCnt = toolbarDef.length;
            for (var i = 0; i < itemCnt; i++) {
              var def = toolbarDef[i];
              toolbarItems.push(def);
              elementMap[def.id] = def;
            }
            elements.push(element);
            hasMembers = true;
          }
        }
      }

      // register additional/override existing icons, if available
      var uiSettings = this._getUISettings(options);
      if (uiSettings && uiSettings.hasOwnProperty('icons')) {
        this._registerIcons(uiSettings['icons']);
        delete uiSettings['icons'];
      }
      if (uiSettings && uiSettings.hasOwnProperty('additionalClasses')) {
        this._registerAllAdditionalClasses(uiSettings['additionalClasses']);
        delete uiSettings['additionalClasses'];
      }

      // attach model to UI/create UI from model
      var $editable = options.$editable;
      var $toolbar = CUI.rte.UIUtils.getToolbar($editable, options.tbType);
      var elementCnt = elements.length;
      if (!$toolbar) {
        // create new toolbar if none is present yet
        this._buildToolbar($editable, elements, options);
      }

      // use existing/newly created toolbar
      var toolbar = new CUI.rte.ui.cui.ToolbarImpl(elementMap, $editable,
        options.tbType, options.isFullScreen || options.useFixedInlineToolbar || options.isSticky);
      for (var e = 0; e < elementCnt; e++) {
        elements[e].notifyToolbar(toolbar);
      }
      toolbar.createPopoverTriggerToElementMapping();

      // add marker class for touch/desktop usage
      var $ui = CUI.rte.UIUtils.createOrGetUIContainer($editable);
      if (com.ua.isTouch && !$ui.hasClass('is-touch')) {
        $ui.addClass('is-touch');
      }
      if (!com.ua.isTouch && !$ui.hasClass('is-desktop')) {
        $ui.addClass('is-desktop');
      }

      return toolbar;
    },


    // Creating elements -------------------------------------------------------------------

    createElement: function (id, plugin, toggle, tooltip, css, cmdDef) {
      return new CUI.rte.ui.cui.ElementImpl(id, plugin, toggle, tooltip, css,
        cmdDef);
    },

    createParaFormatter: function (id, plugin, tooltip, formats) {
      return new CUI.rte.ui.cui.ParaFormatterImpl(id, plugin, false, tooltip, false,
        undefined, formats);
    },

    createStyleSelector: function (id, plugin, tooltip, styles) {
      return new CUI.rte.ui.cui.StyleSelectorImpl(id, plugin, false, tooltip, false,
        undefined, styles);
    }

  });

  CUI.rte.ui.cui.DEFAULT_UI_SETTINGS = {
    'inline': {
      // TODO adjust to final decision of default inline toolbar settings
      'toolbar': [
        '#format',
        '#justify',
        '#lists',
        'links#modifylink',
        'links#unlink',
        'table#createoredit',
        'fullscreen#start',
        'control#close',
        'control#save'
      ],
      'popovers': {
        'format': {
          'ref': 'format',
          'items': [
            'format#bold',
            'format#italic',
            'format#underline'
          ]
        },
        'justify': {
          'ref': 'justify',
          'items': [
            'justify#justifyleft',
            'justify#justifycenter',
            'justify#justifyright'
          ]
        },
        'lists': {
          'ref': 'lists',
          'items': [
            'lists#unordered',
            'lists#ordered',
            'lists#outdent',
            'lists#indent'
          ]
        },
        'styles': {
          'ref': 'styles',
          'items': 'styles:getStyles:styles-pulldown'
        },
        'paraformat': {
          'ref': 'paraformat',
          'items': 'paraformat:getFormats:paraformat-pulldown'
        }
      }
    },
    'fullscreen': {
      'toolbar': [
        'format#bold',
        'format#italic',
        'format#underline',
        'subsuperscript#subscript',
        'subsuperscript#superscript',
        'edit#cut',
        'edit#copy',
        'edit#paste-default',
        'edit#paste-plaintext',
        'edit#paste-wordhtml',
        'links#modifylink',
        'links#unlink',
        'links#anchor',
        'findreplace#find',
        'findreplace#replace',
        'undo#undo',
        'undo#redo',
        'justify#justifyleft',
        'justify#justifycenter',
        'justify#justifyright',
        'lists#unordered',
        'lists#ordered',
        'lists#outdent',
        'lists#indent',
        'table#createoredit',
        'image#imageProps',
        'spellcheck#checktext',
        'generichtml#generichtml',
        'misctools#specialchars',
        'misctools#sourceedit',
        '#styles',
        '#paraformat',
        'fullscreen#finish'
      ],
      'popovers': {
        'styles': {
          'ref': 'styles',
          'items': 'styles:getStyles:styles-pulldown'
        },
        'paraformat': {
          'ref': 'paraformat',
          'items': 'paraformat:getFormats:paraformat-pulldown'
        }
      }
    },
    'tableEditOptions': {
      'toolbar': [
        'table#insertcolumn-before',
        'table#insertcolumn-after',
        'table#removecolumn',
        'table#insertrow-before',
        'table#insertrow-after',
        'table#removerow',
        'table#mergecells-right',
        'table#mergecells-down',
        'table#mergecells',
        'table#splitcell-horizontal',
        'table#splitcell-vertical',
        'table#selectrow',
        'table#selectcolumn',
        'table#ensureparagraph',
        'table#modifytableandcell',
        'table#removetable',
        'undo#undo',
        'undo#redo',
        'table#exitTableEditing'
      ]
    }
  };

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  /**
   * @class CUI.rte.ui.cui.CmItemImpl
   * @private
   */
  CUI.rte.ui.cui.CmItemImpl = new Class({

    toString: 'CmItemImpl',

    extend: CUI.rte.ui.CmItem,

    /**
     * @cfg {Object} text Descriptive text for the context menu item
     * @ignore
     */
    text: null,

    /**
     * The selection context (contains selection definition + node list represented by
     * the selection).
     * @type Object
     * @private
     */
    selectionContext: null,

    /**
     * The edit context to be used
     * @type CUI.rte.EditContext
     * @private
     */
    editContext: null,


    construct: function (config) {
      // TODO ...
      CUI.rte.Utils.apply(this, config);
    },

    build: function (items, editorKernel, editContext, selectionContext) {
      this.editorKernel = editorKernel;
      this.selectionContext = selectionContext;
      this.editContext = editContext;
      // TODO ...
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  /**
   * @class CUI.rte.ui.ext.CmSeparatorImpl
   * @private
   */
  CUI.rte.ui.cui.CmSeparatorImpl = new Class({

    toString: 'CmSeparatorImpl',

    extend: CUI.rte.ui.CmSeparator,

    build: function (items) {
      // TODO implement
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.CuiContextMenuBuilder = new Class({

    toString: 'CuiContextMenuBuilder',

    extend: CUI.rte.ui.ContextMenuBuilder,


    construct: function (editorKernel) {
      // TODO ...?
    },

    build: function (selectionContext, context) {
      // returning undefined means that we don't use a context menu
      return undefined;
    },

    createItem: function (config) {
      return new CUI.rte.ui.cui.CmItemImpl(config);
    },

    createSeparator: function () {
      return new CUI.rte.ui.cui.CmSeparatorImpl();
    },

    showAt: function (x, y) {
      // TODO ...?
    },

    hideAll: function () {
      // TODO ...?
    },

    isVisible: function () {
      return false;
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.Mask = new Class({

    $mask: null,

    show: function () {
      // ignore on touch devices - will not work; SafariMobile screws up completely
      if (!CUI.rte.Common.ua.isTouch) {
        var $body = $('body');
        this.$mask = $('<div></div>');
        this.$mask.addClass('rte-dialog-mask');
        var maskHeight = document.body.scrollHeight;
        this.$mask.height(maskHeight);
        $body.append(this.$mask);
      }
    },

    hide: function () {
      if (!CUI.rte.Common.ua.isTouch) {
        this.$mask.off('click.rte-dialog-mask');
        this.$mask.remove();
      }
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  function requiresFocus(dom) {
    var $dom = $(dom);
    return $dom.is('input[is="coral-textfield"]') || $dom.is('.coral-SelectList-item') || $dom.is('.coral-Select-select--native');
  }

  function requiresEvent(dom) {
    var $dom = $(dom);
    return $dom.is('input') || $dom.is('button') ||
      $dom.is('span.coral-Checkbox-checkmark');
  }

  CUI.rte.ui.cui.AbstractBaseDialog = new Class({

    $container: null,

    /*
    Dialog content dom to appened in popover content
     */
    content: null,

    $dialog: null,

    mask: null,

    editorKernel: null,

    objToEdit: null,

    range: null,

    isSuspended: false,

    restoreSelectionOnHide: false,

    _elements: {},

    _command: undefined,

    /**
     * @private
     */
    getTrigger: function() {
      if (!this.editorKernel || !this._command) {
        return;
      }
      return this.editorKernel.getToolbar().getToolbar().parent().find(
         'button[data-action=\'' + this._command + '\']');
    },

    /**
     * @private
     */
    getPopoverManager: function() {
      if (!this.editorKernel) {
        return;
      }
      return this.editorKernel.toolbar.popover;
    },

    attach: function (config, $container, editorKernel, enforceCreation) {
      this.$container = $container;
      this.editorKernel = editorKernel;
      this.setRestoreSelectionOnHide(true);
      this._command = config.parameters.command;
      var mode = config.mode;
      var dataType = this.getDataType(config);
      this.$dialog = CUI.rte.UIUtils.getDialog(dataType, mode, this.$container);
      if (enforceCreation && this.$dialog.length) {
        this.$dialog.remove();
        this.$dialog = CUI.rte.UIUtils.getDialog(dataType, mode, this.$container);
      }
      if (!this.$dialog.length) {
        // if dialog is not available (for example, provided in the markup), create
        // it by using an appropriate Domly template
        this.$dialog = $(Coral.templates.RichTextEditor['popover']({
          'isDialog': true,
          'dataType': dataType
        }));
        var dialogContent;
        if (Coral.templates.RichTextEditor['dlg_' + dataType]) {
          dialogContent = Coral.templates.RichTextEditor['dlg_' + dataType].call(this._elements, config);
        } else if (CUI.rte.templates['dlg-' + dataType]) {
          dialogContent = $(CUI.rte.Templates['dlg-' + dataType](config))[0];
        }
        this.$dialog[0].childNodes[0].content.appendChild(this.content? this.content: dialogContent);
        var space = mode || 'global';
        var $dlgSpace = CUI.rte.UIUtils.getSpace(space, $container);
        $dlgSpace.append(this.$dialog);
        // to ensure this.$dialog is a DOM node not a document fragment
        this.$dialog = $dlgSpace.children().last();
      }
      var self = this;
      this.$dialog.finger('click.rte-dialog', function (e) {
        var focusRequired = requiresFocus(e.target);
        var eventRequired = requiresEvent(e.target);
        if (!focusRequired && !self.isSuspended) {
          self.editorKernel.focus();
          if (self.range) {
            CUI.rte.Selection.selectRangeBookmark(
              self.editorKernel.getEditContext(), self.range);
          }
        } else if (!focusRequired && !eventRequired) {
          CUI.rte.UIUtils.killEvent(e);
          if (!focusRequired) {
            self.editorKernel.focus();
          }
        }
      });
      this.$dialog.on('click.rte-dialog', 'button[data-type=\'apply\']',
        function (e) {
          self.apply();
          e.preventDefault();
          e.stopPropagation();
        });
      this.$dialog.on('click.rte-dialog', 'button[data-type=\'cancel\']',
        function (e) {
          self.cancel();
          e.preventDefault();
          e.stopPropagation();
        });
      this.mask = new CUI.rte.ui.cui.Mask();
      this.initialize(config);
    },

    detach: function () {
      this.$dialog.off('click.rte-dialog');
    },

    initialize: function (config) {
      // may be overridden for additional dialog initialization
    },

    show: function () {
      this.range = CUI.rte.Selection.createRangeBookmark(
        this.editorKernel.getEditContext());
      var popoverManager = this.getPopoverManager();
      var isSelfTriggered = popoverManager.isShown(this.$dialog);
      var toolbar = this.editorKernel.toolbar;
      popoverManager.hide(true);
      if (this.$dialog && !isSelfTriggered) {
        var self = this;
        popoverManager.use(this.$dialog, this.getTrigger(), toolbar.getToolbar(),
          function () {
            self.cancel();
          });
        this.editorKernel.lock();
        this.editorKernel.fireUIEvent('dialogshow');
        // TODO mask is currently on top of everything - dialog included
        // this.mask.show();
        // maually do the layout - is required here because the editor is already
        // locked, so automatic update will not work
        toolbar.triggerUIUpdate();
        this.onShow();
      } else if (isSelfTriggered) {
        this.editorKernel.focus();
        this.editorKernel.unlock();
        CUI.rte.Selection.selectRangeBookmark(this.editorKernel.getEditContext(),
          this.range);
        this.editorKernel.fireUIEvent('dialoghide');
      }
    },

    hide: function () {
      this.getPopoverManager().hide();
      this.editorKernel.focus();
      this.editorKernel.unlock();
      if (this.restoreSelectionOnHide) {
        CUI.rte.Selection.selectRangeBookmark(this.editorKernel.getEditContext(),
          this.range);
      }
      this.editorKernel.fireUIEvent('dialoghide');
      // TODO mask is currently on top of everything - dialog included
      // this.mask.hide();
      // hide the toolbar temporarily on touch devices, as the device will most
      // likely do some screen updates immediately after the command is executed and
      // the dialog is hidden - so this should result in a less disruptive UI behavior
      var tb = this.editorKernel.toolbar;
      if (CUI.rte.Common.ua.isTouch && !tb._isSticky) {
        tb.hideTemporarily();
      }
      this.onHide();
    },

    isShown: function () {
      return this.getPopoverManager().isShown(this.$dialog);
    },

    getDataType: function () {
      throw new Error('Dialog does not implement #getDataType');
    },

    apply: function () {
      this.hide();
    },

    cancel: function () {
      this.hide();
    },

    onShow: function () {
      // method is called after the dialog is shown and can be overridden if necessary
    },

    onHide: function () {
      // method is called after the dialog is hidden and can be overridden if necessary
    },

    transparent: function () {
      this.$dialog.addClass('transparent');
    },

    opaque: function () {
      this.$dialog.removeClass('transparent');
    },

    suspend: function (isSuspended) {
      this.isSuspended = isSuspended;
    },

    setRestoreSelectionOnHide: function (restoreOnHide) {
      this.restoreSelectionOnHide = restoreOnHide;
    },

    mustRecreate: function () {
      return false;
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.AbstractDialog = new Class({

    extend: CUI.rte.ui.cui.AbstractBaseDialog,

    config: null,

    dialogHelper: null,

    range: null,

    mask: null,

    /**
     * @private
     */
    editorKernel: null,

    initializeEdit: function (editorKernel, objToEdit, applyFn) {
      this.objToEdit = objToEdit;
      this.applyFn = applyFn;
      // TODO adjust to custom config (post 5.6.1)
      this.fromModel();
    },

    getFieldByType: function (name) {
      var $field = this.$dialog.find('*[data-type=\'' + name + '\']');
      if ($field.length > 0) {
        return $field;
      }
      return undefined;
    },

    /**
     * Gets a dialog parameter by its name.
     * @param {String} name The parameter's name
     * @return {Object} The parameter's value; null if no such parameter is defined
     */
    getParameter: function (name) {
      var params = this.config.parameters;
      if (params && params[name]) {
        return params[name];
      }
      return undefined;
    },

    apply: function () {
      if (this.validate()) {
        this.toModel();
        this.hide();
        if (this.applyFn) {
          this.applyFn(this.editorKernel.getEditContext(), this.objToEdit);
        }
      }
    },

    initialize: function (config) {
      this.config = config;
    },

    preprocessModel: function () {
      // this method may be overridden by implementing dialogs to pre-process
      // the model before the fromModel()-methods are being executed
    },

    dlgFromModel: function () {
      // this method may be overridden by implementing dialogs to transfer basic data
      // from model to view
    },

    fromModel: function () {
      this.preprocessModel();
      // TODO handle additional fields (backwards compatibility)
      this.dlgFromModel();
    },

    validate: function () {
      // may be overridden by implementing dialog
      return true;
    },

    dlgToModel: function () {
      // this method may be overridden by implementing dialogs to transfer basic data
      // from view to model
    },

    postprocessModel: function () {
      // this method may be overridden by implementing dialogs to post-process
      // the model after all toModel()-methods have been executed
    },

    toModel: function () {
      this.dlgToModel();
      // TODO handle additional fields (backwards compatibility)
      this.postprocessModel();
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2016 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/* global Class: true */
/* jshint strict: false */
(function($, CUI) {
  //'use strict';

  CUI.rte.ui.cui.DefaultDialog = new Class({

    extend: CUI.rte.ui.cui.AbstractDialog,

    getDataType: function() {
      return 'default';
    },

    initialize: function(config) {
      this.config = config;
      this.context = this.editorKernel.getEditContext();
      this.touchScrollLimiter = this.context.getState('CUI.touchScrollLimiter');
    },

    onShow: function() {
      if (!CUI.rte.Common.ua.isTouch) {
        var self = this;
        window.setTimeout(function() {
          var items = self.config.dialogItems;
          if (items && (items.length > 0)) {
            var id = items[0].item.id;
            if (id) {
              $('#' + id).focus();
            }
          }
        }, 1);
      }
      if (this.touchScrollLimiter) {
        this.touchScrollLimiter.suspend();
      }
    },

    onHide: function() {
      if (this.touchScrollLimiter) {
        this.touchScrollLimiter.reactivate();
      }
      if (this.config.parameters && this.config.parameters.selfDestroy) {
        if (this.$dialog) {
          this.$dialog.remove();
          this.$dialog = null;
        }
      }
    },

    preprocessModel: function() {
      // nothing to do
    },

    _executeOnItems: function(fn) {
      var items = this.config.dialogItems;
      if (items && items.length) {
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          if (item.item.id) {
            var $field = $('#' + item.item.id);
            fn(item, $field.get(0));
          }
        }
      }
    },

    dlgFromModel: function() {
      var self = this;
      this._executeOnItems(function(item, field) {
        if (item.fromModel) {
          item.fromModel(self.objToEdit, field);
        }
      });
    },

    validate: function() {
      var isValid = true;
      this._executeOnItems(function(item, field) {
        if (item.validate) {
          if (!item.validate(field)) {
            isValid = false;
          }
        }
      });
      return isValid;
    },

    dlgToModel: function() {
      var self = this;
      this._executeOnItems(function(item, field) {
        if (item.toModel) {
          item.toModel(self.objToEdit, field);
        }
      });
    },

    postprocessModel: function() {
      // nothing to do
    }

  });

}(window.jQuery, window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.LinkBaseDialog = new Class({

    extend: CUI.rte.ui.cui.AbstractDialog,

    toString: 'LinkBaseDialog',

    getDataType: function () {
      return 'link';
    },

    handleLinkSuccess: function (href) {
      if (href) {
        this.hrefField.value = href;
      }
    },

    // config.linkOptionsLoader - to load options for path browser to complete internal links
    initialize: function (config) {
      this.config = config;
      this.context = this.editorKernel.getEditContext();
      this.touchScrollLimiter = this.context.getState('CUI.touchScrollLimiter');

      this.hrefField = this.$dialog.find('input.rte-linkfield[is="coral-textfield"]')[0];

      this._elements.targetSelect.items.getAll()[0].selected = true;
      // Cancel all keydown events
      this.$dialog.on('keydown', this.handleKeyDown);
    },

    onShow: function () {
      if (!CUI.rte.Common.ua.isTouch) {
        var self = this;
        window.setTimeout(function () {
          $(self.hrefField).focus();
        }, 1);
      }
      if(this.touchScrollLimiter) {
        this.touchScrollLimiter.suspend();
      }
    },

    onHide: function() {
      if(this.touchScrollLimiter) {
        this.touchScrollLimiter.reactivate();
      }
    },

    handleKeyDown: function (event) {
      event.stopPropagation();
    },

    preprocessModel: function () {
      if (this.objToEdit && this.objToEdit.dom) {
        this.objToEdit.href = CUI.rte.HtmlRules.Links.getLinkHref(
          this.objToEdit.dom);
        var com = CUI.rte.Common;
        var attribNames = com.getAttributeNames(this.objToEdit.dom, false,
          function (dom, attribName, attribNameLC) {
            // exclude href, rte_href & target from generic attribute handling,
            // as they are handled explicitly and not generically
            return attribNameLC === com.HREF_ATTRIB || attribNameLC === 'href' ||
              attribNameLC === 'target';
          });
        for (var i = 0; i < attribNames.length; i++) {
          var attribName = attribNames[i];
          var value = com.getAttribute(this.objToEdit.dom, attribName);
          if (typeof value !== 'undefined') {
            this.objToEdit.attributes[attribName] = value;
          }
        }
      }
    },

    dlgFromModel: function () {

      var value;
      if (this.hrefField) {
        value = '';
        if (this.objToEdit) {
          var href = this.objToEdit.href;
          if (href) {
            value = href;
          }
        }
        this.hrefField.value = value;
      }
      var targetSelect = this._elements.targetSelect;
      var target = (this.objToEdit && this.objToEdit.target ?
        this.objToEdit.target.toLowerCase() : null);
      if (target) {
        targetSelect.items.getAll().forEach(function(elem, index) {
          if (elem.value === target) {
            elem.selected = true;
          }
        }, this);
      } else {
        targetSelect.items.getAll()[0].selected = true;
      }
      var titleField = this.getFieldByType('title');
      if (titleField) {
        value = (this.objToEdit && this.objToEdit.attributes &&
        this.objToEdit.attributes['title'] ?
          this.objToEdit.attributes['title'] : null);
        titleField.val(value);
      }
    },

    validate: function () {

      if (this.hrefField) {
        var href = this.hrefField.value;
        if (href && (href.length > 0)) {
          return true;
        }
      }
      return false;
    },

    dlgToModel: function () {
      if (this.objToEdit) {

        if (this.hrefField) {
          var href = this.hrefField.value;
          if (href) {
            this.objToEdit.href = href;
          }
        }
        var targetSelect = this._elements.targetSelect;
        var target = targetSelect.value;
        if (target) {
          this.objToEdit.target = target;
        } else {
          this.objToEdit.target = null;
        }
        var titleField = this.getFieldByType('title');
        if (titleField) {
          var titleVal = titleField.val();
          if (titleVal !== null && titleVal !== undefined) {
            this.objToEdit.attributes['title'] = titleVal;
          }
        }
      }
    },

    postprocessModel: function () {
      var linkRules = this.getParameter('linkRules');
      if (linkRules) {
        linkRules.applyToObject(this.objToEdit);
      }
    }

  });


})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.AnchorDialog = new Class({

    extend: CUI.rte.ui.cui.AbstractBaseDialog,

    toString: 'AnchorDialog',

    $idField: null,

    $removeButton: null,

    $removeColumn: null,

    id: null,

    getDataType: function () {
      return 'anchor';
    },

    initialize: function (config) {
      var self = this;
      this.applyFn = config.execute;
      this.$idField = this.$container.find('input[data-type=\'id\']');
      this.$removeButton = this.$container.find('button[data-type=\'delete\']');
      this.$removeColumn = this.$removeButton.parent('.rte-dialog-column');
      this.$removeButton.on('click', function (e) {
        self.hide();
        e.stopPropagation();
        config.execute(undefined);
      });
    },

    setAnchor: function (anchor) {
      if (anchor) {
        this.$removeColumn[0].removeAttribute('hidden');
      } else if (!this.$removeColumn[0].hasAttribute('hidden')) {
        this.$removeColumn[0].setAttribute('hidden', 'true');
      }
      this.$idField.val(anchor.id);
    },

    getid: function () {
      var id = null;
      var idValue = this.$idField.val();
      if (idValue.length > 0) {
        id = idValue;
      }
      return id;
    },

    resetValues: function () {
      if (!this.$removeColumn[0].hasAttribute('hidden')) {
        this.$removeColumn[0].setAttribute('hidden', 'true');
      }
      this.$idField.val('');
    },

    apply: function () {
      this.applyFn(this.getid());
      this.inherited(arguments);
    },

    onShow: function () {
      if (!CUI.rte.Common.ua.isTouch) {
        var self = this;
        window.setTimeout(function () {
          self.$idField.focus();
        });
      }
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  function disableButton($btn, isDisabled) {
    if ($btn && $btn.length) {
      $btn[0].disabled = isDisabled;
    }
  }

  function isDisabled($btn) {
    return $btn.prop('disabled');
  }

  CUI.rte.ui.cui.FindReplaceDialog = new Class({

    extend: CUI.rte.ui.cui.AbstractBaseDialog,

    toString: 'FindReplaceDialog',

    isReplace: false,

    canReplace: false,

    currentFindTerm: undefined,


    _adjustButtonState: function () {
      var text = this.$findField.val();
      var isEnabled = (text.length > 0);
      disableButton(this.$findButton, !isEnabled);
      disableButton(this.$replaceButton,
        !(isEnabled && this.canReplace && (this.currentFindTerm === text)));
      disableButton(this.$replaceAllButton, !isEnabled);
    },

    getDataType: function (config) {
      return (config.isReplace ? 'replace' : 'find');
    },

    initialize: function (config) {
      this._elements.matchCaseBox.label.textContent = CUI.rte.Utils.i18n('dialogs.find.matchCase');
      this.isReplace = config.isReplace;
      this.findFn = config.findFn;
      this.replaceFn = config.replaceFn;
      var self = this;
      this.$findField = this.$dialog.find('input[data-type=\'find\']');
      this.$findField.on('keyup', function (e) {
        self._adjustButtonState();
      });
      this.$dialog.on('focus', 'input[is="coral-textfield"]', function (e) {
        self.opaque();
        self.setRestoreSelectionOnHide(true);
      });
      this.$replaceField = this.$dialog.find('input[data-type=\'replace\']');
      this.$findButton = this.$dialog.find('button[data-type=\'execFind\']');
      this.$findButton[0].label.textContent = CUI.rte.Utils.i18n('dialog.replace.findButton');
      this.$findButton.on('click', function (e) {
        if (!isDisabled(self.$findButton)) {
          // on find, we remember the actual find term (as we should deactivate
          // "Replace" if the term changes to avoid inconsistencies) and hide
          // any "end of text"-alerts that are currently present (because
          // "Find" starts a new search then)
          self.currentFindTerm = self.$findField.val();
          self.$dialog.find('coral-alert').hide();
          self.setRestoreSelectionOnHide(!self.applyDialog(self.findFn, null));
          e.preventDefault();
          self.transparent();
        }
        e.stopPropagation();
      });
      disableButton(this.$findButton, true);
      if (this.isReplace) {
        this.$replaceButton = this.$dialog.find(
          'button[data-type=\'execReplace\']');
        this.$replaceButton[0].label.textContent = CUI.rte.Utils.i18n('dialog.replace.replaceButton');
        this.$replaceButton.on('click', function (e) {
          if (!isDisabled(self.$replaceButton)) {
            self.applyDialog(self.replaceFn, {
              'replaceAll': false
            });
            e.preventDefault();
            self.transparent();
          }
          e.stopPropagation();
        });
        disableButton(this.$replaceButton, true);
        this.$replaceAllButton = this.$dialog.find(
          'button[data-type=\'execReplaceAll\']');
        this.$replaceAllButton[0].label.textContent = CUI.rte.Utils.i18n('dialog.replace.replaceAllButton');
        this.$replaceAllButton.on('click', function (e) {
          if (!isDisabled(self.$replaceAllButton)) {
            self.applyDialog(self.replaceFn, {
              'replaceAll': true
            });
            e.preventDefault();
          }
          e.stopPropagation();
        });
        disableButton(this.$replaceAllButton, true);
      }
    },

    setMode: function (isInitialFind, canReplace) {
      this.canReplace = canReplace;
      if (this.isReplace && this.$replaceButton) {
        disableButton(this.$replaceButton, !canReplace);
      }
      if (this.isReplace && this.$replaceAllButton) {
        disableButton(this.$replaceAllButton, !canReplace);
      }
    },

    focusFindField: function () {
      this.$findField.focus();
    },

    applyDialog: function (fn, options) {
      options = options || {};
      if (fn) {
        options.findText = this.$findField.val();
        options.matchCase = this._elements.matchCaseBox.checked;
        if (this.isReplace) {
          options.replaceText = this.$replaceField.val();
        }
        this.editorKernel.focus();
        return fn(this.editorKernel.getEditContext(), options, this);
      }
      return false;
    },

    onShow: function () {
      this._adjustButtonState();
      if (!CUI.rte.Common.ua.isTouch) {
        var self = this;
        window.setTimeout(function () {
          self.$findField.focus();
        }, 1);
      }
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {
  //'use strict';
  CUI.rte.ui.cui.ImagePropsDialog = new Class({

    extend: CUI.rte.ui.cui.AbstractDialog,

    toString: 'ImagePropsDialog',

    altString: '.rte-dialog--image .rte-dialog-column--alt',

    getDataType: function () {
      return 'image';
    },

    initialize: function (config) {
      this._elements.targetSelect.items.getAll()[0].selected = true;
      this.config = config;
    },

    /**
     * Fetch the alignment of the selected Image
     * @param selectedImageNode
     * @returns {string}
     */
    getCurrentAlignment: function (selectedImageNode) {
      var com = CUI.rte.Common;
      var style = com.getAttribute(selectedImageNode, 'style');
      if (style) {
        if (style.indexOf('float: left') !== -1) {
          return 'left';
        }
        else if (style.indexOf('float: right') !== -1) {
          return 'right';
        }
        else if (style.indexOf('float: inherit') !== -1) {
          return 'inherit';
        } else {
          return 'none';
        }
      }
      else {
        return 'none';
      }
    },

    onShow: function () {
      var altText = $(this.altString).find('input[data-type="alt"]');
      altText.val(this.objToEdit.getAttribute('alt'));
    },


    apply: function () {
      if (this.validate()) {
        this.toModel();
        this.hide();

        var altText = $(this.altString).find('input[data-type="alt"]');
        var text = altText.val();
        var props = {
          'alt': text
        };
        this.applyFn('image', props);
      }
      var alignment = {
        'style.float': 'none'
      };
      switch (this._elements.targetSelect.selectedItem.value) {
        case 'none':
          this.editorKernel.relayCmd('image', alignment);
          break;
        case 'left':
          alignment['style.float'] = 'left';
          this.editorKernel.relayCmd('image', alignment);
          break;
        case 'inherit':
          alignment['style.float'] = 'inherit';
          this.editorKernel.relayCmd('image', alignment);
          break;
        case 'right':
          alignment['style.float'] = 'right';
          this.editorKernel.relayCmd('image', alignment);
          break;
      }
    }
  });


})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.PasteDialog = new Class({

    extend: CUI.rte.ui.cui.AbstractDialog,

    toString: 'PasteDialog',

    $iframe: null,

    $pasteBox: null,

    $textArea: null,

    apply: function () {
      if (this.validate()) {
        this.toModel();
        this.hide();
        if (this.applyFn) {
          var isHtml = (this.config.type === 'iframe');
          var value = this.$pasteBox.val();
          var dom = null;
          if (isHtml) {
            // we are working in different document/window environments;
            // hence we'll have to move the DOM tree over to the editor's
            // document
            var pastedDom = this.$iframe.prop('contentWindow').document.body;
            dom = this.config.editContext.createElement('div');
            dom.innerHTML = pastedDom.innerHTML;
          }
          this.applyFn(this.config.editContext, value, isHtml, dom);
        }
      }
    },

    initialize: function (config) {
      if (config.type === 'iframe') {
        this.$iframe = this.$container.find('iframe');
        this.$pasteBox = this.$iframe;
      } else {
        this.$textArea = this.$container.find('textarea');
        this.$pasteBox = this.$textArea;
      }
      this.config = config;
      this.applyFn = config.pasteFn;
    },

    getDataType: function (config) {
      return (config.type === 'iframe' ? 'pastewordhtml' : 'pasteplaintext');
    },

    mustRecreate: function () {
      return true;
    },

    onShow: function () {
      if (this.config.type === 'iframe') {
        this.$iframe.attr('name', 'rte-paste-html-' + Date.now());
        this.$iframe.attr('frameBorder', '0');
        // jshint scripturl:true
        this.$iframe.attr('src', 'javascript:;'); //TODO : Add a check for IE
        var win = this.$iframe.prop('contentWindow');
        win.document.open();
        win.document.write('<html><head><style type=\'text/css\'>' +
          'body{border:.0625rem solid #2d2d2d;margin:0;padding:3px;cursor:text;height:94%;' +
          'font-family:sans-serif;font-size:13px}' +
          'body:focus{border-color:#3287d2}' +
          '</style></head>' +
          '<body></body></html>');
        win.document.designMode = 'on';
        win.document.close();
      } else {
        this.$pasteBox.click(function (e) {
          e.stopPropagation();
        });
      }
      if (!CUI.rte.Common.ua.isTouch) {
        var self = this;
        window.setTimeout(function () {
          self.$pasteBox.focus();
        });
      }
    },

    setValue: function (value) {
    }
  });


})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  var SPECIAL_CHARS_PER_ROW = 9;

  CUI.rte.ui.cui.SpecialCharsDialog = new Class({

    extend: CUI.rte.ui.cui.AbstractBaseDialog,

    toString: 'SpecialCharsDialog',

    getDataType: function () {
      return 'specialchars';
    },

    initialize: function (config) {
      this.chars = config.chars;
      // TODO use theming, etc.
      config.tableCls = 'rte-dialog-innerTable';
      config.rowCls = 'rte-dialog-columnContainer';
      config.cellCls = 'rte-dialog-column';
      var charSelector = '';
      var charCnt = 0;
      for (var cName in this.chars) {
        if (this.chars.hasOwnProperty(cName)) {
          var cDef = this.chars[cName];
          var col;
          if (cDef.entity) {
            var encodedEntity = CUI.rte.Utils.htmlEncode(cDef.entity).replace(/&amp;/g,'&');
            col = charCnt % SPECIAL_CHARS_PER_ROW;
            if (col === 0) {
              charSelector += '<div';
              if (config.rowCls) {
                charSelector += ' id=\'' + config.rowCls + '\'';
              }
              charSelector += '>';
            }
            charSelector += '<div data-entity=\'' + encodedEntity + '\'';
            if (config.cellCls !== null && config.cellCls !== undefined) {
              charSelector += ' class=\'' + config.cellCls + '\'';
            }
            charSelector += '>';
            charSelector += encodedEntity;
            charSelector += '</div>';
            if (col === (SPECIAL_CHARS_PER_ROW - 1)) {
              charSelector += '</div>';
            }
            charCnt++;
          } else if ((cDef.rangeStart) && (cDef.rangeEnd)) {
            for (var cCode = cDef.rangeStart; cCode <= cDef.rangeEnd; cCode++) {
              var entity = '&#' + cCode + ';';
              col = charCnt % SPECIAL_CHARS_PER_ROW;
              if (col === 0) {
                charSelector += '<div';
                if (config.rowCls) {
                  charSelector += ' id=\'' + config.rowCls + '\'';
                }
                charSelector += '>';
              }
              charSelector += '<div data-entity=\'' + entity + '\'';
              if (config.cellCls !== null && config.cellCls !== undefined) {
                charSelector += ' class=\'' + config.cellCls + '\'';
              }
              charSelector += '>';
              charSelector += entity;
              charSelector += '</div>';
              if (col === (SPECIAL_CHARS_PER_ROW - 1)) {
                charSelector += '</div>';
              }
              charCnt++;
            }
          }
        }
      }
      this.$selector = this.$dialog.find(
        '.rte-specialchars-selector .' + config.tableCls);
      this.$selector.html(charSelector);
      var self = this;
      this.$selector.on('click', 'div.' + config.cellCls, function (e) {
        var toInsert = $(e.target).data('entity');
        var dm = self.editorKernel.getDialogManager();
        dm.hide(self);
        // TODO use correct caret position
        self.editorKernel.focus();
        config.insertCharacter(toInsert);
        e.stopPropagation();
        e.preventDefault();
      });
      var context = self.editorKernel.getEditContext();
      var tsl = context.getState('CUI.touchScrollLimiter');
      this.$dialog.on('show', function () {
        if (tsl) {
          tsl.suspend();
        }
      });
      this.$dialog.on('hide', function () {
        if (tsl) {
          tsl.reactivate();
        }
      });
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.SpellcheckerDialog = new Class({

    extend: CUI.rte.ui.cui.AbstractDialog,

    toString: 'SpellcheckerDialog',

    getDataType: function () {
      return 'spellchecker';
    },

    initialize: function (config) {
      this.config = config;
      var suggestions = config.suggestions;
      var $spellSuggestionButtons = this.$dialog.find('.rte-dialog-column--spellchecker .rte-dialogButton');
      $.each($spellSuggestionButtons, function (index, value) {
        value.label.textContent = suggestions[index].display;
      });
    },

    mustRecreate: function () {
      return true;
    }

  });


})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.TablePropsDialog = new Class({

    extend: CUI.rte.ui.cui.AbstractDialog,

    toString: 'TablePropsDialog',

    propertyItems: null,

    $columns: null,

    $rows: null,

    $width: null,

    $height: null,

    $cellPadding: null,

    $cellSpacing: null,

    $border: null,

    $caption: null,

    apply: function () {
      if (this.validate()) {
        this.toModel();
        this.editorKernel.getDialogManager().hide();
        if (this.applyFn) {
          this.applyFn(this.config.cmd, this.createExecutionConfig(), this.editorKernel.getEditContext());
        }
      }
    },

    /**
     * @private
     */
    createExecutionConfig: function () {
      var execConfig = {};
      $.each(this.propertyItems, function (index, item) {
        if (item.length <= 0) {
          return;
        }
        var id = item.data().type;
        var value = item.val();
        if (value) {
          execConfig[id] = value;
        }
        return true;
      });
      return execConfig;
    },

    initialize: function (config) {
      this.$columns = this.$container.find('.rte-dialog--tableprops input[data-type=\'columns\']');
      this.$rows = this.$container.find('.rte-dialog--tableprops input[data-type=\'rows\']');
      this.$width = this.$container.find('.rte-dialog--tableprops input[data-type=\'width\']');
      this.$height = this.$container.find('.rte-dialog--tableprops input[data-type=\'height\']');
      this.$cellPadding = this.$container.find('.rte-dialog--tableprops input[data-type=\'cellpadding\']');
      this.$cellSpacing = this.$container.find('.rte-dialog--tableprops input[data-type=\'cellspacing\']');
      this.$border = this.$container.find('.rte-dialog--tableprops input[data-type=\'border\']');
      this.$caption = this.$container.find('.rte-dialog--tableprops input[data-type=\'caption\']');
      //Set property items. For header dropdown, CUI.Select is being used, so we need to add a custom
      //object for that which would be updated with new value of select whenever user selects something from
      //that dropdown. This object would be helpful in retrieving selected header value in createTableConfig
      //function.
      this.propertyItems = [this.$columns, this.$rows, this.$width, this.$height, this.$cellPadding, this.$cellSpacing,
        this.$border, this.$caption,
        {
          value: 'none',
          data: function () {
            return {type: 'header'};
          },
          val: function () {
            return this.value;
          },
          setVal: function (val) {
            this.value = val;
          }
        }
      ];
      //On header selection, update propertyItems with new value of header
      var self = this;
      this._elements.headerSelect
        .on('change', function (event) {
          $.each(self.propertyItems, function (index, item) {
            if (item.length <= 0) {
              return;
            }
            var id = item.data().type;
            if (id === 'header') {
              item.setVal(event.target.value);
            }
          });
        });
      this.config = config;
      this.applyFn = config.execFn;
    },

    getDataType: function () {
      return 'tableprops';
    },

    /**
     * @private
     */
    setValueForSelect: function (select, propertyId, value) {
      value = value ? value : 'none';
      select.items.getAll().forEach(function(elem, index) {
        if (elem.value === value) {
          elem.selected = true;
        }
      }, this);
      $.each(this.propertyItems, function (index, item) {
        if (item.length <= 0) {
          return;
        }
        var id = item.data().type;
        if (id === propertyId) {
          item.setVal(value);
        }
      });
    },

    onShow: function () {
      //reset dialog input values to defaults
      this.$columns.val('3');
      this.$rows.val('2');
      this.$width.val('');
      this.$height.val('');
      this.$cellPadding.val('1');
      this.$cellSpacing.val('0');
      this.$border.val('1');
      this.setValueForSelect(this._elements.headerSelect, 'header', 'none');
    }
  });


})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.TableAndCellPropsDialog = new Class({

    extend: CUI.rte.ui.cui.TablePropsDialog,

    toString: 'TableAndCellPropsDialog',

    /**
     * @private
     */

    $cellHeadersContainer: null,

    $cellIdContainer: null,

    $cellScopeContainer: null,

    cellType: null,

    cellScope: null,

    $cellWidth: null,

    $cellHeight: null,

    $cellHeaders: null,

    $cellId: null,

    getDataType: function () {
      return 'tableandcellprops';
    },

    // Override CUI.rte.ui.cui.TablePropsDialog#createExecutionConfig
    createExecutionConfig: function () {
      var id, value;
      var execConfig = CUI.rte.Utils.scope(this.superClass.createExecutionConfig, this)();
      if (this.cellType === 'th') {
        value = this.cellScope;
        if (value) {
          execConfig['cell-scope'] = value;
        }
        id = this.$cellId.data().type;
        value = this.$cellId.val();
        if (value) {
          execConfig[id] = value;
        }
        if (this.$hiddenHeaderSwitch[0].checked) {
          id = this.$hiddenHeaderSwitch.data().type;
          execConfig[id] = this.$hiddenHeaderSwitch[0].value;
        }
      } else {
        id = this.$cellHeaders.data().type;
        value = this.$cellHeaders.val();
        if (value) {
          execConfig[id] = value;
        }
      }
      return execConfig;
    },

    initialize: function (config) {
      var self = this;
      this._elements.tab1.label.textContent = CUI.rte.Utils.i18n('dialog.tableAndCellProps.cellProps');
      this._elements.tab2.label.textContent = CUI.rte.Utils.i18n('dialog.tableAndCellProps.tableProps');
      this._elements.widthToolTip.content.textContent = CUI.rte.Utils.i18n('dialog.tableAndCellProps.widthToolTip');
      this._elements.heightToolTip.content.textContent = CUI.rte.Utils.i18n('dialog.tableAndCellProps.heightToolTip');
      this._elements.widthToolTip.target = '_prev';
      this._elements.heightToolTip.target = '_prev';
      $(this._elements.panel1.content).append(this._elements.panel1content.childNodes);
      $(this._elements.panel2.content).append(this._elements.panel2content.childNodes);
      $(this._elements.panel1content).remove();
      $(this._elements.panel2content).remove();
      this.$width = this.$container.find('.rte-dialog--tableandcellprops input[data-type=\'width\']');
      this.$height = this.$container.find('.rte-dialog--tableandcellprops input[data-type=\'height\']');
      this.$cellPadding = this.$container.find('.rte-dialog--tableandcellprops input[data-type=\'cellpadding\']');
      this.$cellSpacing = this.$container.find('.rte-dialog--tableandcellprops input[data-type=\'cellspacing\']');
      this.$border = this.$container.find('.rte-dialog--tableandcellprops input[data-type=\'border\']');
      this.$caption = this.$container.find('.rte-dialog--tableandcellprops input[data-type=\'caption\']');
      this.$cellWidth = this.$container.find('.rte-dialog--tableandcellprops input[data-type=\'cell-width\']');
      this.$cellHeight = this.$container.find('.rte-dialog--tableandcellprops input[data-type=\'cell-height\']');
      this.$cellHeaders = this.$container.find('.rte-dialog--tableandcellprops input[data-type=\'cell-headers\']');
      this.$cellId = this.$container.find('.rte-dialog--tableandcellprops input[data-type=\'cell-id\']');
      this.$hiddenHeaderSwitch = this.$container.find('.rte-dialog--tableandcellprops .rte-Switch');
      this.$cellHeadersContainer = $('.rte-dialog.rte-dialog--tableandcellprops .rte-dialog-columnContainer--headerAttribute');
      this.$cellIdContainer = $('.rte-dialog.rte-dialog--tableandcellprops .rte-dialog-columnContainer--idAttribute');
      this.$cellScopeContainer = $('.rte-dialog.rte-dialog--tableandcellprops .rte-dialog-columnContainer--scopeAttribute');
      this.propertyItems = [this.$width, this.$height, this.$cellPadding, this.$cellSpacing, this.$border, this.$caption];
      this.propertyItems.push(this.$cellWidth);
      this.propertyItems.push(this.$cellHeight);
      this.propertyItems.push({
        value: 'none',
        data: function () {
          return {type: 'cell-align'};
        },
        val: function () {
          return this.value === 'none' ? CUI.rte.commands.Table.CONFIG_NONE : this.value;
        },
        setVal: function (val) {
          this.value = val;
        }
      });
      this.propertyItems.push({
        value: 'none',
        data: function () {
          return {type: 'cell-valign'};
        },
        val: function () {
          return this.value === 'none' ? CUI.rte.commands.Table.CONFIG_NONE : this.value;
        },
        setVal: function (val) {
          this.value = val;
        }
      });
      this.propertyItems.push({
        value: 'none',
        data: function () {
          return {type: 'cell-cellType'};
        },
        val: function () {
          return this.value === 'none' ? null : this.value;
        },
        setVal: function (val) {
          this.value = val;
        }
      });
      this._elements.panel1.setAttribute('selected', '');
        //On selection change, update propertyItems with new value of selections
      this._elements.cellHorizontalAlignmentSelect
        .on('change', function (event) {
          $.each(self.propertyItems, function (index, item) {
            if (item.length <= 0) {
              return;
            }
            var id = item.data().type;
            if (id === 'cell-align') {
              item.setVal(event.target.value);
            }
          });
        });

      //On selection change, update propertyItems with new value of selections
      this._elements.cellVerticalAlignmentSelect
        .on('change', function (event) {
          $.each(self.propertyItems, function (index, item) {
            if (item.length <= 0) {
              return;
            }
            var id = item.data().type;
            if (id === 'cell-valign') {
              item.setVal(event.target.value);
            }
          });
        });

      //On selection change, update propertyItems with new value of selections
      this._elements.cellTypeSelect
        .on('change', function (event) {
          $.each(self.propertyItems, function (index, item) {
            if (item.length <= 0) {
              return;
            }
            var id = item.data().type;
            if (id === 'cell-cellType') {
              item.setVal(event.target.value);
            }
            if (self.cellType !== event.target.value) {
              self.cellType = event.target.value;
              self.$cellHeadersContainer.toggle();
              self.$cellScopeContainer.toggle();
              self.$cellIdContainer.toggle();
            }
          });
        });
      //On selection change, update cellScope with new value of selection
      this._elements.scopeAttributeSelect
        .on('change', function (event) {
          self.cellScope = (event.target.value === 'none' ? CUI.rte.commands.Table.CONFIG_NONE : event.target.value);
        });
      this.config = config;
      this.applyFn = config.execFn;
    },

    onShow: function () {
      //set dialog input values to those obtained from table/cell being edited
      var table = this.editorKernel.queryState('table');
      var cell = this.editorKernel.queryState('modifycell');
      var com = CUI.rte.Common;
      this.cellType = com.isTag(cell, 'th') ? 'th' : 'td';
      var cellStyle = com.getAttribute(cell, 'style');
      var captionField = com.getChildNodesByType(table, 'caption');
      var caption = captionField.length > 0 ? captionField[0].innerHTML : null;
      this.$width.val(com.getAttribute(table, 'width'));
      this.$height.val(com.getAttribute(table, 'height'));
      this.$cellPadding.val(com.getAttribute(table, 'cellpadding'));
      this.$cellSpacing.val(com.getAttribute(table, 'cellspacing'));
      this.$border.val(com.getAttribute(table, 'border'));
      this.$caption.val(caption);
      this.$cellWidth.val(com.getAttribute(cell, 'width'));
      this.$cellHeight.val(com.getAttribute(cell, 'height'));
      this.$hiddenHeaderSwitch[0].checked = com.getAttribute(cell, 'hiddenheader');
      var align = null;
      if (cellStyle) {
        var styles = cellStyle.split(';');
        for (var i = 0; i < styles.length; i++) {
          if (styles[i].trim().indexOf('text-align') === 0) {
            align = styles[i].split(':')[1].trim();
          }
        }
      }
      this.setValueForSelect(this._elements.cellHorizontalAlignmentSelect, 'cell-align', align);
      this.setValueForSelect(this._elements.cellVerticalAlignmentSelect, 'cell-valign', com.getAttribute(cell, 'valign'));
      this.setValueForSelect(this._elements.cellTypeSelect, 'cell-cellType', com.isTag(cell, 'th') ? 'th' : 'td');
      if (this.cellType === 'th') {
        var value = com.getAttribute(cell, 'scope');
        value = value ? value : 'none';
        this._elements.scopeAttributeSelect.items.getAll().forEach(function(elem, index) {
          if (elem.value === value) {
            elem.selected = true;
          }
        }, this);
        this.cellScope = (value === 'none' ? CUI.rte.commands.Table.CONFIG_NONE : value);
        this.$cellId.val(com.getAttribute(cell, 'id'));
        this.$cellHeadersContainer.hide();
        this.$cellIdContainer.show();
        this.$cellScopeContainer.show();
      } else {
        this.$cellHeaders.val(com.getAttribute(cell, 'headers'));
        this.$cellScopeContainer.hide();
        this.$cellIdContainer.hide();
        this.$cellHeadersContainer.show();
      }
    }
  });


})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  CUI.rte.ui.cui.CuiDialogManager = new Class({

    toString: 'CuiDialogManager',

    extend: CUI.rte.ui.DialogManager,

    editorKernel: null,

    dialogShown: null,

    construct: function (editorKernel) {
      this.editorKernel = editorKernel;
      this.editorKernel.addUIListener('dialoghide', this.onDialogHide, this);
    },

    create: function (dialogId, config) {
      var dialog;
      // add CUI-specific config data
      var context = this.editorKernel.getEditContext();
      var $container = CUI.rte.UIUtils.getUIContainer($(context.root));
      switch (dialogId) {
      case CUI.rte.ui.DialogManager.DLG_ANCHOR:
        dialog = new CUI.rte.ui.cui.AnchorDialog();
        dialog.attach(config, $container, this.editorKernel);
        break;
      case CUI.rte.ui.DialogManager.DLG_FINDREPLACE:
        dialog = new CUI.rte.ui.cui.FindReplaceDialog();
        dialog.attach(config, $container, this.editorKernel);
        break;
      case CUI.rte.ui.DialogManager.DLG_PASTE:
        dialog = new CUI.rte.ui.cui.PasteDialog();
        dialog.attach(config, $container, this.editorKernel, true);
        break;
      case CUI.rte.ui.DialogManager.DLG_SPECCHARS:
        dialog = new CUI.rte.ui.cui.SpecialCharsDialog();
        dialog.attach(config, $container, this.editorKernel);
        break;
      case CUI.rte.ui.DialogManager.DLG_SPELLCHECKER:
        dialog = new CUI.rte.ui.cui.SpellcheckerDialog();
        dialog.attach(config, $container, this.editorKernel, true);
        break;
      case CUI.rte.ui.DialogManager.DLG_TABLEPROPS:
        dialog = new CUI.rte.ui.cui.TablePropsDialog();
        dialog.attach(config, $container, this.editorKernel);
        break;
      case CUI.rte.ui.DialogManager.DLG_TABLEANDCELLPROPS:
        dialog = new CUI.rte.ui.cui.TableAndCellPropsDialog();
        dialog.attach(config, $container, this.editorKernel);
        break;
      case CUI.rte.ui.DialogManager.DLG_IMAGEPROPS:
        dialog = new CUI.rte.ui.cui.ImagePropsDialog();
        dialog.attach(config, $container, this.editorKernel, true);
        break;
      }
      return dialog;
    },

    mustRecreate: function (dialog) {
      return dialog.mustRecreate();
    },

    show: function (dialog) {
      dialog.show();
      this.dialogShown = dialog;
    },

    hide: function (dialog) {
      dialog = dialog || this.dialogShown;
      if (dialog) {
        dialog.hide();
      }
    },

    onDialogHide: function(dialog) {
      this.dialogShown = undefined;
    },

    alert: function (title, message, fn, options) {
      var self = this;
      options = options || {};
      var boxWidth;
      var globalDef;
      var $insertRef;
      var classes;
      if (options.dialog) {
        var $dialog = options.dialog.$dialog;
        $dialog.find('coral-alert').hide();
        $insertRef = $($dialog[0].content);
        boxWidth = $insertRef.innerWidth() -
          parseInt($insertRef.css('padding-left'), 10) -
          parseInt($insertRef.css('padding-right'), 10);
      } else {
        var $editable = $(this.editorKernel.getEditContext().root);
        var $uiContainer = CUI.rte.UIUtils.getUIContainer($editable);
        $insertRef = $uiContainer.find('div[data-type=\'global\']');
        $insertRef = $insertRef.length ? $insertRef : $(document.body);
        classes = 'rte-globalAlert';
        globalDef = {
          vpWidth: $(window).width()
        };
      }
      var alertJsonConfig = {
        size: 'S',
        variant: options.type || 'info',
        content: {
          innerHTML: message
        }
      };
      if (!options.dialog) {
        alertJsonConfig.header = {
          innerHTML: title
        };
        alertJsonConfig.size = 'L';
      }
      var $alert = $(new Coral.Alert().set(alertJsonConfig));
      if (classes) {
        $alert.addClass(classes);
      }
      $insertRef.append($alert);
      if (globalDef) {
        var width = $alert.outerWidth();
        $alert.offset({
          'left': Math.round((globalDef.vpWidth - width) / 2),
          'top': $alert.offset().top
        });
      }
      if (boxWidth) {
        var offset = parseInt($alert.css('border-left'), 10) +
          parseInt($alert.css('border-right'), 10);
        $alert.innerWidth(boxWidth - offset);
      }
      $alert.on('hide', function (e) {
        $alert.remove();
        $alert = undefined;
      });

      // need to handle the close button on our own in this case - note that we will
      // always react on the click event (due to the infamous iframe touchevent bugs
      // of SafariMobile)

      function close(evt) {
        if ($alert) {
          $alert.hide();
        }
        self.editorKernel.focus();
        evt.stopPropagation();
        evt.preventDefault();
      }

      if (!CUI.rte.Common.ua.isTouchInIframe) {
        $alert.fipo('tap', 'click', close);
        $alert.fipo('tap', 'click', '[data-dismiss=\'alert\']', close);
      } else {
        $alert.on('click', close);
        $alert.on('click', '[data-dismiss=\'alert\']', close);
      }
    },

    isShown: function (dialog) {
      return dialog && dialog.isShown();
    },

    createDialogHelper: function () {
      return new CUI.rte.ui.cui.CuiDialogHelper(this.editorKernel);
    },

    prepareShow: function (dialog) {
      var popovers = this.editorKernel.toolbar.popover;
      popovers.hide(true);
    },

    toggleVisibility: function (dialog) {
      return true;
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  var TYPES = {
    'rtelinkdialog': CUI.rte.ui.cui.LinkBaseDialog,
    'rtedefaultdialog': CUI.rte.ui.cui.DefaultDialog
  };

  CUI.rte.ui.cui.CuiDialogHelper = new Class({

    toString: 'CuiDialogHelper',

    extend: CUI.rte.ui.DialogHelper,

    dialog: null,

    /**
     * @protected
     * @ignore
     */
    instantiateDialog: function (dialogConfig) {
      var Cls;
      if (this.dialog) {
        Cls = this.dialog;
      } else {
        var type = dialogConfig.type;
        if (!TYPES.hasOwnProperty(type)) {
          throw new Error('Unknown dialog type: ' + type);
        }
        Cls = TYPES[type];
      }
      // pre-render items if present
      if (dialogConfig.dialogItems) {
        for (var i = 0; i < dialogConfig.dialogItems.length; i++) {
          var item = dialogConfig.dialogItems[i];
          if (item.item) {
            var config = item.item;
            var itemType = config.type;
            item.rendered = Coral.templates.RichTextEditor['item_' + itemType](config);
          }
        }
      }
      var context = this.editorKernel.getEditContext();
      var $editable = $(context.root);
      var $container = CUI.rte.UIUtils.getUIContainer($editable);
      var dlg = new Cls();
      dlg.attach(dialogConfig, $container, this.editorKernel);
      return dlg;
    },

    createItem: function (type, name, label) {
      return {
        'type': type,
        'id': name,
        'label': label
      };
    },

    getItemType: function (item) {
      return item.type;
    },

    getItemName: function (item) {
      if (!item.id) {
        item.id = 'id-' + new Date().getTime();
      }
      return item.id;
    },

    getItemValue: function (item) {
      return item.value;
    },

    setItemValue: function (item, value) {
      item.value = value;
    },

    calculateInitialPosition: function () {
      // not required here - the position is managed by CUI.rte.ui.cui.PopupManager
    },

    registerDialog: function (dialog) {
      this.dialog = dialog;
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($, CUI) {

  'use strict';
  var com = CUI.rte.Common;

  var isFullScreen = false;

  var FULLSCREEN_ID = 'RTEFullScreenMode';

  var $fullScreenDialog;

  /**
   * Array containing link elements referencing external style sheets which were added while starting FSM.
   */
  var $externalStyleSheetLinks = [];

  function getFullScreenDialog() {
    var $fsDialog = $('#' + FULLSCREEN_ID);
    if ($fsDialog.length === 0) {
      var $content = $('body');
      var allowMinimize = com.ua.isTouch ? false : true;
      $content.append(Coral.templates.RichTextEditor['fullscreen_dialog']({'allowMinimize': allowMinimize}));
      $fsDialog = $content.find('.rte-fullscreen-dialog');
      $fsDialog.attr('id', FULLSCREEN_ID);
      $content.append($fsDialog);
    }
    return $fsDialog;
  }

  function removeFullScreenDiv() {
    var $toRemove = $fullScreenDialog || $('#' + FULLSCREEN_ID);
    if ($toRemove.length > 0) {
      $toRemove.remove();
    }
    $fullScreenDialog = undefined;
  }


  CUI.rte.ui.cui.FullScreenHelper = (function () {

    return {

      /**
       * Starts full screen mode.
       * @param $fsContent (optional) The content to be shown in fullscreen mode
       * @param options (optional) The options for some fullscreen mode behavior
       * @return {jQuery} The full screen container
       */
      start: function ($fsContent, options) {
        var $link;
        if (!isFullScreen) {
          $fullScreenDialog = getFullScreenDialog();
          if (options) {
            if (options.hasOwnProperty('css')) {
              $fullScreenDialog.addClass(options['css']);
            }
            if (options.hasOwnProperty('externalStyleSheets')) {
              if (CUI.rte.Utils.isArray(options['externalStyleSheets'])) {
                for (var index = 0; index < options['externalStyleSheets'].length; index++) {
                  $link = $('<link rel=\'stylesheet\' href=\'' + options['externalStyleSheets'][index] + '\' type=\'text/css\'>');
                  $externalStyleSheetLinks.push($link);
                  $(document.head).append($link);
                }
              } else {
                $link = $('<link rel=\'stylesheet\' href=\'' + options['externalStyleSheets'] + '\' type=\'text/css\'>');
                $externalStyleSheetLinks.push($link);
                $(document.head).append($link);
              }
            }
          }
          if ($fsContent) {
            $fullScreenDialog.append($fsContent);
          }
          isFullScreen = true;
        }
        return $fullScreenDialog;
      },

      /**
       * Finished full screen mode.
       */
      exit: function () {
        if (isFullScreen) {
          removeFullScreenDiv();
          while ($externalStyleSheetLinks.length > 0) {
            $externalStyleSheetLinks.pop().remove();
          }
          isFullScreen = false;
        }
      },

      /**
       * Checks if full screen mode is currently active.
       * @returns {boolean} True if full screen mode is currently active
       */
      isActive: function () {
        return isFullScreen;
      },

      getContainer: function () {
        return $fullScreenDialog;
      }

    };

  }());

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {
  //'use strict';
  CUI.rte.ui.cui.TouchScrollLimiter = new Class({

    $window: undefined,

    $document: undefined,

    $body: undefined,

    $container: undefined,

    isActive: false,

    attach: function ($container, $editor, $content) {
      var self = this;
      this.isActive = true;
      this.$window = $(window);
      this.$container = $container;
      this.$document = $(document);
      this.$body = $(document.body);
      this.$container = $('<div></div>');
      this.$container.css('overflow', 'hidden');
      var isBlocked, isBlockDecided, startY;
      this.$document.on('touchstart.rteFSEdit', function (e) {
        if (!self.isActive) {
          return;
        }
        startY = e.originalEvent.pageY;
        isBlocked = false;
        isBlockDecided = false;
      });
      this.$document.on('touchmove.rteFSEdit', function (e) {
        if (!self.isActive) {
          return;
        }
        // prevent outer container scrolling if the editor div is on top and the
        // user swipes upwards or the editor div is on bottom and the user swipes
        // downwards - Safari will scroll the outer container instead of the editor
        // div
        if (!isBlockDecided) {
          var deltaY = e.originalEvent.pageY - startY;
          if (deltaY !== 0) {
            var maxScrollTop =
              $editor[0].scrollHeight - $editor[0].clientHeight;
            var scrollTop = $editor[0].scrollTop;
            if (deltaY > 0) {
              isBlocked = (scrollTop <= 0);
            } else {
              isBlocked = (scrollTop >= maxScrollTop);
            }
          }
          isBlockDecided = true;
        }
        if (isBlocked) {
          e.stopPropagation();
          e.preventDefault();
          return;
        }
        // only block if an element other than the editor is targetted
        var isEditor = false;
        var toCheck = e.target;
        while (toCheck && (toCheck.tagName.toLowerCase() !== 'body')) {
          if (toCheck === $editor[0]) {
            isEditor = true;
            break;
          }
          toCheck = toCheck.parentNode;
        }
        if (!isEditor) {
          e.stopPropagation();
          e.preventDefault();
        }
      });
      // ensure that the main window is always scrolled to the top, ensuring the
      // toolbar is actually visible
      this.$window.on('scroll.rteFSEdit', function (e) {
        if (self.$window.scrollTop() !== 0) {
          self.$window.scrollTop(0);
        }
      });
      // Add a padding to the bottom that allows to edit the entire text if the screen
      // keyboard is used
      if ($content) {
        var keybHeight = CUI.rte.Common.getScreenKeyboardHeight();
        $content.css('padding-bottom', keybHeight + 'px');
      }
    },

    detach: function () {
      this.$document.off('touchstart.rteFSEdit');
      this.$document.off('touchmove.rteFSEdit');
      this.$window.off('scroll.rteFSEdit');
    },

    suspend: function () {
      this.isActive = false;
    },

    reactivate: function () {
      this.isActive = true;
    }

  });

})(window.jQuery, window.CUI);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';
  var sel = CUI.rte.Selection;
  var com = CUI.rte.Common;
  var fsh = CUI.rte.ui.cui.FullScreenHelper;

  function getBookmark(rte) {
    var context = rte.editorKernel.getEditContext();
    return sel.createSelectionBookmark(context);
  }

  function selectBookmark(rte, bookmark) {
    var context = rte.editorKernel.getEditContext();
    sel.selectBookmark(context, bookmark);
  }

  var prevOverflow = null;

  var prevScroll = 0;

  CUI.rte.ui.cui.DefaultFullScreenAdapter = new Class({

    extend: CUI.rte.commands.FullScreenAdapter,

    toString: 'DefaultFullScreenAdapter',

    baseRTE: undefined,

    fullScreenRTE: undefined,

    $fullScreenDialog: undefined,

    $editor: undefined,

    $sourceEditor: undefined,

    construct: function (config) {
      this.baseRTE = config.rteInstance;
    },

    _handleEscape: function () {
      this.finish();
      return true;
    },

    _dropFullScreenMode: function () {
      if (this.touchScrollLimiter) {
        this.touchScrollLimiter.detach();
        this.touchScrollLimiter = undefined;
      }
      if (!com.ua.isTouch) {
        $(window).off('resize.rteFSResize');
        var $body = $(document.body);
        $body.scrollTop(prevScroll);
        $body.css('overflow', prevOverflow);
        prevOverflow = null;
        prevScroll = 0;
      }
      var $fullScreenDialog = fsh.getContainer();
      $fullScreenDialog.off('.rteOOA');
      fsh.exit();
    },

    /**
     * Finishes editing from full screen mode (iOS only) - the current content of the
     * full screen editor is transferred to the base RTE, which then is regularily gets
     * "finished".
     *
     * @private
     */
    _leaveFromFullScreenMode: function (isCancelled) {
      var content = this.fullScreenRTE.getContent();
      this.fullScreenRTE.suspend();
      this.fullScreenRTE = undefined;
      this._dropFullScreenMode();
      if (!isCancelled) {
        this.baseRTE.reactivate(content);
      }
      this.baseRTE.finish(isCancelled);
      this.baseRTE = undefined;
    },

    start: function () {
      var isTouch = com.ua.isTouch, bkm = getBookmark(this.baseRTE), self = this, $editable, $ui, $uiSource, $toolbar;
      var content = this.baseRTE.getContent(), undoConfig = this.baseRTE.getUndoConfig(), tbType = 'fullscreen', config;
      var $wrapper;
      this.baseRTE.suspend();
      this.$fullScreenDialog = fsh.start();
      this.$sourceEditor = this.$fullScreenDialog.find('.rte-sourceEditor');
      this.$richtextContainer = this.$fullScreenDialog.find('.rte-fullscreen-richtextContainer');
      this.$editor = this.$fullScreenDialog.find('.rte-editor');
      this.$toggleButton = this.$fullScreenDialog.find('.rte-fullScreenExit');
      this.$toggleButton.on('click.rte-handler', function (e) {
        var editorKernel = self.fullScreenRTE.editorKernel;
        var dm = editorKernel.getDialogManager();
        dm.hide();
        var oppositeKernel = self.finish();
        CUI.rte.Utils.defer(oppositeKernel.updateToolbar, 1, oppositeKernel);
        editorKernel.enableFocusHandling();
        e.stopPropagation();
      });
      $wrapper = this.$fullScreenDialog.find('.rte-editorWrapper');
      // either copy UI from base instance or create new one ...
      $editable = this.baseRTE.$element;
      $uiSource = CUI.rte.UIUtils.getUIContainer($editable);
      if ($uiSource) {
        $ui = $uiSource.clone(false);
      } else {
        $ui = $('<div/>');
        $ui.addClass('rte-ui');
      }
      // ... and determine the correct config object from the copied UI
      $toolbar = CUI.rte.UIUtils.getToolbar($editable, tbType);
      config = CUI.rte.Utils.copyObject(this.baseRTE.originalConfig);
      if ($toolbar && ($toolbar.length > 0)) {
        var features = CUI.rte.ConfigUtils.createFeaturesFromToolbar(this.$fullScreenDialog,
          $toolbar);
        config = CUI.rte.ConfigUtils.mergeConfigAndFeatures(config, features);
      }

      this.$sourceEditor.hide();
      this.$richtextContainer.prepend($ui);
      this.$fullScreenDialog[0].show();
      self = this;
      this.$sourceEditor.fipo('tap.rte-' + this.id, 'click.rte-' + this.id,
        function (e) {
          e.stopPropagation();
        });
      // need to prevent both mousedown and click events from bubbling up to
      // avoid focus loss on desktop browsers
      this.$fullScreenDialog.fipo('touchstart.rteOOA', 'mousedown.rteOOA click.rteOOA',
        function (e) {
          var target = e.target, $target = $(target);
          if (com.isTag($target[0], 'coral-dialog-content') ||
            $target.hasClass('rte-fullscreen-header') ||
            $target.hasClass('coral-Dialog-title') ||
            $target.hasClass('coral-Dialog-wrapper') ||
            $target.hasClass('rte-fullscreen-footer-content') ||
            $target.hasClass('rte-editorWrapper') ||
            $target.hasClass('rte-toolbar') ||
            $target.hasClass('rte-fullscreen-dialog')) {
            e.preventDefault();
            e.stopPropagation();
          }
        });
      this.fullScreenRTE = new CUI.RichText({
        'element': this.$editor,
        'initialContent': content,
        'preventCaretInitialize': true,
        '$ui': $ui,
        'isFullScreen': true,
        'tbType': tbType,
        'autoConfig': true,
        'fullScreenAdapter': this,
        'listeners': {
          'beforeEscape': CUI.rte.Utils.scope(this._handleEscape, this),
          // handler that ensure fullscreen mode gets hidden if RTE is left
          // in fullscreen mode (iOS only)
          'beforeFinish': function () {
            self._leaveFromFullScreenMode();
          },
          'beforeCancel': function () {
            self._leaveFromFullScreenMode(true);
          }
        }
      });
      this.fullScreenRTE.start(config);
      this.fullScreenRTE.setUndoConfig(undoConfig);
      this.fullScreenRTE.focus();
      selectBookmark(this.fullScreenRTE, bkm);
      if (isTouch) {
        this.touchScrollLimiter = new CUI.rte.ui.cui.TouchScrollLimiter();
        this.touchScrollLimiter.attach(this.$fullScreenDialog, $wrapper, this.$editor);
      }
      var ek = this.fullScreenRTE.editorKernel;
      if (!isTouch) {
        var $body = $(document.body);
        prevScroll = $body.scrollTop();
        $body.scrollTop(0);
        prevOverflow = $body.css('overflow');
        $body.css('overflow', 'hidden');
      }
      var context = ek.getEditContext();
      context.setState('CUI.touchScrollLimiter', this.touchScrollLimiter);
      return ek;
    },

    // Keeping this function for backward-compatibility
    toggleSourceEdit: function(sourceEditMode){
      this.fullScreenRTE.toggleSourceEdit(sourceEditMode);
    },

    finish: function () {
      var bkm = getBookmark(this.fullScreenRTE);
      var content = this.fullScreenRTE.getContent();
      var undoConfig = this.fullScreenRTE.getUndoConfig();
      this.$toggleButton.off('click.rte-handler');
      this.fullScreenRTE.suspend();
      this.fullScreenRTE = undefined;
      this._dropFullScreenMode();
      this.baseRTE.reactivate(content);
      this.baseRTE.setUndoConfig(undoConfig);
      this.baseRTE.focus();
      selectBookmark(this.baseRTE, bkm);
      return this.baseRTE.editorKernel;
    },

    isFullScreen: function () {
      return fsh.isActive();
    }

  });

})(window.jQuery, window.CUI);

window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["RichTextEditor"] = window["Coral"]["templates"]["RichTextEditor"] || {};
window["Coral"]["templates"]["RichTextEditor"]["dlg_anchor"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " rte-dialog-columnContainer";
  var el1 = document.createTextNode("\r\n    ");
  el0.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " rte-dialog-column";
  var el3 = document.createTextNode("\r\n        ");
  el2.appendChild(el3);
  var el4 = document.createElement("input","coral-textfield");
  el4.setAttribute("is", "coral-textfield");
  el4.setAttribute("data-type", "id");
  el4.setAttribute("value", "");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\r\n    ");
  el2.appendChild(el5);
  el0.appendChild(el2);
  var el6 = document.createTextNode("\r\n    ");
  el0.appendChild(el6);
  var el7 = document.createElement("div");
  el7.className += " rte-dialog-column";
  var el8 = document.createTextNode("\r\n        ");
  el7.appendChild(el8);
  var el9 = document.createElement("button","coral-button");
  el9.setAttribute("is", "coral-button");
  el9.setAttribute("icon", "close");
  el9.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el9.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el9.setAttribute("iconsize", "S");
  el9.setAttribute("data-type", "cancel");
  el9.setAttribute("tabindex", "-1");
  el7.appendChild(el9);
  var el10 = document.createTextNode("\r\n    ");
  el7.appendChild(el10);
  el0.appendChild(el7);
  var el11 = document.createTextNode("\r\n    ");
  el0.appendChild(el11);
  var el12 = document.createElement("div");
  el12.className += " rte-dialog-column";
  el12.setAttribute("hidden", "true");
  var el13 = document.createTextNode("\r\n        ");
  el12.appendChild(el13);
  var el14 = document.createElement("button","coral-button");
  el14.setAttribute("is", "coral-button");
  el14.setAttribute("icon", "delete");
  el14.setAttribute("iconsize", "S");
  el14.setAttribute("variant", "warning");
  el14.setAttribute("data-type", "delete");
  el14.setAttribute("tabindex", "-1");
  el12.appendChild(el14);
  var el15 = document.createTextNode("\r\n    ");
  el12.appendChild(el15);
  el0.appendChild(el12);
  var el16 = document.createTextNode("\r\n    ");
  el0.appendChild(el16);
  var el17 = document.createElement("div");
  el17.className += " rte-dialog-column";
  var el18 = document.createTextNode("\r\n        ");
  el17.appendChild(el18);
  var el19 = document.createElement("button","coral-button");
  el19.setAttribute("is", "coral-button");
  el19.setAttribute("icon", "check");
  el19.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el19.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el19.setAttribute("iconsize", "S");
  el19.setAttribute("variant", "primary");
  el19.setAttribute("data-type", "apply");
  el19.setAttribute("tabindex", "-1");
  el17.appendChild(el19);
  var el20 = document.createTextNode("\r\n    ");
  el17.appendChild(el20);
  el0.appendChild(el17);
  var el21 = document.createTextNode("\r\n");
  el0.appendChild(el21);
  frag.appendChild(el0);
  var el22 = document.createTextNode("\r\n");
  frag.appendChild(el22);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["dlg_default"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  if (data_0["title"]) {
    var el1 = document.createTextNode("\r\n  ");
    frag.appendChild(el1);
    var el2 = document.createElement("div");
    el2.className += " rte-dialog-headerContainer";
    var el3 = document.createTextNode("\r\n    ");
    el2.appendChild(el3);
    var el4 = document.createElement("h3");
    el4.className += " coral-Heading coral-Heading--3";
    el4.textContent = data_0["title"];
    el2.appendChild(el4);
    var el5 = document.createTextNode("\r\n  ");
    el2.appendChild(el5);
    frag.appendChild(el2);
    var el6 = document.createTextNode("\r\n");
    frag.appendChild(el6);
  }
  var el7 = document.createTextNode("\r\n");
  frag.appendChild(el7);
  var el8 = document.createElement("div");
  el8.className += " rte-dialog-rowContainer";
  var el9 = document.createTextNode("\r\n  ");
  el8.appendChild(el9);
  var el10 = document.createElement("div");
  el10.className += " rte-dialog-row";
  var el11 = document.createTextNode("\r\n    ");
  el10.appendChild(el11);
  var iterated_1 = data_0["dialogItems"];
  for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
    var data_1 = data = iterated_1[i1];
    var el13 = document.createTextNode("\r\n      ");
    el10.appendChild(el13);
    el10.appendChild(data_1["rendered"]);
    var el15 = document.createTextNode("\r\n    ");
    el10.appendChild(el15);
  }
  var el16 = document.createTextNode("\r\n  ");
  el10.appendChild(el16);
  el8.appendChild(el10);
  var el17 = document.createTextNode("\r\n");
  el8.appendChild(el17);
  frag.appendChild(el8);
  var el18 = document.createTextNode("\r\n");
  frag.appendChild(el18);
  var el19 = document.createElement("div");
  el19.className += " rte-dialog-columnContainer u-coral-pullRight";
  var el20 = document.createTextNode("\r\n  ");
  el19.appendChild(el20);
  var el21 = document.createElement("div");
  el21.className += " rte-dialog-column";
  var el22 = document.createTextNode("\r\n    ");
  el21.appendChild(el22);
  var el23 = document.createElement("button","coral-button");
  el23.setAttribute("is", "coral-button");
  el23.setAttribute("icon", "close");
  el23.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el23.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el23.setAttribute("size", "S");
  el23.setAttribute("data-type", "cancel");
  el23.setAttribute("tabindex", "-1");
  el21.appendChild(el23);
  var el24 = document.createTextNode("\r\n    ");
  el21.appendChild(el24);
  var el25 = document.createElement("button","coral-button");
  el25.setAttribute("is", "coral-button");
  el25.setAttribute("icon", "check");
  el25.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el25.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el25.setAttribute("iconsize", "S");
  el25.setAttribute("variant", "primary");
  el25.setAttribute("type", "button");
  el25.setAttribute("data-type", "apply");
  el25.setAttribute("tabindex", "-1");
  el21.appendChild(el25);
  var el26 = document.createTextNode("\r\n  ");
  el21.appendChild(el26);
  el19.appendChild(el21);
  var el27 = document.createTextNode("\r\n");
  el19.appendChild(el27);
  frag.appendChild(el19);
  var el28 = document.createTextNode("\r\n");
  frag.appendChild(el28);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["dlg_find"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createTextNode(" ");
  frag.appendChild(el0);
  var el1 = document.createElement("div");
  el1.className += " rte-dialog-columnContainer";
  var el2 = document.createTextNode("\r\n    ");
  el1.appendChild(el2);
  var el3 = document.createElement("div");
  el3.className += " rte-dialog-column";
  var el4 = document.createTextNode("\r\n        ");
  el3.appendChild(el4);
  var el5 = document.createElement("input","coral-textfield");
  el5.setAttribute("is", "coral-textfield");
  el5.setAttribute("data-type", "find");
  el5.setAttribute("value", "");
  el3.appendChild(el5);
  var el6 = document.createTextNode("\r\n    ");
  el3.appendChild(el6);
  el1.appendChild(el3);
  var el7 = document.createTextNode("\r\n    ");
  el1.appendChild(el7);
  var el8 = document.createElement("div");
  el8.className += " rte-dialog-column";
  var el9 = document.createTextNode("\r\n        ");
  el8.appendChild(el9);
  var el10 = this["matchCaseBox"] = document.createElement("coral-checkbox");
  el10.setAttribute("name", "matchCase");
  el10.setAttribute("value", "false");
  el10.setAttribute("data-type", "matchCase");
  el10.setAttribute("handle", "matchCaseBox");
  el8.appendChild(el10);
  var el11 = document.createTextNode("\r\n    ");
  el8.appendChild(el11);
  el1.appendChild(el8);
  var el12 = document.createTextNode("\r\n    ");
  el1.appendChild(el12);
  var el13 = document.createElement("div");
  el13.className += " rte-dialog-column";
  var el14 = document.createTextNode("\r\n        ");
  el13.appendChild(el14);
  var el15 = document.createElement("button","coral-button");
  el15.setAttribute("is", "coral-button");
  el15.setAttribute("icon", "close");
  el15.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el15.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el15.setAttribute("size", "S");
  el15.setAttribute("data-type", "cancel");
  el15.setAttribute("tabindex", "-1");
  el13.appendChild(el15);
  var el16 = document.createTextNode("\r\n    ");
  el13.appendChild(el16);
  el1.appendChild(el13);
  var el17 = document.createTextNode("\r\n    ");
  el1.appendChild(el17);
  var el18 = document.createElement("div");
  el18.className += " rte-dialog-column";
  var el19 = document.createTextNode("\r\n        ");
  el18.appendChild(el19);
  var el20 = document.createElement("button","coral-button");
  el20.setAttribute("is", "coral-button");
  el20.setAttribute("icon", "search");
  el20.setAttribute("iconsize", "S");
  el20.setAttribute("variant", "primary");
  el20.setAttribute("data-type", "execFind");
  el20.setAttribute("tabindex", "-1");
  el18.appendChild(el20);
  var el21 = document.createTextNode("\r\n    ");
  el18.appendChild(el21);
  el1.appendChild(el18);
  var el22 = document.createTextNode("\r\n");
  el1.appendChild(el22);
  frag.appendChild(el1);
  var el23 = document.createTextNode("\r\n");
  frag.appendChild(el23);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["dlg_image"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " rte-dialog-columnContainer";
  var el1 = document.createTextNode("\r\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " rte-dialog-column rte-dialog-column--alt";
  var el3 = document.createElement("label");
  var el4 = document.createTextNode(" ");
  el3.appendChild(el4);
  var el5 = document.createElement("input","coral-textfield");
  el5.setAttribute("is", "coral-textfield");
  el5.setAttribute("data-type", "alt");
  el5.setAttribute("placeholder", "Alt Text");
  el3.appendChild(el5);
  var el6 = document.createTextNode(" ");
  el3.appendChild(el6);
  el2.appendChild(el3);
  var el7 = document.createTextNode(" ");
  el2.appendChild(el7);
  el0.appendChild(el2);
  var el8 = document.createTextNode("\r\n  ");
  el0.appendChild(el8);
  var el9 = document.createElement("div");
  el9.className += " rte-dialog-column";
  var el10 = document.createTextNode("\r\n    ");
  el9.appendChild(el10);
  var el11 = this["targetSelect"] = document.createElement("coral-select");
  el11.setAttribute("handle", "targetSelect");
  var el12 = document.createTextNode("\r\n      ");
  el11.appendChild(el12);
  var el13 = document.createElement("coral-select-item");
  el13.setAttribute("value", "none");
  el13.textContent = CUI["rte"]["Utils"]["i18n"]('plugins.image.noAlign');
  el11.appendChild(el13);
  var el14 = document.createTextNode("\r\n      ");
  el11.appendChild(el14);
  var el15 = document.createElement("coral-select-item");
  el15.setAttribute("value", "left");
  el15.textContent = CUI["rte"]["Utils"]["i18n"]('plugins.image.alignLeft');
  el11.appendChild(el15);
  var el16 = document.createTextNode("\r\n      ");
  el11.appendChild(el16);
  var el17 = document.createElement("coral-select-item");
  el17.setAttribute("value", "right");
  el17.textContent = CUI["rte"]["Utils"]["i18n"]('plugins.image.alignRight');
  el11.appendChild(el17);
  var el18 = document.createTextNode("\r\n      ");
  el11.appendChild(el18);
  var el19 = document.createElement("coral-select-item");
  el19.setAttribute("value", "inherit");
  el19.textContent = CUI["rte"]["Utils"]["i18n"]('plugins.image.alignInherit');
  el11.appendChild(el19);
  var el20 = document.createTextNode("\r\n    ");
  el11.appendChild(el20);
  el9.appendChild(el11);
  var el21 = document.createTextNode("\r\n  ");
  el9.appendChild(el21);
  el0.appendChild(el9);
  var el22 = document.createTextNode("\r\n  ");
  el0.appendChild(el22);
  var el23 = document.createElement("div");
  el23.className += " rte-dialog-column";
  var el24 = document.createTextNode("\r\n    ");
  el23.appendChild(el24);
  var el25 = document.createElement("button","coral-button");
  el25.setAttribute("is", "coral-button");
  el25.setAttribute("icon", "close");
  el25.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el25.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el25.setAttribute("iconsize", "S");
  el25.setAttribute("type", "button");
  el25.setAttribute("data-type", "cancel");
  el25.setAttribute("tabindex", "-1");
  el23.appendChild(el25);
  var el26 = document.createTextNode("\r\n  ");
  el23.appendChild(el26);
  el0.appendChild(el23);
  var el27 = document.createTextNode("\r\n  ");
  el0.appendChild(el27);
  var el28 = document.createElement("div");
  el28.className += " rte-dialog-column";
  var el29 = document.createTextNode("\r\n    ");
  el28.appendChild(el29);
  var el30 = document.createElement("button","coral-button");
  el30.setAttribute("is", "coral-button");
  el30.setAttribute("icon", "check");
  el30.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el30.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el30.setAttribute("iconsize", "S");
  el30.setAttribute("variant", "primary");
  el30.setAttribute("type", "button");
  el30.setAttribute("data-type", "apply");
  el30.setAttribute("tabindex", "-1");
  el28.appendChild(el30);
  var el31 = document.createTextNode("\r\n  ");
  el28.appendChild(el31);
  el0.appendChild(el28);
  var el32 = document.createTextNode("\r\n");
  el0.appendChild(el32);
  frag.appendChild(el0);
  var el33 = document.createTextNode("\r\n");
  frag.appendChild(el33);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["dlg_link"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " rte-dialog-columnContainer";
  var el1 = document.createTextNode("\r\n    ");
  el0.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " rte-dialog-column";
  var el3 = document.createTextNode("\r\n      ");
  el2.appendChild(el3);
  var el4 = document.createElement("input","coral-textfield");
  el4.setAttribute("is", "coral-textfield");
  el4.className += " rte-linkfield";
  el4.setAttribute("name", "href");
  el4.setAttribute("placeholder", CUI["rte"]["Utils"]["i18n"]('dialog.link.path'));
  el2.appendChild(el4);
  var el5 = document.createTextNode("\r\n    ");
  el2.appendChild(el5);
  el0.appendChild(el2);
  var el6 = document.createTextNode("\r\n");
  el0.appendChild(el6);
  frag.appendChild(el0);
  var el7 = document.createTextNode("\r\n");
  frag.appendChild(el7);
  var el8 = document.createElement("div");
  el8.className += " rte-dialog-columnContainer";
  var el9 = document.createTextNode("\r\n    ");
  el8.appendChild(el9);
  var el10 = document.createElement("div");
  el10.className += " rte-dialog-column";
  var el11 = document.createElement("label");
  var el12 = document.createTextNode(" ");
  el11.appendChild(el12);
  var el13 = document.createElement("input","coral-textfield");
  el13.setAttribute("is", "coral-textfield");
  el13.setAttribute("data-type", "title");
  el13.setAttribute("placeholder", CUI["rte"]["Utils"]["i18n"]('dialog.link.titleFieldPlaceHolder'));
  el11.appendChild(el13);
  var el14 = document.createTextNode(" ");
  el11.appendChild(el14);
  el10.appendChild(el11);
  var el15 = document.createTextNode(" ");
  el10.appendChild(el15);
  el8.appendChild(el10);
  var el16 = document.createTextNode("\r\n");
  el8.appendChild(el16);
  frag.appendChild(el8);
  var el17 = document.createTextNode("\r\n");
  frag.appendChild(el17);
  var el18 = document.createElement("div");
  el18.className += " rte-dialog-columnContainer";
  var el19 = document.createTextNode("\r\n    ");
  el18.appendChild(el19);
  var el20 = document.createElement("div");
  el20.className += " rte-dialog-column";
  var el21 = document.createTextNode("\r\n        ");
  el20.appendChild(el21);
  var el22 = this["targetSelect"] = document.createElement("coral-select");
  el22.setAttribute("handle", "targetSelect");
  var el23 = document.createTextNode("\r\n            ");
  el22.appendChild(el23);
  var el24 = document.createElement("coral-select-item");
  el24.setAttribute("value", "");
  el24.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.link.target');
  el22.appendChild(el24);
  var el25 = document.createTextNode("\r\n            ");
  el22.appendChild(el25);
  var el26 = document.createElement("coral-select-item");
  el26.setAttribute("value", "_self");
  el26.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.link.same_tab');
  el22.appendChild(el26);
  var el27 = document.createTextNode("\r\n            ");
  el22.appendChild(el27);
  var el28 = document.createElement("coral-select-item");
  el28.setAttribute("value", "_blank");
  el28.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.link.new_tab');
  el22.appendChild(el28);
  var el29 = document.createTextNode("\r\n            ");
  el22.appendChild(el29);
  var el30 = document.createElement("coral-select-item");
  el30.setAttribute("value", "_parent");
  el30.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.link.parent_frame');
  el22.appendChild(el30);
  var el31 = document.createTextNode("\r\n            ");
  el22.appendChild(el31);
  var el32 = document.createElement("coral-select-item");
  el32.setAttribute("value", "_top");
  el32.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.link.top_frame');
  el22.appendChild(el32);
  var el33 = document.createTextNode("\r\n        ");
  el22.appendChild(el33);
  el20.appendChild(el22);
  var el34 = document.createTextNode("\r\n    ");
  el20.appendChild(el34);
  el18.appendChild(el20);
  var el35 = document.createTextNode("\r\n");
  el18.appendChild(el35);
  frag.appendChild(el18);
  var el36 = document.createTextNode("\r\n");
  frag.appendChild(el36);
  var el37 = document.createElement("div");
  el37.className += " rte-dialog-columnContainer";
  var el38 = document.createTextNode("\r\n    ");
  el37.appendChild(el38);
  var el39 = document.createElement("div");
  el39.className += " rte-dialog-column rte-dialog-column--rightAligned";
  var el40 = document.createTextNode("\r\n        ");
  el39.appendChild(el40);
  var el41 = document.createElement("button","coral-button");
  el41.setAttribute("is", "coral-button");
  el41.setAttribute("icon", "close");
  el41.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el41.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el41.setAttribute("iconsize", "S");
  el41.setAttribute("type", "button");
  el41.setAttribute("data-type", "cancel");
  el41.setAttribute("tabindex", "-1");
  el39.appendChild(el41);
  var el42 = document.createTextNode("\r\n        ");
  el39.appendChild(el42);
  var el43 = document.createElement("button","coral-button");
  el43.setAttribute("is", "coral-button");
  el43.setAttribute("icon", "check");
  el43.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el43.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el43.setAttribute("iconsize", "S");
  el43.setAttribute("variant", "primary");
  el43.setAttribute("type", "button");
  el43.setAttribute("data-type", "apply");
  el43.setAttribute("tabindex", "-1");
  el39.appendChild(el43);
  var el44 = document.createTextNode("\r\n    ");
  el39.appendChild(el44);
  el37.appendChild(el39);
  var el45 = document.createTextNode("\r\n");
  el37.appendChild(el45);
  frag.appendChild(el37);
  var el46 = document.createTextNode("\r\n");
  frag.appendChild(el46);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["dlg_pasteplaintext"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createTextNode(" ");
  frag.appendChild(el0);
  var el1 = document.createElement("div");
  el1.className += " rte-dialog-columnContainer";
  var el2 = document.createTextNode("\r\n    ");
  el1.appendChild(el2);
  var el3 = document.createElement("div");
  el3.className += " rte-dialog-column";
  var el4 = document.createTextNode("\r\n        ");
  el3.appendChild(el4);
  var el5 = document.createElement("textarea","coral-textarea");
  el5.setAttribute("is", "coral-textarea");
  el5.setAttribute("placeholder", CUI["rte"]["Utils"]["i18n"]('dialog.pastePlainText.pasteAreaPlaceHolder'));
  el5.setAttribute("rows", "4");
  el3.appendChild(el5);
  var el6 = document.createTextNode("\r\n    ");
  el3.appendChild(el6);
  el1.appendChild(el3);
  var el7 = document.createTextNode("\r\n");
  el1.appendChild(el7);
  frag.appendChild(el1);
  var el8 = document.createTextNode("\r\n");
  frag.appendChild(el8);
  var el9 = document.createElement("div");
  el9.className += " rte-dialog-columnContainer u-coral-pullRight";
  var el10 = document.createTextNode("\r\n    ");
  el9.appendChild(el10);
  var el11 = document.createElement("div");
  el11.className += " rte-dialog-column";
  var el12 = document.createTextNode("\r\n        ");
  el11.appendChild(el12);
  var el13 = document.createElement("button","coral-button");
  el13.setAttribute("is", "coral-button");
  el13.setAttribute("icon", "close");
  el13.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el13.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el13.setAttribute("iconsize", "S");
  el13.setAttribute("data-type", "cancel");
  el13.setAttribute("tabindex", "-1");
  el11.appendChild(el13);
  var el14 = document.createTextNode("\r\n        ");
  el11.appendChild(el14);
  var el15 = document.createElement("button","coral-button");
  el15.setAttribute("is", "coral-button");
  el15.setAttribute("icon", "check");
  el15.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el15.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el15.setAttribute("iconsize", "S");
  el15.setAttribute("variant", "primary");
  el15.setAttribute("data-type", "apply");
  el15.setAttribute("tabindex", "-1");
  el11.appendChild(el15);
  var el16 = document.createTextNode("\r\n    ");
  el11.appendChild(el16);
  el9.appendChild(el11);
  var el17 = document.createTextNode("\r\n");
  el9.appendChild(el17);
  frag.appendChild(el9);
  var el18 = document.createTextNode("\r\n");
  frag.appendChild(el18);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["dlg_pastewordhtml"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " rte-dialog-columnContainer";
  var el1 = document.createTextNode("\r\n    ");
  el0.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " rte-dialog-column";
  var el3 = document.createTextNode("\r\n        ");
  el2.appendChild(el3);
  var el4 = document.createElement("iframe");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\r\n    ");
  el2.appendChild(el5);
  el0.appendChild(el2);
  var el6 = document.createTextNode("\r\n");
  el0.appendChild(el6);
  frag.appendChild(el0);
  var el7 = document.createTextNode("\r\n");
  frag.appendChild(el7);
  var el8 = document.createElement("div");
  el8.className += " rte-dialog-columnContainer u-coral-pullRight";
  var el9 = document.createTextNode("\r\n    ");
  el8.appendChild(el9);
  var el10 = document.createElement("div");
  el10.className += " rte-dialog-column";
  var el11 = document.createTextNode("\r\n        ");
  el10.appendChild(el11);
  var el12 = document.createElement("button","coral-button");
  el12.setAttribute("is", "coral-button");
  el12.setAttribute("icon", "close");
  el12.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el12.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el12.setAttribute("iconsize", "S");
  el12.setAttribute("data-type", "cancel");
  el12.setAttribute("tabindex", "-1");
  el10.appendChild(el12);
  var el13 = document.createTextNode("\r\n        ");
  el10.appendChild(el13);
  var el14 = document.createElement("button","coral-button");
  el14.setAttribute("is", "coral-button");
  el14.setAttribute("icon", "check");
  el14.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el14.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el14.setAttribute("iconsize", "S");
  el14.setAttribute("variant", "primary");
  el14.setAttribute("data-type", "apply");
  el14.setAttribute("tabindex", "-1");
  el10.appendChild(el14);
  var el15 = document.createTextNode("\r\n    ");
  el10.appendChild(el15);
  el8.appendChild(el10);
  var el16 = document.createTextNode("\r\n");
  el8.appendChild(el16);
  frag.appendChild(el8);
  var el17 = document.createTextNode("\r\n");
  frag.appendChild(el17);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["dlg_replace"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " rte-dialog-columnContainer";
  var el1 = document.createTextNode("\r\n    ");
  el0.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " rte-dialog-column";
  var el3 = document.createTextNode("\r\n        ");
  el2.appendChild(el3);
  var el4 = document.createElement("input","coral-textfield");
  el4.setAttribute("is", "coral-textfield");
  el4.setAttribute("data-type", "find");
  el4.setAttribute("value", "");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\r\n    ");
  el2.appendChild(el5);
  el0.appendChild(el2);
  var el6 = document.createTextNode("\r\n    ");
  el0.appendChild(el6);
  var el7 = document.createElement("div");
  el7.className += " rte-dialog-column";
  var el8 = document.createTextNode("\r\n        ");
  el7.appendChild(el8);
  var el9 = document.createElement("button","coral-button");
  el9.setAttribute("is", "coral-button");
  el9.setAttribute("variant", "primary");
  el9.setAttribute("data-type", "execFind");
  el9.setAttribute("tabindex", "-1");
  el9.className += " rte-dialogTextButton";
  el7.appendChild(el9);
  var el10 = document.createTextNode("\r\n    ");
  el7.appendChild(el10);
  el0.appendChild(el7);
  var el11 = document.createTextNode("\r\n");
  el0.appendChild(el11);
  frag.appendChild(el0);
  var el12 = document.createTextNode("\r\n");
  frag.appendChild(el12);
  var el13 = document.createElement("div");
  el13.className += " rte-dialog-columnContainer";
  var el14 = document.createTextNode("\r\n    ");
  el13.appendChild(el14);
  var el15 = document.createElement("div");
  el15.className += " rte-dialog-column";
  var el16 = document.createTextNode("\r\n        ");
  el15.appendChild(el16);
  var el17 = document.createElement("input","coral-textfield");
  el17.setAttribute("is", "coral-textfield");
  el17.setAttribute("data-type", "replace");
  el17.setAttribute("value", "");
  el15.appendChild(el17);
  var el18 = document.createTextNode("\r\n    ");
  el15.appendChild(el18);
  el13.appendChild(el15);
  var el19 = document.createTextNode("\r\n    ");
  el13.appendChild(el19);
  var el20 = document.createElement("div");
  el20.className += " rte-dialog-column";
  var el21 = document.createTextNode("\r\n        ");
  el20.appendChild(el21);
  var el22 = document.createElement("button","coral-button");
  el22.setAttribute("is", "coral-button");
  el22.setAttribute("variant", "primary");
  el22.setAttribute("data-type", "execReplace");
  el22.setAttribute("tabindex", "-1");
  el22.className += " rte-dialogTextButton";
  el20.appendChild(el22);
  var el23 = document.createTextNode("\r\n    ");
  el20.appendChild(el23);
  el13.appendChild(el20);
  var el24 = document.createTextNode("\r\n");
  el13.appendChild(el24);
  frag.appendChild(el13);
  var el25 = document.createTextNode("\r\n");
  frag.appendChild(el25);
  var el26 = document.createElement("div");
  el26.className += " rte-dialog-columnContainer";
  var el27 = document.createTextNode("\r\n    ");
  el26.appendChild(el27);
  var el28 = document.createElement("div");
  el28.className += " rte-dialog-innerTable";
  var el29 = document.createTextNode("\r\n        ");
  el28.appendChild(el29);
  var el30 = document.createElement("div");
  el30.className += " rte-dialog-columnContainer";
  var el31 = document.createTextNode("\r\n            ");
  el30.appendChild(el31);
  var el32 = document.createElement("div");
  el32.className += " rte-dialog-column";
  var el33 = document.createTextNode("\r\n                ");
  el32.appendChild(el33);
  var el34 = this["matchCaseBox"] = document.createElement("coral-checkbox");
  el34.setAttribute("name", "matchCase");
  el34.setAttribute("value", "false");
  el34.setAttribute("data-type", "matchCase");
  el34.setAttribute("handle", "matchCaseBox");
  el32.appendChild(el34);
  var el35 = document.createTextNode("\r\n            ");
  el32.appendChild(el35);
  el30.appendChild(el32);
  var el36 = document.createTextNode("\r\n            ");
  el30.appendChild(el36);
  var el37 = document.createElement("div");
  el37.className += " rte-dialog-column u-coral-pullRight";
  var el38 = document.createTextNode("\r\n                ");
  el37.appendChild(el38);
  var el39 = document.createElement("button","coral-button");
  el39.setAttribute("is", "coral-button");
  el39.setAttribute("icon", "close");
  el39.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el39.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el39.setAttribute("iconsize", "S");
  el39.setAttribute("data-type", "cancel");
  el39.setAttribute("tabindex", "-1");
  el37.appendChild(el39);
  var el40 = document.createTextNode("\r\n            ");
  el37.appendChild(el40);
  el30.appendChild(el37);
  var el41 = document.createTextNode("\r\n        ");
  el30.appendChild(el41);
  el28.appendChild(el30);
  var el42 = document.createTextNode("\r\n    ");
  el28.appendChild(el42);
  el26.appendChild(el28);
  var el43 = document.createTextNode("\r\n    ");
  el26.appendChild(el43);
  var el44 = document.createElement("div");
  el44.className += " rte-dialog-column";
  var el45 = document.createTextNode("\r\n        ");
  el44.appendChild(el45);
  var el46 = document.createElement("button","coral-button");
  el46.setAttribute("is", "coral-button");
  el46.setAttribute("variant", "primary");
  el46.setAttribute("data-type", "execReplaceAll");
  el46.setAttribute("tabindex", "-1");
  el46.className += " rte-dialogTextButton";
  el44.appendChild(el46);
  var el47 = document.createTextNode("\r\n    ");
  el44.appendChild(el47);
  el26.appendChild(el44);
  var el48 = document.createTextNode("\r\n");
  el26.appendChild(el48);
  frag.appendChild(el26);
  var el49 = document.createTextNode("\r\n");
  frag.appendChild(el49);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["dlg_specialchars"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " rte-dialog-columnContainer";
  var el1 = document.createTextNode("\r\n    ");
  el0.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " rte-dialog-column rte-dialog-column--specialchars";
  var el3 = document.createTextNode("\r\n        ");
  el2.appendChild(el3);
  var el4 = document.createElement("div");
  el4.className += " rte-specialchars-selector";
  var el5 = document.createTextNode("\r\n            ");
  el4.appendChild(el5);
  var el6 = document.createElement("div");
  el6.className += " rte-dialog-innerTable";
  el6.textContent = "\r\n            ";
  el4.appendChild(el6);
  var el7 = document.createTextNode("\r\n        ");
  el4.appendChild(el7);
  el2.appendChild(el4);
  var el8 = document.createTextNode("\r\n    ");
  el2.appendChild(el8);
  el0.appendChild(el2);
  var el9 = document.createTextNode("\r\n");
  el0.appendChild(el9);
  frag.appendChild(el0);
  var el10 = document.createTextNode("\r\n");
  frag.appendChild(el10);
  var el11 = document.createElement("coral-popover-separator");
  frag.appendChild(el11);
  var el12 = document.createTextNode("\r\n");
  frag.appendChild(el12);
  var el13 = document.createElement("div");
  el13.className += " rte-dialog-columnContainer u-coral-pullRight";
  var el14 = document.createTextNode("\r\n    ");
  el13.appendChild(el14);
  var el15 = document.createElement("div");
  el15.className += " rte-dialog-column";
  var el16 = document.createTextNode("\r\n        ");
  el15.appendChild(el16);
  var el17 = document.createElement("button","coral-button");
  el17.setAttribute("is", "coral-button");
  el17.setAttribute("icon", "close");
  el17.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el17.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el17.setAttribute("iconsize", "S");
  el17.setAttribute("data-type", "cancel");
  el17.setAttribute("tabindex", "-1");
  el15.appendChild(el17);
  var el18 = document.createTextNode("\r\n    ");
  el15.appendChild(el18);
  el13.appendChild(el15);
  var el19 = document.createTextNode("\r\n");
  el13.appendChild(el19);
  frag.appendChild(el13);
  var el20 = document.createTextNode("\r\n");
  frag.appendChild(el20);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["dlg_spellchecker"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " rte-dialog-columnContainer";
  var el1 = document.createTextNode("\r\n    ");
  el0.appendChild(el1);
  var iterated_1 = data_0["suggestions"];
  for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
    var data_1 = data = iterated_1[i1];
    var el3 = document.createTextNode("\r\n        ");
    el0.appendChild(el3);
    var el4 = document.createElement("div");
    el4.className += " rte-dialog-column rte-dialog-column--spellchecker u-coral-noPadding";
    var el5 = document.createTextNode("\r\n            ");
    el4.appendChild(el5);
    var el6 = document.createElement("button","coral-button");
    el6.setAttribute("is", "coral-button");
    el6.setAttribute("tabindex", "-1");
    if (data_1["original"]) {
    el6.setAttribute("data-value", data_1["original"]);
    el6.setAttribute("data-type", "replaceWord");
    el6.className += " rte-dialogButton u-coral-noBorder";
    }
    if (!(data_1["original"])) {
    el6.setAttribute("disabled", "disabled");
    el6.className += " rte-dialogButton u-coral-noBorder is-disabled";
    }
    el4.appendChild(el6);
    var el7 = document.createTextNode("\r\n        ");
    el4.appendChild(el7);
    el0.appendChild(el4);
    var el8 = document.createTextNode("\r\n    ");
    el0.appendChild(el8);
  }
  var el9 = document.createTextNode("\r\n");
  el0.appendChild(el9);
  frag.appendChild(el0);
  var el10 = document.createTextNode("\r\n");
  frag.appendChild(el10);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["dlg_tableandcellprops"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " rte-tabview";
  var el1 = document.createTextNode("\r\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("coral-tablist");
  el2.setAttribute("target", ".rte-panelstack");
  var el3 = document.createTextNode("\r\n    ");
  el2.appendChild(el3);
  var el4 = this["tab1"] = document.createElement("coral-tab");
  el4.setAttribute("handle", "tab1");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\r\n    ");
  el2.appendChild(el5);
  var el6 = this["tab2"] = document.createElement("coral-tab");
  el6.setAttribute("handle", "tab2");
  el2.appendChild(el6);
  var el7 = document.createTextNode("\r\n  ");
  el2.appendChild(el7);
  el0.appendChild(el2);
  var el8 = document.createTextNode("\r\n  ");
  el0.appendChild(el8);
  var el9 = document.createElement("coral-panelstack");
  el9.className += " rte-panelstack u-coral-noPadding-horizontal u-coral-padding-vertical";
  var el10 = document.createTextNode("\r\n    ");
  el9.appendChild(el10);
  var el11 = this["panel1"] = document.createElement("coral-panel");
  el11.setAttribute("handle", "panel1");
  el9.appendChild(el11);
  var el12 = document.createTextNode("\r\n    ");
  el9.appendChild(el12);
  var el13 = this["panel2"] = document.createElement("coral-panel");
  el13.setAttribute("handle", "panel2");
  el9.appendChild(el13);
  var el14 = document.createTextNode("\r\n  ");
  el9.appendChild(el14);
  el0.appendChild(el9);
  var el15 = document.createTextNode("\r\n");
  el0.appendChild(el15);
  frag.appendChild(el0);
  var el16 = document.createTextNode("\r\n");
  frag.appendChild(el16);
  var el17 = document.createElement("div");
  el17.className += " rte-dialog-columnContainer u-coral-pullRight";
  var el18 = document.createTextNode("\r\n  ");
  el17.appendChild(el18);
  var el19 = document.createElement("div");
  el19.className += " rte-dialog-column";
  var el20 = document.createTextNode("\r\n    ");
  el19.appendChild(el20);
  var el21 = document.createElement("button","coral-button");
  el21.setAttribute("is", "coral-button");
  el21.setAttribute("icon", "close");
  el21.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el21.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el21.setAttribute("iconsize", "S");
  el21.setAttribute("data-type", "cancel");
  el21.setAttribute("tabindex", "-1");
  el19.appendChild(el21);
  var el22 = document.createTextNode("\r\n    ");
  el19.appendChild(el22);
  var el23 = document.createElement("button","coral-button");
  el23.setAttribute("is", "coral-button");
  el23.setAttribute("icon", "check");
  el23.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el23.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el23.setAttribute("iconsize", "S");
  el23.setAttribute("variant", "primary");
  el23.setAttribute("data-type", "apply");
  el23.setAttribute("tabindex", "-1");
  el19.appendChild(el23);
  var el24 = document.createTextNode("\r\n  ");
  el19.appendChild(el24);
  el17.appendChild(el19);
  var el25 = document.createTextNode("\r\n");
  el17.appendChild(el25);
  frag.appendChild(el17);
  var el26 = document.createTextNode("\r\n\r\n");
  frag.appendChild(el26);
  var el27 = this["panel1content"] = document.createElement("div");
  el27.setAttribute("handle", "panel1content");
  var el28 = document.createTextNode("\r\n  ");
  el27.appendChild(el28);
  var el29 = document.createElement("div");
  el29.className += " rte-dialog-table";
  var el30 = document.createTextNode("\r\n    ");
  el29.appendChild(el30);
  var el31 = document.createElement("div");
  el31.className += " rte-dialog-columnContainer";
  var el32 = document.createTextNode("\r\n      ");
  el31.appendChild(el32);
  var el33 = document.createElement("div");
  el33.className += " rte-dialog-column rte-dialog-column--rightAligned";
  var el34 = document.createTextNode("\r\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.width')+"    \r\n        ");
  el33.appendChild(el34);
  var el35 = document.createElement("input","coral-textfield");
  el35.setAttribute("is", "coral-textfield");
  el35.setAttribute("data-type", "cell-width");
  el35.setAttribute("value", "");
  el35.className += " rte--small";
  el33.appendChild(el35);
  var el36 = document.createTextNode("\r\n        ");
  el33.appendChild(el36);
  var el37 = document.createElement("coral-icon");
  el37.setAttribute("icon", "infoCircle");
  el37.setAttribute("size", "S");
  el37.setAttribute("tabindex", "0");
  el37.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.widthToolTip'));
  el33.appendChild(el37);
  var el38 = document.createTextNode("\r\n        ");
  el33.appendChild(el38);
  var el39 = this["widthToolTip"] = document.createElement("coral-tooltip");
  el39.setAttribute("handle", "widthToolTip");
  el33.appendChild(el39);
  var el40 = document.createTextNode("\r\n      ");
  el33.appendChild(el40);
  el31.appendChild(el33);
  var el41 = document.createTextNode("\r\n      ");
  el31.appendChild(el41);
  var el42 = document.createElement("div");
  el42.className += " rte-dialog-column";
  var el43 = document.createTextNode("\r\n        ");
  el42.appendChild(el43);
  var el44 = this["cellHorizontalAlignmentSelect"] = document.createElement("coral-select");
  el44.className += " rte-dialog-select--cellHorizontalAlignment";
  el44.setAttribute("handle", "cellHorizontalAlignmentSelect");
  var el45 = document.createTextNode("\r\n          ");
  el44.appendChild(el45);
  var el46 = document.createElement("coral-select-item");
  el46.setAttribute("value", "none");
  el46.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.noneAlignHor');
  el44.appendChild(el46);
  var el47 = document.createTextNode("\r\n          ");
  el44.appendChild(el47);
  var el48 = document.createElement("coral-select-item");
  el48.setAttribute("value", "left");
  el48.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.leftAlign');
  el44.appendChild(el48);
  var el49 = document.createTextNode("\r\n          ");
  el44.appendChild(el49);
  var el50 = document.createElement("coral-select-item");
  el50.setAttribute("value", "center");
  el50.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.centerAlign');
  el44.appendChild(el50);
  var el51 = document.createTextNode("\r\n          ");
  el44.appendChild(el51);
  var el52 = document.createElement("coral-select-item");
  el52.setAttribute("value", "right");
  el52.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.rightAlign');
  el44.appendChild(el52);
  var el53 = document.createTextNode("\r\n        ");
  el44.appendChild(el53);
  el42.appendChild(el44);
  var el54 = document.createTextNode("\r\n      ");
  el42.appendChild(el54);
  el31.appendChild(el42);
  var el55 = document.createTextNode("\r\n    ");
  el31.appendChild(el55);
  el29.appendChild(el31);
  var el56 = document.createTextNode("\r\n    ");
  el29.appendChild(el56);
  var el57 = document.createElement("div");
  el57.className += " rte-dialog-columnContainer";
  var el58 = document.createTextNode("\r\n      ");
  el57.appendChild(el58);
  var el59 = document.createElement("div");
  el59.className += " rte-dialog-column rte-dialog-column--rightAligned";
  var el60 = document.createTextNode("\r\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.height')+"    \r\n        ");
  el59.appendChild(el60);
  var el61 = document.createElement("input","coral-textfield");
  el61.setAttribute("is", "coral-textfield");
  el61.setAttribute("data-type", "cell-height");
  el61.setAttribute("value", "");
  el61.className += " rte--small";
  el59.appendChild(el61);
  var el62 = document.createTextNode("\r\n        ");
  el59.appendChild(el62);
  var el63 = document.createElement("coral-icon");
  el63.setAttribute("icon", "infoCircle");
  el63.setAttribute("size", "S");
  el63.setAttribute("tabindex", "0");
  el63.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.heightToolTip'));
  el59.appendChild(el63);
  var el64 = document.createTextNode("\r\n        ");
  el59.appendChild(el64);
  var el65 = this["heightToolTip"] = document.createElement("coral-tooltip");
  el65.setAttribute("handle", "heightToolTip");
  el59.appendChild(el65);
  var el66 = document.createTextNode("\r\n      ");
  el59.appendChild(el66);
  el57.appendChild(el59);
  var el67 = document.createTextNode("\r\n      ");
  el57.appendChild(el67);
  var el68 = document.createElement("div");
  el68.className += " rte-dialog-column";
  var el69 = document.createTextNode("\r\n        ");
  el68.appendChild(el69);
  var el70 = this["cellVerticalAlignmentSelect"] = document.createElement("coral-select");
  el70.className += " rte-dialog-select--cellVerticalAlignment";
  el70.setAttribute("handle", "cellVerticalAlignmentSelect");
  var el71 = document.createTextNode("\r\n          ");
  el70.appendChild(el71);
  var el72 = document.createElement("coral-select-item");
  el72.setAttribute("value", "none");
  el72.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.noneAlignVer');
  el70.appendChild(el72);
  var el73 = document.createTextNode("\r\n          ");
  el70.appendChild(el73);
  var el74 = document.createElement("coral-select-item");
  el74.setAttribute("value", "top");
  el74.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.topAlign');
  el70.appendChild(el74);
  var el75 = document.createTextNode("\r\n          ");
  el70.appendChild(el75);
  var el76 = document.createElement("coral-select-item");
  el76.setAttribute("value", "middle");
  el76.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.middleAlign');
  el70.appendChild(el76);
  var el77 = document.createTextNode("\r\n          ");
  el70.appendChild(el77);
  var el78 = document.createElement("coral-select-item");
  el78.setAttribute("value", "bottom");
  el78.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.bottomAlign');
  el70.appendChild(el78);
  var el79 = document.createTextNode("\r\n          ");
  el70.appendChild(el79);
  var el80 = document.createElement("coral-select-item");
  el80.setAttribute("value", "baseline");
  el80.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.baselineAlign');
  el70.appendChild(el80);
  var el81 = document.createTextNode("\r\n        ");
  el70.appendChild(el81);
  el68.appendChild(el70);
  var el82 = document.createTextNode("\r\n      ");
  el68.appendChild(el82);
  el57.appendChild(el68);
  var el83 = document.createTextNode("\r\n    ");
  el57.appendChild(el83);
  el29.appendChild(el57);
  var el84 = document.createTextNode("\r\n  ");
  el29.appendChild(el84);
  el27.appendChild(el29);
  var el85 = document.createTextNode("\r\n  ");
  el27.appendChild(el85);
  var el86 = document.createElement("coral-popover-separator");
  el27.appendChild(el86);
  var el87 = document.createTextNode("\r\n  ");
  el27.appendChild(el87);
  var el88 = document.createElement("div");
  el88.className += " rte-dialog-table";
  var el89 = document.createTextNode("\r\n    ");
  el88.appendChild(el89);
  var el90 = document.createElement("div");
  el90.className += " rte-dialog-columnContainer";
  var el91 = document.createTextNode("\r\n      ");
  el90.appendChild(el91);
  var el92 = document.createElement("div");
  el92.className += " rte-dialog-column rte-dialog-column--cellType";
  el92.textContent = "\r\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.cellType')+"\r\n      ";
  el90.appendChild(el92);
  var el93 = document.createTextNode("\r\n      ");
  el90.appendChild(el93);
  var el94 = document.createElement("div");
  el94.className += " rte-dialog-column";
  var el95 = document.createTextNode("\r\n        ");
  el94.appendChild(el95);
  var el96 = this["cellTypeSelect"] = document.createElement("coral-select");
  el96.className += " rte-dialog-select--cellType";
  el96.setAttribute("placeholder", CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.cellType'));
  el96.setAttribute("handle", "cellTypeSelect");
  var el97 = document.createTextNode("\r\n          ");
  el96.appendChild(el97);
  var el98 = document.createElement("coral-select-item");
  el98.setAttribute("value", "td");
  el98.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.dataCell');
  el96.appendChild(el98);
  var el99 = document.createTextNode("\r\n          ");
  el96.appendChild(el99);
  var el100 = document.createElement("coral-select-item");
  el100.setAttribute("value", "th");
  el100.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.headerCell');
  el96.appendChild(el100);
  var el101 = document.createTextNode("\r\n        ");
  el96.appendChild(el101);
  el94.appendChild(el96);
  var el102 = document.createTextNode("\r\n      ");
  el94.appendChild(el102);
  el90.appendChild(el94);
  var el103 = document.createTextNode("\r\n    ");
  el90.appendChild(el103);
  el88.appendChild(el90);
  var el104 = document.createTextNode("\r\n    ");
  el88.appendChild(el104);
  var el105 = document.createElement("div");
  el105.className += " rte-dialog-columnContainer rte-dialog-columnContainer--headerAttribute";
  var el106 = document.createTextNode("\r\n      ");
  el105.appendChild(el106);
  var el107 = document.createElement("div");
  el107.className += " rte-dialog-column";
  el107.textContent = "\r\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.headerAttrib')+"\r\n      ";
  el105.appendChild(el107);
  var el108 = document.createTextNode("\r\n      ");
  el105.appendChild(el108);
  var el109 = document.createElement("div");
  el109.className += " rte-dialog-column";
  var el110 = document.createTextNode("\r\n        ");
  el109.appendChild(el110);
  var el111 = document.createElement("input","coral-textfield");
  el111.setAttribute("is", "coral-textfield");
  el111.setAttribute("data-type", "cell-headers");
  el111.setAttribute("value", "");
  el111.className += " rte--large";
  el109.appendChild(el111);
  var el112 = document.createTextNode("\r\n      ");
  el109.appendChild(el112);
  el105.appendChild(el109);
  var el113 = document.createTextNode("\r\n    ");
  el105.appendChild(el113);
  el88.appendChild(el105);
  var el114 = document.createTextNode("\r\n    ");
  el88.appendChild(el114);
  var el115 = document.createElement("div");
  el115.className += " rte-dialog-columnContainer rte-dialog-columnContainer--idAttribute";
  var el116 = document.createTextNode("\r\n      ");
  el115.appendChild(el116);
  var el117 = document.createElement("div");
  el117.className += " rte-dialog-column";
  el117.textContent = "\r\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.idAttrib')+"\r\n      ";
  el115.appendChild(el117);
  var el118 = document.createTextNode("\r\n      ");
  el115.appendChild(el118);
  var el119 = document.createElement("div");
  el119.className += " rte-dialog-column";
  var el120 = document.createTextNode("\r\n        ");
  el119.appendChild(el120);
  var el121 = document.createElement("input","coral-textfield");
  el121.setAttribute("is", "coral-textfield");
  el121.setAttribute("data-type", "cell-id");
  el121.setAttribute("value", "");
  el121.className += " rte--small rte-Textfield--cellId";
  el119.appendChild(el121);
  var el122 = document.createTextNode("\r\n        ");
  el119.appendChild(el122);
  var el123 = document.createElement("label");
  el123.id = "rte-Switch-label--hiddenHeader";
  el123.textContent = "  "+CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.hiddenHeader')+"  ";
  el119.appendChild(el123);
  var el124 = document.createTextNode("\r\n        ");
  el119.appendChild(el124);
  var el125 = document.createElement("coral-switch");
  el125.className += " rte-Switch";
  el125.setAttribute("value", "true");
  el125.setAttribute("data-type", "cell-hiddenheader");
  el125.setAttribute("labelledby", "rte-Switch-label--hiddenHeader");
  el119.appendChild(el125);
  var el126 = document.createTextNode("\r\n      ");
  el119.appendChild(el126);
  el115.appendChild(el119);
  var el127 = document.createTextNode("\r\n    ");
  el115.appendChild(el127);
  el88.appendChild(el115);
  var el128 = document.createTextNode("\r\n    ");
  el88.appendChild(el128);
  var el129 = document.createElement("div");
  el129.className += " rte-dialog-columnContainer rte-dialog-columnContainer--scopeAttribute";
  var el130 = document.createTextNode("\r\n      ");
  el129.appendChild(el130);
  var el131 = document.createElement("div");
  el131.className += " rte-dialog-column";
  el131.textContent = "\r\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.scopeAttrib')+"\r\n      ";
  el129.appendChild(el131);
  var el132 = document.createTextNode("\r\n      ");
  el129.appendChild(el132);
  var el133 = document.createElement("div");
  el133.className += " rte-dialog-column";
  var el134 = document.createTextNode("\r\n        ");
  el133.appendChild(el134);
  var el135 = this["scopeAttributeSelect"] = document.createElement("coral-select");
  el135.className += " rte-dialog-column--scopeAttribute";
  el135.setAttribute("handle", "scopeAttributeSelect");
  var el136 = document.createTextNode("\r\n          ");
  el135.appendChild(el136);
  var el137 = document.createElement("coral-select-item");
  el137.setAttribute("value", "none");
  el137.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.noneScopeAttrib');
  el135.appendChild(el137);
  var el138 = document.createTextNode("\r\n          ");
  el135.appendChild(el138);
  var el139 = document.createElement("coral-select-item");
  el139.setAttribute("value", "row");
  el139.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.rowScope');
  el135.appendChild(el139);
  var el140 = document.createTextNode("\r\n          ");
  el135.appendChild(el140);
  var el141 = document.createElement("coral-select-item");
  el141.setAttribute("value", "col");
  el141.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.columnScope');
  el135.appendChild(el141);
  var el142 = document.createTextNode("\r\n        ");
  el135.appendChild(el142);
  el133.appendChild(el135);
  var el143 = document.createTextNode("\r\n      ");
  el133.appendChild(el143);
  el129.appendChild(el133);
  var el144 = document.createTextNode("\r\n    ");
  el129.appendChild(el144);
  el88.appendChild(el129);
  var el145 = document.createTextNode("\r\n  ");
  el88.appendChild(el145);
  el27.appendChild(el88);
  var el146 = document.createTextNode("\r\n");
  el27.appendChild(el146);
  frag.appendChild(el27);
  var el147 = document.createTextNode("\r\n\r\n\r\n");
  frag.appendChild(el147);
  var el148 = this["panel2content"] = document.createElement("div");
  el148.setAttribute("handle", "panel2content");
  var el149 = document.createTextNode("\r\n  ");
  el148.appendChild(el149);
  var el150 = document.createElement("div");
  el150.className += " rte-dialog-table";
  var el151 = document.createTextNode("\r\n    ");
  el150.appendChild(el151);
  var el152 = document.createElement("div");
  el152.className += " rte-dialog-columnContainer";
  var el153 = document.createTextNode("\r\n      ");
  el152.appendChild(el153);
  var el154 = document.createElement("div");
  el154.className += " rte-dialog-column";
  el154.textContent = "\r\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.width')+"\r\n      ";
  el152.appendChild(el154);
  var el155 = document.createTextNode("\r\n      ");
  el152.appendChild(el155);
  var el156 = document.createElement("div");
  el156.className += " rte-dialog-column";
  var el157 = document.createTextNode("\r\n        ");
  el156.appendChild(el157);
  var el158 = document.createElement("input","coral-textfield");
  el158.setAttribute("is", "coral-textfield");
  el158.setAttribute("data-type", "width");
  el158.setAttribute("value", "");
  el158.className += " rte--small";
  el156.appendChild(el158);
  var el159 = document.createTextNode(" \r\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.cellPadding')+" ");
  el156.appendChild(el159);
  var el160 = document.createElement("input","coral-textfield");
  el160.setAttribute("is", "coral-textfield");
  el160.setAttribute("data-type", "cellpadding");
  el160.setAttribute("value", "");
  el160.className += " rte--small";
  el156.appendChild(el160);
  var el161 = document.createTextNode(" \r\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.border')+" ");
  el156.appendChild(el161);
  var el162 = document.createElement("input","coral-textfield");
  el162.setAttribute("is", "coral-textfield");
  el162.setAttribute("data-type", "border");
  el162.setAttribute("value", "");
  el162.className += " rte--small";
  el156.appendChild(el162);
  var el163 = document.createTextNode("\r\n      ");
  el156.appendChild(el163);
  el152.appendChild(el156);
  var el164 = document.createTextNode("\r\n    ");
  el152.appendChild(el164);
  el150.appendChild(el152);
  var el165 = document.createTextNode("\r\n    ");
  el150.appendChild(el165);
  var el166 = document.createElement("div");
  el166.className += " rte-dialog-columnContainer";
  var el167 = document.createTextNode("\r\n      ");
  el166.appendChild(el167);
  var el168 = document.createElement("div");
  el168.className += " rte-dialog-column";
  el168.textContent = "\r\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.height')+"\r\n      ";
  el166.appendChild(el168);
  var el169 = document.createTextNode("\r\n      ");
  el166.appendChild(el169);
  var el170 = document.createElement("div");
  el170.className += " rte-dialog-column";
  var el171 = document.createTextNode("\r\n        ");
  el170.appendChild(el171);
  var el172 = document.createElement("input","coral-textfield");
  el172.setAttribute("is", "coral-textfield");
  el172.setAttribute("data-type", "height");
  el172.setAttribute("value", "");
  el172.className += " rte--small";
  el170.appendChild(el172);
  var el173 = document.createTextNode(" \r\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.cellSpacing')+"  ");
  el170.appendChild(el173);
  var el174 = document.createElement("input","coral-textfield");
  el174.setAttribute("is", "coral-textfield");
  el174.setAttribute("data-type", "cellspacing");
  el174.setAttribute("value", "");
  el174.className += " rte--small";
  el170.appendChild(el174);
  var el175 = document.createTextNode("\r\n      ");
  el170.appendChild(el175);
  el166.appendChild(el170);
  var el176 = document.createTextNode("\r\n    ");
  el166.appendChild(el176);
  el150.appendChild(el166);
  var el177 = document.createTextNode("\r\n    ");
  el150.appendChild(el177);
  var el178 = document.createElement("div");
  el178.className += " rte-dialog-columnContainer";
  var el179 = document.createTextNode("\r\n      ");
  el178.appendChild(el179);
  var el180 = document.createElement("div");
  el180.className += " rte-dialog-column";
  el180.textContent = "\r\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableAndCellProps.caption')+"\r\n      ";
  el178.appendChild(el180);
  var el181 = document.createTextNode("\r\n      ");
  el178.appendChild(el181);
  var el182 = document.createElement("div");
  el182.className += " rte-dialog-column";
  var el183 = document.createTextNode("\r\n        ");
  el182.appendChild(el183);
  var el184 = document.createElement("input","coral-textfield");
  el184.setAttribute("is", "coral-textfield");
  el184.setAttribute("data-type", "caption");
  el184.setAttribute("value", "");
  el184.className += " rte--large";
  el182.appendChild(el184);
  var el185 = document.createTextNode("\r\n      ");
  el182.appendChild(el185);
  el178.appendChild(el182);
  var el186 = document.createTextNode("\r\n    ");
  el178.appendChild(el186);
  el150.appendChild(el178);
  var el187 = document.createTextNode("\r\n  ");
  el150.appendChild(el187);
  el148.appendChild(el150);
  var el188 = document.createTextNode("\r\n");
  el148.appendChild(el188);
  frag.appendChild(el148);
  var el189 = document.createTextNode("\r\n");
  frag.appendChild(el189);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["dlg_tableprops"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " rte-dialog-columnContainer";
  var el1 = document.createTextNode("\n    ");
  el0.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " rte-dialog-column";
  el2.textContent = "\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableProps.columns')+"\n    ";
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n    ");
  el0.appendChild(el3);
  var el4 = document.createElement("div");
  el4.className += " rte-dialog-column";
  var el5 = document.createTextNode("\n        ");
  el4.appendChild(el5);
  var el6 = document.createElement("input","coral-textfield");
  el6.setAttribute("is", "coral-textfield");
  el6.setAttribute("data-type", "columns");
  el6.setAttribute("value", "");
  el6.className += " rte--small";
  el4.appendChild(el6);
  var el7 = document.createTextNode(" \n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableProps.width')+"  ");
  el4.appendChild(el7);
  var el8 = document.createElement("input","coral-textfield");
  el8.setAttribute("is", "coral-textfield");
  el8.setAttribute("data-type", "width");
  el8.setAttribute("value", "");
  el8.className += " rte--small";
  el4.appendChild(el8);
  var el9 = document.createTextNode(" \n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableProps.cellPadding')+" ");
  el4.appendChild(el9);
  var el10 = document.createElement("input","coral-textfield");
  el10.setAttribute("is", "coral-textfield");
  el10.setAttribute("data-type", "cellpadding");
  el10.setAttribute("value", "");
  el10.className += " rte--small";
  el4.appendChild(el10);
  var el11 = document.createTextNode("\n    ");
  el4.appendChild(el11);
  el0.appendChild(el4);
  var el12 = document.createTextNode("\n");
  el0.appendChild(el12);
  frag.appendChild(el0);
  var el13 = document.createTextNode("\n");
  frag.appendChild(el13);
  var el14 = document.createElement("div");
  el14.className += " rte-dialog-columnContainer";
  var el15 = document.createTextNode("\n    ");
  el14.appendChild(el15);
  var el16 = document.createElement("div");
  el16.className += " rte-dialog-column";
  el16.textContent = "\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableProps.rows')+"\n    ";
  el14.appendChild(el16);
  var el17 = document.createTextNode("\n    ");
  el14.appendChild(el17);
  var el18 = document.createElement("div");
  el18.className += " rte-dialog-column";
  var el19 = document.createTextNode("\n        ");
  el18.appendChild(el19);
  var el20 = document.createElement("input","coral-textfield");
  el20.setAttribute("is", "coral-textfield");
  el20.setAttribute("data-type", "rows");
  el20.setAttribute("value", "");
  el20.className += " rte--small";
  el18.appendChild(el20);
  var el21 = document.createTextNode(" \n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableProps.height')+" ");
  el18.appendChild(el21);
  var el22 = document.createElement("input","coral-textfield");
  el22.setAttribute("is", "coral-textfield");
  el22.setAttribute("data-type", "height");
  el22.setAttribute("value", "");
  el22.className += " rte--small";
  el18.appendChild(el22);
  var el23 = document.createTextNode(" \n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableProps.cellSpacing')+"  ");
  el18.appendChild(el23);
  var el24 = document.createElement("input","coral-textfield");
  el24.setAttribute("is", "coral-textfield");
  el24.setAttribute("data-type", "cellspacing");
  el24.setAttribute("value", "");
  el24.className += " rte--small";
  el18.appendChild(el24);
  var el25 = document.createTextNode("\n    ");
  el18.appendChild(el25);
  el14.appendChild(el18);
  var el26 = document.createTextNode("\n");
  el14.appendChild(el26);
  frag.appendChild(el14);
  var el27 = document.createTextNode("\n");
  frag.appendChild(el27);
  var el28 = document.createElement("div");
  el28.className += " rte-dialog-columnContainer";
  var el29 = document.createTextNode("\n    ");
  el28.appendChild(el29);
  var el30 = document.createElement("div");
  el30.className += " rte-dialog-column";
  el30.textContent = "\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableProps.border')+"\n    ";
  el28.appendChild(el30);
  var el31 = document.createTextNode("\n    ");
  el28.appendChild(el31);
  var el32 = document.createElement("div");
  el32.className += " rte-dialog-column";
  var el33 = document.createTextNode("\n        ");
  el32.appendChild(el33);
  var el34 = document.createElement("input","coral-textfield");
  el34.setAttribute("is", "coral-textfield");
  el34.setAttribute("data-type", "border");
  el34.setAttribute("value", "");
  el34.className += " rte--small";
  el32.appendChild(el34);
  var el35 = document.createTextNode(" \n        ");
  el32.appendChild(el35);
  var el36 = this["headerSelect"] = document.createElement("coral-select");
  el36.className += " rte-dialog-column--headerField";
  el36.setAttribute("handle", "headerSelect");
  el36.setAttribute("placeholder", "No Header");
  var el37 = document.createTextNode("\n            ");
  el36.appendChild(el37);
  var el38 = document.createElement("coral-select-item");
  el38.setAttribute("value", "none");
  el38.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableProps.noHeader');
  el36.appendChild(el38);
  var el39 = document.createTextNode("\n            ");
  el36.appendChild(el39);
  var el40 = document.createElement("coral-select-item");
  el40.setAttribute("value", "top");
  el40.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableProps.rowHeader');
  el36.appendChild(el40);
  var el41 = document.createTextNode("\n            ");
  el36.appendChild(el41);
  var el42 = document.createElement("coral-select-item");
  el42.setAttribute("value", "left");
  el42.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableProps.colHeader');
  el36.appendChild(el42);
  var el43 = document.createTextNode("\n            ");
  el36.appendChild(el43);
  var el44 = document.createElement("coral-select-item");
  el44.setAttribute("value", "topleft");
  el44.textContent = CUI["rte"]["Utils"]["i18n"]('dialog.tableProps.rowAndColHeader');
  el36.appendChild(el44);
  var el45 = document.createTextNode("\n        ");
  el36.appendChild(el45);
  el32.appendChild(el36);
  var el46 = document.createTextNode("\n    ");
  el32.appendChild(el46);
  el28.appendChild(el32);
  var el47 = document.createTextNode("\n");
  el28.appendChild(el47);
  frag.appendChild(el28);
  var el48 = document.createTextNode("\n");
  frag.appendChild(el48);
  var el49 = document.createElement("div");
  el49.className += " rte-dialog-columnContainer";
  var el50 = document.createTextNode("\n    ");
  el49.appendChild(el50);
  var el51 = document.createElement("div");
  el51.className += " rte-dialog-column rte-dialog-column--caption";
  el51.textContent = "\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.tableProps.caption')+"\n    ";
  el49.appendChild(el51);
  var el52 = document.createTextNode("\n    ");
  el49.appendChild(el52);
  var el53 = document.createElement("div");
  el53.className += " rte-dialog-column";
  var el54 = document.createTextNode("\n        ");
  el53.appendChild(el54);
  var el55 = document.createElement("input","coral-textfield");
  el55.setAttribute("is", "coral-textfield");
  el55.setAttribute("data-type", "caption");
  el55.setAttribute("value", "");
  el55.className += " rte--large";
  el53.appendChild(el55);
  var el56 = document.createTextNode("\n    ");
  el53.appendChild(el56);
  el49.appendChild(el53);
  var el57 = document.createTextNode("\n");
  el49.appendChild(el57);
  frag.appendChild(el49);
  var el58 = document.createTextNode("\n");
  frag.appendChild(el58);
  var el59 = document.createElement("coral-popover-separator");
  frag.appendChild(el59);
  var el60 = document.createTextNode("\n");
  frag.appendChild(el60);
  var el61 = document.createElement("div");
  el61.className += " rte-dialog-columnContainer u-coral-pullRight";
  var el62 = document.createTextNode("\n    ");
  el61.appendChild(el62);
  var el63 = document.createElement("div");
  el63.className += " rte-dialog-column";
  var el64 = document.createTextNode("\n        ");
  el63.appendChild(el64);
  var el65 = document.createElement("button","coral-button");
  el65.setAttribute("is", "coral-button");
  el65.setAttribute("icon", "close");
  el65.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el65.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.cancel'));
  el65.setAttribute("iconsize", "S");
  el65.setAttribute("data-type", "cancel");
  el65.setAttribute("tabindex", "-1");
  el63.appendChild(el65);
  var el66 = document.createTextNode("\n        ");
  el63.appendChild(el66);
  var el67 = document.createElement("button","coral-button");
  el67.setAttribute("is", "coral-button");
  el67.setAttribute("icon", "check");
  el67.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el67.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('dialog.apply'));
  el67.setAttribute("iconsize", "S");
  el67.setAttribute("variant", "primary");
  el67.setAttribute("data-type", "apply");
  el67.setAttribute("tabindex", "-1");
  el63.appendChild(el67);
  var el68 = document.createTextNode("\n    ");
  el63.appendChild(el68);
  el61.appendChild(el63);
  var el69 = document.createTextNode("\n");
  el61.appendChild(el69);
  frag.appendChild(el61);
  var el70 = document.createTextNode("\n");
  frag.appendChild(el70);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["fullscreen_dialog"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("coral-dialog");
  el0.setAttribute("fullscreen", "");
  el0.className += " rte-fullscreen-dialog";
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("coral-dialog-header");
  el2.className += " rte-fullscreen-header";
  el2.textContent = "\n    "+CUI["rte"]["Utils"]["i18n"]('dialog.fullscreen.text')+"\n  ";
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n  ");
  el0.appendChild(el3);
  var el4 = document.createElement("coral-dialog-content");
  var el5 = document.createTextNode("\n    ");
  el4.appendChild(el5);
  var el6 = document.createElement("div");
  el6.className += " rte-fullscreen-richtextContainer";
  var el7 = document.createTextNode("\n      ");
  el6.appendChild(el7);
  var el8 = document.createElement("div");
  el8.className += " rte-editorWrapper";
  var el9 = document.createTextNode("\n        ");
  el8.appendChild(el9);
  var el10 = document.createElement("div");
  el10.className += " rte-editor u-coral-padding";
  el10.textContent = "\n        ";
  el8.appendChild(el10);
  var el11 = document.createTextNode("\n        ");
  el8.appendChild(el11);
  var el12 = document.createElement("textarea");
  el12.className += " rte-sourceEditor u-coral-noBorder";
  el8.appendChild(el12);
  var el13 = document.createTextNode("\n      ");
  el8.appendChild(el13);
  el6.appendChild(el8);
  var el14 = document.createTextNode("\n    ");
  el6.appendChild(el14);
  el4.appendChild(el6);
  var el15 = document.createTextNode("\n  ");
  el4.appendChild(el15);
  el0.appendChild(el4);
  var el16 = document.createTextNode("\n  ");
  el0.appendChild(el16);
  if (data_0["allowMinimize"]) {
    var el18 = document.createTextNode("\n    ");
    el0.appendChild(el18);
    var el19 = document.createElement("coral-dialog-footer");
    var el20 = document.createTextNode("\n      ");
    el19.appendChild(el20);
    var el21 = document.createElement("span");
    el21.className += " rte-fullscreen-footer-content";
    var el22 = document.createTextNode("\n        "+CUI["rte"]["Utils"]["i18n"]('dialog.fullscreen.minimize')+"\n        ");
    el21.appendChild(el22);
    var el23 = document.createElement("button","coral-button");
    el23.setAttribute("iconsize", "S");
    el23.setAttribute("is", "coral-button");
    el23.setAttribute("icon", "fullScreenExit");
    el23.setAttribute("variant", "quiet");
    el23.setAttribute("data-action", "fullscreen#finish");
    el23.setAttribute("title", CUI["rte"]["Utils"]["i18n"]('Fullscreen'));
    el23.setAttribute("aria-label", CUI["rte"]["Utils"]["i18n"]('Fullscreen'));
    el23.setAttribute("tabindex", "-1");
    el23.className += " rte-fullScreenExit rte--modechanger";
    el21.appendChild(el23);
    var el24 = document.createTextNode("\n        ");
    el21.appendChild(el24);
    el19.appendChild(el21);
    var el25 = document.createTextNode("\n    ");
    el19.appendChild(el25);
    el0.appendChild(el19);
    var el26 = document.createTextNode("\n  ");
    el0.appendChild(el26);
  }
  var el27 = document.createTextNode("\n");
  el0.appendChild(el27);
  frag.appendChild(el0);
  var el28 = document.createTextNode("\n");
  frag.appendChild(el28);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["item_textarea"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  if (data_0["label"]) {
    var el1 = document.createTextNode("\r\n  ");
    frag.appendChild(el1);
    var el2 = document.createElement("label");
    el2.setAttribute("for", data_0["id"]);
    el2.textContent = data_0["label"];
    frag.appendChild(el2);
    var el3 = document.createElement("br");
    frag.appendChild(el3);
    var el4 = document.createTextNode("\r\n");
    frag.appendChild(el4);
  }
  var el5 = document.createTextNode("\r\n");
  frag.appendChild(el5);
  var el6 = document.createElement("textarea");
  el6.setAttribute("name", data_0["id"]);
  el6.id = data_0["id"];
  el6.className += " rte--medium";
  frag.appendChild(el6);
  var el7 = document.createTextNode("\r\n");
  frag.appendChild(el7);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["paraformat_pulldown"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("coral-buttonlist");
  el0.className += " rte-toolbar-list";
  var el1 = document.createTextNode("\r\n");
  el0.appendChild(el1);
  var iterated_1 = data_0;
  for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
    var data_1 = data = iterated_1[i1];
    var el3 = document.createTextNode("\r\n    ");
    el0.appendChild(el3);
    var el4 = document.createElement("button","coral-buttonlist-item");
    el4.setAttribute("is", "coral-buttonlist-item");
    el4.setAttribute("data-action", "paraformat#"+data_1["tag"]);
    el4.textContent = data_1["description"];
    el0.appendChild(el4);
    var el5 = document.createTextNode("\r\n");
    el0.appendChild(el5);
  }
  var el6 = document.createTextNode("\r\n");
  el0.appendChild(el6);
  frag.appendChild(el0);
  var el7 = document.createTextNode("\r\n");
  frag.appendChild(el7);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["popover_item"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("button","coral-button");
  el0.setAttribute("is", "coral-button");
  el0.setAttribute("type", "button");
  el0.setAttribute("title", data_0["tooltip"]);
  el0.setAttribute("variant", "quiet");
  el0.setAttribute("icon", data_0["icon"]);
  el0.setAttribute("data-action", data_0["plugin"]+"#"+data_0["command"]);
  el0.setAttribute("tabindex", "-1");
  el0.className += " rte-toolbar-item is-disabled "+data_0["addClasses"];
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["popover_trigger"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("button","coral-button");
  el0.setAttribute("is", "coral-button");
  el0.setAttribute("type", "button");
  el0.setAttribute("title", data_0["tooltip"]);
  el0.setAttribute("variant", data_0["variant"]);
  el0.setAttribute("icon", data_0["icon"]);
  el0.setAttribute("data-action", data_0["ref"]);
  el0.setAttribute("tabindex", "-1");
  el0.className += " rte-toolbar-item rte--trigger"+data_0["addClasses"];
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("coral-icon");
  el2.setAttribute("icon", "chevronDown");
  el2.setAttribute("size", "xxs");
  el2.className += " rte-openIcon";
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n");
  el0.appendChild(el3);
  frag.appendChild(el0);
  var el4 = document.createTextNode("\n");
  frag.appendChild(el4);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["popover"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("coral-popover");
  el0.setAttribute("interaction", "off");
  if (data_0["isDialog"]) {
  el0.setAttribute("data-rte-dialog", data_0["dataType"]);
  el0.className += " rte-dialog rte-dialog--"+data_0["dataType"];
  }
  if (!(data_0["isDialog"])) {
  el0.setAttribute("data-id", data_0["ref"]);
  el0.className += " rte-popover";
  }
  frag.appendChild(el0);
  var el1 = document.createTextNode("\r\n");
  frag.appendChild(el1);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["popovercontent"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("coral-buttongroup");
  var el1 = document.createTextNode("\r\n  ");
  el0.appendChild(el1);
  var iterated_1 = data_0["popoverItems"];
  for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
    var data_1 = data = iterated_1[i1];
    var el3 = document.createTextNode("\r\n      ");
    el0.appendChild(el3);
    el0.appendChild(data_1);
    var el5 = document.createTextNode("\r\n  ");
    el0.appendChild(el5);
  }
  var el6 = document.createTextNode("\r\n");
  el0.appendChild(el6);
  frag.appendChild(el0);
  var el7 = document.createTextNode("\r\n");
  frag.appendChild(el7);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["styles_pulldown"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("coral-buttonlist");
  el0.className += " rte-toolbar-list";
  var el1 = document.createTextNode("\r\n");
  el0.appendChild(el1);
  var iterated_1 = data_0;
  for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
    var data_1 = data = iterated_1[i1];
    var el3 = document.createTextNode("\r\n    ");
    el0.appendChild(el3);
    var el4 = document.createElement("button","coral-buttonlist-item");
    el4.setAttribute("is", "coral-buttonlist-item");
    el4.setAttribute("data-action", "styles#"+data_1["cssName"]);
    el4.textContent = data_1["text"];
    el0.appendChild(el4);
    var el5 = document.createTextNode("\r\n");
    el0.appendChild(el5);
  }
  var el6 = document.createTextNode("\r\n");
  el0.appendChild(el6);
  frag.appendChild(el0);
  var el7 = document.createTextNode("\r\n");
  frag.appendChild(el7);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["tb_container"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var iterated_1 = data_0["toolbars"];
  for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
    var data_1 = data = iterated_1[i1];
    var el1 = document.createTextNode("\r\n");
    frag.appendChild(el1);
    var el2 = document.createElement("div");
    el2.setAttribute("data-type", data_1["id"]);
    var el3 = document.createTextNode("\r\n    ");
    el2.appendChild(el3);
    el2.appendChild(data_1["toolbar"]);
    var el5 = document.createTextNode("\r\n    ");
    el2.appendChild(el5);
    var iterated_2 = data_1["popovers"];
    for (var i2 = 0, ni2 = iterated_2.length; i2 < ni2; i2++) {
      var data_2 = data = iterated_2[i2];
      var el7 = document.createTextNode("\r\n        ");
      el2.appendChild(el7);
      el2.appendChild(data_2);
      var el9 = document.createTextNode("\r\n    ");
      el2.appendChild(el9);
    }
    var el10 = document.createTextNode("\r\n");
    el2.appendChild(el10);
    frag.appendChild(el2);
    var el11 = document.createTextNode("\r\n");
    frag.appendChild(el11);
  }
  var el12 = document.createTextNode("\r\n");
  frag.appendChild(el12);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["toolbar_item"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("button","coral-button");
  el0.setAttribute("is", "coral-button");
  el0.setAttribute("variant", data_0["variant"]);
  el0.setAttribute("type", "button");
  el0.setAttribute("title", data_0["tooltip"]);
  el0.setAttribute("icon", data_0["icon"]);
  el0.setAttribute("data-action", data_0["plugin"]+"#"+data_0["command"]);
  el0.setAttribute("tabindex", "-1");
  el0.className += " rte-toolbar-item disabled "+data_0["addClasses"];
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  if (data_0["trigger"]) {
    var el3 = document.createTextNode("\n    ");
    el0.appendChild(el3);
    var el4 = document.createElement("coral-icon");
    el4.setAttribute("icon", "chevronDown");
    el4.setAttribute("size", "xxs");
    el4.className += " rte-openIcon";
    el0.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el0.appendChild(el5);
  }
  var el6 = document.createTextNode("\n");
  el0.appendChild(el6);
  frag.appendChild(el0);
  var el7 = document.createTextNode("\n");
  frag.appendChild(el7);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["toolbar"] = (function anonymous(data_0
/**/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("coral-buttongroup");
  el0.setAttribute("selectionmode", "multiple");
  el0.className += " rte-toolbar";
  var el1 = document.createTextNode("\r\n");
  el0.appendChild(el1);
  var iterated_1 = data_0["toolbarItems"];
  for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
    var data_1 = data = iterated_1[i1];
    var el3 = document.createTextNode("\r\n    ");
    el0.appendChild(el3);
    el0.appendChild(data_1);
    var el5 = document.createTextNode("\r\n");
    el0.appendChild(el5);
  }
  var el6 = document.createTextNode("\r\n");
  el0.appendChild(el6);
  frag.appendChild(el0);
  var el7 = document.createTextNode("\r\n");
  frag.appendChild(el7);
  return frag;
});

window["Coral"]["templates"]["RichTextEditor"]["ui_space"] = (function anonymous(data_0
/**/) {
  var data = data_0;
  var el0 = document.createElement("div");
  el0.setAttribute("data-type", data_0["mode"]);
  return el0;
});
/* global Class: true */
/* jshint strict: false */
(function ($, CUI) {

  //'use strict';

  var idCounter = 1;

  CUI.RichText = new Class(/** @lends CUI.RichText# */ {

    toString: 'RichText',

    extend: CUI.Widget,

    editorKernel: null,

    useFixedInlineToolbar: false,

    uiSettings: null,

    $sourceEditor: undefined,

    savedSpellcheckAttrib: null,

    savedOutlineStyle: null,

    isActive: false,

    options: null,

    _initialContent: null,

    id: null,

    $valueOnFocus: null,

    /**
     * Flag to ignore the next "out of area" click event
     * @private
     * @type Boolean
     */
    ignoreNextClick: false,

    ignoreClick: false,

    construct: function (options) {
      this.options = options || {};
      if (this.options.componentType === 'table') {
        this.options['additionalClasses'] = {
          'table#exitTableEditing': 'rte--modechanger'
        };
      }
      if (this.options.hasOwnProperty('$ui')) {
        this.$element.data('rte-ui', this.options.$ui);
      }
      this.id = String(idCounter++);
    },

    getComponentType: function () {
      return this.options ? this.options.componentType : undefined;
    },

    // Helpers -------------------------------------------------------------------------

    _isMimeTypeAccepted: function(mimeType) {
      if (mimeType === undefined || mimeType === null ||
        (mimeType.indexOf('image/') !== 0 && mimeType.indexOf('application/pdf') !== 0)) {
        return false;
      }
      return true;
    },

    _dispatchEvent: function (name) {
      var isVetoed = false;
      if (this.options.listeners && this.options.listeners[name]) {
        var listenerFn = this.options.listeners[name];
        if (typeof listenerFn === 'function') {
          isVetoed = !!listenerFn.call(this);
        }
      }
      return isVetoed;
    },

    _hidePopover: function () {
      if (this.editorKernel.toolbar) {
        var tb = this.editorKernel.toolbar;
        if (tb.popover) {
          return tb.popover.hide();
        }
      }
      return false;
    },

    _finishRequested: function () {
      this.finish(true);
    },

    _saveRequested: function () {
      this.finish(false);
    },

    _onFocusGain: function() {
      if (this.$valueOnFocus === null || this.$valueOnFocus === undefined) {
        this.$valueOnFocus = this.$element.html();
      }
    },

    _onFocusLoss: function() {
      if (this.$element.html() !== this.$valueOnFocus) {
        this.$valueOnFocus = this.$element.html();
        this.$element.trigger('change');
      }
    },

    _handleToolbarOnSelectionChange: function () {
      var com = CUI.rte.Common;
      var editContext = this.editorKernel.getEditContext();
      var self = this;
      if (com.ua.isTouch) {
        // On touch devices (Safari Mobile), no touch events are dispatched while
        // the user defines a selection. As a workaround, we listen to
        // selectionchange events instead (which at least indicate changes in the
        // selection, but not when the selection process starts or ends). To
        // determine the end of the selection process, a timed "best guess" approach
        // is used - currently, the selection is declared "final" if it does not
        // change for a second. This works well even if the user changes the
        // selection after the 1sec interval - simply another cycle of
        // hiding/showing the toolbar gets started in that case.
        var _lastSel;
        this.$textContainer.on('selectionchange.rte-toolbarhide-' + this.id, function (e) {
          if (self.editorKernel.isLocked() || !self.isActive) {
            _lastSel = undefined;
            return;
          }
          var context = self.editorKernel.getEditContext();
          // using native selection instead of selection abstraction here, as
          // it is faster and we are in a controlled environment (Webkit mobile)
          // here
          var slct = context.win.getSelection();
          // check if selection is valid - if not, reuse last known selection or
          // set caret to the start of the text
          if (!com.isAncestor(context, context.root, slct.focusNode) || !com.isAncestor(context, context.root, slct.anchorNode)) {
            slct.removeAllRanges();
            var range = context.doc.createRange();
            if (_lastSel) {
              range.setStart(_lastSel.ande, _lastSel.aoffs);
              range.setEnd(_lastSel.fnde, _lastSel.foffs);
            } else {
              range.selectNodeContents(context.root);
              range.collapse(true);
            }
            slct.addRange(range);
          }
          if (!slct.isCollapsed) {
            var locks = context.getState('CUI.SelectionLock');
            if (locks === undefined) {
              var isSameSelection = false;
              if (_lastSel) {
                isSameSelection =
                  (_lastSel.ande === slct.anchorNode) &&
                  (_lastSel.aoffs === slct.anchorOffset) &&
                  (_lastSel.fnde === slct.focusNode) &&
                  (_lastSel.foffs === slct.focusOffset);
              }
              var tb = self.editorKernel.toolbar;
              if (!isSameSelection && !tb._isSticky) {
                tb.hideTemporarily();
              }
            } else {
              locks--;
              if (locks > 0) {
                context.setState('CUI.SelectionLock', locks);
              } else {
                context.setState('CUI.SelectionLock');
              }
            }
          }
          _lastSel = {
            ande: slct.anchorNode,
            aoffs: slct.anchorOffset,
            fnde: slct.focusNode,
            foffs: slct.focusOffset
          };
        });
      } else {
        var _isClick = false;
        var _isToolbarHidden = false;
        var body = editContext.doc.body;
        var $body = $(body);
        this.$textContainer.pointer('mousedown.rte-toolbarhide-' + this.id,
          function (e) {
            _isClick = true;
          });
        this.$textContainer.pointer('mousemove.rte-toolbarhide-' + this.id,
          function (e) {
            if (_isClick && !_isToolbarHidden && !self.editorKernel.isLocked()) {
              var tb = self.editorKernel.toolbar;
              if (!tb.isSticky() && !self.useFixedInlineToolbar) {
                self.editorKernel.toolbar.hide();
                _isToolbarHidden = true;
              }
            }
          });
        this.$textContainer.pointer('mouseup.rte-toolbarhide-' + this.id,
          function (e) {
            if (_isToolbarHidden) {
              self.editorKernel.toolbar.show();
              _isToolbarHidden = false;
            }
            _isClick = false;
          });
        $body.add(document.body).pointer('mouseup.rte-toolbarhide-' + this.id,
          function(e) {
              if (_isClick && _isToolbarHidden) {
                  self.editorKernel.toolbar.show();
                  _isToolbarHidden = false;
                  // Hide the popover just like textcontainer does when clicked
                  if (!self.editorKernel.isLocked()) {
                      self._hidePopover();
                  }
                  // Flag to cancel click event attached on the body
                  self.ignoreClick = true;
              }
              _isClick = false;
          });
      }
    },

    getTextDiv: function (parentEl) {
      return parentEl;
    },

    isEmptyText: function () {
      return false;
    },

    prepareForNewText: function () {
      /*
       CQ.form.rte.Common.removeAllChildren(this.textContainer);
       */
    },

    handleKeyUp: function (e) {
      if (!this.editorKernel.isLocked()) {
        this._hidePopover();
      }
      // keyCode 27 refers to ESC key
      if (e.getCharCode() === 27) {
        if (!this.useFixedInlineToolbar && !this._dispatchEvent('beforeEscape')) {
          this.finish(true);
        }
      }
    },

    initializeEditorKernel: function (initialContent, isResumed) {
      var com = CUI.rte.Common;
      // Currently, the toolbar type is determined by analzing the full screen mode
      // definition. In later incarnations of the RTE it may make sense to make this
      // configurable explicitly
      var isFullScreen = !!this.options.isFullScreen;
      this.editorKernel.createToolbar({
        '$editable': this.$element,
        'uiSettings': this.uiSettings,
        'isFullScreen': isFullScreen,
        'tbType': (isFullScreen ? 'fullscreen' : 'inline'),
        'componentType': this.options.componentType,
        'additionalClasses': this.options.additionalClasses,
        'useFixedInlineToolbar': this.useFixedInlineToolbar
      });
      this.editorKernel.addUIListener('updatestate', this.updateState, this);
      this.editorKernel.addUIListener('focusgained', this._onFocusGain, this);
      this.editorKernel.addUIListener('focuslost', this._onFocusLoss, this);
      var doc = this.textContainer.ownerDocument;
      var win = com.getWindowForDocument(doc);
      this.editorKernel.initializeEditContext(win, doc, this.textContainer);
      this.editorKernel.initializeEventHandling();
      if (!isResumed) {
        if (this.options.hasOwnProperty('fullScreenAdapter')) {
          this.fullScreenAdapter = this.options.fullScreenAdapter;
        } else {
          this.fullScreenAdapter = new CUI.rte.ui.cui.DefaultFullScreenAdapter({
            'rteInstance': this
          });
        }
      }
      // since edit context is initialized again, we need to call setFullScreenAdapter again
      this.editorKernel.execCmd('setFullScreenAdapter', this.fullScreenAdapter);
      this.editorKernel.setUnprocessedHtml(initialContent || '');
      if (!isResumed && !this.options.preventCaretInitialize) {
        this.editorKernel.initializeCaret(true);
      }
      this.editorKernel.execCmd('initializeundo');
      this.editorKernel.addUIListener('requestClose', this._finishRequested, this);
      this.editorKernel.addUIListener('requestSave', this._saveRequested, this);
      var self = this;
      if (isFullScreen) {
        this.editorKernel.addUIListener('enablesourceedit', function () {
          self.fullScreenAdapter.toggleSourceEdit(true);
        }, this);
        this.editorKernel.addUIListener('disablesourceedit', function () {
          self.fullScreenAdapter.toggleSourceEdit(false);
        }, this);
      } else if (this.useFixedInlineToolbar) {
          this.editorKernel.addUIListener('enablesourceedit', function () {
            self.toggleSourceEdit(true);
          }, this);
          this.editorKernel.addUIListener('disablesourceedit', function () {
            self.toggleSourceEdit(false);
          }, this);
      }
      var tb = this.editorKernel.toolbar;
      if (CUI.rte.Common.ua.isTouch && !tb._isSticky) {
        // show the toolbar with a slight delay on touch devices; this looks a lot
        // smoother, as the device is most likely to scroll in the first
        // bunch of milliseconds anyway
        tb.hideTemporarily();
      }
    },

    initializeEventHandling: function () {
      var sel = CUI.rte.Selection;
      var self = this;
      var editContext = this.editorKernel.getEditContext();
      var body = editContext.doc.body;
      var $body = $(body);
      var $uiBody = $(document.body);
      // temporary focus handling - we need to retransfer focus immediately
      // to the text container (at least in iOS 6) to prevent the keyboard from
      // disappearing and losing the focus altogether
      $body.on('focus.rte-' + this.id, '.rte-toolbar-item', function (e) {
        self.$textContainer.focus();
        e.stopPropagation();
        e.preventDefault();
      });
      if (!this.useFixedInlineToolbar) {
        this.$textContainer.finger('blur.rte-' + this.id, function (e) {
          if (!self.editorKernel.isLocked()) {
            // get back in a few milliseconds and see if it was a temporary focus
            // change (if a toolbar button was invoked) and finish otherwise -
            // this is the case on mobile devices if the on-screen keyboard gets
            // hidden
            CUI.rte.Utils.defer(function () {
              if (!self.isTemporaryFocusChange && self.isActive && !self.editorKernel.isLocked()) {
                self.finish(false);
              }
              self.isTemporaryFocusChange = false;
            }, 10);
          } else {
            self.isTemporaryFocusChange = false;
          }
        });
      }
      // Prevent changing the selection on touch devices when the editor is locked
      // (and the user is editing a dialog) - the "mask" implementation used on
      // desktop does not work as expected; SafariMobile does interesting things with
      // the mask switched on (for example, masks the dialog and allows editing
      // - despite the mask has a much higher z-index - instead of vice versa).
      this.$textContainer.finger('touchstart.rte-' + this.id, function (e) {
        if (self.editorKernel.isLocked()) {
          CUI.rte.UIUtils.killEvent(e);
        }
      });
      // additional keyboard handling (this is internal event handling - no ID
      // required/allowed! - "this" will be used for differentiation)
      CUI.rte.Eventing.on(editContext, body, 'keyup', this.handleKeyUp, this);
      // handle clicks/taps (clicks on the editable div vs. common/"out of area"
      // clicks vs. clicks on toolbar items)
      this.$textContainer.fipo('tap.rte-' + this.id, 'click.rte-' + this.id,
        function (e) {
          if (!self.editorKernel.isLocked()) {
            self._hidePopover();
          }
          if (self.editorKernel.toolbar.isHidden()) {
            self.editorKernel.toolbar.show();
          }
          e.stopPropagation();
        });
      var bookmark;
      $body.add(document.body).fipo('touchstart.rte-ooa-' + this.id, 'mousedown.rte-ooa-' + this.id,
        function (e) {
          // we need to save the bookmark as soon as possible, as it gets lost
          // somewhere in the event handling between the initial
          // touchstart/mousedown event and the tap/click event where we
          // actually might need it
          var context = self.editorKernel.getEditContext();
          bookmark = sel.createRangeBookmark(context);
        });
      $body.add(document.body).fipo('tap.rte-ooa-' + this.id, 'click.rte-ooa-' + this.id, function (e) {
        // there are cases where "out of area clicks" must be ignored - for example,
        // on touch devices, the initial tap is followed by a click event that
        // would stop editing immediately; so the ignoreNextClick flag may be
        // used to handle those cases
        if (self.ignoreNextClick) {
          self.ignoreNextClick = false;
          return;
        }
        if (self.ignoreClick) {
          self.ignoreClick = false;
          return;
        }
        // also ignore if editing is currently locked
        if (self.editorKernel.isLocked()) {
          return;
        }
        // TODO find a cleaner solution ...
        if (self._hidePopover()) {
          var context = self.editorKernel.getEditContext();
          self.editorKernel.focus(context);
          // restore the bookmark that was saved on the initial
          // touchstart/mousedown event
          if (bookmark) {
            sel.selectRangeBookmark(context, bookmark);
            bookmark = undefined;
          }
          self.isTemporaryFocusChange = true;
          CUI.rte.UIUtils.killEvent(e);
        } else if (self.isActive && !self.useFixedInlineToolbar) {
          self.finish(false);
          self.$textContainer.blur();
        }
      });
      $body.finger('tap.rte-ooa-' + this.id, CUI.rte.UIUtils.killEvent);
      // prevent losing focus for toolbar items
      $uiBody.fipo('tap.rte-item-' + this.id, 'click.rte-item-' + this.id,
        '.rte-toolbar-item',
        function (e) {
          self.isTemporaryFocusChange = true;
          CUI.rte.UIUtils.killEvent(e);
        });
      // prevent losing focus for popovers (additional handlers)
      /*
       $uiBody.fipo("tap.rte-item", "click.rte-item", ".rte-popover .item",
       function(e) {
       self.isTemporaryFocusChange = true;
       CUI.rte.UIUtils.killEvent(e);
       });
       */
      $uiBody.fipo('tap.rte-item-' + this.id, 'click.rte-item-' + this.id,
        'coral-popover .rte-toolbar-list button',
        function (e) {
          self.isTemporaryFocusChange = true;
          CUI.rte.UIUtils.killEvent(e);
        });
      $uiBody.on('mousedown.rte-item-' + this.id, '.rte-toolbar-item',
        function (e) {
          CUI.rte.UIUtils.killEvent(e);
        });
      // prevent losing focus for popovers (additional elements)
      $uiBody.on('mousedown.rte-item-' + this.id,
        '.rte-toolbar-list button',
        function (e) {
          CUI.rte.UIUtils.killEvent(e);
        });
      // hide toolbar/popover while a selection is created
      this._handleToolbarOnSelectionChange();
    },

    deactivateEditorKernel: function () {
      if (this.editorKernel !== null && this.editorKernel !== undefined) {
        this.editorKernel.removeUIListener('requestClose');
        this.editorKernel.removeUIListener('requestSave');
        this.editorKernel.removeUIListener('updatestate');
        this.editorKernel.removeUIListener('focusgained');
        this.editorKernel.removeUIListener('focuslost');
        this.editorKernel.suspendEventHandling();
        this.editorKernel.destroyToolbar();
        this.editorKernel.destroyBackgroundToolbars();
        this.editorKernel.hasFocus = false;
      }
    },

    finalizeEventHandling: function () {
      if (this.editorKernel !== null && this.editorKernel !== undefined) {
        var context = this.editorKernel.getEditContext();
        var body = context.doc.body;
        var $body = $(body);
        var $uiBody = $(document.body);
        var $doc = $(context.doc);
        // Widget
        CUI.rte.Eventing.un(body, 'keyup', this.handleKeyUp, this);
        this.$textContainer.off('blur.rte-' + this.id + ' touchstart.rte-' + this.id +
          ' tap.rte-' + this.id + ' click.rte-' + this.id);
        $body.off('focus.rte-' + this.id + ' tap.rte-ooa-' + this.id +
          ' click.rte-ooa-' + this.id);
        $body.off('touchstart.rte-ooa-' + this.id +
          ' mousedown.rte-ooa-' + this.id + ' mouseup.rte-toolbarhide-' + this.id);
        // Toolbar
        $uiBody.off('tap.rte-item-' + this.id + ' click.rte-item-' + this.id);
        $uiBody.off('mousedown.rte-item-' + this.id + ' mouseup.rte-toolbarhide-' + this.id);
        this.$textContainer.off('mousemove.rte-toolbarhide-' + this.id);
        this.$textContainer.off('mouseup.rte-toolbarhide-' + this.id +
          ' mousedown.rte-toolbarhide-' + this.id);
        $doc.off('selectionchange.rte-toolbarhide-' + this.id);
      }
    },

    updateState: function () {
      this.editorKernel.updateToolbar();
    },


    // Interface -----------------------------------------------------------------------

    /**
     * Gets the current content of the edited text <i>while editing is in progress</i>.
     * Returns undefined before/after editing is started/has been finished.
     * @returns {String} The edited content; undefined if content is not being edited
     *          at the moment
     */
    getContent: function () {
      if (!this.isActive) {
        return undefined;
      }
      return this.editorKernel.getProcessedHtml();
    },

    setContent: function (html) {
      if (this.isActive) {
        this.editorKernel.setUnprocessedHtml(html);
      }
    },

    /**
     * Support for drag and drop of Image
     * @param event
     * @deprecated use notifyDrop method instead
     */
    insertImage: function(path) {
      var cmdValue = {
        path : path
      };
      this.editorKernel.relayCmd('insertimg', cmdValue);
    },

    /**
     * Handler that reacts on objects that were dropped on this editor.
     * @param {Object} dragData Description of the object that has been dropped on the
     *        component. This has to be of the form:
     *        {
     *          path: path of dropped object,
     *          mimeType: mime type of dropped object
     *        }
     *        if mimeType is empty string, dropped object is assumed to be a page.
     */
    notifyDrop: function(dragData) {
      var com = CUI.rte.Common;
      var sel = CUI.rte.Selection;
      var path = dragData.path;
      var mimeType = dragData.mimeType;
      if (path === undefined || path === null || !this._isMimeTypeAccepted(mimeType)) {
        return;
      }
      var isPage = (mimeType === '');
      var pSel = this.editorKernel.createQualifiedSelection(
        this.editorKernel.getEditContext());
      if (pSel && sel.isSelection(pSel)) {
        // insert as a link -> path has to be encoded before inserting the link;
        // see also bug #30206
        path = path.replace(/&/g, '%26');
        // todo respect link HTML rules
        // todo respect trim selection whitespace
        if (isPage) {
          path = path + '.html';
        }
        this.editorKernel.relayCmd('modifylink', {
          'url': path
        });
      } else {
        if (com.strStartsWith(mimeType, 'image/')) {
          // insert as image
          var cmdValue = {
            path: path
          };
          this.editorKernel.relayCmd('insertimg', cmdValue);
        }
      }
    },

    getUndoConfig: function () {
      return this.editorKernel.execCmd('getundoconfig');
    },

    setUndoConfig: function (undoConfig) {
      if (undoConfig) {
        this.editorKernel.execCmd('undoconfig', undoConfig);
      }
    },

    focus: function () {
      this.editorKernel.focus();
    },

    start: function (config, useFixedInlineToolbar) {
      if (this.isActive) {
        throw new Error('Cannot start an already active editor.');
      }
      this.originalConfig = (config ? CUI.rte.Utils.copyObject(config) : {});
      var isFullScreen = !!this.options.isFullScreen;
      this.useFixedInlineToolbar = useFixedInlineToolbar;
      this.uiSettings = (config ? config.uiSettings : undefined);
      if (this.editorKernel === null) {
        var ac = !!this.options.autoConfig;
        this.editorKernel = new CUI.rte.DivKernel(config,
          function (plugin, feature) {
            if (ac) {
              // ensure that fullscreen toggle + close button are always
              // available, even if not explicitly configured
              if (plugin === 'control') {
                return (feature === 'close' || feature === 'save');
              } else if (plugin === 'fullscreen') {
                var fsf = (isFullScreen ? undefined : 'start');
                return (feature === fsf);
              }
            }
            return undefined;
          });
      }
      var ua = CUI.rte.Common.ua;
      this.ignoreNextClick = ua.isTouch;
      this.$textContainer = this.getTextDiv(this.$element);
      this.$textContainer.addClass('is-edited');
      this.textContainer = this.$textContainer[0];
      if (!this.options.preventDOMRewrite) {
        this._initialContent = this.textContainer.innerHTML;
      }
      // if the component includes the "empty text placeholder", the placeholder
      // has to be removed and prepared for richtext editing
      this.isEmptyContent = this.isEmptyText();
      if (this.isEmptyContent) {
        this.prepareForNewText();
      }
      var initialContent = this.options.initialContent;
      if (initialContent === undefined) {
        initialContent = this.$textContainer.html();
      }
      this.textContainer.contentEditable = 'true';
      if (ua.isGecko || ua.isWebKit) {
        this.savedOutlineStyle = this.textContainer.style.outlineStyle;
        this.textContainer.style.outlineStyle = 'none';
      }
      this.initializeEditorKernel(initialContent);
      if (isFullScreen) {
        this.$sourceEditor = this.fullScreenAdapter.$sourceEditor;
      } else if (this.useFixedInlineToolbar) {
          this.$sourceEditor = $('<textarea/>');
          this.$sourceEditor.addClass('rte-sourceEditor');
          this.$sourceEditor.addClass('u-coral-noBorder');
          this.$textContainer.after(this.$sourceEditor);
          this.$sourceEditor.hide();
          this.$sourceEditor.fipo('tap.rte-' + this.id, 'click.rte-' + this.id,
            function (e) {
              e.stopPropagation();
            });
      }
      var context = this.editorKernel.getEditContext();
      var body = context.doc.body;
      this.savedSpellcheckAttrib = body.spellcheck;
      body.spellcheck = false;
      this.initializeEventHandling();
      this.isActive = true;
      this._dispatchEvent('onStarted');
      this.$element.trigger('editing-start');
    },

    finish: function (isCancelled) {
      if (this.sourceEditMode) {
        this.editorKernel.fireUIEvent('disablesourceedit');
      }
      if (this._dispatchEvent(isCancelled ? 'beforeCancel' : 'beforeFinish')) {
        return undefined;
      }
      var context = this.editorKernel.getEditContext();
      var body = context.doc.body;
      var editedContent = this.editorKernel.getProcessedHtml();
      if (this.isActive) {
        CUI.rte.Selection.resetSelection(context, 'start');
        this.finalizeEventHandling();
        this.deactivateEditorKernel();
        this.$textContainer.removeClass('is-edited');
        this.textContainer.contentEditable = 'inherit';
      }
      this.textContainer.blur();
      body.spellcheck = this.savedSpellcheckAttrib;
      var ua = CUI.rte.Common.ua;
      if ((ua.isGecko || ua.isWebKit) && this.savedOutlineStyle) {
        this.textContainer.style.outlineStyle = this.savedOutlineStyle;
      }
      if (!this.options.preventDOMRewrite) {
        this.textContainer.innerHTML =
          (isCancelled ? this._initialContent : editedContent);
      }
      this.isActive = false;
      this._dispatchEvent(isCancelled ? 'onCancelled' : 'onFinished');
      this.$element.trigger(isCancelled ? 'editing-cancelled' : 'editing-finished',
        [editedContent]);
      return editedContent;
    },

    suspend: function () {
      if (this.isActive) {
        this.editorKernel.getToolbar().hide();
        this.finalizeEventHandling();
        this.deactivateEditorKernel();
        this.$textContainer.removeClass('is-edited');
        this.textContainer.contentEditable = 'inherit';
        this.isActive = false;
      }
    },

    reactivate: function (initialContent) {
      if (!this.isActive) {
        this.$textContainer.addClass('is-edited');
        this.textContainer.contentEditable = 'true';
        this.initializeEditorKernel(initialContent, true);
        this.initializeEventHandling();
        this.editorKernel.getToolbar().show();
        this.isActive = true;
        this._dispatchEvent('onResumed');
      }
      },

    /**
     * Get content from source editor and push it into RTE.
     * @private
     */
    pushValue: function () {
      var v = this.$sourceEditor.val();
      if (!this.sourceEditMode || this.togglingSourceEdit) {
        this.editorKernel.setUnprocessedHtml(v);
      }
    },

    /**
     * Get content from RTE and push it into source editor.
     * @private
     */
    syncValue: function () {
      if (!this.sourceEditMode || this.togglingSourceEdit) {
        var html = this.editorKernel.getProcessedHtml();
        this.$sourceEditor.val(html);
      }
    },

    toggleSourceEdit: function (sourceEditMode) {
      this.togglingSourceEdit = true;
      if (sourceEditMode === undefined) {
        sourceEditMode = !this.sourceEditMode;
      }
      sourceEditMode = sourceEditMode === true;
      var isChanged = sourceEditMode !== this.sourceEditMode;
      this.sourceEditMode = sourceEditMode;
      var ek = this.editorKernel;
      if (!isChanged) {
        return;
      }
      if (this.sourceEditMode) {
        ek.disableFocusHandling();
        ek.notifyBlur();
        ek.disableToolbar(['sourceedit']);
        this.syncValue();
        this.$element.hide();
        this.$sourceEditor.show();
        this.$sourceEditor.focus();
        ek.firePluginEvent('sourceedit', {
          'enabled': true
        }, false);
      } else {
        ek.enableFocusHandling();
        if (this.initialized && !this.disabled) {
          ek.enableToolbar();
        }
        this.$element.show();
        this.$sourceEditor.hide();
        this.pushValue();
        ek.focus();
        ek.firePluginEvent('sourceedit', {
          'enabled': false
        }, false);
      }
      this.togglingSourceEdit = false;
    }

  });

  // Register ...
  CUI.util.plugClass(CUI.RichText, 'richEdit', function (rte) {
    CUI.rte.ConfigUtils.loadConfigAndStartEditing(rte, $(this));
  });

  // Data API
  if (CUI.options.dataAPI) {
    $(function () {
      // This listener will be executed only in those situations where we expect that
      // rte will be initialized on click inside contenteditable div, which is the case for stand-alone RTE
      // The selector is '.rte' and hence the contenteditable div needs to have this class if we want this
      // listener to work
      $('body').fipo('tap.rte.data-api', 'click.rte.data-api', '.rte',
        function (e) {
          var $this = $(this);
          if (!$this.hasClass('is-edited') && !$this.hasClass('is-initializing')) {
            $this.richEdit();
            e.preventDefault();
          }
        });
    });
  }

}(window.jQuery, window.CUI));

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function (CUI) {
  'use strict';
  CUI.rte.ui.ToolkitRegistry.initialize('cui');
  CUI.rte.Utils.setI18nProvider(new CUI.rte.DefaultI18nProvider());
})(window.CUI);

/*
 ADOBE CONFIDENTIAL

 Copyright 2016 Adobe Systems Incorporated
 All Rights Reserved.

 NOTICE:  All information contained herein is, and remains
 the property of Adobe Systems Incorporated and its suppliers,
 if any.  The intellectual and technical concepts contained
 herein are proprietary to Adobe Systems Incorporated and its
 suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from Adobe Systems Incorporated.
 */

// overrides several constants etc. for usage in a Granite/CQ context

CUI.rte.Theme.BLANK_IMAGE = "/libs/clientlibs/granite/richtext/resources/images/blank.png";
